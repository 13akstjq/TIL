<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>시계열 데이터에서 기본 모델 적용하는 방법 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2024-07-12-HowToBaselineModelsinTimeSeries" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="시계열 데이터에서 기본 모델 적용하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:title" content="시계열 데이터에서 기본 모델 적용하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/2024-07-12-HowToBaselineModelsinTimeSeries_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2024-07-12-HowToBaselineModelsinTimeSeries" data-gatsby-head="true"/><meta name="twitter:title" content="시계열 데이터에서 기본 모델 적용하는 방법 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/2024-07-12-HowToBaselineModelsinTimeSeries_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-12 19:52" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-5ecfd58aae5a7e3d.js" defer=""></script><script src="/_next/static/xx51Gh_JNHDTBdDwrgykD/_buildManifest.js" defer=""></script><script src="/_next/static/xx51Gh_JNHDTBdDwrgykD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">시계열 데이터에서 기본 모델 적용하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="시계열 데이터에서 기본 모델 적용하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 12, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-07-12-HowToBaselineModelsinTimeSeries&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/TIL/assets/img/2024-07-12-HowToBaselineModelsinTimeSeries_0.png" alt="이미지"></p>
<p>데이터 수집을 완료했습니다. 사업 케이스를 개요하고 후보 모델(예: 랜덤 포레스트)을 결정했으며, 개발 환경을 설정하고 키보드에 손을 대었습니다. 이제 시계열 모델을 구축하고 훈련할 준비가 되었습니다.</p>
<p>잠깐만요 - 바로 시작하지 마세요. 랜덤 포레스트 모델의 훈련 및 테스트를 시작하기 전에 먼저 베이스라인 모델을 훈련해야 합니다.</p>
<h1>베이스라인 모델이란 무엇인가요?</h1>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>기준 모델은 최종적으로 더 복잡한 머신 러닝 모델을 구축하기 위한 기준이 되는 간단한 모델입니다.</p>
<p>데이터 과학자들이 기준 모델을 만드는 이유는:</p>
<ul>
<li>기준 모델을 통해 더 복잡한 모델의 성능을 어느 정도 예측할 수 있습니다.</li>
<li>기준 모델의 성능이 좋지 않을 경우, 데이터 품질에 문제가 있을 수 있음을 나타낼 수 있습니다.</li>
<li>기준 모델이 최종 모델보다 더 나은 성능을 보일 경우, 해당 알고리즘, 특성, 하이퍼파라미터 또는 다른 데이터 전처리에 문제가 있을 수 있습니다.</li>
<li>기준 모델과 복잡한 모델이 비슷하게 성능을 보인다면, 복잡한 모델이 더 세밀한 조정이 필요하다는 것을 나타낼 수 있습니다. 또한, 더 복잡한 모델이 필요하지 않을 수도 있고, 보다 간단한 모델이 충분할 수도 있습니다.</li>
</ul>
<p>보통 기준 모델은 이동 평균 모델과 같은 통계 모델이거나, 대상 모델의 간단한 버전일 수 있습니다. 예를 들어, Random Forest 모델을 학습할 예정이라면 먼저 기준으로 Decision Tree 모델을 학습시킬 수 있습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>시계열 데이터의 기준 모델</h1>
<p>시계열 데이터에 대해 기준 모델로 인기 있는 옵션이 몇 가지 있습니다. 이 중에서 함께 공유하고 싶어요. 이 두 가지 모두 데이터의 시간순서를 전제로 하고 데이터의 패턴에 따라 예측을 수행하기 때문에 잘 작동합니다.</p>
<h2>단순 예측</h2>
<p>단순 예측은 가장 간단한 방법입니다 — 다음 값은 이전 값과 동일하다고 가정합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>날씨를 예측해보려는 모델을 구축 중이라고 가정해 봅시다. 이미 'Date'와 'TemperatureF' 두 개의 열이 적어도 포함된 데이터프레임 df를 불러왔다고 상정할게요. 이를 Python으로 구현하기 위해 먼저 타임스탬프와 타겟 변수를 분리하고 학습 및 테스트 세트로 분할하세요.</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np 

<span class="hljs-comment"># 분할 인덱스 정의</span>
split_time = <span class="hljs-number">1000</span>

<span class="hljs-comment"># 타겟 배열과 시간/날짜 배열 분리</span>
series = np.array(df[<span class="hljs-string">'TemperatureF'</span>])
time = np.array(df[<span class="hljs-string">'Date'</span>])

<span class="hljs-comment"># 학습 및 테스트 세트 나누기</span>
time_train = time[:split_time]
time_test = time[split_time:]

series_train = series[:split_time]
series_test = series[split_time:]
</code></pre>
<p>이제 데이터를 준비했으므로, 순진한 예측을 계산할 수 있어요.</p>
<pre><code class="hljs language-python"><span class="hljs-comment"># 순진한 예측은 단순히 시리즈를 1만큼 이동합니다</span>
naive_fcst = series[split_time - <span class="hljs-number">1</span>: -<span class="hljs-number">1</span>]
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>결과를 시각화하고 테스트 세트에서 나이브 예측이 어떻게 수행되는지 확인하기 위해 plotly 그래프 개체를 사용할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> plotly.<span class="hljs-property">graph_objects</span> <span class="hljs-keyword">as</span> go

fig = go.<span class="hljs-title class_">Figure</span>([
        go.<span class="hljs-title class_">Scatter</span>(x=time_test, y=series_test, text=<span class="hljs-string">'true'</span>, name=<span class="hljs-string">'true'</span>),
        go.<span class="hljs-title class_">Scatter</span>(x=time_test, y=naive_fcst, text=<span class="hljs-string">'pred'</span>, name=<span class="hljs-string">'pred'</span>),
    ])

fig.<span class="hljs-title function_">show</span>()
</code></pre>
<p>여기 제 결과물입니다:</p>
<img src="/TIL/assets/img/2024-07-12-HowToBaselineModelsinTimeSeries_1.png">
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>마지막 단계는 후에 벤치마킹에 사용할 메트릭을 계산하는 것입니다. 선택할 메트릭은 특정 문제에 따라 다를 것이지만 MSE 및 RMSE를 계산하는 방법은 다음과 같습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> sklearn.<span class="hljs-property">metrics</span> <span class="hljs-keyword">import</span> mean_squared_error

mse = <span class="hljs-title function_">mean_squared_error</span>(series_test,naive_fcst)
rmse = <span class="hljs-title function_">mean_squared_error</span>(series_test,naive_fcst,squared=<span class="hljs-title class_">False</span>)

<span class="hljs-title function_">print</span>(“<span class="hljs-attr">MSE</span>:”, mse)
<span class="hljs-title function_">print</span>(“<span class="hljs-attr">RMSE</span>:”, rmse)
</code></pre>
<h2>이동 평균 예측</h2>
<p>이동평균(MA) 베이스라인 모델은 다음 데이터 포인트를 바로 이전 n개의 데이터 포인트의 평균으로 예측합니다. n의 값은 사용자에 달려있어요—일반적인 이동평균에는 30일 이동평균, 60일, 90일, 180일 등이 있습니다. 또한 사용 사례 및 분야에 따라 달라집니다. 주식 시장에서는 종종 21, 50, 100 및 200을 사용합니다. 게다가, 최종 모델로 30일을 예측할 것이라는 것을 알고 있다면 30일 이동평균을 사용하여 베이스라인을 테스트하는 것이 좋습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>특정 문제와 목표 결과에 대해 일반적으로 사용되는 이동 평균을 조사해보는 것이 중요합니다.</p>
<p>이를 Python으로 구현하려면, 이전과 동일한 데이터 구조(시간 및 시리즈)를 유지한 채 다음을 수행하십시오.</p>
<p>먼저, 전체 데이터셋에 대한 예측을 생성하십시오.</p>
<pre><code class="hljs language-python"><span class="hljs-comment"># 리스트 초기화</span>
forecast = []
window_size = <span class="hljs-number">30</span>

<span class="hljs-comment"># 윈도우 크기를 기반으로 이동 평균 계산</span>
<span class="hljs-keyword">for</span> time <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(series) - window_size):
    forecast.append(series[time:time + window_size].mean())

<span class="hljs-comment"># 넘파이 배열로 변환</span>
forecast = np.array(forecast)
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>다음으로 이동 평균 예측에서 테스트 세트를 분리하세요. 원래의 테스트 세트와 일치시키기 위해 window_size만큼 예측 배열을 이동할 겁니다.</p>
<pre><code class="hljs language-js">moving_avg = forecast[split_time - <span class="hljs-attr">window_size</span>:]
</code></pre>
<p>이전과 같이 결과를 시각화해서 표시해주세요.</p>
<pre><code class="hljs language-js">fig = go.<span class="hljs-title class_">Figure</span>([
        go.<span class="hljs-title class_">Scatter</span>(x=time_test, y=series_test, text=<span class="hljs-string">'true'</span>, name=<span class="hljs-string">'true'</span>),
        go.<span class="hljs-title class_">Scatter</span>(x=time_test, y=moving_avg, text=<span class="hljs-string">'pred'</span>, name=<span class="hljs-string">'pred'</span>),
    ])

fig.<span class="hljs-title function_">show</span>()
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이렇게 보이도록 표 태그를 마크다운 형식으로 변경해보세요.</p>
<p><img src="/TIL/assets/img/2024-07-12-HowToBaselineModelsinTimeSeries_2.png" alt="Moving Average Chart"></p>
<p>에러 메트릭을 얻으려면, 이전과 같은 과정을 따르되 moving_avg 배열을 사용하면 됩니다.</p>
<pre><code class="hljs language-python">mse = mean_squared_error(series_test, moving_avg)
rmse = mean_squared_error(series_test, moving_avg, squared=<span class="hljs-literal">False</span>)

<span class="hljs-built_in">print</span>(<span class="hljs-string">"MSE:"</span>, mse)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"RMSE:"</span>, rmse)
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>주의 사항 + 결론</h1>
<p>"예측"이라는 단어를 사용했지만, 사실 미래를 예측한 것은 아니에요. 저는 train test split을 했기 때문에 테스트 세트에서 예측을 할 때 이미 날짜별 이전 값을 가지고 있었거든요. 만약 앞으로 30일을 예측하려고 한다면, 진정한 naive 예측은 다음 30일이 마지막 날이나 마지막 데이터 포인트와 똑같다고 가정할 것이에요. 이는 수평선 예측으로 이어질 거에요. 이와 마찬가지로 이동평균에도 적용돼요. 그래서 이러한 기술들은 실제로 오랜 기간을 예측하기에는 최적적이지 않아요. 그러나 이러한 기법들은 여전히 기준을 설정하고 최종 모델에서 괜찮은 성능이 어떤 것인지를 평가하는 데 유용해요.</p>
<p>기준 모델은 코드의 타당성을 점검하고 최종 모델이 데이터셋에서 신뢰성 있게 예측할 수 있는 능력을 추정하는 좋은 방법을 제공해요. 데이터 오류를 탐지하고 최종 모델 선택 과정에 도움이 되는 요소일 수 있어요. 다음에 시계열 데이터를 다룰 때는 꼭 먼저 기준선을 설정해보세요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"시계열 데이터에서 기본 모델 적용하는 방법","description":"","date":"2024-07-12 19:52","slug":"2024-07-12-HowToBaselineModelsinTimeSeries","content":"\n\n\n![이미지](/TIL/assets/img/2024-07-12-HowToBaselineModelsinTimeSeries_0.png)\n\n데이터 수집을 완료했습니다. 사업 케이스를 개요하고 후보 모델(예: 랜덤 포레스트)을 결정했으며, 개발 환경을 설정하고 키보드에 손을 대었습니다. 이제 시계열 모델을 구축하고 훈련할 준비가 되었습니다.\n\n잠깐만요 - 바로 시작하지 마세요. 랜덤 포레스트 모델의 훈련 및 테스트를 시작하기 전에 먼저 베이스라인 모델을 훈련해야 합니다.\n\n# 베이스라인 모델이란 무엇인가요?\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기준 모델은 최종적으로 더 복잡한 머신 러닝 모델을 구축하기 위한 기준이 되는 간단한 모델입니다.\n\n데이터 과학자들이 기준 모델을 만드는 이유는:\n\n- 기준 모델을 통해 더 복잡한 모델의 성능을 어느 정도 예측할 수 있습니다.\n- 기준 모델의 성능이 좋지 않을 경우, 데이터 품질에 문제가 있을 수 있음을 나타낼 수 있습니다.\n- 기준 모델이 최종 모델보다 더 나은 성능을 보일 경우, 해당 알고리즘, 특성, 하이퍼파라미터 또는 다른 데이터 전처리에 문제가 있을 수 있습니다.\n- 기준 모델과 복잡한 모델이 비슷하게 성능을 보인다면, 복잡한 모델이 더 세밀한 조정이 필요하다는 것을 나타낼 수 있습니다. 또한, 더 복잡한 모델이 필요하지 않을 수도 있고, 보다 간단한 모델이 충분할 수도 있습니다.\n\n보통 기준 모델은 이동 평균 모델과 같은 통계 모델이거나, 대상 모델의 간단한 버전일 수 있습니다. 예를 들어, Random Forest 모델을 학습할 예정이라면 먼저 기준으로 Decision Tree 모델을 학습시킬 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 시계열 데이터의 기준 모델\n\n시계열 데이터에 대해 기준 모델로 인기 있는 옵션이 몇 가지 있습니다. 이 중에서 함께 공유하고 싶어요. 이 두 가지 모두 데이터의 시간순서를 전제로 하고 데이터의 패턴에 따라 예측을 수행하기 때문에 잘 작동합니다.\n\n## 단순 예측\n\n단순 예측은 가장 간단한 방법입니다 — 다음 값은 이전 값과 동일하다고 가정합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n날씨를 예측해보려는 모델을 구축 중이라고 가정해 봅시다. 이미 'Date'와 'TemperatureF' 두 개의 열이 적어도 포함된 데이터프레임 df를 불러왔다고 상정할게요. 이를 Python으로 구현하기 위해 먼저 타임스탬프와 타겟 변수를 분리하고 학습 및 테스트 세트로 분할하세요.\n\n```python\nimport numpy as np \n\n# 분할 인덱스 정의\nsplit_time = 1000\n\n# 타겟 배열과 시간/날짜 배열 분리\nseries = np.array(df['TemperatureF'])\ntime = np.array(df['Date'])\n\n# 학습 및 테스트 세트 나누기\ntime_train = time[:split_time]\ntime_test = time[split_time:]\n\nseries_train = series[:split_time]\nseries_test = series[split_time:]\n```\n\n이제 데이터를 준비했으므로, 순진한 예측을 계산할 수 있어요.\n\n```python\n# 순진한 예측은 단순히 시리즈를 1만큼 이동합니다\nnaive_fcst = series[split_time - 1: -1]\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n결과를 시각화하고 테스트 세트에서 나이브 예측이 어떻게 수행되는지 확인하기 위해 plotly 그래프 개체를 사용할 수 있습니다:\n\n```js\nimport plotly.graph_objects as go\n\nfig = go.Figure([\n        go.Scatter(x=time_test, y=series_test, text='true', name='true'),\n        go.Scatter(x=time_test, y=naive_fcst, text='pred', name='pred'),\n    ])\n\nfig.show()\n```\n\n여기 제 결과물입니다:\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-HowToBaselineModelsinTimeSeries_1.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마지막 단계는 후에 벤치마킹에 사용할 메트릭을 계산하는 것입니다. 선택할 메트릭은 특정 문제에 따라 다를 것이지만 MSE 및 RMSE를 계산하는 방법은 다음과 같습니다:\n\n```js\nfrom sklearn.metrics import mean_squared_error\n\nmse = mean_squared_error(series_test,naive_fcst)\nrmse = mean_squared_error(series_test,naive_fcst,squared=False)\n\nprint(“MSE:”, mse)\nprint(“RMSE:”, rmse)\n```\n\n## 이동 평균 예측\n\n이동평균(MA) 베이스라인 모델은 다음 데이터 포인트를 바로 이전 n개의 데이터 포인트의 평균으로 예측합니다. n의 값은 사용자에 달려있어요—일반적인 이동평균에는 30일 이동평균, 60일, 90일, 180일 등이 있습니다. 또한 사용 사례 및 분야에 따라 달라집니다. 주식 시장에서는 종종 21, 50, 100 및 200을 사용합니다. 게다가, 최종 모델로 30일을 예측할 것이라는 것을 알고 있다면 30일 이동평균을 사용하여 베이스라인을 테스트하는 것이 좋습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n특정 문제와 목표 결과에 대해 일반적으로 사용되는 이동 평균을 조사해보는 것이 중요합니다.\n\n이를 Python으로 구현하려면, 이전과 동일한 데이터 구조(시간 및 시리즈)를 유지한 채 다음을 수행하십시오.\n\n먼저, 전체 데이터셋에 대한 예측을 생성하십시오.\n\n```python\n# 리스트 초기화\nforecast = []\nwindow_size = 30\n\n# 윈도우 크기를 기반으로 이동 평균 계산\nfor time in range(len(series) - window_size):\n    forecast.append(series[time:time + window_size].mean())\n\n# 넘파이 배열로 변환\nforecast = np.array(forecast)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음으로 이동 평균 예측에서 테스트 세트를 분리하세요. 원래의 테스트 세트와 일치시키기 위해 window_size만큼 예측 배열을 이동할 겁니다.\n\n```js\nmoving_avg = forecast[split_time - window_size:]\n```\n\n이전과 같이 결과를 시각화해서 표시해주세요.\n\n```js\nfig = go.Figure([\n        go.Scatter(x=time_test, y=series_test, text='true', name='true'),\n        go.Scatter(x=time_test, y=moving_avg, text='pred', name='pred'),\n    ])\n\nfig.show()\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이렇게 보이도록 표 태그를 마크다운 형식으로 변경해보세요. \n\n![Moving Average Chart](/TIL/assets/img/2024-07-12-HowToBaselineModelsinTimeSeries_2.png)\n\n에러 메트릭을 얻으려면, 이전과 같은 과정을 따르되 moving_avg 배열을 사용하면 됩니다.\n\n```python\nmse = mean_squared_error(series_test, moving_avg)\nrmse = mean_squared_error(series_test, moving_avg, squared=False)\n\nprint(\"MSE:\", mse)\nprint(\"RMSE:\", rmse)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 주의 사항 + 결론\n\n\"예측\"이라는 단어를 사용했지만, 사실 미래를 예측한 것은 아니에요. 저는 train test split을 했기 때문에 테스트 세트에서 예측을 할 때 이미 날짜별 이전 값을 가지고 있었거든요. 만약 앞으로 30일을 예측하려고 한다면, 진정한 naive 예측은 다음 30일이 마지막 날이나 마지막 데이터 포인트와 똑같다고 가정할 것이에요. 이는 수평선 예측으로 이어질 거에요. 이와 마찬가지로 이동평균에도 적용돼요. 그래서 이러한 기술들은 실제로 오랜 기간을 예측하기에는 최적적이지 않아요. 그러나 이러한 기법들은 여전히 기준을 설정하고 최종 모델에서 괜찮은 성능이 어떤 것인지를 평가하는 데 유용해요.\n\n기준 모델은 코드의 타당성을 점검하고 최종 모델이 데이터셋에서 신뢰성 있게 예측할 수 있는 능력을 추정하는 좋은 방법을 제공해요. 데이터 오류를 탐지하고 최종 모델 선택 과정에 도움이 되는 요소일 수 있어요. 다음에 시계열 데이터를 다룰 때는 꼭 먼저 기준선을 설정해보세요.","ogImage":{"url":"/TIL/assets/img/2024-07-12-HowToBaselineModelsinTimeSeries_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-HowToBaselineModelsinTimeSeries_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-HowToBaselineModelsinTimeSeries_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e데이터 수집을 완료했습니다. 사업 케이스를 개요하고 후보 모델(예: 랜덤 포레스트)을 결정했으며, 개발 환경을 설정하고 키보드에 손을 대었습니다. 이제 시계열 모델을 구축하고 훈련할 준비가 되었습니다.\u003c/p\u003e\n\u003cp\u003e잠깐만요 - 바로 시작하지 마세요. 랜덤 포레스트 모델의 훈련 및 테스트를 시작하기 전에 먼저 베이스라인 모델을 훈련해야 합니다.\u003c/p\u003e\n\u003ch1\u003e베이스라인 모델이란 무엇인가요?\u003c/h1\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e기준 모델은 최종적으로 더 복잡한 머신 러닝 모델을 구축하기 위한 기준이 되는 간단한 모델입니다.\u003c/p\u003e\n\u003cp\u003e데이터 과학자들이 기준 모델을 만드는 이유는:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e기준 모델을 통해 더 복잡한 모델의 성능을 어느 정도 예측할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e기준 모델의 성능이 좋지 않을 경우, 데이터 품질에 문제가 있을 수 있음을 나타낼 수 있습니다.\u003c/li\u003e\n\u003cli\u003e기준 모델이 최종 모델보다 더 나은 성능을 보일 경우, 해당 알고리즘, 특성, 하이퍼파라미터 또는 다른 데이터 전처리에 문제가 있을 수 있습니다.\u003c/li\u003e\n\u003cli\u003e기준 모델과 복잡한 모델이 비슷하게 성능을 보인다면, 복잡한 모델이 더 세밀한 조정이 필요하다는 것을 나타낼 수 있습니다. 또한, 더 복잡한 모델이 필요하지 않을 수도 있고, 보다 간단한 모델이 충분할 수도 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e보통 기준 모델은 이동 평균 모델과 같은 통계 모델이거나, 대상 모델의 간단한 버전일 수 있습니다. 예를 들어, Random Forest 모델을 학습할 예정이라면 먼저 기준으로 Decision Tree 모델을 학습시킬 수 있습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e시계열 데이터의 기준 모델\u003c/h1\u003e\n\u003cp\u003e시계열 데이터에 대해 기준 모델로 인기 있는 옵션이 몇 가지 있습니다. 이 중에서 함께 공유하고 싶어요. 이 두 가지 모두 데이터의 시간순서를 전제로 하고 데이터의 패턴에 따라 예측을 수행하기 때문에 잘 작동합니다.\u003c/p\u003e\n\u003ch2\u003e단순 예측\u003c/h2\u003e\n\u003cp\u003e단순 예측은 가장 간단한 방법입니다 — 다음 값은 이전 값과 동일하다고 가정합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e날씨를 예측해보려는 모델을 구축 중이라고 가정해 봅시다. 이미 'Date'와 'TemperatureF' 두 개의 열이 적어도 포함된 데이터프레임 df를 불러왔다고 상정할게요. 이를 Python으로 구현하기 위해 먼저 타임스탬프와 타겟 변수를 분리하고 학습 및 테스트 세트로 분할하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e numpy \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e np \n\n\u003cspan class=\"hljs-comment\"\u003e# 분할 인덱스 정의\u003c/span\u003e\nsplit_time = \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e# 타겟 배열과 시간/날짜 배열 분리\u003c/span\u003e\nseries = np.array(df[\u003cspan class=\"hljs-string\"\u003e'TemperatureF'\u003c/span\u003e])\ntime = np.array(df[\u003cspan class=\"hljs-string\"\u003e'Date'\u003c/span\u003e])\n\n\u003cspan class=\"hljs-comment\"\u003e# 학습 및 테스트 세트 나누기\u003c/span\u003e\ntime_train = time[:split_time]\ntime_test = time[split_time:]\n\nseries_train = series[:split_time]\nseries_test = series[split_time:]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 데이터를 준비했으므로, 순진한 예측을 계산할 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-comment\"\u003e# 순진한 예측은 단순히 시리즈를 1만큼 이동합니다\u003c/span\u003e\nnaive_fcst = series[split_time - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e: -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e결과를 시각화하고 테스트 세트에서 나이브 예측이 어떻게 수행되는지 확인하기 위해 plotly 그래프 개체를 사용할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e plotly.\u003cspan class=\"hljs-property\"\u003egraph_objects\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e go\n\nfig = go.\u003cspan class=\"hljs-title class_\"\u003eFigure\u003c/span\u003e([\n        go.\u003cspan class=\"hljs-title class_\"\u003eScatter\u003c/span\u003e(x=time_test, y=series_test, text=\u003cspan class=\"hljs-string\"\u003e'true'\u003c/span\u003e, name=\u003cspan class=\"hljs-string\"\u003e'true'\u003c/span\u003e),\n        go.\u003cspan class=\"hljs-title class_\"\u003eScatter\u003c/span\u003e(x=time_test, y=naive_fcst, text=\u003cspan class=\"hljs-string\"\u003e'pred'\u003c/span\u003e, name=\u003cspan class=\"hljs-string\"\u003e'pred'\u003c/span\u003e),\n    ])\n\nfig.\u003cspan class=\"hljs-title function_\"\u003eshow\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기 제 결과물입니다:\u003c/p\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-12-HowToBaselineModelsinTimeSeries_1.png\"\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e마지막 단계는 후에 벤치마킹에 사용할 메트릭을 계산하는 것입니다. 선택할 메트릭은 특정 문제에 따라 다를 것이지만 MSE 및 RMSE를 계산하는 방법은 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e sklearn.\u003cspan class=\"hljs-property\"\u003emetrics\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e mean_squared_error\n\nmse = \u003cspan class=\"hljs-title function_\"\u003emean_squared_error\u003c/span\u003e(series_test,naive_fcst)\nrmse = \u003cspan class=\"hljs-title function_\"\u003emean_squared_error\u003c/span\u003e(series_test,naive_fcst,squared=\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e)\n\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(“\u003cspan class=\"hljs-attr\"\u003eMSE\u003c/span\u003e:”, mse)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(“\u003cspan class=\"hljs-attr\"\u003eRMSE\u003c/span\u003e:”, rmse)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e이동 평균 예측\u003c/h2\u003e\n\u003cp\u003e이동평균(MA) 베이스라인 모델은 다음 데이터 포인트를 바로 이전 n개의 데이터 포인트의 평균으로 예측합니다. n의 값은 사용자에 달려있어요—일반적인 이동평균에는 30일 이동평균, 60일, 90일, 180일 등이 있습니다. 또한 사용 사례 및 분야에 따라 달라집니다. 주식 시장에서는 종종 21, 50, 100 및 200을 사용합니다. 게다가, 최종 모델로 30일을 예측할 것이라는 것을 알고 있다면 30일 이동평균을 사용하여 베이스라인을 테스트하는 것이 좋습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e특정 문제와 목표 결과에 대해 일반적으로 사용되는 이동 평균을 조사해보는 것이 중요합니다.\u003c/p\u003e\n\u003cp\u003e이를 Python으로 구현하려면, 이전과 동일한 데이터 구조(시간 및 시리즈)를 유지한 채 다음을 수행하십시오.\u003c/p\u003e\n\u003cp\u003e먼저, 전체 데이터셋에 대한 예측을 생성하십시오.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-comment\"\u003e# 리스트 초기화\u003c/span\u003e\nforecast = []\nwindow_size = \u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e# 윈도우 크기를 기반으로 이동 평균 계산\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e time \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(series) - window_size):\n    forecast.append(series[time:time + window_size].mean())\n\n\u003cspan class=\"hljs-comment\"\u003e# 넘파이 배열로 변환\u003c/span\u003e\nforecast = np.array(forecast)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e다음으로 이동 평균 예측에서 테스트 세트를 분리하세요. 원래의 테스트 세트와 일치시키기 위해 window_size만큼 예측 배열을 이동할 겁니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003emoving_avg = forecast[split_time - \u003cspan class=\"hljs-attr\"\u003ewindow_size\u003c/span\u003e:]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이전과 같이 결과를 시각화해서 표시해주세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efig = go.\u003cspan class=\"hljs-title class_\"\u003eFigure\u003c/span\u003e([\n        go.\u003cspan class=\"hljs-title class_\"\u003eScatter\u003c/span\u003e(x=time_test, y=series_test, text=\u003cspan class=\"hljs-string\"\u003e'true'\u003c/span\u003e, name=\u003cspan class=\"hljs-string\"\u003e'true'\u003c/span\u003e),\n        go.\u003cspan class=\"hljs-title class_\"\u003eScatter\u003c/span\u003e(x=time_test, y=moving_avg, text=\u003cspan class=\"hljs-string\"\u003e'pred'\u003c/span\u003e, name=\u003cspan class=\"hljs-string\"\u003e'pred'\u003c/span\u003e),\n    ])\n\nfig.\u003cspan class=\"hljs-title function_\"\u003eshow\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이렇게 보이도록 표 태그를 마크다운 형식으로 변경해보세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-HowToBaselineModelsinTimeSeries_2.png\" alt=\"Moving Average Chart\"\u003e\u003c/p\u003e\n\u003cp\u003e에러 메트릭을 얻으려면, 이전과 같은 과정을 따르되 moving_avg 배열을 사용하면 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003emse = mean_squared_error(series_test, moving_avg)\nrmse = mean_squared_error(series_test, moving_avg, squared=\u003cspan class=\"hljs-literal\"\u003eFalse\u003c/span\u003e)\n\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"MSE:\"\u003c/span\u003e, mse)\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"RMSE:\"\u003c/span\u003e, rmse)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e주의 사항 + 결론\u003c/h1\u003e\n\u003cp\u003e\"예측\"이라는 단어를 사용했지만, 사실 미래를 예측한 것은 아니에요. 저는 train test split을 했기 때문에 테스트 세트에서 예측을 할 때 이미 날짜별 이전 값을 가지고 있었거든요. 만약 앞으로 30일을 예측하려고 한다면, 진정한 naive 예측은 다음 30일이 마지막 날이나 마지막 데이터 포인트와 똑같다고 가정할 것이에요. 이는 수평선 예측으로 이어질 거에요. 이와 마찬가지로 이동평균에도 적용돼요. 그래서 이러한 기술들은 실제로 오랜 기간을 예측하기에는 최적적이지 않아요. 그러나 이러한 기법들은 여전히 기준을 설정하고 최종 모델에서 괜찮은 성능이 어떤 것인지를 평가하는 데 유용해요.\u003c/p\u003e\n\u003cp\u003e기준 모델은 코드의 타당성을 점검하고 최종 모델이 데이터셋에서 신뢰성 있게 예측할 수 있는 능력을 추정하는 좋은 방법을 제공해요. 데이터 오류를 탐지하고 최종 모델 선택 과정에 도움이 되는 요소일 수 있어요. 다음에 시계열 데이터를 다룰 때는 꼭 먼저 기준선을 설정해보세요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-12-HowToBaselineModelsinTimeSeries"},"buildId":"xx51Gh_JNHDTBdDwrgykD","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>