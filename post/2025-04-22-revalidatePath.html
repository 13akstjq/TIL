<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Next.js 15에서 revalidatePath를 활용해 데이터 재검증하는 방법 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-revalidatePath" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Next.js 15에서 revalidatePath를 활용해 데이터 재검증하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:title" content="Next.js 15에서 revalidatePath를 활용해 데이터 재검증하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-revalidatePath" data-gatsby-head="true"/><meta name="twitter:title" content="Next.js 15에서 revalidatePath를 활용해 데이터 재검증하는 방법 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2025-04-22 12:45" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/0eef537492fed77a.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/0eef537492fed77a.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-8ded8b979ba73586.js" defer=""></script><script src="/TIL/_next/static/KUC9M_yIlA1Ugo01xmkHL/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/KUC9M_yIlA1Ugo01xmkHL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Next.js 15에서 revalidatePath를 활용해 데이터 재검증하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Next.js 15에서 revalidatePath를 활용해 데이터 재검증하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Apr 22, 2025</span><span class="posts_reading_time__f7YPP">9<!-- --> min read</span></span></div></div></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>revalidatePath 정리해보기</h1>
<p>revalidatePath는 특정 경로에 대해 캐시된 데이터를 즉시 갱신(무효화)할 수 있게 해주는 함수예요.</p>
<blockquote>
<p>참고하면 좋은 점:
revalidatePath는 해당 경로를 다시 방문할 때 캐시를 무효화시켜줘요. 즉, 함수 호출 후 바로 캐시가 갈아엎어지는 게 아니라, 다음에 그 경로에 접근할 때 무효화가 적용된다는 뜻이죠. 동적 경로 세그먼트로 호출해도 한꺼번에 여러 경로가 즉시 무효화되는 게 아니라 '다음 방문 시점'부터 적용돼요.</p>
</blockquote>
<p>현재는 서버 액션 내에서 revalidatePath를 쓰면, 클라이언트 사이드 라우터 캐시에 있는 모든 경로가 무효화되는 임시 동작을 하고 있어요. 이 부분은 향후 개선되어서 특정 경로에만 적용되도록 바뀔 거랍니다.</p>
<p>한편 서버 사이드 라우트 캐시에서는 특정 경로만 무효화하는 걸로 동작해요.</p>
<hr>
<h2>파라미터</h2>
<p>(여기에 파라미터 관련 내용이 따라올 예정인데, 현재는 정보가 없네요.)</p>
<hr>
<h3>팁 하나 덧붙이자면요</h3>
<p>이 기능은 예를 들어 게시글을 수정했을 때 수정된 내용이 바로 캐시에 반영되도록 강제로 갱신하고 싶을 때 많이 쓰이죠. 단, 재방문 시에 무효화가 되니까 페이지를 사용자에게 리다이렉트하거나, 클라이언트에서 다시 방문하게 만들어야 캐시 갱신 효과를 바로 볼 수 있다는 점 잊지 마세요!</p>
<p>무효화를 즉시 반영해주는 것과는 조금 다르니까, 상황에 따라 적절히 활용해보세요.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-ts"><span class="hljs-title function_">revalidatePath</span>(<span class="hljs-attr">path</span>: <span class="hljs-built_in">string</span>, <span class="hljs-keyword">type</span>?: <span class="hljs-string">'page'</span> | <span class="hljs-string">'layout'</span>): <span class="hljs-built_in">void</span>;
</code></pre>
<ul>
<li><strong>path</strong>: 다시 유효성 검사를 하고 싶은 데이터와 연결된 파일 시스템 경로 문자열입니다. 예를 들어, <code>/product/[slug]/page</code>처럼 동적 세그먼트를 포함할 수 있고, 혹은 <code>/product/123</code> 같은 실제 라우트 경로를 쓸 수도 있어요. 1024자 미만이어야 하고, 대소문자를 구분합니다.</li>
<li><strong>type</strong>: (선택적) <code>'page'</code> 또는 <code>'layout'</code> 문자열로, 재유효성 검사를 할 경로 유형을 정하는 거예요. 경로에 동적 세그먼트가 있다면 반드시 이 파라미터를 넣어야 합니다. 반대로, 동적 페이지 경로의 실제 라우트 예시(<code>/product/1</code>)를 줄 때는 넣지 않아야 합니다.</li>
</ul>
<h2>반환값</h2>
<p><code>revalidatePath</code> 함수는 값을 반환하지 않습니다. 즉, <code>void</code> 타입이에요.</p>
<hr>
<h3>한 마디 더!</h3>
<p><code>revalidatePath</code>는 Next.js에서 ISR(Incremental Static Regeneration)을 쓸 때, 특정 경로나 레이아웃을 수동으로 재검증하고 싶을 때 유용합니다. 페이지를 변경했을 때 빌드 전체를 다시 할 필요 없이 부분적으로 빠르게 리프레시하는 느낌이라 생각하면 편해요.</p>
<p>예를 들어, 어떤 상품 디테일 페이지 내용을 업데이트했을 때 해당 상품 페이지의 캐시만 재검증해서 최신 상태로 만들 수 있죠. 동적 경로가 섞인 경우에는 <code>type</code>을 꼭 신경 써서 넣어줘야 원하는 경로가 제대로 갱신됩니다.</p>
<p>개발 중에는 이 함수를 잘 활용하면 페이지 리빌드 시간을 크게 단축시킬 수 있으니 꼭 기억해두세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>예시</h2>
<h3>특정 URL 재검증하기</h3>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { revalidatePath } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/cache'</span>

<span class="hljs-title function_">revalidatePath</span>(<span class="hljs-string">'/blog/post-1'</span>)
</code></pre>
<p>위 코드는 <code>/blog/post-1</code> 경로를 다음 페이지 방문 시 재검증하도록 설정하는 방법이에요. 즉, 사용자가 해당 URL에 접속하면 콘텐츠가 최신 상태인지 Next.js가 다시 확인해서 캐시를 갱신하게 되는 거죠.</p>
<p>추가로, revalidatePath는 아주 유용한 함수인데요, 페이지 빌드 후에 데이터가 바뀌었을 때 해당 페이지를 다시 유효성 검사해서 최신 내용을 보여주고 싶을 때 자주 사용됩니다. 예를 들어, 블로그 글을 수정하는 CMS 관리 페이지에서 이 함수를 호출하면 변경된 글이 사용자에게 바로 반영되게 할 수 있어요.</p>
<p>그리고 한 가지 팁을 더 드리자면, revalidatePath 외에도 revalidateTag 같은 함수도 있는데, 여러 페이지에서 공통으로 쓰이는 데이터(예: 헤더, 푸터 정보)를 태그 단위로 재검증할 때 편리합니다. 상황에 맞게 잘 활용해보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>페이지 경로 재검증 (Revalidating A Page Path)</h3>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { revalidatePath } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/cache'</span>

<span class="hljs-title function_">revalidatePath</span>(<span class="hljs-string">'/blog/[slug]'</span>, <span class="hljs-string">'page'</span>)
<span class="hljs-comment">// 또는 라우트 그룹을 사용할 때</span>
<span class="hljs-title function_">revalidatePath</span>(<span class="hljs-string">'/(main)/blog/[slug]'</span>, <span class="hljs-string">'page'</span>)
</code></pre>
<p>이 코드는 특정 페이지 파일과 일치하는 URL이 다음에 방문할 때 다시 검증하도록 만들어줍니다. 쉽게 말해, 해당 경로에 있는 페이지가 업데이트되었을 때, 다음 방문부터 최신 내용이 반영되도록 하는 기능이에요.</p>
<p>단, 중요한 점은 이 함수가 딱 지정한 경로에만 유효하다는 거예요. 예를 들어 <code>/blog/[slug]</code>를 재검증한다고 해서 <code>/blog/[slug]/[author]</code> 같은 하위 경로까지 자동으로 재검증되지 않습니다. 필요할 경우 하위 경로도 별도로 재검증해줘야 해요.</p>
<hr>
<h3>재검증에 대해 한마디 더!</h3>
<p>이 기능은 SSR(서버 사이드 렌더링)이나 ISR(Incremental Static Regeneration)을 활용하는 프로젝트에서 자주 쓰입니다. 예를 들어, 블로그 글을 수정했을 때, 방문자가 새로 페이지를 요청하면 최신 버전을 보여주고 싶을 때 유용하죠.</p>
<p>하지만 너무 많은 경로에 대해 자주 재검증을 걸면 서버 부하가 늘 수 있으니, 꼭 필요한 경로에만 적절히 활용하는 게 좋습니다.</p>
<hr>
<h3>재검증 레이아웃 경로 (Revalidating A Layout Path)</h3>
<p>(다음 섹션에서 계속 이어서 작성할게요!)</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Next.js에서 제공하는 revalidatePath 함수에 대해 간단히 이야기해볼게요. 이 함수는 특정 경로와 그 경로에 연결된 레이아웃을 기준으로 페이지를 다시 검증(리빌드)하는 작업을 해줍니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { revalidatePath } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/cache'</span>

<span class="hljs-title function_">revalidatePath</span>(<span class="hljs-string">'/blog/[slug]'</span>, <span class="hljs-string">'layout'</span>)
<span class="hljs-comment">// 또는 경로 그룹 사용 시</span>
<span class="hljs-title function_">revalidatePath</span>(<span class="hljs-string">'/(main)/post/[slug]'</span>, <span class="hljs-string">'layout'</span>)
</code></pre>
<p>위 코드는 <code>/blog/[slug]</code>에 해당하는 레이아웃 파일을 기준으로, 해당 경로뿐만 아니라 그 경로 하위에 있는 다른 페이지들도 다음 방문 시 자동으로 다시 리빌드되게 해줍니다. 예를 들어 <code>/blog/[slug]/[another]</code> 같은 하위 경로도 포함되겠죠.</p>
<h3>모든 데이터를 재검증 하는 방법</h3>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { revalidatePath } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/cache'</span>

<span class="hljs-title function_">revalidatePath</span>(<span class="hljs-string">'/'</span>, <span class="hljs-string">'layout'</span>)
</code></pre>
<p>위처럼 루트 경로(<code>/</code>)에 대해 revalidatePath를 호출하면, 루트 레이아웃 아래에 속한 모든 페이지들이 다음 방문 시 다시 검증되어 최신 상태로 업데이트됩니다.</p>
<hr>
<h3>추가 팁!</h3>
<ul>
<li><code>revalidatePath</code>가 유용한 시점: 서버에서 어떤 데이터를 업데이트했는데 클라이언트 페이지에서 바로 최신 데이터가 반영되길 원할 때 써보세요.</li>
<li>"layout" 옵션은 선택사항인데, 해당 경로의 레이아웃이 바뀌었을 때 그 변경 사항을 반영하기 위해 추가하는 경우가 많습니다.</li>
<li>Next.js의 ISR(Incremental Static Regeneration)과 비슷한 개념이지만, 이 함수로 좀 더 세밀하게 특정 경로를 재검증할 수 있어서 편리해요.</li>
</ul>
<p>실제로 프로젝트에서 데이터 변경이 잦거나 특정 유저 액션 후 페이지를 새로 고침 시 최신 데이터를 보여주고 싶다면 적극 활용해보시길 바랍니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>클라이언트 사이드 라우터 캐시를 지우고, 다음에 페이지를 방문할 때 데이터 캐시를 다시 검증하는 작업에 대해 이야기해볼게요.</p>
<h3>서버 액션(Server Action)</h3>
<pre><code class="hljs language-js"><span class="hljs-string">'use server'</span>

<span class="hljs-keyword">import</span> { revalidatePath } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/cache'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">submit</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">submitForm</span>()
  <span class="hljs-title function_">revalidatePath</span>(<span class="hljs-string">'/'</span>)
}
</code></pre>
<p>위 코드는 간단하게 설명하면, 폼 제출 같은 서버 액션이 일어난 후에 특정 경로('/')의 캐시를 강제로 다시 검증(revalidate)하도록 해요. 이렇게 하면 클라이언트 쪽에 저장된 라우터 캐시를 초기화하고, 데이터가 최신 상태인지 확인할 수 있어서 사용자에게 더 정확한 정보를 제공할 수 있답니다.</p>
<p><strong>조금 더 풀어서 설명하자면</strong>, <code>revalidatePath()</code> 함수는 Next.js의 서버 캐시를 특정 경로 기준으로 새로 고치는 역할을 해요. 이 덕분에, 예를 들어 데이터가 업데이트된 페이지를 구독하고 있는 사용자가, 다음 번 방문 때 반드시 최신 내용이 보여지도록 할 수 있죠.</p>
<h3>Route Handler</h3>
<p>아래는 Route Handler에서 비슷한 맥락으로 쓰이는 코드의 예시입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { revalidatePath } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/cache'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">POST</span>(<span class="hljs-params">request</span>) {
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> request.<span class="hljs-title function_">json</span>()
  <span class="hljs-comment">// 데이터 저장 로직 등 처리</span>
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">saveData</span>(data)

  <span class="hljs-comment">// '/' 경로 캐시 재검증</span>
  <span class="hljs-title function_">revalidatePath</span>(<span class="hljs-string">'/'</span>)

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(<span class="hljs-string">'Success'</span>, { <span class="hljs-attr">status</span>: <span class="hljs-number">200</span> })
}
</code></pre>
<p>Route Handler에서도 POST 요청 처리 후에 동일하게 <code>revalidatePath</code>를 호출해서 특정 경로의 캐시를 새로고침할 수 있어요.</p>
<hr>
<blockquote>
<p><strong>TIP!</strong></p>
<p>Next.js 13부터 새로운 데이터 패칭 방식과 서버 액션이 도입되면서, 이런 재검증 로직이 더 간편해졌어요. 특히 ISR(Incremental Static Regeneration)을 활용해 캐시를 누적하고, 필요한 순간에만 갱신하는 전략 덕분에 성능과 UX가 훨씬 좋아졌답니다. 적절한 타이밍에 <code>revalidatePath</code>를 호출하는 것이 핵심이에요!</p>
</blockquote>
<p>필요하면 댓글이나 DM으로 질문 주세요. 더 친절하게 설명해드릴게요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>요즘 Next.js에서 ISR(Incremental Static Regeneration)을 활용할 일이 많아지면서, 특정 경로를 서버 사이드에서 동적으로 다시 빌드(재검증) 하는 방법에 대한 궁금증이 많아졌어요. 위에 코드가 그런 상황에서 유용한 예시라서 좀 쉽게 풀어서 설명해 드릴게요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { revalidatePath } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/cache'</span>
<span class="hljs-keyword">import</span> type { <span class="hljs-title class_">NextRequest</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/server'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">GET</span>(<span class="hljs-params">request: NextRequest</span>) {
  <span class="hljs-comment">// URL 쿼리에서 'path' 파라미터를 받아온다</span>
  <span class="hljs-keyword">const</span> path = request.<span class="hljs-property">nextUrl</span>.<span class="hljs-property">searchParams</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">'path'</span>)

  <span class="hljs-keyword">if</span> (path) {
    <span class="hljs-comment">// 해당 path를 Next.js에서 다시 빌드하도록 요청</span>
    <span class="hljs-title function_">revalidatePath</span>(path)
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Response</span>.<span class="hljs-title function_">json</span>({ <span class="hljs-attr">revalidated</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">now</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() })
  }

  <span class="hljs-comment">// path 파라미터가 없으면 에러 메시지 반환</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Response</span>.<span class="hljs-title function_">json</span>({
    <span class="hljs-attr">revalidated</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">now</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(),
    <span class="hljs-attr">message</span>: <span class="hljs-string">'Missing path to revalidate'</span>,
  })
}
</code></pre>
<h3>코드 설명</h3>
<ul>
<li><code>revalidatePath</code>: Next.js 13에서 도입된 function으로, ISR에서 특정 경로를 다시 빌드하도록 시그널을 넣어줍니다.</li>
<li>이 API는 <code>GET</code> 요청을 받아서, 쿼리스트링에 <code>?path=/some-route</code> 형식으로 재검증할 경로를 전달하면 동작해요.</li>
<li>만약 <code>path</code>가 없으면 재검증을 할 수 없으니, 메시지를 되돌려주는 안전장치가 있죠.</li>
</ul>
<hr>
<h3>여기서 더 알아두시면 좋은 점!</h3>
<ul>
<li><code>revalidatePath</code>는 내부적으로 Next.js의 캐시를 무효화해서, 다음에 해당 경로로 접근할 때 최신 버전의 페이지가 보여지게 만들어 줍니다.</li>
<li>재검증 요청을 API route처럼 만들어 두면, 관리자 페이지에서 "컨텐츠 업데이트" 버튼을 눌러 해당 페이지를 동적으로 최신화할 수 있어요.</li>
<li>주의할 점은, <code>path</code> 값은 Next.js 안에서 존재하는 페이지 경로여야 제대로 동작합니다. 없는 경로를 넣으면 에러는 안 나지만, 의미가 없겠죠.</li>
</ul>
<hr>
<h3>보너스: 서버 컴포넌트라면 이런 식으로 쓰기도</h3>
<p>Next.js 13 앱 디렉토리의 서버 컴포넌트에서는 이런 API route 없이 <code>revalidatePath</code>를 쓸 수 있습니다. 예를 들어, 폼 제출 후 해당 경로를 다시 검증하고 싶은 경우 이렇게요:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { revalidatePath } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/cache'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">updatePost</span>(<span class="hljs-params">data: FormData</span>) {
  <span class="hljs-comment">// 글 업데이트 로직 수행</span>
  <span class="hljs-keyword">const</span> postId = data.<span class="hljs-title function_">get</span>(<span class="hljs-string">'postId'</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>;

  <span class="hljs-comment">// 포스트 페이지 재검증 요청</span>
  <span class="hljs-title function_">revalidatePath</span>(<span class="hljs-string">`/posts/<span class="hljs-subst">${postId}</span>`</span>);
}
</code></pre>
<hr>
<p>요약하자면, 오늘 보여드린 코드는 Next.js에서 특정 경로의 ISR 캐시를 수동으로 갱신하고 싶을 때 참 잘 쓰이는 방법입니다. 참고하시고, 필요할 때 활용해 보세요~!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Next.js 15에서 revalidatePath를 활용해 데이터 재검증하는 방법","description":"","date":"2025-04-22 12:45","slug":"2025-04-22-revalidatePath","content":"\n\n# revalidatePath 정리해보기\n\nrevalidatePath는 특정 경로에 대해 캐시된 데이터를 즉시 갱신(무효화)할 수 있게 해주는 함수예요.\n\n\u003e 참고하면 좋은 점:\nrevalidatePath는 해당 경로를 다시 방문할 때 캐시를 무효화시켜줘요. 즉, 함수 호출 후 바로 캐시가 갈아엎어지는 게 아니라, 다음에 그 경로에 접근할 때 무효화가 적용된다는 뜻이죠. 동적 경로 세그먼트로 호출해도 한꺼번에 여러 경로가 즉시 무효화되는 게 아니라 '다음 방문 시점'부터 적용돼요.\n\n현재는 서버 액션 내에서 revalidatePath를 쓰면, 클라이언트 사이드 라우터 캐시에 있는 모든 경로가 무효화되는 임시 동작을 하고 있어요. 이 부분은 향후 개선되어서 특정 경로에만 적용되도록 바뀔 거랍니다.\n\n한편 서버 사이드 라우트 캐시에서는 특정 경로만 무효화하는 걸로 동작해요.\n\n---\n\n## 파라미터\n\n(여기에 파라미터 관련 내용이 따라올 예정인데, 현재는 정보가 없네요.)\n\n---\n\n### 팁 하나 덧붙이자면요\n\n이 기능은 예를 들어 게시글을 수정했을 때 수정된 내용이 바로 캐시에 반영되도록 강제로 갱신하고 싶을 때 많이 쓰이죠. 단, 재방문 시에 무효화가 되니까 페이지를 사용자에게 리다이렉트하거나, 클라이언트에서 다시 방문하게 만들어야 캐시 갱신 효과를 바로 볼 수 있다는 점 잊지 마세요! \n\n무효화를 즉시 반영해주는 것과는 조금 다르니까, 상황에 따라 적절히 활용해보세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```ts\nrevalidatePath(path: string, type?: 'page' | 'layout'): void;\n```\n\n- **path**: 다시 유효성 검사를 하고 싶은 데이터와 연결된 파일 시스템 경로 문자열입니다. 예를 들어, `/product/[slug]/page`처럼 동적 세그먼트를 포함할 수 있고, 혹은 `/product/123` 같은 실제 라우트 경로를 쓸 수도 있어요. 1024자 미만이어야 하고, 대소문자를 구분합니다.\n- **type**: (선택적) `'page'` 또는 `'layout'` 문자열로, 재유효성 검사를 할 경로 유형을 정하는 거예요. 경로에 동적 세그먼트가 있다면 반드시 이 파라미터를 넣어야 합니다. 반대로, 동적 페이지 경로의 실제 라우트 예시(`/product/1`)를 줄 때는 넣지 않아야 합니다.\n\n## 반환값\n\n`revalidatePath` 함수는 값을 반환하지 않습니다. 즉, `void` 타입이에요.\n\n---\n\n### 한 마디 더!\n\n`revalidatePath`는 Next.js에서 ISR(Incremental Static Regeneration)을 쓸 때, 특정 경로나 레이아웃을 수동으로 재검증하고 싶을 때 유용합니다. 페이지를 변경했을 때 빌드 전체를 다시 할 필요 없이 부분적으로 빠르게 리프레시하는 느낌이라 생각하면 편해요.\n\n예를 들어, 어떤 상품 디테일 페이지 내용을 업데이트했을 때 해당 상품 페이지의 캐시만 재검증해서 최신 상태로 만들 수 있죠. 동적 경로가 섞인 경우에는 `type`을 꼭 신경 써서 넣어줘야 원하는 경로가 제대로 갱신됩니다.\n\n개발 중에는 이 함수를 잘 활용하면 페이지 리빌드 시간을 크게 단축시킬 수 있으니 꼭 기억해두세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 예시\n\n### 특정 URL 재검증하기\n\n```js\nimport { revalidatePath } from 'next/cache'\n\nrevalidatePath('/blog/post-1')\n```\n\n위 코드는 `/blog/post-1` 경로를 다음 페이지 방문 시 재검증하도록 설정하는 방법이에요. 즉, 사용자가 해당 URL에 접속하면 콘텐츠가 최신 상태인지 Next.js가 다시 확인해서 캐시를 갱신하게 되는 거죠.\n\n추가로, revalidatePath는 아주 유용한 함수인데요, 페이지 빌드 후에 데이터가 바뀌었을 때 해당 페이지를 다시 유효성 검사해서 최신 내용을 보여주고 싶을 때 자주 사용됩니다. 예를 들어, 블로그 글을 수정하는 CMS 관리 페이지에서 이 함수를 호출하면 변경된 글이 사용자에게 바로 반영되게 할 수 있어요.\n\n그리고 한 가지 팁을 더 드리자면, revalidatePath 외에도 revalidateTag 같은 함수도 있는데, 여러 페이지에서 공통으로 쓰이는 데이터(예: 헤더, 푸터 정보)를 태그 단위로 재검증할 때 편리합니다. 상황에 맞게 잘 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 페이지 경로 재검증 (Revalidating A Page Path)\n\n```js\nimport { revalidatePath } from 'next/cache'\n\nrevalidatePath('/blog/[slug]', 'page')\n// 또는 라우트 그룹을 사용할 때\nrevalidatePath('/(main)/blog/[slug]', 'page')\n```\n\n이 코드는 특정 페이지 파일과 일치하는 URL이 다음에 방문할 때 다시 검증하도록 만들어줍니다. 쉽게 말해, 해당 경로에 있는 페이지가 업데이트되었을 때, 다음 방문부터 최신 내용이 반영되도록 하는 기능이에요.\n\n단, 중요한 점은 이 함수가 딱 지정한 경로에만 유효하다는 거예요. 예를 들어 `/blog/[slug]`를 재검증한다고 해서 `/blog/[slug]/[author]` 같은 하위 경로까지 자동으로 재검증되지 않습니다. 필요할 경우 하위 경로도 별도로 재검증해줘야 해요.\n\n---\n\n### 재검증에 대해 한마디 더!\n\n이 기능은 SSR(서버 사이드 렌더링)이나 ISR(Incremental Static Regeneration)을 활용하는 프로젝트에서 자주 쓰입니다. 예를 들어, 블로그 글을 수정했을 때, 방문자가 새로 페이지를 요청하면 최신 버전을 보여주고 싶을 때 유용하죠.\n\n하지만 너무 많은 경로에 대해 자주 재검증을 걸면 서버 부하가 늘 수 있으니, 꼭 필요한 경로에만 적절히 활용하는 게 좋습니다.\n\n---\n\n### 재검증 레이아웃 경로 (Revalidating A Layout Path)\n\n(다음 섹션에서 계속 이어서 작성할게요!)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 제공하는 revalidatePath 함수에 대해 간단히 이야기해볼게요. 이 함수는 특정 경로와 그 경로에 연결된 레이아웃을 기준으로 페이지를 다시 검증(리빌드)하는 작업을 해줍니다.\n\n```js\nimport { revalidatePath } from 'next/cache'\n\nrevalidatePath('/blog/[slug]', 'layout')\n// 또는 경로 그룹 사용 시\nrevalidatePath('/(main)/post/[slug]', 'layout')\n```\n\n위 코드는 `/blog/[slug]`에 해당하는 레이아웃 파일을 기준으로, 해당 경로뿐만 아니라 그 경로 하위에 있는 다른 페이지들도 다음 방문 시 자동으로 다시 리빌드되게 해줍니다. 예를 들어 `/blog/[slug]/[another]` 같은 하위 경로도 포함되겠죠.\n\n### 모든 데이터를 재검증 하는 방법\n\n```js\nimport { revalidatePath } from 'next/cache'\n\nrevalidatePath('/', 'layout')\n```\n\n위처럼 루트 경로(`/`)에 대해 revalidatePath를 호출하면, 루트 레이아웃 아래에 속한 모든 페이지들이 다음 방문 시 다시 검증되어 최신 상태로 업데이트됩니다.\n\n---\n\n### 추가 팁!\n\n- `revalidatePath`가 유용한 시점: 서버에서 어떤 데이터를 업데이트했는데 클라이언트 페이지에서 바로 최신 데이터가 반영되길 원할 때 써보세요.\n- \"layout\" 옵션은 선택사항인데, 해당 경로의 레이아웃이 바뀌었을 때 그 변경 사항을 반영하기 위해 추가하는 경우가 많습니다.\n- Next.js의 ISR(Incremental Static Regeneration)과 비슷한 개념이지만, 이 함수로 좀 더 세밀하게 특정 경로를 재검증할 수 있어서 편리해요.\n\n실제로 프로젝트에서 데이터 변경이 잦거나 특정 유저 액션 후 페이지를 새로 고침 시 최신 데이터를 보여주고 싶다면 적극 활용해보시길 바랍니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n클라이언트 사이드 라우터 캐시를 지우고, 다음에 페이지를 방문할 때 데이터 캐시를 다시 검증하는 작업에 대해 이야기해볼게요.\n\n### 서버 액션(Server Action)\n\n```js\n'use server'\n\nimport { revalidatePath } from 'next/cache'\n\nexport default async function submit() {\n  await submitForm()\n  revalidatePath('/')\n}\n```\n\n위 코드는 간단하게 설명하면, 폼 제출 같은 서버 액션이 일어난 후에 특정 경로('/')의 캐시를 강제로 다시 검증(revalidate)하도록 해요. 이렇게 하면 클라이언트 쪽에 저장된 라우터 캐시를 초기화하고, 데이터가 최신 상태인지 확인할 수 있어서 사용자에게 더 정확한 정보를 제공할 수 있답니다.\n\n**조금 더 풀어서 설명하자면**, `revalidatePath()` 함수는 Next.js의 서버 캐시를 특정 경로 기준으로 새로 고치는 역할을 해요. 이 덕분에, 예를 들어 데이터가 업데이트된 페이지를 구독하고 있는 사용자가, 다음 번 방문 때 반드시 최신 내용이 보여지도록 할 수 있죠.\n\n### Route Handler\n\n아래는 Route Handler에서 비슷한 맥락으로 쓰이는 코드의 예시입니다.\n\n```js\nimport { revalidatePath } from 'next/cache'\n\nexport async function POST(request) {\n  const data = await request.json()\n  // 데이터 저장 로직 등 처리\n  await saveData(data)\n\n  // '/' 경로 캐시 재검증\n  revalidatePath('/')\n\n  return new Response('Success', { status: 200 })\n}\n```\n\nRoute Handler에서도 POST 요청 처리 후에 동일하게 `revalidatePath`를 호출해서 특정 경로의 캐시를 새로고침할 수 있어요.\n\n---\n\n\u003e **TIP!**\n\u003e\n\u003e Next.js 13부터 새로운 데이터 패칭 방식과 서버 액션이 도입되면서, 이런 재검증 로직이 더 간편해졌어요. 특히 ISR(Incremental Static Regeneration)을 활용해 캐시를 누적하고, 필요한 순간에만 갱신하는 전략 덕분에 성능과 UX가 훨씬 좋아졌답니다. 적절한 타이밍에 `revalidatePath`를 호출하는 것이 핵심이에요!\n\n필요하면 댓글이나 DM으로 질문 주세요. 더 친절하게 설명해드릴게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요즘 Next.js에서 ISR(Incremental Static Regeneration)을 활용할 일이 많아지면서, 특정 경로를 서버 사이드에서 동적으로 다시 빌드(재검증) 하는 방법에 대한 궁금증이 많아졌어요. 위에 코드가 그런 상황에서 유용한 예시라서 좀 쉽게 풀어서 설명해 드릴게요.\n\n```js\nimport { revalidatePath } from 'next/cache'\nimport type { NextRequest } from 'next/server'\n\nexport async function GET(request: NextRequest) {\n  // URL 쿼리에서 'path' 파라미터를 받아온다\n  const path = request.nextUrl.searchParams.get('path')\n\n  if (path) {\n    // 해당 path를 Next.js에서 다시 빌드하도록 요청\n    revalidatePath(path)\n    return Response.json({ revalidated: true, now: Date.now() })\n  }\n\n  // path 파라미터가 없으면 에러 메시지 반환\n  return Response.json({\n    revalidated: false,\n    now: Date.now(),\n    message: 'Missing path to revalidate',\n  })\n}\n```\n\n### 코드 설명\n\n- `revalidatePath`: Next.js 13에서 도입된 function으로, ISR에서 특정 경로를 다시 빌드하도록 시그널을 넣어줍니다.\n- 이 API는 `GET` 요청을 받아서, 쿼리스트링에 `?path=/some-route` 형식으로 재검증할 경로를 전달하면 동작해요.\n- 만약 `path`가 없으면 재검증을 할 수 없으니, 메시지를 되돌려주는 안전장치가 있죠.\n\n---\n\n### 여기서 더 알아두시면 좋은 점!\n\n- `revalidatePath`는 내부적으로 Next.js의 캐시를 무효화해서, 다음에 해당 경로로 접근할 때 최신 버전의 페이지가 보여지게 만들어 줍니다.\n- 재검증 요청을 API route처럼 만들어 두면, 관리자 페이지에서 \"컨텐츠 업데이트\" 버튼을 눌러 해당 페이지를 동적으로 최신화할 수 있어요.\n- 주의할 점은, `path` 값은 Next.js 안에서 존재하는 페이지 경로여야 제대로 동작합니다. 없는 경로를 넣으면 에러는 안 나지만, 의미가 없겠죠.\n\n---\n\n### 보너스: 서버 컴포넌트라면 이런 식으로 쓰기도\n\nNext.js 13 앱 디렉토리의 서버 컴포넌트에서는 이런 API route 없이 `revalidatePath`를 쓸 수 있습니다. 예를 들어, 폼 제출 후 해당 경로를 다시 검증하고 싶은 경우 이렇게요:\n\n```ts\nimport { revalidatePath } from 'next/cache';\n\nexport async function updatePost(data: FormData) {\n  // 글 업데이트 로직 수행\n  const postId = data.get('postId') as string;\n\n  // 포스트 페이지 재검증 요청\n  revalidatePath(`/posts/${postId}`);\n}\n```\n\n---\n\n요약하자면, 오늘 보여드린 코드는 Next.js에서 특정 경로의 ISR 캐시를 수동으로 갱신하고 싶을 때 참 잘 쓰이는 방법입니다. 참고하시고, 필요할 때 활용해 보세요~!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":9},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003erevalidatePath 정리해보기\u003c/h1\u003e\n\u003cp\u003erevalidatePath는 특정 경로에 대해 캐시된 데이터를 즉시 갱신(무효화)할 수 있게 해주는 함수예요.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e참고하면 좋은 점:\nrevalidatePath는 해당 경로를 다시 방문할 때 캐시를 무효화시켜줘요. 즉, 함수 호출 후 바로 캐시가 갈아엎어지는 게 아니라, 다음에 그 경로에 접근할 때 무효화가 적용된다는 뜻이죠. 동적 경로 세그먼트로 호출해도 한꺼번에 여러 경로가 즉시 무효화되는 게 아니라 '다음 방문 시점'부터 적용돼요.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e현재는 서버 액션 내에서 revalidatePath를 쓰면, 클라이언트 사이드 라우터 캐시에 있는 모든 경로가 무효화되는 임시 동작을 하고 있어요. 이 부분은 향후 개선되어서 특정 경로에만 적용되도록 바뀔 거랍니다.\u003c/p\u003e\n\u003cp\u003e한편 서버 사이드 라우트 캐시에서는 특정 경로만 무효화하는 걸로 동작해요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e파라미터\u003c/h2\u003e\n\u003cp\u003e(여기에 파라미터 관련 내용이 따라올 예정인데, 현재는 정보가 없네요.)\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e팁 하나 덧붙이자면요\u003c/h3\u003e\n\u003cp\u003e이 기능은 예를 들어 게시글을 수정했을 때 수정된 내용이 바로 캐시에 반영되도록 강제로 갱신하고 싶을 때 많이 쓰이죠. 단, 재방문 시에 무효화가 되니까 페이지를 사용자에게 리다이렉트하거나, 클라이언트에서 다시 방문하게 만들어야 캐시 갱신 효과를 바로 볼 수 있다는 점 잊지 마세요!\u003c/p\u003e\n\u003cp\u003e무효화를 즉시 반영해주는 것과는 조금 다르니까, 상황에 따라 적절히 활용해보세요.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-ts\"\u003e\u003cspan class=\"hljs-title function_\"\u003erevalidatePath\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e?: \u003cspan class=\"hljs-string\"\u003e'page'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'layout'\u003c/span\u003e): \u003cspan class=\"hljs-built_in\"\u003evoid\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003epath\u003c/strong\u003e: 다시 유효성 검사를 하고 싶은 데이터와 연결된 파일 시스템 경로 문자열입니다. 예를 들어, \u003ccode\u003e/product/[slug]/page\u003c/code\u003e처럼 동적 세그먼트를 포함할 수 있고, 혹은 \u003ccode\u003e/product/123\u003c/code\u003e 같은 실제 라우트 경로를 쓸 수도 있어요. 1024자 미만이어야 하고, 대소문자를 구분합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003etype\u003c/strong\u003e: (선택적) \u003ccode\u003e'page'\u003c/code\u003e 또는 \u003ccode\u003e'layout'\u003c/code\u003e 문자열로, 재유효성 검사를 할 경로 유형을 정하는 거예요. 경로에 동적 세그먼트가 있다면 반드시 이 파라미터를 넣어야 합니다. 반대로, 동적 페이지 경로의 실제 라우트 예시(\u003ccode\u003e/product/1\u003c/code\u003e)를 줄 때는 넣지 않아야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e반환값\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003erevalidatePath\u003c/code\u003e 함수는 값을 반환하지 않습니다. 즉, \u003ccode\u003evoid\u003c/code\u003e 타입이에요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e한 마디 더!\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003erevalidatePath\u003c/code\u003e는 Next.js에서 ISR(Incremental Static Regeneration)을 쓸 때, 특정 경로나 레이아웃을 수동으로 재검증하고 싶을 때 유용합니다. 페이지를 변경했을 때 빌드 전체를 다시 할 필요 없이 부분적으로 빠르게 리프레시하는 느낌이라 생각하면 편해요.\u003c/p\u003e\n\u003cp\u003e예를 들어, 어떤 상품 디테일 페이지 내용을 업데이트했을 때 해당 상품 페이지의 캐시만 재검증해서 최신 상태로 만들 수 있죠. 동적 경로가 섞인 경우에는 \u003ccode\u003etype\u003c/code\u003e을 꼭 신경 써서 넣어줘야 원하는 경로가 제대로 갱신됩니다.\u003c/p\u003e\n\u003cp\u003e개발 중에는 이 함수를 잘 활용하면 페이지 리빌드 시간을 크게 단축시킬 수 있으니 꼭 기억해두세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e예시\u003c/h2\u003e\n\u003ch3\u003e특정 URL 재검증하기\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { revalidatePath } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/cache'\u003c/span\u003e\n\n\u003cspan class=\"hljs-title function_\"\u003erevalidatePath\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/blog/post-1'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드는 \u003ccode\u003e/blog/post-1\u003c/code\u003e 경로를 다음 페이지 방문 시 재검증하도록 설정하는 방법이에요. 즉, 사용자가 해당 URL에 접속하면 콘텐츠가 최신 상태인지 Next.js가 다시 확인해서 캐시를 갱신하게 되는 거죠.\u003c/p\u003e\n\u003cp\u003e추가로, revalidatePath는 아주 유용한 함수인데요, 페이지 빌드 후에 데이터가 바뀌었을 때 해당 페이지를 다시 유효성 검사해서 최신 내용을 보여주고 싶을 때 자주 사용됩니다. 예를 들어, 블로그 글을 수정하는 CMS 관리 페이지에서 이 함수를 호출하면 변경된 글이 사용자에게 바로 반영되게 할 수 있어요.\u003c/p\u003e\n\u003cp\u003e그리고 한 가지 팁을 더 드리자면, revalidatePath 외에도 revalidateTag 같은 함수도 있는데, 여러 페이지에서 공통으로 쓰이는 데이터(예: 헤더, 푸터 정보)를 태그 단위로 재검증할 때 편리합니다. 상황에 맞게 잘 활용해보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003e페이지 경로 재검증 (Revalidating A Page Path)\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { revalidatePath } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/cache'\u003c/span\u003e\n\n\u003cspan class=\"hljs-title function_\"\u003erevalidatePath\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/blog/[slug]'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'page'\u003c/span\u003e)\n\u003cspan class=\"hljs-comment\"\u003e// 또는 라우트 그룹을 사용할 때\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003erevalidatePath\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/(main)/blog/[slug]'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'page'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 코드는 특정 페이지 파일과 일치하는 URL이 다음에 방문할 때 다시 검증하도록 만들어줍니다. 쉽게 말해, 해당 경로에 있는 페이지가 업데이트되었을 때, 다음 방문부터 최신 내용이 반영되도록 하는 기능이에요.\u003c/p\u003e\n\u003cp\u003e단, 중요한 점은 이 함수가 딱 지정한 경로에만 유효하다는 거예요. 예를 들어 \u003ccode\u003e/blog/[slug]\u003c/code\u003e를 재검증한다고 해서 \u003ccode\u003e/blog/[slug]/[author]\u003c/code\u003e 같은 하위 경로까지 자동으로 재검증되지 않습니다. 필요할 경우 하위 경로도 별도로 재검증해줘야 해요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e재검증에 대해 한마디 더!\u003c/h3\u003e\n\u003cp\u003e이 기능은 SSR(서버 사이드 렌더링)이나 ISR(Incremental Static Regeneration)을 활용하는 프로젝트에서 자주 쓰입니다. 예를 들어, 블로그 글을 수정했을 때, 방문자가 새로 페이지를 요청하면 최신 버전을 보여주고 싶을 때 유용하죠.\u003c/p\u003e\n\u003cp\u003e하지만 너무 많은 경로에 대해 자주 재검증을 걸면 서버 부하가 늘 수 있으니, 꼭 필요한 경로에만 적절히 활용하는 게 좋습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e재검증 레이아웃 경로 (Revalidating A Layout Path)\u003c/h3\u003e\n\u003cp\u003e(다음 섹션에서 계속 이어서 작성할게요!)\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eNext.js에서 제공하는 revalidatePath 함수에 대해 간단히 이야기해볼게요. 이 함수는 특정 경로와 그 경로에 연결된 레이아웃을 기준으로 페이지를 다시 검증(리빌드)하는 작업을 해줍니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { revalidatePath } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/cache'\u003c/span\u003e\n\n\u003cspan class=\"hljs-title function_\"\u003erevalidatePath\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/blog/[slug]'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'layout'\u003c/span\u003e)\n\u003cspan class=\"hljs-comment\"\u003e// 또는 경로 그룹 사용 시\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003erevalidatePath\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/(main)/post/[slug]'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'layout'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드는 \u003ccode\u003e/blog/[slug]\u003c/code\u003e에 해당하는 레이아웃 파일을 기준으로, 해당 경로뿐만 아니라 그 경로 하위에 있는 다른 페이지들도 다음 방문 시 자동으로 다시 리빌드되게 해줍니다. 예를 들어 \u003ccode\u003e/blog/[slug]/[another]\u003c/code\u003e 같은 하위 경로도 포함되겠죠.\u003c/p\u003e\n\u003ch3\u003e모든 데이터를 재검증 하는 방법\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { revalidatePath } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/cache'\u003c/span\u003e\n\n\u003cspan class=\"hljs-title function_\"\u003erevalidatePath\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'layout'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위처럼 루트 경로(\u003ccode\u003e/\u003c/code\u003e)에 대해 revalidatePath를 호출하면, 루트 레이아웃 아래에 속한 모든 페이지들이 다음 방문 시 다시 검증되어 최신 상태로 업데이트됩니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e추가 팁!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003erevalidatePath\u003c/code\u003e가 유용한 시점: 서버에서 어떤 데이터를 업데이트했는데 클라이언트 페이지에서 바로 최신 데이터가 반영되길 원할 때 써보세요.\u003c/li\u003e\n\u003cli\u003e\"layout\" 옵션은 선택사항인데, 해당 경로의 레이아웃이 바뀌었을 때 그 변경 사항을 반영하기 위해 추가하는 경우가 많습니다.\u003c/li\u003e\n\u003cli\u003eNext.js의 ISR(Incremental Static Regeneration)과 비슷한 개념이지만, 이 함수로 좀 더 세밀하게 특정 경로를 재검증할 수 있어서 편리해요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e실제로 프로젝트에서 데이터 변경이 잦거나 특정 유저 액션 후 페이지를 새로 고침 시 최신 데이터를 보여주고 싶다면 적극 활용해보시길 바랍니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e클라이언트 사이드 라우터 캐시를 지우고, 다음에 페이지를 방문할 때 데이터 캐시를 다시 검증하는 작업에 대해 이야기해볼게요.\u003c/p\u003e\n\u003ch3\u003e서버 액션(Server Action)\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e'use server'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { revalidatePath } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/cache'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esubmit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esubmitForm\u003c/span\u003e()\n  \u003cspan class=\"hljs-title function_\"\u003erevalidatePath\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/'\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드는 간단하게 설명하면, 폼 제출 같은 서버 액션이 일어난 후에 특정 경로('/')의 캐시를 강제로 다시 검증(revalidate)하도록 해요. 이렇게 하면 클라이언트 쪽에 저장된 라우터 캐시를 초기화하고, 데이터가 최신 상태인지 확인할 수 있어서 사용자에게 더 정확한 정보를 제공할 수 있답니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e조금 더 풀어서 설명하자면\u003c/strong\u003e, \u003ccode\u003erevalidatePath()\u003c/code\u003e 함수는 Next.js의 서버 캐시를 특정 경로 기준으로 새로 고치는 역할을 해요. 이 덕분에, 예를 들어 데이터가 업데이트된 페이지를 구독하고 있는 사용자가, 다음 번 방문 때 반드시 최신 내용이 보여지도록 할 수 있죠.\u003c/p\u003e\n\u003ch3\u003eRoute Handler\u003c/h3\u003e\n\u003cp\u003e아래는 Route Handler에서 비슷한 맥락으로 쓰이는 코드의 예시입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { revalidatePath } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/cache'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePOST\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003erequest\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e data = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e request.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e()\n  \u003cspan class=\"hljs-comment\"\u003e// 데이터 저장 로직 등 처리\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esaveData\u003c/span\u003e(data)\n\n  \u003cspan class=\"hljs-comment\"\u003e// '/' 경로 캐시 재검증\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003erevalidatePath\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/'\u003c/span\u003e)\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eResponse\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Success'\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003estatus\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e })\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRoute Handler에서도 POST 요청 처리 후에 동일하게 \u003ccode\u003erevalidatePath\u003c/code\u003e를 호출해서 특정 경로의 캐시를 새로고침할 수 있어요.\u003c/p\u003e\n\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eTIP!\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eNext.js 13부터 새로운 데이터 패칭 방식과 서버 액션이 도입되면서, 이런 재검증 로직이 더 간편해졌어요. 특히 ISR(Incremental Static Regeneration)을 활용해 캐시를 누적하고, 필요한 순간에만 갱신하는 전략 덕분에 성능과 UX가 훨씬 좋아졌답니다. 적절한 타이밍에 \u003ccode\u003erevalidatePath\u003c/code\u003e를 호출하는 것이 핵심이에요!\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e필요하면 댓글이나 DM으로 질문 주세요. 더 친절하게 설명해드릴게요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e요즘 Next.js에서 ISR(Incremental Static Regeneration)을 활용할 일이 많아지면서, 특정 경로를 서버 사이드에서 동적으로 다시 빌드(재검증) 하는 방법에 대한 궁금증이 많아졌어요. 위에 코드가 그런 상황에서 유용한 예시라서 좀 쉽게 풀어서 설명해 드릴게요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { revalidatePath } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/cache'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e type { \u003cspan class=\"hljs-title class_\"\u003eNextRequest\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/server'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eGET\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003erequest: NextRequest\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// URL 쿼리에서 'path' 파라미터를 받아온다\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e path = request.\u003cspan class=\"hljs-property\"\u003enextUrl\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003esearchParams\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'path'\u003c/span\u003e)\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (path) {\n    \u003cspan class=\"hljs-comment\"\u003e// 해당 path를 Next.js에서 다시 빌드하도록 요청\u003c/span\u003e\n    \u003cspan class=\"hljs-title function_\"\u003erevalidatePath\u003c/span\u003e(path)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eResponse\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003erevalidated\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003enow\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDate\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enow\u003c/span\u003e() })\n  }\n\n  \u003cspan class=\"hljs-comment\"\u003e// path 파라미터가 없으면 에러 메시지 반환\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eResponse\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e({\n    \u003cspan class=\"hljs-attr\"\u003erevalidated\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003enow\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDate\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enow\u003c/span\u003e(),\n    \u003cspan class=\"hljs-attr\"\u003emessage\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Missing path to revalidate'\u003c/span\u003e,\n  })\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e코드 설명\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003erevalidatePath\u003c/code\u003e: Next.js 13에서 도입된 function으로, ISR에서 특정 경로를 다시 빌드하도록 시그널을 넣어줍니다.\u003c/li\u003e\n\u003cli\u003e이 API는 \u003ccode\u003eGET\u003c/code\u003e 요청을 받아서, 쿼리스트링에 \u003ccode\u003e?path=/some-route\u003c/code\u003e 형식으로 재검증할 경로를 전달하면 동작해요.\u003c/li\u003e\n\u003cli\u003e만약 \u003ccode\u003epath\u003c/code\u003e가 없으면 재검증을 할 수 없으니, 메시지를 되돌려주는 안전장치가 있죠.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003e여기서 더 알아두시면 좋은 점!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003erevalidatePath\u003c/code\u003e는 내부적으로 Next.js의 캐시를 무효화해서, 다음에 해당 경로로 접근할 때 최신 버전의 페이지가 보여지게 만들어 줍니다.\u003c/li\u003e\n\u003cli\u003e재검증 요청을 API route처럼 만들어 두면, 관리자 페이지에서 \"컨텐츠 업데이트\" 버튼을 눌러 해당 페이지를 동적으로 최신화할 수 있어요.\u003c/li\u003e\n\u003cli\u003e주의할 점은, \u003ccode\u003epath\u003c/code\u003e 값은 Next.js 안에서 존재하는 페이지 경로여야 제대로 동작합니다. 없는 경로를 넣으면 에러는 안 나지만, 의미가 없겠죠.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003e보너스: 서버 컴포넌트라면 이런 식으로 쓰기도\u003c/h3\u003e\n\u003cp\u003eNext.js 13 앱 디렉토리의 서버 컴포넌트에서는 이런 API route 없이 \u003ccode\u003erevalidatePath\u003c/code\u003e를 쓸 수 있습니다. 예를 들어, 폼 제출 후 해당 경로를 다시 검증하고 싶은 경우 이렇게요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-ts\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { revalidatePath } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/cache'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eupdatePost\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edata: FormData\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 글 업데이트 로직 수행\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e postId = data.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'postId'\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-comment\"\u003e// 포스트 페이지 재검증 요청\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003erevalidatePath\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`/posts/\u003cspan class=\"hljs-subst\"\u003e${postId}\u003c/span\u003e`\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003cp\u003e요약하자면, 오늘 보여드린 코드는 Next.js에서 특정 경로의 ISR 캐시를 수동으로 갱신하고 싶을 때 참 잘 쓰이는 방법입니다. 참고하시고, 필요할 때 활용해 보세요~!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2025-04-22-revalidatePath"},"buildId":"KUC9M_yIlA1Ugo01xmkHL","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>