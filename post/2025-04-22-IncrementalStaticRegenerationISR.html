<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Next.js 15에서 Incremental Static Regeneration(ISR)로 정적 웹사이트 업데이트 하기 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-IncrementalStaticRegenerationISR" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Next.js 15에서 Incremental Static Regeneration(ISR)로 정적 웹사이트 업데이트 하기 | TIL" data-gatsby-head="true"/><meta property="og:title" content="Next.js 15에서 Incremental Static Regeneration(ISR)로 정적 웹사이트 업데이트 하기 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-IncrementalStaticRegenerationISR" data-gatsby-head="true"/><meta name="twitter:title" content="Next.js 15에서 Incremental Static Regeneration(ISR)로 정적 웹사이트 업데이트 하기 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2025-04-22 02:01" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-8ded8b979ba73586.js" defer=""></script><script src="/TIL/_next/static/X4OrKfmLtU3-3BijwfHe6/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/X4OrKfmLtU3-3BijwfHe6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Next.js 15에서 Incremental Static Regeneration(ISR)로 정적 웹사이트 업데이트 하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Next.js 15에서 Incremental Static Regeneration(ISR)로 정적 웹사이트 업데이트 하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Apr 22, 2025</span><span class="posts_reading_time__f7YPP">19<!-- --> min read</span></span></div></div></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>Incremental Static Regeneration (ISR)이란?</h1>
<p>안녕하세요! 오늘은 **Incremental Static Regeneration (ISR)**에 대해 쉽고 간단하게 이야기해보려고 해요. ISR은 특히 Next.js 같은 프레임워크에서 자주 쓰이는 개념인데, 기본적으로 정적 페이지를 효율적으로 업데이트할 수 있게 해주는 방법이에요.</p>
<hr>
<h2>ISR이 왜 좋을까?</h2>
<ul>
<li>
<p><strong>전체 사이트를 다시 빌드하지 않아도 돼요!</strong><br>
기존에 정적으로 생성된 페이지들을 모두 다시 생성하는 대신, 바뀐 페이지만 업데이트할 수 있답니다.</p>
</li>
<li>
<p><strong>서버 부하가 줄어들어요.</strong><br>
거의 대부분의 요청에 대해 이미 만들어진 정적 페이지를 바로 보여주기 때문에 서버가 한결 가벼워져요.</p>
</li>
<li>
<p><strong>cache-control 헤더가 자동으로 달려요.</strong><br>
페이지마다 적절한 캐시 정책이 적용되어서, 사용자에게 빠른 경험을 제공할 수 있어요.</p>
</li>
<li>
<p><strong>콘텐츠가 많은 사이트도 걱정 끝!</strong><br>
많은 페이지를 가진 사이트도 빌드 시간이 너무 길어지는 걸 피할 수 있어요.</p>
</li>
</ul>
<hr>
<h2>간단한 예시</h2>
<p>다음은 ISR을 활용한 아주 기본적인 Next.js의 <code>getStaticProps</code> 예시입니다.</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getStaticProps</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchDataSomehow</span>();

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">props</span>: {
      data,
    },
    <span class="hljs-comment">// 페이지가 60초마다 다시 생성되도록 설정</span>
    <span class="hljs-attr">revalidate</span>: <span class="hljs-number">60</span>,
  };
}
</code></pre>
<p>위에서 핵심은 <code>revalidate</code> 키예요. 여기서 60초를 지정했으니, 사용자가 페이지에 접속할 때마다 적어도 60초가 지난 후에는 새로 데이터를 가져와서 페이지를 다시 만들어줘요.</p>
<p>즉, "최소 60초 주기로 페이지를 갱신한다" 라고 이해하면 돼요.</p>
<hr>
<h2>좀 더 알려드리는 팁!</h2>
<ul>
<li><code>revalidate</code>에 너무 짧은 시간을 설정하면, 서버 부하가 다시 올라갈 수 있으니 적당한 값을 찾는 게 중요해요.</li>
<li>현재 Next.js는 ISR을 사용하면서 자동으로 incremental cache를 관리해줍니다. 덕분에 개발자가 별도로 캐싱 로직을 신경 쓸 필요가 줄어듭니다.</li>
<li>빌드 후 데이터가 자주 변경되는 뉴스, 블로그, 마켓플레이스 같은 서비스에서 굉장히 빛을 발합니다.</li>
</ul>
<hr>
<p>자, 오늘은 ISR에 대해서 간단히 알아봤는데요. 정적 사이트의 장점과 동적인 데이터 갱신을 함께 누리고 싶은 분들에게 정말 추천드리는 기술이에요. 더 궁금한 점이나 실제 예제 궁금하면 언제든지 댓글 달아주세요! 😊</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>여러분, Next.js에서 동적 라우팅과 ISR(Incremental Static Regeneration)을 활용하는 예제를 하나 같이 살펴볼게요! 위에 작성된 코드를 바탕으로 우리 블로그 포스트 페이지를 만든다고 가정해봅시다.</p>
<h3>이 코드가 뭘 하는 거냐면요</h3>
<ul>
<li><code>generateStaticParams</code> 함수 안에서 <code>https://api.vercel.app/blog</code> API를 호출해, 빌드 시점에 미리 25개의 블로그 포스트 경로를 생성해요.</li>
<li>이렇게 미리 생성된 페이지들은 사용자 요청 시 즉시 로드되고 캐시되죠.</li>
<li><code>revalidate = 60</code> 설정 덕분에, 60초마다 페이지가 백그라운드에서 다시 생성됩니다. 즉, 오래된 페이지를 보여주더라도 동시에 최신 페이지를 서버에서 준비시키는 거예요.</li>
<li>만약 아직 생성하지 않은 새로운 블로그 포스트 URL이 들어오면, <code>dynamicParams = true</code> 설정 때문에 404 대신 서버에서 해당 페이지를 “on-demand”로 생성해줍니다.</li>
</ul>
<p>한 마디로, 정적 생성과 서버 사이드 렌더링의 장점을 적절히 섞어 어떤 페이지는 미리 생성해 빠르게 제공하고, 새 페이지는 요청이 들어올 때 만들어서 서비스하는 똑똑한 방식인 거죠!</p>
<hr>
<h3>조금 더 풀어서 설명해볼게요!</h3>

























<table><thead><tr><th>설정</th><th>설명</th></tr></thead><tbody><tr><td><code>revalidate = 60</code></td><td>한번 캐싱한 페이지는 60초간 다시 생성하지 않고 캐시를 사용함. 60초 후 첫 요청 때 백그라운드로 새 페이지를 생성함.</td></tr><tr><td><code>dynamicParams = true</code></td><td><code>generateStaticParams</code>에 없는 경로가 요청되면 404가 아닌 동적으로 페이지를 생성함.</td></tr><tr><td><code>generateStaticParams</code></td><td>빌드 타임에 미리 생성할 동적 경로 목록을 반환함. 이 예제는 모든 블로그 포스트 ID가 여기 포함됨.</td></tr><tr><td><code>Page</code> 컴포넌트</td><td>요청된 <code>id</code> 파라미터로부터 해당 포스트를 API에서 받아와서 렌더링함.</td></tr></tbody></table>
<hr>
<h3>추가적으로 알아두면 좋은 점!</h3>
<ul>
<li>이 방식은 데이터가 자주 변하지 않는 콘텐츠에 딱 맞아요. 아주 빠른 실시간 업데이트는 어렵지만, 몇 분 단위 변경이라면 사용자 경험을 살릴 수 있습니다.</li>
<li>만약 완전 최신 데이터가 필요하면 <code>revalidate</code>를 0으로 두고 매 요청마다 서버 렌더링(SSR)을 할 수도 있어요. 하지만 속도는 느려질 수 있죠.</li>
<li>Next.js 13버전 이상에서 도입된 이 방식은 ISR과 동적 라우팅을 동시에 처리할 때 좋은 선택이니, 블로그나 뉴스 사이트 같은 프로젝트에 활용해보세요!</li>
</ul>
<hr>
<p>필요하면 제가 이 코드를 기반으로 직접 해볼 수 있는 샘플 프로젝트도 만들어서 공유해드릴게요. 혹시 관련해서 궁금한 점, 더 깊게 알고 싶은 부분 있으면 편하게 물어봐 주세요!</p>
<p>참고로 공식 문서도 정말 잘 정리되어 있으니 한 번 쭉 읽어보시면 큰 도움이 됩니다.</p>
<hr>
<h2>참고 자료</h2>
<ul>
<li><a href="https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes#incremental-static-regeneration" rel="nofollow" target="_blank">Next.js Dynamic Routes &#x26; ISR 공식 문서</a></li>
<li><a href="https://nextjs.org/docs/getting-started/upgrade-guide#app-router" rel="nofollow" target="_blank">Next.js 13 App Router 소개</a></li>
</ul>
<p>다음에도 쓸모 있는 Next.js 팁으로 찾아올게요! :)</p>
<hr>
<blockquote>
<p>혹시 이 내용을 마크다운 문서로 쓰거나 블로그에 올리고 싶다면 추가 설명과 코드는 댓글로도 언제든 요청해 주세요!</p>
</blockquote>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>라우트 세그먼트 설정(Route segment config)</h3>
<p>라우트를 잘 관리하려면 설정할 수 있는 옵션들이 몇 가지 있는데요, 대표적으로 <code>revalidate</code>와 <code>dynamicParams</code>가 있어요.</p>

















<table><thead><tr><th>옵션 이름</th><th>설명</th></tr></thead><tbody><tr><td>revalidate</td><td>해당 라우트 데이터를 다시 검증하는 주기(초 단위)를 설정해요. 이걸 설정하면 데이터를 자동으로 갱신해서 최신 상태를 유지할 수 있답니다.</td></tr><tr><td>dynamicParams</td><td>라우트에서 동적 파라미터를 사용할지 여부를 결정해요. 동적 파라미터란 URL 경로 내에서 변하는 값들을 말하죠(예: <code>/post/[id]</code>의 <code>id</code>). 이 옵션으로 다루는 방식을 설정할 수 있어요.</td></tr></tbody></table>
<hr>
<h3>함수 소개(Functions)</h3>
<p><code>revalidate</code>와 연관해서 사용할 수 있는 함수들도 있어요! 주로 캐시를 새로고침하거나 특정 경로를 다시 유효화하는 용도로 쓰이는데요.</p>

















<table><thead><tr><th>함수 이름</th><th>설명</th></tr></thead><tbody><tr><td>revalidatePath</td><td>특정 경로(path)에 대해 데이터를 재검증하도록 요청하는 함수예요. 예를 들어, 어떤 글을 수정한 후 그 경로를 갱신할 때 사용하죠.</td></tr><tr><td>revalidateTag</td><td>태그(tag)를 이용해 어느 그룹에 속한 데이터들을 한 번에 다시 검증하도록 할 수 있어요. 여러 경로를 묶어서 관리할 때 유용해요.</td></tr></tbody></table>
<hr>
<h3>덧붙여서</h3>
<p>Next.js 같은 최신 웹 프레임워크들에서 이런 revalidation 시스템을 잘 활용하면, 서버의 부담을 크게 줄이면서도 사용자에게 항상 최신 데이터를 보여줄 수 있어요. 예를 들어, 자주 변하지 않는 페이지는 캐시를 오래 유지하고, 실시간으로 변하는 페이지는 자주 재검증해서 최적 성능을 유지할 수 있죠.</p>
<p>또한, <code>dynamicParams</code> 옵션을 올바르게 설정하면, 빌드 시에 미리 생성할 경로나 런타임에 처리할 경로를 적절하게 나눌 수 있어서 프로젝트 구조를 깔끔하게 유지하는데 큰 도움이 돼요.</p>
<p>이런 설정과 함수들을 잘 이해하고 활용해보시면, 더욱 빠르고 효율적인 웹앱을 만들 수 있답니다. 궁금하신 점 있으면 언제든 질문 주세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>예시</h2>
<h3>시간 기반 리밸리데이션(Time-based Revalidation)</h3>
<p>이 예시는 <code>/blog</code> 경로에서 블로그 글 목록을 불러와 보여주는 방법이에요. 그리고 중요한 점은 페이지에 캐시된 데이터가 1시간마다 새로 고쳐진다는 거죠.</p>
<p>어떻게 동작하냐면, 첫 방문 시 데이터를 불러와서 캐시에 저장합니다. 그 후 1시간이 지나 다음에 페이지를 방문하면, 기존 캐시를 바로 버리고 다시 가져오는 게 아니라, 사용자에게는 기존 페이지를 보여주면서 백그라운드에선 새로운 글 목록으로 페이지를 다시 생성해 캐시를 업데이트해요. 덕분에 사용자는 항상 빠르고 끊김 없는 경험을, 백엔드는 최신 데이터를 보장할 수 있답니다.</p>
<pre><code class="hljs language-js">interface <span class="hljs-title class_">Post</span> {
  <span class="hljs-attr">id</span>: string
  <span class="hljs-attr">title</span>: string
  <span class="hljs-attr">content</span>: string
}
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> revalidate = <span class="hljs-number">3600</span> <span class="hljs-comment">// 3600초 = 1시간마다 캐시 무효화</span>
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://api.vercel.app/blog'</span>)
  <span class="hljs-keyword">const</span> <span class="hljs-attr">posts</span>: <span class="hljs-title class_">Post</span>[] = <span class="hljs-keyword">await</span> data.<span class="hljs-title function_">json</span>()
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">main</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>Blog Posts<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">ul</span>></span>
        {posts.map((post) => (
          <span class="hljs-tag">&#x3C;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{post.id}</span>></span>{post.title}<span class="hljs-tag">&#x3C;/<span class="hljs-name">li</span>></span>
        ))}
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">ul</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">main</span>></span></span>
  )
}
</code></pre>
<hr>
<h3>추가 팁!</h3>
<ul>
<li>여기서 <code>revalidate</code> 값에 넣는 숫자는 초(seconds) 단위예요. 3600은 1시간을 의미하니까, 10분마다 갱신하려면 600으로 바꾸면 되겠죠?</li>
<li>이렇게 시간 기반 갱신은 자주 변하지 않는 데이터에 딱이에요. 예를 들어 뉴스 헤드라인이나 프로필 정보처럼 자주 고쳐질 필요 없는 데이터를 캐시에 담기로 적합하죠.</li>
<li>만약 데이터가 수시로 업데이트되어 즉각 반영이 필요하면 <code>revalidate</code>를 사용하지 않고 서버 사이드 렌더링(SSR) 또는 클라이언트 측 데이터 패칭을 고려해보세요.</li>
<li><code>Next.js</code> 같은 최신 프레임워크를 쓰면 이런 캐시 전략을 아주 간편하게 구현할 수 있으니, 프로젝트에 따라 적절히 활용해보세요!</li>
</ul>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>재검증(revalidation) 시간을 길게 설정하는 걸 추천해요. 예를 들어, 1초 대신 1시간으로 말이죠. 만약 더 세밀한 데이터 갱신이 필요하다면 on-demand revalidation(필요할 때만 재검증)를 고려해보세요. 그리고 실시간 데이터가 꼭 필요하다면, 동적 렌더링(dynamic rendering)으로 전환하는 것도 좋은 방법입니다.</p>
<h3>필요할 때만 재검증: revalidatePath 활용법</h3>
<p>좀 더 정확하게 데이터 재검증을 하고 싶다면, revalidatePath 함수를 써서 페이지를 필요할 때만 무효화시키는 방법이 있어요.</p>
<p>예를 들어, 새로운 게시글을 추가한 후에 이 Server Action을 호출하면, Server Component에서 fetch를 쓰든 DB에 직접 연결하든 상관없이 해당 경로(route)의 캐시를 지우고, Server Component가 새로운 데이터를 가져오도록 할 수 있습니다.</p>
<p>이렇게 하면 불필요한 데이터 갱신을 줄이면서도 필요한 순간에 최신 데이터를 보여줄 수 있어서 성능과 사용자 경험 두 마리 토끼를 잡을 수 있답니다.</p>
<p>간단하게 요약하면:</p>





















<table><thead><tr><th>상황</th><th>추천 방법</th></tr></thead><tbody><tr><td>데이터 갱신이 1초 단위로 자주 필요하다면</td><td>on-demand revalidation 사용</td></tr><tr><td>실시간 데이터가 꼭 필요하다면</td><td>동적 렌더링(dynamic rendering) 고려</td></tr><tr><td>갱신 주기가 길어도 무방하다면</td><td>긴 revalidation 시간(예: 1시간) 설정</td></tr></tbody></table>
<p>이렇게 상황에 맞게 적절한 방법을 선택하는 게 중요해요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>여러분, Next.js에서 서버 측 캐시를 관리할 때 <code>revalidatePath</code> 함수만큼 유용한 게 없어요. 위 코드처럼 <code>/posts</code> 경로의 캐시를 무효화하고 싶을 때 아주 간단하게 쓸 수 있거든요.</p>
<pre><code class="hljs language-js"><span class="hljs-string">'use server'</span>
 
<span class="hljs-keyword">import</span> { revalidatePath } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/cache'</span>
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createPost</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// /posts 경로 캐시를 무효화하기</span>
  <span class="hljs-title function_">revalidatePath</span>(<span class="hljs-string">'/posts'</span>)
}
</code></pre>
<p>이렇게 하면 새로운 게시글을 추가하고 나서 바로 <code>/posts</code>를 방문했을 때 최신 글 목록을 볼 수 있죠.</p>
<h3>근데, 만약 경로 단위가 아니라 더 세밀한 캐시 무효화가 필요하다면?</h3>
<p>바로 <code>revalidateTag</code>라는 기능을 써볼 수 있어요. 이건 fetch 요청에 태그를 달아서, 특정 태그가 붙은 데이터만 골라서 다시 불러오게 하는 방법이에요. 예를 들어, 게시글 하나하나에 태그를 붙여서 수정된 글만 빠르게 반영하도록 할 수 있죠.</p>
<h4>간단 예시</h4>
<pre><code class="hljs language-js"><span class="hljs-string">'use server'</span>

<span class="hljs-keyword">import</span> { revalidateTag } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/cache'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">updatePost</span>(<span class="hljs-params">id</span>) {
  <span class="hljs-comment">// 특정 게시글에 붙은 태그를 기반으로 캐시를 무효화하기</span>
  <span class="hljs-title function_">revalidateTag</span>(<span class="hljs-string">`post-<span class="hljs-subst">${id}</span>`</span>)
}
</code></pre>
<p>fetch를 할 때도 태그를 붙여줘야 하는데요,</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> post = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/posts/<span class="hljs-subst">${id}</span>`</span>, {
  <span class="hljs-attr">next</span>: { <span class="hljs-attr">tags</span>: [<span class="hljs-string">`post-<span class="hljs-subst">${id}</span>`</span>] },
}).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =></span> res.<span class="hljs-title function_">json</span>())
</code></pre>
<p>이렇게 하면 이 게시글은 <code>post-123</code> 같은 식으로 태그가 붙고, 해당 게시글이 업데이트될 때만 캐시가 무효화되어 더 효과적으로 리소스를 관리할 수 있답니다.</p>
<hr>
<h3>정리</h3>




















<table><thead><tr><th>함수명</th><th>역할</th><th>사용 케이스</th></tr></thead><tbody><tr><td><code>revalidatePath</code></td><td>경로 단위 캐시 무효화</td><td>페이지 전체를 새로 고쳐야 할 때</td></tr><tr><td><code>revalidateTag</code></td><td>태그 단위 캐시 무효화</td><td>데이터 단위로 세밀하게 캐시를 관리하고 싶을 때</td></tr></tbody></table>
<hr>
<p>이렇게 <code>revalidateTag</code>를 활용하면, 대용량 데이터나 자주 변경되는 목록이 있을 때 정말 도움 많이 돼요. 오늘 바로 적용해보시고 캐시 전략 더 똑똑하게 짜보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Next.js에서 데이터를 효율적으로 캐싱하고 다시 불러오는 방법에 대해 알아볼게요! 특히 <code>fetch</code> 함수와 ORM을 이용할 때, 그리고 캐시를 자동으로 재검증하는 방법까지 다뤄보겠습니다.</p>
<hr>
<h3>1. fetch 함수에 <code>next</code> 옵션으로 태그 지정하기</h3>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://api.vercel.app/blog'</span>, {
    <span class="hljs-attr">next</span>: { <span class="hljs-attr">tags</span>: [<span class="hljs-string">'posts'</span>] }, <span class="hljs-comment">// 여기에 태그를 넣어 캐시를 관리할 수 있어요</span>
  })
  <span class="hljs-keyword">const</span> posts = <span class="hljs-keyword">await</span> data.<span class="hljs-title function_">json</span>()
  <span class="hljs-comment">// 이제 posts를 화면에 렌더링</span>
}
</code></pre>
<ul>
<li><code>next: { tags: ['posts'] }</code> 옵션을 주면, 이 요청이 <code>'posts'</code>라는 태그와 연결돼서 관리돼요.</li>
<li>나중에 <code>'posts'</code> 태그가 변경됐을 때 캐시를 재검증 할 수 있답니다.</li>
</ul>
<hr>
<h3>2. ORM이나 DB 연결 시 <code>unstable_cache</code> 사용하기</h3>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { unstable_cache } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/cache'</span>
<span class="hljs-keyword">import</span> { db, posts } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/lib/db'</span>
 
<span class="hljs-keyword">const</span> getCachedPosts = <span class="hljs-title function_">unstable_cache</span>(
  <span class="hljs-keyword">async</span> () => {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> db.<span class="hljs-title function_">select</span>().<span class="hljs-title function_">from</span>(posts)  <span class="hljs-comment">// 데이터베이스에서 포스트를 조회</span>
  },
  [<span class="hljs-string">'posts'</span>],                   <span class="hljs-comment">// 캐시 관련 태그</span>
  { <span class="hljs-attr">revalidate</span>: <span class="hljs-number">3600</span>, <span class="hljs-attr">tags</span>: [<span class="hljs-string">'posts'</span>] }  <span class="hljs-comment">// 3600초(1시간)마다 재검증, tags와 연결</span>
)
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> posts = <span class="hljs-title function_">getCachedPosts</span>()  <span class="hljs-comment">// 캐시된 데이터를 불러옴</span>
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<ul>
<li><code>unstable_cache</code> 함수는 캐시된 결과를 기억하며 해당 데이터를 재활용해요.</li>
<li><code>revalidate</code> 옵션으로 몇 초마다 다시 데이터를 불러올지 설정할 수 있어요.</li>
<li>태그를 사용해서 데이터를 더욱 세밀하게 관리 가능!</li>
</ul>
<hr>
<h3>3. 캐시가 무효화되었을 때 재검증하기 - <code>revalidateTag</code> 활용</h3>
<p>서버 액션(Server Actions)이나 라우트 핸들러(Route Handler) 안에서 다음과 같이 캐시 태그를 재검증할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { revalidateTag } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/cache'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">POST</span>(<span class="hljs-params">request</span>) {
  <span class="hljs-comment">// 예를 들어 데이터를 변경하는 로직</span>
  <span class="hljs-comment">// ...</span>
  
  <span class="hljs-comment">// 변경 후 'posts' 태그 관련 캐시를 재검증해서 최신 데이터 사용하도록 유도</span>
  <span class="hljs-title function_">revalidateTag</span>(<span class="hljs-string">'posts'</span>)

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(<span class="hljs-string">'Updated and cache revalidated'</span>)
}
</code></pre>
<ul>
<li>업데이트가 발생하면 캐시 무효화를 하면서 관련된 태그를 재검증합니다.</li>
<li>이렇게 하면 데이터가 바뀌었을 때 페이지가 최신 상태로 렌더링돼요.</li>
</ul>
<hr>
<h2>조금 더!</h2>
<ul>
<li>이 태그 기반 캐시 전략은 여러 페이지에서 같은 API 데이터를 공유할 때 정말 유용해요.</li>
<li><code>unstable_cache</code>는 아직 <code>unstable</code> 단계이니, 공식 문서나 업데이트 내용을 주의 깊게 지켜보는 게 좋아요.</li>
<li><code>fetch</code> 함수의 <code>next</code> 옵션 중에 <code>revalidate</code> 값을 직접 지정할 수도 있고, <code>tags</code>와 혼합해서 사용하면 훨씬 강력한 캐싱 전략을 구성할 수 있습니다.</li>
</ul>
<p>잘 활용하면 페이지 성능과 데이터 일관성을 높일 수 있으니 여유 있을 때 한번 적용해보세요! 도움이 되셨으면 좋겠네요. 😊</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이번에는 Next.js에서 서버 측 캐시를 다루는 방법 중에서, revalidateTag 함수를 사용하는 간단한 예제를 살펴보고, 오류 처리와 캐시 위치 커스터마이징에 대해 알아볼게요.</p>
<pre><code class="hljs language-js"><span class="hljs-string">'use server'</span>
 
<span class="hljs-keyword">import</span> { revalidateTag } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/cache'</span>
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createPost</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 'posts'라는 태그가 붙은 모든 캐시 데이터를 무효화합니다.</span>
  <span class="hljs-title function_">revalidateTag</span>(<span class="hljs-string">'posts'</span>)
}
</code></pre>
<p>위 코드에서 <code>revalidateTag('posts')</code>를 호출하면, 캐시에 'posts'라는 태그로 분류된 데이터가 모두 무효화되어 다음 요청 시 새로운 데이터를 다시 가져오도록 만듭니다. 이렇게 하면 게시글 리스트나 관련 콘텐츠가 업데이트될 때, 서버 캐시를 손쉽게 갱신할 수 있죠.</p>
<h3>예기치 않은 예외 처리 (Handling uncaught exceptions)</h3>
<p>만약 데이터 재검증 중에 에러가 발생한다면, Next.js는 바로 새로운 데이터 요청을 실패하더라도 이전에 성공적으로 생성된 데이터를 계속해서 캐시에서 제공합니다. 즉, 사용자에게는 데이터가 갑자기 사라지거나 오류가 노출되지 않고 안정적으로 서비스가 유지됩니다. 그리고 다음 요청 시점에 다시 재검증을 시도하니, 일시적인 문제라도 금방 해결됩니다.</p>
<p>이 부분이 꽤나 유용한데, 서버 오류로 인한 서비스 중단 없이도 캐시가 안정적으로 유지되고 복구되기 때문이죠.</p>
<h3>캐시 위치 커스터마이징하기</h3>
<p>Next.js 내장 캐시는 기본적으로 프로젝트 내 <code>.next/cache</code> 폴더에 저장됩니다. 하지만 상황에 따라 캐시 위치를 바꾸고 싶을 때가 있죠. 예를 들어, CI/CD 환경에서 캐시를 공유하거나 특정 디스크 경로에 캐시를 두고 싶을 때가 그렇답니다.</p>
<p>Next.js에서는 <code>next.config.js</code> 파일에서 <code>experimental</code> 설정 아래 <code>serverActions</code>와 같은 옵션을 다루듯, 캐시 관련 설정도 향후 업데이트를 기대할 수 있는데, 현재 공식 문서에서는 구체적인 캐시 위치 변경 방법은 제한적입니다. 그래도 곧 더 다양한 설정 옵션들이 추가될 예정이라서, 공식 문서를 꾸준히 확인하는 걸 추천드려요.</p>
<hr>
<p>마지막으로 Next.js의 캐시 전략은 점점 발전 중이라서, 개발자가 직접 캐시 태그를 관리하며 성능을 최적화할 수 있는 부분이 늘고 있어요. 보다 유연하고 빠른 데이터 페칭을 위한 중요한 기능이니, 꼭 한번 직접 써보시면서 익혀두시면 좋을 것 같아요! 혹시 서비스 로딩 속도가 느리거나 데이터 최신화에 문제가 있을 때, 캐시 무효화 전략부터 점검해보세요 :)</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Next.js에서 페이지를 캐싱하고 재검증하는 기능인 Incremental Static Regeneration(ISR)은 동일한 캐시를 공유해서 사용해요.</p>
<p>만약 Vercel에 배포한다면, ISR 캐시는 자동으로 안정적인 저장소에 저장되어서 데이터가 안전하게 보존되죠. 그런데 직접 서버를 운영(셀프 호스팅)할 때는 ISR 캐시가 Next.js 서버 내의 파일 시스템(디스크)에 저장돼요. Pages Router와 App Router 둘 다 셀프 호스팅할 때 이 방식이 자동으로 적용됩니다.</p>
<p>또한 필요에 따라 Next.js 캐시 위치를 직접 설정할 수도 있어요. 이렇게 하면 캐시된 페이지와 데이터를 더 영속적인 저장소에 보관할 수 있고, 여러 컨테이너나 인스턴스에서 캐시를 공유하는 것도 가능해집니다. 더 자세한 설정 방법은 공식 문서를 참고해 보세요.</p>
<hr>
<h3>간단히 말해서!</h3>
<ul>
<li><strong>Vercel 배포:</strong> 캐시 자동 저장(내구성 있는 저장소)</li>
<li><strong>셀프 호스팅:</strong> 캐시가 서버 디스크에 저장</li>
<li><strong>캐시 위치 변경 가능:</strong> 여러 서버 간 캐시 공유 및 데이터 보존 용도</li>
</ul>
<p>만약 캐시 문제가 발생하거나 페이지가 예상대로 재검증되지 않는다면 캐시 설정을 점검해 보는 게 좋겠죠? 다음번에는 흔한 이슈와 해결법도 함께 소개할게요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>로컬 개발 환경에서 캐시된 데이터 디버깅하기</h3>
<p>fetch API를 사용할 때, 어떤 요청이 캐시된 것인지, 혹은 캐시되지 않은 것인지 확인하고 싶다면 추가적인 로깅(logging) 설정을 해보는 게 좋아요. 이렇게 하면 네트워크 요청이 실제로 어떻게 처리되는지 한눈에 파악할 수 있답니다.</p>
<p>예를 들어, 아래처럼 <code>logging</code> 옵션을 설정하면 모든 fetch 호출의 전체 URL(fullUrl)을 로그로 남길 수 있어요.</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">logging</span>: {
    <span class="hljs-attr">fetches</span>: {
      <span class="hljs-attr">fullUrl</span>: <span class="hljs-literal">true</span>,
    },
  },
}
</code></pre>
<p>이 설정을 통해 "아, 이 요청은 캐시에서 바로 가져왔구나", "이 요청은 서버에 직접 다녀왔구나" 같은 정보를 쉽게 알 수 있게 됩니다. 특히 복잡한 캐싱 로직을 다룰 때, 문제를 빠르게 찾아내는 데 정말 유용하죠.</p>
<p>또한, 브라우저 개발자 도구(Network 탭)를 열어 보거나, 서버에서 캐시 헤더(Cache-Control, ETag 등)를 확인하는 것도 도움이 됩니다. 이런 방법들을 병행하면 캐시 동작을 더 명확히 이해할 수 있어요.</p>
<h3>프로덕션 환경에서의 올바른 동작 확인하기</h3>
<p>로컬 환경에서 잘 작동한다고 해도, 프로덕션 환경에서는 다른 조건들이 작용할 수 있어요. 그렇기 때문에 실제 운영 서버에서 캐시가 제대로 동작하는지 반드시 확인해야 합니다. 다음과 같은 점들을 체크해 보세요.</p>
<ul>
<li><strong>실제 네트워크 요청 확인</strong>: 운영 중인 서버의 로그 혹은 브라우저 개발자 도구를 통해 매 요청마다 캐시가 제대로 적용되는지 봅니다.</li>
<li><strong>HTTP 캐시 헤더 점검</strong>: 서버가 올바른 캐시 정책을 설정했는지 확인해 보세요. 캐시 만료시간, 재검증(ETag, Last-Modified) 관련 헤더들이 적절히 사용되는지 중요합니다.</li>
<li><strong>캐시 무효화 전략 검토</strong>: 업데이트가 필요한 데이터가 있을 때 캐시가 제대로 초기화(unset)되는지 테스트해 보아야 합니다.</li>
<li><strong>콘텐츠 배포 네트워크(CDN) 설정</strong>: 만약 CDN을 사용한다면 CDN 캐시 정책도 함께 고려해야 하니, CDN 로그나 설정도 꼭 살펴보세요.</li>
</ul>
<p>이처럼 디버깅할 때 로컬 개발 환경뿐 아니라 프로덕션 환경에서의 케이스까지 살펴보면, 예상치 못한 캐싱 문제를 미리 차단할 수 있어서 안정적인 서비스를 운영할 수 있답니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>프로덕션 환경에서 페이지가 제대로 캐시되고 재검증되는지 확인하려면, 로컬에서 직접 테스트해보는 게 좋아요. 방법은 간단해요!</p>
<ol>
<li>먼저 <code>next build</code> 명령어로 프로젝트를 빌드합니다.</li>
<li>그리고 <code>next start</code>로 프로덕션용 Next.js 서버를 실행해보세요.</li>
</ol>
<p>이렇게 하면 ISR(Incremental Static Regeneration) 동작을 실제 프로덕션 환경처럼 경험할 수 있어요.</p>
<p>그리고 개발하는 동안 캐시 동작을 좀 더 자세히 보고 싶다면, 프로젝트 루트에 있는 <code>.env</code> 파일에 아래 환경 변수를 추가해보세요.</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">NEXT_PRIVATE_DEBUG_CACHE</span>=<span class="hljs-number">1</span>
</code></pre>
<p>이걸 넣으면 Next.js 서버 콘솔에서 ISR 캐시 히트(hit)와 미스(miss) 정보를 출력해줍니다. 덕분에 빌드 과정에서 생성된 페이지들과, 사용자 요청에 따라 어떤 경로들이 새롭게 생성되는지 세세하게 확인할 수 있죠.</p>
<hr>
<p>추가로 팁 하나! 서버 로그를 보면서 페이지가 갱신되는 타이밍을 체크하면, 재검증 설정(<code>revalidate</code> 옵션)과 실제 동작이 잘 맞는지 쉽게 디버깅할 수 있어요. 혹시 ISR이 잘 작동하지 않는다고 느껴지면, 이 환경 변수 설정과 로그 확인부터 해보시길 추천합니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>주의할 점 (Caveats)</h2>
<ul>
<li>ISR(Incremental Static Regeneration)은 기본적으로 Node.js 런타임 환경에서만 지원돼요.</li>
<li>Static Export 방식으로 프로젝트를 만들 때는 ISR을 사용할 수 없답니다.</li>
<li>정적으로 렌더링된 경로에서 여러 개의 fetch 요청을 하고 각각 다른 revalidate 주기를 설정했다면, 가장 짧은 시간이 ISR에 적용돼요. 하지만 Data Cache에서는 각각 설정한 재검증 주기가 따로 지켜진답니다.</li>
<li>만약 경로 내 fetch 요청 중에 revalidate 시간이 0이거나 명시적으로 no-store가 설정되어 있다면, 그 경로는 동적으로 렌더링돼요.</li>
<li>미들웨어(Middleware)는 on-demand ISR 요청에는 실행되지 않아요. 즉, 경로 재작성(path rewrites)이나 미들웨어 내 로직이 적용되지 않으니, 재검증할 때는 꼭 정확한 경로를 지정해야 해요. 예를 들어, /post-1로 rewrite된 경로가 아니라 /post/1과 같이 실제 경로를 사용해야 합니다.</li>
</ul>
<hr>
<h2>버전 히스토리 (Version history)</h2>





























<table><thead><tr><th>버전</th><th>변경 사항</th></tr></thead><tbody><tr><td>v14.1.0</td><td>커스텀 <code>cacheHandler</code>가 안정화되었어요.</td></tr><tr><td>v13.0.0</td><td>App Router가 도입되었답니다.</td></tr><tr><td>v12.2.0</td><td>Pages Router에서 On-Demand ISR이 안정화됐어요.</td></tr><tr><td>v12.0.0</td><td>Pages Router에 <a href="https://nextjs.org/blog/next-12#bot-aware-isr-fallback" rel="nofollow" target="_blank">Bot-aware ISR fallback</a>이 추가되었죠.</td></tr><tr><td>v9.5.0</td><td>Pages Router에 <a href="https://nextjs.org/blog/next-9-5" rel="nofollow" target="_blank">안정화된 ISR</a>이 도입되었어요.</td></tr></tbody></table>
<hr>
<p>이번 내용에서는 Next.js에서 ISR을 사용할 때 주의해야 할 점들과 버전별 주요 업데이트 소식을 함께 정리했는데요, 보통 ISR을 잘 활용하면 성능과 SEO 모두 잡을 수 있어 굉장히 유용해요. 다만 위에서 언급한 몇 가지 제한사항들을 꼭 숙지해서 개발 중 예상치 못한 문제가 생기지 않도록 하는 게 중요해요.</p>
<p>또한, 버전업이 자주 되기 때문에 새로운 기능이나 안정화된 기능들은 공식 블로그나 문서를 꾸준히 체크하는 걸 추천드려요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Next.js 15에서 Incremental Static Regeneration(ISR)로 정적 웹사이트 업데이트 하기","description":"","date":"2025-04-22 02:01","slug":"2025-04-22-IncrementalStaticRegenerationISR","content":"\n\n# Incremental Static Regeneration (ISR)이란?\n\n안녕하세요! 오늘은 **Incremental Static Regeneration (ISR)**에 대해 쉽고 간단하게 이야기해보려고 해요. ISR은 특히 Next.js 같은 프레임워크에서 자주 쓰이는 개념인데, 기본적으로 정적 페이지를 효율적으로 업데이트할 수 있게 해주는 방법이에요.\n\n---\n\n## ISR이 왜 좋을까?\n\n- **전체 사이트를 다시 빌드하지 않아도 돼요!**  \n  기존에 정적으로 생성된 페이지들을 모두 다시 생성하는 대신, 바뀐 페이지만 업데이트할 수 있답니다.\n\n- **서버 부하가 줄어들어요.**  \n  거의 대부분의 요청에 대해 이미 만들어진 정적 페이지를 바로 보여주기 때문에 서버가 한결 가벼워져요.\n\n- **cache-control 헤더가 자동으로 달려요.**  \n  페이지마다 적절한 캐시 정책이 적용되어서, 사용자에게 빠른 경험을 제공할 수 있어요.\n\n- **콘텐츠가 많은 사이트도 걱정 끝!**  \n  많은 페이지를 가진 사이트도 빌드 시간이 너무 길어지는 걸 피할 수 있어요.\n\n---\n\n## 간단한 예시\n\n다음은 ISR을 활용한 아주 기본적인 Next.js의 `getStaticProps` 예시입니다.\n\n```jsx\nexport async function getStaticProps() {\n  const data = await fetchDataSomehow();\n\n  return {\n    props: {\n      data,\n    },\n    // 페이지가 60초마다 다시 생성되도록 설정\n    revalidate: 60,\n  };\n}\n```\n\n위에서 핵심은 `revalidate` 키예요. 여기서 60초를 지정했으니, 사용자가 페이지에 접속할 때마다 적어도 60초가 지난 후에는 새로 데이터를 가져와서 페이지를 다시 만들어줘요. \n\n즉, \"최소 60초 주기로 페이지를 갱신한다\" 라고 이해하면 돼요.\n\n---\n\n## 좀 더 알려드리는 팁!\n\n- `revalidate`에 너무 짧은 시간을 설정하면, 서버 부하가 다시 올라갈 수 있으니 적당한 값을 찾는 게 중요해요.\n- 현재 Next.js는 ISR을 사용하면서 자동으로 incremental cache를 관리해줍니다. 덕분에 개발자가 별도로 캐싱 로직을 신경 쓸 필요가 줄어듭니다.\n- 빌드 후 데이터가 자주 변경되는 뉴스, 블로그, 마켓플레이스 같은 서비스에서 굉장히 빛을 발합니다.\n\n---\n\n자, 오늘은 ISR에 대해서 간단히 알아봤는데요. 정적 사이트의 장점과 동적인 데이터 갱신을 함께 누리고 싶은 분들에게 정말 추천드리는 기술이에요. 더 궁금한 점이나 실제 예제 궁금하면 언제든지 댓글 달아주세요! 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러분, Next.js에서 동적 라우팅과 ISR(Incremental Static Regeneration)을 활용하는 예제를 하나 같이 살펴볼게요! 위에 작성된 코드를 바탕으로 우리 블로그 포스트 페이지를 만든다고 가정해봅시다.\n\n### 이 코드가 뭘 하는 거냐면요\n\n- `generateStaticParams` 함수 안에서 `https://api.vercel.app/blog` API를 호출해, 빌드 시점에 미리 25개의 블로그 포스트 경로를 생성해요.\n- 이렇게 미리 생성된 페이지들은 사용자 요청 시 즉시 로드되고 캐시되죠.\n- `revalidate = 60` 설정 덕분에, 60초마다 페이지가 백그라운드에서 다시 생성됩니다. 즉, 오래된 페이지를 보여주더라도 동시에 최신 페이지를 서버에서 준비시키는 거예요.\n- 만약 아직 생성하지 않은 새로운 블로그 포스트 URL이 들어오면, `dynamicParams = true` 설정 때문에 404 대신 서버에서 해당 페이지를 “on-demand”로 생성해줍니다.\n\n한 마디로, 정적 생성과 서버 사이드 렌더링의 장점을 적절히 섞어 어떤 페이지는 미리 생성해 빠르게 제공하고, 새 페이지는 요청이 들어올 때 만들어서 서비스하는 똑똑한 방식인 거죠!\n\n---\n\n### 조금 더 풀어서 설명해볼게요!\n\n| 설정                     | 설명                                                        |\n|-------------------------|-------------------------------------------------------------|\n| `revalidate = 60`       | 한번 캐싱한 페이지는 60초간 다시 생성하지 않고 캐시를 사용함. 60초 후 첫 요청 때 백그라운드로 새 페이지를 생성함. |\n| `dynamicParams = true`  | `generateStaticParams`에 없는 경로가 요청되면 404가 아닌 동적으로 페이지를 생성함. |\n| `generateStaticParams`  | 빌드 타임에 미리 생성할 동적 경로 목록을 반환함. 이 예제는 모든 블로그 포스트 ID가 여기 포함됨. |\n| `Page` 컴포넌트          | 요청된 `id` 파라미터로부터 해당 포스트를 API에서 받아와서 렌더링함. |\n\n---\n\n### 추가적으로 알아두면 좋은 점!\n\n- 이 방식은 데이터가 자주 변하지 않는 콘텐츠에 딱 맞아요. 아주 빠른 실시간 업데이트는 어렵지만, 몇 분 단위 변경이라면 사용자 경험을 살릴 수 있습니다.\n- 만약 완전 최신 데이터가 필요하면 `revalidate`를 0으로 두고 매 요청마다 서버 렌더링(SSR)을 할 수도 있어요. 하지만 속도는 느려질 수 있죠.\n- Next.js 13버전 이상에서 도입된 이 방식은 ISR과 동적 라우팅을 동시에 처리할 때 좋은 선택이니, 블로그나 뉴스 사이트 같은 프로젝트에 활용해보세요!\n\n---\n\n필요하면 제가 이 코드를 기반으로 직접 해볼 수 있는 샘플 프로젝트도 만들어서 공유해드릴게요. 혹시 관련해서 궁금한 점, 더 깊게 알고 싶은 부분 있으면 편하게 물어봐 주세요!\n\n참고로 공식 문서도 정말 잘 정리되어 있으니 한 번 쭉 읽어보시면 큰 도움이 됩니다.\n\n---\n\n## 참고 자료\n\n- [Next.js Dynamic Routes \u0026 ISR 공식 문서](https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes#incremental-static-regeneration)\n- [Next.js 13 App Router 소개](https://nextjs.org/docs/getting-started/upgrade-guide#app-router)\n\n다음에도 쓸모 있는 Next.js 팁으로 찾아올게요! :)\n\n---\n\n\u003e 혹시 이 내용을 마크다운 문서로 쓰거나 블로그에 올리고 싶다면 추가 설명과 코드는 댓글로도 언제든 요청해 주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 라우트 세그먼트 설정(Route segment config)\n\n라우트를 잘 관리하려면 설정할 수 있는 옵션들이 몇 가지 있는데요, 대표적으로 `revalidate`와 `dynamicParams`가 있어요.\n\n| 옵션 이름       | 설명                                                         |\n|----------------|--------------------------------------------------------------|\n| revalidate     | 해당 라우트 데이터를 다시 검증하는 주기(초 단위)를 설정해요. 이걸 설정하면 데이터를 자동으로 갱신해서 최신 상태를 유지할 수 있답니다.  |\n| dynamicParams  | 라우트에서 동적 파라미터를 사용할지 여부를 결정해요. 동적 파라미터란 URL 경로 내에서 변하는 값들을 말하죠(예: `/post/[id]`의 `id`). 이 옵션으로 다루는 방식을 설정할 수 있어요. |\n\n---\n\n### 함수 소개(Functions)\n\n`revalidate`와 연관해서 사용할 수 있는 함수들도 있어요! 주로 캐시를 새로고침하거나 특정 경로를 다시 유효화하는 용도로 쓰이는데요.\n\n| 함수 이름       | 설명                                                                                          |\n|----------------|-----------------------------------------------------------------------------------------------|\n| revalidatePath  | 특정 경로(path)에 대해 데이터를 재검증하도록 요청하는 함수예요. 예를 들어, 어떤 글을 수정한 후 그 경로를 갱신할 때 사용하죠.  |\n| revalidateTag   | 태그(tag)를 이용해 어느 그룹에 속한 데이터들을 한 번에 다시 검증하도록 할 수 있어요. 여러 경로를 묶어서 관리할 때 유용해요.       |\n\n---\n\n### 덧붙여서\n\nNext.js 같은 최신 웹 프레임워크들에서 이런 revalidation 시스템을 잘 활용하면, 서버의 부담을 크게 줄이면서도 사용자에게 항상 최신 데이터를 보여줄 수 있어요. 예를 들어, 자주 변하지 않는 페이지는 캐시를 오래 유지하고, 실시간으로 변하는 페이지는 자주 재검증해서 최적 성능을 유지할 수 있죠.\n\n또한, `dynamicParams` 옵션을 올바르게 설정하면, 빌드 시에 미리 생성할 경로나 런타임에 처리할 경로를 적절하게 나눌 수 있어서 프로젝트 구조를 깔끔하게 유지하는데 큰 도움이 돼요.\n\n이런 설정과 함수들을 잘 이해하고 활용해보시면, 더욱 빠르고 효율적인 웹앱을 만들 수 있답니다. 궁금하신 점 있으면 언제든 질문 주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 예시\n\n### 시간 기반 리밸리데이션(Time-based Revalidation)\n\n이 예시는 `/blog` 경로에서 블로그 글 목록을 불러와 보여주는 방법이에요. 그리고 중요한 점은 페이지에 캐시된 데이터가 1시간마다 새로 고쳐진다는 거죠. \n\n어떻게 동작하냐면, 첫 방문 시 데이터를 불러와서 캐시에 저장합니다. 그 후 1시간이 지나 다음에 페이지를 방문하면, 기존 캐시를 바로 버리고 다시 가져오는 게 아니라, 사용자에게는 기존 페이지를 보여주면서 백그라운드에선 새로운 글 목록으로 페이지를 다시 생성해 캐시를 업데이트해요. 덕분에 사용자는 항상 빠르고 끊김 없는 경험을, 백엔드는 최신 데이터를 보장할 수 있답니다.\n\n```js\ninterface Post {\n  id: string\n  title: string\n  content: string\n}\n \nexport const revalidate = 3600 // 3600초 = 1시간마다 캐시 무효화\n \nexport default async function Page() {\n  const data = await fetch('https://api.vercel.app/blog')\n  const posts: Post[] = await data.json()\n  return (\n    \u003cmain\u003e\n      \u003ch1\u003eBlog Posts\u003c/h1\u003e\n      \u003cul\u003e\n        {posts.map((post) =\u003e (\n          \u003cli key={post.id}\u003e{post.title}\u003c/li\u003e\n        ))}\n      \u003c/ul\u003e\n    \u003c/main\u003e\n  )\n}\n```\n\n---\n\n### 추가 팁!\n\n- 여기서 `revalidate` 값에 넣는 숫자는 초(seconds) 단위예요. 3600은 1시간을 의미하니까, 10분마다 갱신하려면 600으로 바꾸면 되겠죠?\n- 이렇게 시간 기반 갱신은 자주 변하지 않는 데이터에 딱이에요. 예를 들어 뉴스 헤드라인이나 프로필 정보처럼 자주 고쳐질 필요 없는 데이터를 캐시에 담기로 적합하죠.\n- 만약 데이터가 수시로 업데이트되어 즉각 반영이 필요하면 `revalidate`를 사용하지 않고 서버 사이드 렌더링(SSR) 또는 클라이언트 측 데이터 패칭을 고려해보세요.\n- `Next.js` 같은 최신 프레임워크를 쓰면 이런 캐시 전략을 아주 간편하게 구현할 수 있으니, 프로젝트에 따라 적절히 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n재검증(revalidation) 시간을 길게 설정하는 걸 추천해요. 예를 들어, 1초 대신 1시간으로 말이죠. 만약 더 세밀한 데이터 갱신이 필요하다면 on-demand revalidation(필요할 때만 재검증)를 고려해보세요. 그리고 실시간 데이터가 꼭 필요하다면, 동적 렌더링(dynamic rendering)으로 전환하는 것도 좋은 방법입니다.\n\n### 필요할 때만 재검증: revalidatePath 활용법\n\n좀 더 정확하게 데이터 재검증을 하고 싶다면, revalidatePath 함수를 써서 페이지를 필요할 때만 무효화시키는 방법이 있어요.\n\n예를 들어, 새로운 게시글을 추가한 후에 이 Server Action을 호출하면, Server Component에서 fetch를 쓰든 DB에 직접 연결하든 상관없이 해당 경로(route)의 캐시를 지우고, Server Component가 새로운 데이터를 가져오도록 할 수 있습니다.\n\n이렇게 하면 불필요한 데이터 갱신을 줄이면서도 필요한 순간에 최신 데이터를 보여줄 수 있어서 성능과 사용자 경험 두 마리 토끼를 잡을 수 있답니다. \n\n간단하게 요약하면:\n\n| 상황                  | 추천 방법                         |\n|---------------------|------------------------------|\n| 데이터 갱신이 1초 단위로 자주 필요하다면 | on-demand revalidation 사용       |\n| 실시간 데이터가 꼭 필요하다면        | 동적 렌더링(dynamic rendering) 고려 |\n| 갱신 주기가 길어도 무방하다면       | 긴 revalidation 시간(예: 1시간) 설정 | \n\n이렇게 상황에 맞게 적절한 방법을 선택하는 게 중요해요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러분, Next.js에서 서버 측 캐시를 관리할 때 `revalidatePath` 함수만큼 유용한 게 없어요. 위 코드처럼 `/posts` 경로의 캐시를 무효화하고 싶을 때 아주 간단하게 쓸 수 있거든요.\n\n```js\n'use server'\n \nimport { revalidatePath } from 'next/cache'\n \nexport async function createPost() {\n  // /posts 경로 캐시를 무효화하기\n  revalidatePath('/posts')\n}\n```\n\n이렇게 하면 새로운 게시글을 추가하고 나서 바로 `/posts`를 방문했을 때 최신 글 목록을 볼 수 있죠.\n\n### 근데, 만약 경로 단위가 아니라 더 세밀한 캐시 무효화가 필요하다면?\n\n바로 `revalidateTag`라는 기능을 써볼 수 있어요. 이건 fetch 요청에 태그를 달아서, 특정 태그가 붙은 데이터만 골라서 다시 불러오게 하는 방법이에요. 예를 들어, 게시글 하나하나에 태그를 붙여서 수정된 글만 빠르게 반영하도록 할 수 있죠.\n\n#### 간단 예시\n\n```js\n'use server'\n\nimport { revalidateTag } from 'next/cache'\n\nexport async function updatePost(id) {\n  // 특정 게시글에 붙은 태그를 기반으로 캐시를 무효화하기\n  revalidateTag(`post-${id}`)\n}\n```\n\nfetch를 할 때도 태그를 붙여줘야 하는데요,\n\n```js\nconst post = await fetch(`/api/posts/${id}`, {\n  next: { tags: [`post-${id}`] },\n}).then(res =\u003e res.json())\n```\n\n이렇게 하면 이 게시글은 `post-123` 같은 식으로 태그가 붙고, 해당 게시글이 업데이트될 때만 캐시가 무효화되어 더 효과적으로 리소스를 관리할 수 있답니다.\n\n---\n\n### 정리\n\n| 함수명           | 역할                           | 사용 케이스                               |\n|----------------|------------------------------|----------------------------------------|\n| `revalidatePath` | 경로 단위 캐시 무효화                | 페이지 전체를 새로 고쳐야 할 때                      |\n| `revalidateTag` | 태그 단위 캐시 무효화                | 데이터 단위로 세밀하게 캐시를 관리하고 싶을 때          |\n\n---\n\n이렇게 `revalidateTag`를 활용하면, 대용량 데이터나 자주 변경되는 목록이 있을 때 정말 도움 많이 돼요. 오늘 바로 적용해보시고 캐시 전략 더 똑똑하게 짜보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 데이터를 효율적으로 캐싱하고 다시 불러오는 방법에 대해 알아볼게요! 특히 `fetch` 함수와 ORM을 이용할 때, 그리고 캐시를 자동으로 재검증하는 방법까지 다뤄보겠습니다.\n\n---\n\n### 1. fetch 함수에 `next` 옵션으로 태그 지정하기\n\n```js\nexport default async function Page() {\n  const data = await fetch('https://api.vercel.app/blog', {\n    next: { tags: ['posts'] }, // 여기에 태그를 넣어 캐시를 관리할 수 있어요\n  })\n  const posts = await data.json()\n  // 이제 posts를 화면에 렌더링\n}\n```\n\n- `next: { tags: ['posts'] }` 옵션을 주면, 이 요청이 `'posts'`라는 태그와 연결돼서 관리돼요.\n- 나중에 `'posts'` 태그가 변경됐을 때 캐시를 재검증 할 수 있답니다.\n\n---\n\n### 2. ORM이나 DB 연결 시 `unstable_cache` 사용하기\n\n```js\nimport { unstable_cache } from 'next/cache'\nimport { db, posts } from '@/lib/db'\n \nconst getCachedPosts = unstable_cache(\n  async () =\u003e {\n    return await db.select().from(posts)  // 데이터베이스에서 포스트를 조회\n  },\n  ['posts'],                   // 캐시 관련 태그\n  { revalidate: 3600, tags: ['posts'] }  // 3600초(1시간)마다 재검증, tags와 연결\n)\n \nexport default async function Page() {\n  const posts = getCachedPosts()  // 캐시된 데이터를 불러옴\n  // ...\n}\n```\n\n- `unstable_cache` 함수는 캐시된 결과를 기억하며 해당 데이터를 재활용해요.\n- `revalidate` 옵션으로 몇 초마다 다시 데이터를 불러올지 설정할 수 있어요.\n- 태그를 사용해서 데이터를 더욱 세밀하게 관리 가능!\n\n---\n\n### 3. 캐시가 무효화되었을 때 재검증하기 - `revalidateTag` 활용\n\n서버 액션(Server Actions)이나 라우트 핸들러(Route Handler) 안에서 다음과 같이 캐시 태그를 재검증할 수 있습니다:\n\n```js\nimport { revalidateTag } from 'next/cache'\n\nexport async function POST(request) {\n  // 예를 들어 데이터를 변경하는 로직\n  // ...\n  \n  // 변경 후 'posts' 태그 관련 캐시를 재검증해서 최신 데이터 사용하도록 유도\n  revalidateTag('posts')\n\n  return new Response('Updated and cache revalidated')\n}\n```\n\n- 업데이트가 발생하면 캐시 무효화를 하면서 관련된 태그를 재검증합니다.\n- 이렇게 하면 데이터가 바뀌었을 때 페이지가 최신 상태로 렌더링돼요.\n\n---\n\n## 조금 더!\n\n- 이 태그 기반 캐시 전략은 여러 페이지에서 같은 API 데이터를 공유할 때 정말 유용해요.\n- `unstable_cache`는 아직 `unstable` 단계이니, 공식 문서나 업데이트 내용을 주의 깊게 지켜보는 게 좋아요.\n- `fetch` 함수의 `next` 옵션 중에 `revalidate` 값을 직접 지정할 수도 있고, `tags`와 혼합해서 사용하면 훨씬 강력한 캐싱 전략을 구성할 수 있습니다.\n\n잘 활용하면 페이지 성능과 데이터 일관성을 높일 수 있으니 여유 있을 때 한번 적용해보세요! 도움이 되셨으면 좋겠네요. 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번에는 Next.js에서 서버 측 캐시를 다루는 방법 중에서, revalidateTag 함수를 사용하는 간단한 예제를 살펴보고, 오류 처리와 캐시 위치 커스터마이징에 대해 알아볼게요.\n\n```js\n'use server'\n \nimport { revalidateTag } from 'next/cache'\n \nexport async function createPost() {\n  // 'posts'라는 태그가 붙은 모든 캐시 데이터를 무효화합니다.\n  revalidateTag('posts')\n}\n```\n\n위 코드에서 `revalidateTag('posts')`를 호출하면, 캐시에 'posts'라는 태그로 분류된 데이터가 모두 무효화되어 다음 요청 시 새로운 데이터를 다시 가져오도록 만듭니다. 이렇게 하면 게시글 리스트나 관련 콘텐츠가 업데이트될 때, 서버 캐시를 손쉽게 갱신할 수 있죠.\n\n### 예기치 않은 예외 처리 (Handling uncaught exceptions)\n\n만약 데이터 재검증 중에 에러가 발생한다면, Next.js는 바로 새로운 데이터 요청을 실패하더라도 이전에 성공적으로 생성된 데이터를 계속해서 캐시에서 제공합니다. 즉, 사용자에게는 데이터가 갑자기 사라지거나 오류가 노출되지 않고 안정적으로 서비스가 유지됩니다. 그리고 다음 요청 시점에 다시 재검증을 시도하니, 일시적인 문제라도 금방 해결됩니다.\n\n이 부분이 꽤나 유용한데, 서버 오류로 인한 서비스 중단 없이도 캐시가 안정적으로 유지되고 복구되기 때문이죠.\n\n### 캐시 위치 커스터마이징하기\n\nNext.js 내장 캐시는 기본적으로 프로젝트 내 `.next/cache` 폴더에 저장됩니다. 하지만 상황에 따라 캐시 위치를 바꾸고 싶을 때가 있죠. 예를 들어, CI/CD 환경에서 캐시를 공유하거나 특정 디스크 경로에 캐시를 두고 싶을 때가 그렇답니다.\n\nNext.js에서는 `next.config.js` 파일에서 `experimental` 설정 아래 `serverActions`와 같은 옵션을 다루듯, 캐시 관련 설정도 향후 업데이트를 기대할 수 있는데, 현재 공식 문서에서는 구체적인 캐시 위치 변경 방법은 제한적입니다. 그래도 곧 더 다양한 설정 옵션들이 추가될 예정이라서, 공식 문서를 꾸준히 확인하는 걸 추천드려요.\n\n---\n\n마지막으로 Next.js의 캐시 전략은 점점 발전 중이라서, 개발자가 직접 캐시 태그를 관리하며 성능을 최적화할 수 있는 부분이 늘고 있어요. 보다 유연하고 빠른 데이터 페칭을 위한 중요한 기능이니, 꼭 한번 직접 써보시면서 익혀두시면 좋을 것 같아요! 혹시 서비스 로딩 속도가 느리거나 데이터 최신화에 문제가 있을 때, 캐시 무효화 전략부터 점검해보세요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 페이지를 캐싱하고 재검증하는 기능인 Incremental Static Regeneration(ISR)은 동일한 캐시를 공유해서 사용해요. \n\n만약 Vercel에 배포한다면, ISR 캐시는 자동으로 안정적인 저장소에 저장되어서 데이터가 안전하게 보존되죠. 그런데 직접 서버를 운영(셀프 호스팅)할 때는 ISR 캐시가 Next.js 서버 내의 파일 시스템(디스크)에 저장돼요. Pages Router와 App Router 둘 다 셀프 호스팅할 때 이 방식이 자동으로 적용됩니다.\n\n또한 필요에 따라 Next.js 캐시 위치를 직접 설정할 수도 있어요. 이렇게 하면 캐시된 페이지와 데이터를 더 영속적인 저장소에 보관할 수 있고, 여러 컨테이너나 인스턴스에서 캐시를 공유하는 것도 가능해집니다. 더 자세한 설정 방법은 공식 문서를 참고해 보세요.\n\n---\n\n### 간단히 말해서!\n- **Vercel 배포:** 캐시 자동 저장(내구성 있는 저장소)\n- **셀프 호스팅:** 캐시가 서버 디스크에 저장\n- **캐시 위치 변경 가능:** 여러 서버 간 캐시 공유 및 데이터 보존 용도\n\n만약 캐시 문제가 발생하거나 페이지가 예상대로 재검증되지 않는다면 캐시 설정을 점검해 보는 게 좋겠죠? 다음번에는 흔한 이슈와 해결법도 함께 소개할게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 로컬 개발 환경에서 캐시된 데이터 디버깅하기\n\nfetch API를 사용할 때, 어떤 요청이 캐시된 것인지, 혹은 캐시되지 않은 것인지 확인하고 싶다면 추가적인 로깅(logging) 설정을 해보는 게 좋아요. 이렇게 하면 네트워크 요청이 실제로 어떻게 처리되는지 한눈에 파악할 수 있답니다. \n\n예를 들어, 아래처럼 `logging` 옵션을 설정하면 모든 fetch 호출의 전체 URL(fullUrl)을 로그로 남길 수 있어요.\n\n```js\nmodule.exports = {\n  logging: {\n    fetches: {\n      fullUrl: true,\n    },\n  },\n}\n```\n\n이 설정을 통해 \"아, 이 요청은 캐시에서 바로 가져왔구나\", \"이 요청은 서버에 직접 다녀왔구나\" 같은 정보를 쉽게 알 수 있게 됩니다. 특히 복잡한 캐싱 로직을 다룰 때, 문제를 빠르게 찾아내는 데 정말 유용하죠.\n\n또한, 브라우저 개발자 도구(Network 탭)를 열어 보거나, 서버에서 캐시 헤더(Cache-Control, ETag 등)를 확인하는 것도 도움이 됩니다. 이런 방법들을 병행하면 캐시 동작을 더 명확히 이해할 수 있어요.\n\n### 프로덕션 환경에서의 올바른 동작 확인하기\n\n로컬 환경에서 잘 작동한다고 해도, 프로덕션 환경에서는 다른 조건들이 작용할 수 있어요. 그렇기 때문에 실제 운영 서버에서 캐시가 제대로 동작하는지 반드시 확인해야 합니다. 다음과 같은 점들을 체크해 보세요.\n\n- **실제 네트워크 요청 확인**: 운영 중인 서버의 로그 혹은 브라우저 개발자 도구를 통해 매 요청마다 캐시가 제대로 적용되는지 봅니다.\n- **HTTP 캐시 헤더 점검**: 서버가 올바른 캐시 정책을 설정했는지 확인해 보세요. 캐시 만료시간, 재검증(ETag, Last-Modified) 관련 헤더들이 적절히 사용되는지 중요합니다.\n- **캐시 무효화 전략 검토**: 업데이트가 필요한 데이터가 있을 때 캐시가 제대로 초기화(unset)되는지 테스트해 보아야 합니다.\n- **콘텐츠 배포 네트워크(CDN) 설정**: 만약 CDN을 사용한다면 CDN 캐시 정책도 함께 고려해야 하니, CDN 로그나 설정도 꼭 살펴보세요.\n\n이처럼 디버깅할 때 로컬 개발 환경뿐 아니라 프로덕션 환경에서의 케이스까지 살펴보면, 예상치 못한 캐싱 문제를 미리 차단할 수 있어서 안정적인 서비스를 운영할 수 있답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프로덕션 환경에서 페이지가 제대로 캐시되고 재검증되는지 확인하려면, 로컬에서 직접 테스트해보는 게 좋아요. 방법은 간단해요!\n\n1. 먼저 `next build` 명령어로 프로젝트를 빌드합니다.\n2. 그리고 `next start`로 프로덕션용 Next.js 서버를 실행해보세요.\n\n이렇게 하면 ISR(Incremental Static Regeneration) 동작을 실제 프로덕션 환경처럼 경험할 수 있어요. \n\n그리고 개발하는 동안 캐시 동작을 좀 더 자세히 보고 싶다면, 프로젝트 루트에 있는 `.env` 파일에 아래 환경 변수를 추가해보세요.\n\n```js\nNEXT_PRIVATE_DEBUG_CACHE=1\n```\n\n이걸 넣으면 Next.js 서버 콘솔에서 ISR 캐시 히트(hit)와 미스(miss) 정보를 출력해줍니다. 덕분에 빌드 과정에서 생성된 페이지들과, 사용자 요청에 따라 어떤 경로들이 새롭게 생성되는지 세세하게 확인할 수 있죠.\n\n---\n\n추가로 팁 하나! 서버 로그를 보면서 페이지가 갱신되는 타이밍을 체크하면, 재검증 설정(`revalidate` 옵션)과 실제 동작이 잘 맞는지 쉽게 디버깅할 수 있어요. 혹시 ISR이 잘 작동하지 않는다고 느껴지면, 이 환경 변수 설정과 로그 확인부터 해보시길 추천합니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 주의할 점 (Caveats)\n\n- ISR(Incremental Static Regeneration)은 기본적으로 Node.js 런타임 환경에서만 지원돼요.\n- Static Export 방식으로 프로젝트를 만들 때는 ISR을 사용할 수 없답니다.\n- 정적으로 렌더링된 경로에서 여러 개의 fetch 요청을 하고 각각 다른 revalidate 주기를 설정했다면, 가장 짧은 시간이 ISR에 적용돼요. 하지만 Data Cache에서는 각각 설정한 재검증 주기가 따로 지켜진답니다.\n- 만약 경로 내 fetch 요청 중에 revalidate 시간이 0이거나 명시적으로 no-store가 설정되어 있다면, 그 경로는 동적으로 렌더링돼요.\n- 미들웨어(Middleware)는 on-demand ISR 요청에는 실행되지 않아요. 즉, 경로 재작성(path rewrites)이나 미들웨어 내 로직이 적용되지 않으니, 재검증할 때는 꼭 정확한 경로를 지정해야 해요. 예를 들어, /post-1로 rewrite된 경로가 아니라 /post/1과 같이 실제 경로를 사용해야 합니다.\n\n---\n\n## 버전 히스토리 (Version history)\n\n| 버전       | 변경 사항                                      |\n|------------|--------------------------------------------|\n| v14.1.0    | 커스텀 `cacheHandler`가 안정화되었어요.          |\n| v13.0.0    | App Router가 도입되었답니다.                      |\n| v12.2.0    | Pages Router에서 On-Demand ISR이 안정화됐어요.    |\n| v12.0.0    | Pages Router에 [Bot-aware ISR fallback](https://nextjs.org/blog/next-12#bot-aware-isr-fallback)이 추가되었죠. |\n| v9.5.0     | Pages Router에 [안정화된 ISR](https://nextjs.org/blog/next-9-5)이 도입되었어요. |\n\n---\n\n이번 내용에서는 Next.js에서 ISR을 사용할 때 주의해야 할 점들과 버전별 주요 업데이트 소식을 함께 정리했는데요, 보통 ISR을 잘 활용하면 성능과 SEO 모두 잡을 수 있어 굉장히 유용해요. 다만 위에서 언급한 몇 가지 제한사항들을 꼭 숙지해서 개발 중 예상치 못한 문제가 생기지 않도록 하는 게 중요해요.\n\n또한, 버전업이 자주 되기 때문에 새로운 기능이나 안정화된 기능들은 공식 블로그나 문서를 꾸준히 체크하는 걸 추천드려요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":19},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003eIncremental Static Regeneration (ISR)이란?\u003c/h1\u003e\n\u003cp\u003e안녕하세요! 오늘은 **Incremental Static Regeneration (ISR)**에 대해 쉽고 간단하게 이야기해보려고 해요. ISR은 특히 Next.js 같은 프레임워크에서 자주 쓰이는 개념인데, 기본적으로 정적 페이지를 효율적으로 업데이트할 수 있게 해주는 방법이에요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003eISR이 왜 좋을까?\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e전체 사이트를 다시 빌드하지 않아도 돼요!\u003c/strong\u003e\u003cbr\u003e\n기존에 정적으로 생성된 페이지들을 모두 다시 생성하는 대신, 바뀐 페이지만 업데이트할 수 있답니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e서버 부하가 줄어들어요.\u003c/strong\u003e\u003cbr\u003e\n거의 대부분의 요청에 대해 이미 만들어진 정적 페이지를 바로 보여주기 때문에 서버가 한결 가벼워져요.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003ecache-control 헤더가 자동으로 달려요.\u003c/strong\u003e\u003cbr\u003e\n페이지마다 적절한 캐시 정책이 적용되어서, 사용자에게 빠른 경험을 제공할 수 있어요.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e콘텐츠가 많은 사이트도 걱정 끝!\u003c/strong\u003e\u003cbr\u003e\n많은 페이지를 가진 사이트도 빌드 시간이 너무 길어지는 걸 피할 수 있어요.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003e간단한 예시\u003c/h2\u003e\n\u003cp\u003e다음은 ISR을 활용한 아주 기본적인 Next.js의 \u003ccode\u003egetStaticProps\u003c/code\u003e 예시입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetStaticProps\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e data = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetchDataSomehow\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003eprops\u003c/span\u003e: {\n      data,\n    },\n    \u003cspan class=\"hljs-comment\"\u003e// 페이지가 60초마다 다시 생성되도록 설정\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003erevalidate\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e,\n  };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위에서 핵심은 \u003ccode\u003erevalidate\u003c/code\u003e 키예요. 여기서 60초를 지정했으니, 사용자가 페이지에 접속할 때마다 적어도 60초가 지난 후에는 새로 데이터를 가져와서 페이지를 다시 만들어줘요.\u003c/p\u003e\n\u003cp\u003e즉, \"최소 60초 주기로 페이지를 갱신한다\" 라고 이해하면 돼요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e좀 더 알려드리는 팁!\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003erevalidate\u003c/code\u003e에 너무 짧은 시간을 설정하면, 서버 부하가 다시 올라갈 수 있으니 적당한 값을 찾는 게 중요해요.\u003c/li\u003e\n\u003cli\u003e현재 Next.js는 ISR을 사용하면서 자동으로 incremental cache를 관리해줍니다. 덕분에 개발자가 별도로 캐싱 로직을 신경 쓸 필요가 줄어듭니다.\u003c/li\u003e\n\u003cli\u003e빌드 후 데이터가 자주 변경되는 뉴스, 블로그, 마켓플레이스 같은 서비스에서 굉장히 빛을 발합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e자, 오늘은 ISR에 대해서 간단히 알아봤는데요. 정적 사이트의 장점과 동적인 데이터 갱신을 함께 누리고 싶은 분들에게 정말 추천드리는 기술이에요. 더 궁금한 점이나 실제 예제 궁금하면 언제든지 댓글 달아주세요! 😊\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e여러분, Next.js에서 동적 라우팅과 ISR(Incremental Static Regeneration)을 활용하는 예제를 하나 같이 살펴볼게요! 위에 작성된 코드를 바탕으로 우리 블로그 포스트 페이지를 만든다고 가정해봅시다.\u003c/p\u003e\n\u003ch3\u003e이 코드가 뭘 하는 거냐면요\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003egenerateStaticParams\u003c/code\u003e 함수 안에서 \u003ccode\u003ehttps://api.vercel.app/blog\u003c/code\u003e API를 호출해, 빌드 시점에 미리 25개의 블로그 포스트 경로를 생성해요.\u003c/li\u003e\n\u003cli\u003e이렇게 미리 생성된 페이지들은 사용자 요청 시 즉시 로드되고 캐시되죠.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erevalidate = 60\u003c/code\u003e 설정 덕분에, 60초마다 페이지가 백그라운드에서 다시 생성됩니다. 즉, 오래된 페이지를 보여주더라도 동시에 최신 페이지를 서버에서 준비시키는 거예요.\u003c/li\u003e\n\u003cli\u003e만약 아직 생성하지 않은 새로운 블로그 포스트 URL이 들어오면, \u003ccode\u003edynamicParams = true\u003c/code\u003e 설정 때문에 404 대신 서버에서 해당 페이지를 “on-demand”로 생성해줍니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e한 마디로, 정적 생성과 서버 사이드 렌더링의 장점을 적절히 섞어 어떤 페이지는 미리 생성해 빠르게 제공하고, 새 페이지는 요청이 들어올 때 만들어서 서비스하는 똑똑한 방식인 거죠!\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e조금 더 풀어서 설명해볼게요!\u003c/h3\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e설정\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003erevalidate = 60\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e한번 캐싱한 페이지는 60초간 다시 생성하지 않고 캐시를 사용함. 60초 후 첫 요청 때 백그라운드로 새 페이지를 생성함.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003edynamicParams = true\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003egenerateStaticParams\u003c/code\u003e에 없는 경로가 요청되면 404가 아닌 동적으로 페이지를 생성함.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003egenerateStaticParams\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e빌드 타임에 미리 생성할 동적 경로 목록을 반환함. 이 예제는 모든 블로그 포스트 ID가 여기 포함됨.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ePage\u003c/code\u003e 컴포넌트\u003c/td\u003e\u003ctd\u003e요청된 \u003ccode\u003eid\u003c/code\u003e 파라미터로부터 해당 포스트를 API에서 받아와서 렌더링함.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003ch3\u003e추가적으로 알아두면 좋은 점!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e이 방식은 데이터가 자주 변하지 않는 콘텐츠에 딱 맞아요. 아주 빠른 실시간 업데이트는 어렵지만, 몇 분 단위 변경이라면 사용자 경험을 살릴 수 있습니다.\u003c/li\u003e\n\u003cli\u003e만약 완전 최신 데이터가 필요하면 \u003ccode\u003erevalidate\u003c/code\u003e를 0으로 두고 매 요청마다 서버 렌더링(SSR)을 할 수도 있어요. 하지만 속도는 느려질 수 있죠.\u003c/li\u003e\n\u003cli\u003eNext.js 13버전 이상에서 도입된 이 방식은 ISR과 동적 라우팅을 동시에 처리할 때 좋은 선택이니, 블로그나 뉴스 사이트 같은 프로젝트에 활용해보세요!\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e필요하면 제가 이 코드를 기반으로 직접 해볼 수 있는 샘플 프로젝트도 만들어서 공유해드릴게요. 혹시 관련해서 궁금한 점, 더 깊게 알고 싶은 부분 있으면 편하게 물어봐 주세요!\u003c/p\u003e\n\u003cp\u003e참고로 공식 문서도 정말 잘 정리되어 있으니 한 번 쭉 읽어보시면 큰 도움이 됩니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e참고 자료\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes#incremental-static-regeneration\" rel=\"nofollow\" target=\"_blank\"\u003eNext.js Dynamic Routes \u0026#x26; ISR 공식 문서\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://nextjs.org/docs/getting-started/upgrade-guide#app-router\" rel=\"nofollow\" target=\"_blank\"\u003eNext.js 13 App Router 소개\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음에도 쓸모 있는 Next.js 팁으로 찾아올게요! :)\u003c/p\u003e\n\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003e혹시 이 내용을 마크다운 문서로 쓰거나 블로그에 올리고 싶다면 추가 설명과 코드는 댓글로도 언제든 요청해 주세요!\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003e라우트 세그먼트 설정(Route segment config)\u003c/h3\u003e\n\u003cp\u003e라우트를 잘 관리하려면 설정할 수 있는 옵션들이 몇 가지 있는데요, 대표적으로 \u003ccode\u003erevalidate\u003c/code\u003e와 \u003ccode\u003edynamicParams\u003c/code\u003e가 있어요.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e옵션 이름\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003erevalidate\u003c/td\u003e\u003ctd\u003e해당 라우트 데이터를 다시 검증하는 주기(초 단위)를 설정해요. 이걸 설정하면 데이터를 자동으로 갱신해서 최신 상태를 유지할 수 있답니다.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003edynamicParams\u003c/td\u003e\u003ctd\u003e라우트에서 동적 파라미터를 사용할지 여부를 결정해요. 동적 파라미터란 URL 경로 내에서 변하는 값들을 말하죠(예: \u003ccode\u003e/post/[id]\u003c/code\u003e의 \u003ccode\u003eid\u003c/code\u003e). 이 옵션으로 다루는 방식을 설정할 수 있어요.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003ch3\u003e함수 소개(Functions)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003erevalidate\u003c/code\u003e와 연관해서 사용할 수 있는 함수들도 있어요! 주로 캐시를 새로고침하거나 특정 경로를 다시 유효화하는 용도로 쓰이는데요.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e함수 이름\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003erevalidatePath\u003c/td\u003e\u003ctd\u003e특정 경로(path)에 대해 데이터를 재검증하도록 요청하는 함수예요. 예를 들어, 어떤 글을 수정한 후 그 경로를 갱신할 때 사용하죠.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003erevalidateTag\u003c/td\u003e\u003ctd\u003e태그(tag)를 이용해 어느 그룹에 속한 데이터들을 한 번에 다시 검증하도록 할 수 있어요. 여러 경로를 묶어서 관리할 때 유용해요.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003ch3\u003e덧붙여서\u003c/h3\u003e\n\u003cp\u003eNext.js 같은 최신 웹 프레임워크들에서 이런 revalidation 시스템을 잘 활용하면, 서버의 부담을 크게 줄이면서도 사용자에게 항상 최신 데이터를 보여줄 수 있어요. 예를 들어, 자주 변하지 않는 페이지는 캐시를 오래 유지하고, 실시간으로 변하는 페이지는 자주 재검증해서 최적 성능을 유지할 수 있죠.\u003c/p\u003e\n\u003cp\u003e또한, \u003ccode\u003edynamicParams\u003c/code\u003e 옵션을 올바르게 설정하면, 빌드 시에 미리 생성할 경로나 런타임에 처리할 경로를 적절하게 나눌 수 있어서 프로젝트 구조를 깔끔하게 유지하는데 큰 도움이 돼요.\u003c/p\u003e\n\u003cp\u003e이런 설정과 함수들을 잘 이해하고 활용해보시면, 더욱 빠르고 효율적인 웹앱을 만들 수 있답니다. 궁금하신 점 있으면 언제든 질문 주세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e예시\u003c/h2\u003e\n\u003ch3\u003e시간 기반 리밸리데이션(Time-based Revalidation)\u003c/h3\u003e\n\u003cp\u003e이 예시는 \u003ccode\u003e/blog\u003c/code\u003e 경로에서 블로그 글 목록을 불러와 보여주는 방법이에요. 그리고 중요한 점은 페이지에 캐시된 데이터가 1시간마다 새로 고쳐진다는 거죠.\u003c/p\u003e\n\u003cp\u003e어떻게 동작하냐면, 첫 방문 시 데이터를 불러와서 캐시에 저장합니다. 그 후 1시간이 지나 다음에 페이지를 방문하면, 기존 캐시를 바로 버리고 다시 가져오는 게 아니라, 사용자에게는 기존 페이지를 보여주면서 백그라운드에선 새로운 글 목록으로 페이지를 다시 생성해 캐시를 업데이트해요. 덕분에 사용자는 항상 빠르고 끊김 없는 경험을, 백엔드는 최신 데이터를 보장할 수 있답니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003einterface \u003cspan class=\"hljs-title class_\"\u003ePost\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: string\n  \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: string\n  \u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e: string\n}\n \n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e revalidate = \u003cspan class=\"hljs-number\"\u003e3600\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// 3600초 = 1시간마다 캐시 무효화\u003c/span\u003e\n \n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e data = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'https://api.vercel.app/blog'\u003c/span\u003e)\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eposts\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003ePost\u003c/span\u003e[] = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e data.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e()\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003emain\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003eBlog Posts\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eul\u003c/span\u003e\u003e\u003c/span\u003e\n        {posts.map((post) =\u003e (\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{post.id}\u003c/span\u003e\u003e\u003c/span\u003e{post.title}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e\u003e\u003c/span\u003e\n        ))}\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eul\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003emain\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003e추가 팁!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e여기서 \u003ccode\u003erevalidate\u003c/code\u003e 값에 넣는 숫자는 초(seconds) 단위예요. 3600은 1시간을 의미하니까, 10분마다 갱신하려면 600으로 바꾸면 되겠죠?\u003c/li\u003e\n\u003cli\u003e이렇게 시간 기반 갱신은 자주 변하지 않는 데이터에 딱이에요. 예를 들어 뉴스 헤드라인이나 프로필 정보처럼 자주 고쳐질 필요 없는 데이터를 캐시에 담기로 적합하죠.\u003c/li\u003e\n\u003cli\u003e만약 데이터가 수시로 업데이트되어 즉각 반영이 필요하면 \u003ccode\u003erevalidate\u003c/code\u003e를 사용하지 않고 서버 사이드 렌더링(SSR) 또는 클라이언트 측 데이터 패칭을 고려해보세요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eNext.js\u003c/code\u003e 같은 최신 프레임워크를 쓰면 이런 캐시 전략을 아주 간편하게 구현할 수 있으니, 프로젝트에 따라 적절히 활용해보세요!\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e재검증(revalidation) 시간을 길게 설정하는 걸 추천해요. 예를 들어, 1초 대신 1시간으로 말이죠. 만약 더 세밀한 데이터 갱신이 필요하다면 on-demand revalidation(필요할 때만 재검증)를 고려해보세요. 그리고 실시간 데이터가 꼭 필요하다면, 동적 렌더링(dynamic rendering)으로 전환하는 것도 좋은 방법입니다.\u003c/p\u003e\n\u003ch3\u003e필요할 때만 재검증: revalidatePath 활용법\u003c/h3\u003e\n\u003cp\u003e좀 더 정확하게 데이터 재검증을 하고 싶다면, revalidatePath 함수를 써서 페이지를 필요할 때만 무효화시키는 방법이 있어요.\u003c/p\u003e\n\u003cp\u003e예를 들어, 새로운 게시글을 추가한 후에 이 Server Action을 호출하면, Server Component에서 fetch를 쓰든 DB에 직접 연결하든 상관없이 해당 경로(route)의 캐시를 지우고, Server Component가 새로운 데이터를 가져오도록 할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이렇게 하면 불필요한 데이터 갱신을 줄이면서도 필요한 순간에 최신 데이터를 보여줄 수 있어서 성능과 사용자 경험 두 마리 토끼를 잡을 수 있답니다.\u003c/p\u003e\n\u003cp\u003e간단하게 요약하면:\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e상황\u003c/th\u003e\u003cth\u003e추천 방법\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e데이터 갱신이 1초 단위로 자주 필요하다면\u003c/td\u003e\u003ctd\u003eon-demand revalidation 사용\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e실시간 데이터가 꼭 필요하다면\u003c/td\u003e\u003ctd\u003e동적 렌더링(dynamic rendering) 고려\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e갱신 주기가 길어도 무방하다면\u003c/td\u003e\u003ctd\u003e긴 revalidation 시간(예: 1시간) 설정\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e이렇게 상황에 맞게 적절한 방법을 선택하는 게 중요해요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e여러분, Next.js에서 서버 측 캐시를 관리할 때 \u003ccode\u003erevalidatePath\u003c/code\u003e 함수만큼 유용한 게 없어요. 위 코드처럼 \u003ccode\u003e/posts\u003c/code\u003e 경로의 캐시를 무효화하고 싶을 때 아주 간단하게 쓸 수 있거든요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e'use server'\u003c/span\u003e\n \n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { revalidatePath } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/cache'\u003c/span\u003e\n \n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreatePost\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// /posts 경로 캐시를 무효화하기\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003erevalidatePath\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/posts'\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 새로운 게시글을 추가하고 나서 바로 \u003ccode\u003e/posts\u003c/code\u003e를 방문했을 때 최신 글 목록을 볼 수 있죠.\u003c/p\u003e\n\u003ch3\u003e근데, 만약 경로 단위가 아니라 더 세밀한 캐시 무효화가 필요하다면?\u003c/h3\u003e\n\u003cp\u003e바로 \u003ccode\u003erevalidateTag\u003c/code\u003e라는 기능을 써볼 수 있어요. 이건 fetch 요청에 태그를 달아서, 특정 태그가 붙은 데이터만 골라서 다시 불러오게 하는 방법이에요. 예를 들어, 게시글 하나하나에 태그를 붙여서 수정된 글만 빠르게 반영하도록 할 수 있죠.\u003c/p\u003e\n\u003ch4\u003e간단 예시\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e'use server'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { revalidateTag } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/cache'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eupdatePost\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eid\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 특정 게시글에 붙은 태그를 기반으로 캐시를 무효화하기\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003erevalidateTag\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`post-\u003cspan class=\"hljs-subst\"\u003e${id}\u003c/span\u003e`\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003efetch를 할 때도 태그를 붙여줘야 하는데요,\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e post = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`/api/posts/\u003cspan class=\"hljs-subst\"\u003e${id}\u003c/span\u003e`\u003c/span\u003e, {\n  \u003cspan class=\"hljs-attr\"\u003enext\u003c/span\u003e: { \u003cspan class=\"hljs-attr\"\u003etags\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e`post-\u003cspan class=\"hljs-subst\"\u003e${id}\u003c/span\u003e`\u003c/span\u003e] },\n}).\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eres\u003c/span\u003e =\u003e\u003c/span\u003e res.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 이 게시글은 \u003ccode\u003epost-123\u003c/code\u003e 같은 식으로 태그가 붙고, 해당 게시글이 업데이트될 때만 캐시가 무효화되어 더 효과적으로 리소스를 관리할 수 있답니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e정리\u003c/h3\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e함수명\u003c/th\u003e\u003cth\u003e역할\u003c/th\u003e\u003cth\u003e사용 케이스\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003erevalidatePath\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e경로 단위 캐시 무효화\u003c/td\u003e\u003ctd\u003e페이지 전체를 새로 고쳐야 할 때\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003erevalidateTag\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e태그 단위 캐시 무효화\u003c/td\u003e\u003ctd\u003e데이터 단위로 세밀하게 캐시를 관리하고 싶을 때\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003cp\u003e이렇게 \u003ccode\u003erevalidateTag\u003c/code\u003e를 활용하면, 대용량 데이터나 자주 변경되는 목록이 있을 때 정말 도움 많이 돼요. 오늘 바로 적용해보시고 캐시 전략 더 똑똑하게 짜보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eNext.js에서 데이터를 효율적으로 캐싱하고 다시 불러오는 방법에 대해 알아볼게요! 특히 \u003ccode\u003efetch\u003c/code\u003e 함수와 ORM을 이용할 때, 그리고 캐시를 자동으로 재검증하는 방법까지 다뤄보겠습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e1. fetch 함수에 \u003ccode\u003enext\u003c/code\u003e 옵션으로 태그 지정하기\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e data = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'https://api.vercel.app/blog'\u003c/span\u003e, {\n    \u003cspan class=\"hljs-attr\"\u003enext\u003c/span\u003e: { \u003cspan class=\"hljs-attr\"\u003etags\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e'posts'\u003c/span\u003e] }, \u003cspan class=\"hljs-comment\"\u003e// 여기에 태그를 넣어 캐시를 관리할 수 있어요\u003c/span\u003e\n  })\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e posts = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e data.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e()\n  \u003cspan class=\"hljs-comment\"\u003e// 이제 posts를 화면에 렌더링\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003enext: { tags: ['posts'] }\u003c/code\u003e 옵션을 주면, 이 요청이 \u003ccode\u003e'posts'\u003c/code\u003e라는 태그와 연결돼서 관리돼요.\u003c/li\u003e\n\u003cli\u003e나중에 \u003ccode\u003e'posts'\u003c/code\u003e 태그가 변경됐을 때 캐시를 재검증 할 수 있답니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003e2. ORM이나 DB 연결 시 \u003ccode\u003eunstable_cache\u003c/code\u003e 사용하기\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { unstable_cache } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/cache'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { db, posts } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@/lib/db'\u003c/span\u003e\n \n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e getCachedPosts = \u003cspan class=\"hljs-title function_\"\u003eunstable_cache\u003c/span\u003e(\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e () =\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e db.\u003cspan class=\"hljs-title function_\"\u003eselect\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003efrom\u003c/span\u003e(posts)  \u003cspan class=\"hljs-comment\"\u003e// 데이터베이스에서 포스트를 조회\u003c/span\u003e\n  },\n  [\u003cspan class=\"hljs-string\"\u003e'posts'\u003c/span\u003e],                   \u003cspan class=\"hljs-comment\"\u003e// 캐시 관련 태그\u003c/span\u003e\n  { \u003cspan class=\"hljs-attr\"\u003erevalidate\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3600\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etags\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e'posts'\u003c/span\u003e] }  \u003cspan class=\"hljs-comment\"\u003e// 3600초(1시간)마다 재검증, tags와 연결\u003c/span\u003e\n)\n \n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e posts = \u003cspan class=\"hljs-title function_\"\u003egetCachedPosts\u003c/span\u003e()  \u003cspan class=\"hljs-comment\"\u003e// 캐시된 데이터를 불러옴\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eunstable_cache\u003c/code\u003e 함수는 캐시된 결과를 기억하며 해당 데이터를 재활용해요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erevalidate\u003c/code\u003e 옵션으로 몇 초마다 다시 데이터를 불러올지 설정할 수 있어요.\u003c/li\u003e\n\u003cli\u003e태그를 사용해서 데이터를 더욱 세밀하게 관리 가능!\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003e3. 캐시가 무효화되었을 때 재검증하기 - \u003ccode\u003erevalidateTag\u003c/code\u003e 활용\u003c/h3\u003e\n\u003cp\u003e서버 액션(Server Actions)이나 라우트 핸들러(Route Handler) 안에서 다음과 같이 캐시 태그를 재검증할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { revalidateTag } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/cache'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePOST\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003erequest\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 예를 들어 데이터를 변경하는 로직\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n  \n  \u003cspan class=\"hljs-comment\"\u003e// 변경 후 'posts' 태그 관련 캐시를 재검증해서 최신 데이터 사용하도록 유도\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003erevalidateTag\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'posts'\u003c/span\u003e)\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eResponse\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Updated and cache revalidated'\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e업데이트가 발생하면 캐시 무효화를 하면서 관련된 태그를 재검증합니다.\u003c/li\u003e\n\u003cli\u003e이렇게 하면 데이터가 바뀌었을 때 페이지가 최신 상태로 렌더링돼요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003e조금 더!\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e이 태그 기반 캐시 전략은 여러 페이지에서 같은 API 데이터를 공유할 때 정말 유용해요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eunstable_cache\u003c/code\u003e는 아직 \u003ccode\u003eunstable\u003c/code\u003e 단계이니, 공식 문서나 업데이트 내용을 주의 깊게 지켜보는 게 좋아요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efetch\u003c/code\u003e 함수의 \u003ccode\u003enext\u003c/code\u003e 옵션 중에 \u003ccode\u003erevalidate\u003c/code\u003e 값을 직접 지정할 수도 있고, \u003ccode\u003etags\u003c/code\u003e와 혼합해서 사용하면 훨씬 강력한 캐싱 전략을 구성할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e잘 활용하면 페이지 성능과 데이터 일관성을 높일 수 있으니 여유 있을 때 한번 적용해보세요! 도움이 되셨으면 좋겠네요. 😊\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이번에는 Next.js에서 서버 측 캐시를 다루는 방법 중에서, revalidateTag 함수를 사용하는 간단한 예제를 살펴보고, 오류 처리와 캐시 위치 커스터마이징에 대해 알아볼게요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e'use server'\u003c/span\u003e\n \n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { revalidateTag } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/cache'\u003c/span\u003e\n \n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreatePost\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 'posts'라는 태그가 붙은 모든 캐시 데이터를 무효화합니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003erevalidateTag\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'posts'\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드에서 \u003ccode\u003erevalidateTag('posts')\u003c/code\u003e를 호출하면, 캐시에 'posts'라는 태그로 분류된 데이터가 모두 무효화되어 다음 요청 시 새로운 데이터를 다시 가져오도록 만듭니다. 이렇게 하면 게시글 리스트나 관련 콘텐츠가 업데이트될 때, 서버 캐시를 손쉽게 갱신할 수 있죠.\u003c/p\u003e\n\u003ch3\u003e예기치 않은 예외 처리 (Handling uncaught exceptions)\u003c/h3\u003e\n\u003cp\u003e만약 데이터 재검증 중에 에러가 발생한다면, Next.js는 바로 새로운 데이터 요청을 실패하더라도 이전에 성공적으로 생성된 데이터를 계속해서 캐시에서 제공합니다. 즉, 사용자에게는 데이터가 갑자기 사라지거나 오류가 노출되지 않고 안정적으로 서비스가 유지됩니다. 그리고 다음 요청 시점에 다시 재검증을 시도하니, 일시적인 문제라도 금방 해결됩니다.\u003c/p\u003e\n\u003cp\u003e이 부분이 꽤나 유용한데, 서버 오류로 인한 서비스 중단 없이도 캐시가 안정적으로 유지되고 복구되기 때문이죠.\u003c/p\u003e\n\u003ch3\u003e캐시 위치 커스터마이징하기\u003c/h3\u003e\n\u003cp\u003eNext.js 내장 캐시는 기본적으로 프로젝트 내 \u003ccode\u003e.next/cache\u003c/code\u003e 폴더에 저장됩니다. 하지만 상황에 따라 캐시 위치를 바꾸고 싶을 때가 있죠. 예를 들어, CI/CD 환경에서 캐시를 공유하거나 특정 디스크 경로에 캐시를 두고 싶을 때가 그렇답니다.\u003c/p\u003e\n\u003cp\u003eNext.js에서는 \u003ccode\u003enext.config.js\u003c/code\u003e 파일에서 \u003ccode\u003eexperimental\u003c/code\u003e 설정 아래 \u003ccode\u003eserverActions\u003c/code\u003e와 같은 옵션을 다루듯, 캐시 관련 설정도 향후 업데이트를 기대할 수 있는데, 현재 공식 문서에서는 구체적인 캐시 위치 변경 방법은 제한적입니다. 그래도 곧 더 다양한 설정 옵션들이 추가될 예정이라서, 공식 문서를 꾸준히 확인하는 걸 추천드려요.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e마지막으로 Next.js의 캐시 전략은 점점 발전 중이라서, 개발자가 직접 캐시 태그를 관리하며 성능을 최적화할 수 있는 부분이 늘고 있어요. 보다 유연하고 빠른 데이터 페칭을 위한 중요한 기능이니, 꼭 한번 직접 써보시면서 익혀두시면 좋을 것 같아요! 혹시 서비스 로딩 속도가 느리거나 데이터 최신화에 문제가 있을 때, 캐시 무효화 전략부터 점검해보세요 :)\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eNext.js에서 페이지를 캐싱하고 재검증하는 기능인 Incremental Static Regeneration(ISR)은 동일한 캐시를 공유해서 사용해요.\u003c/p\u003e\n\u003cp\u003e만약 Vercel에 배포한다면, ISR 캐시는 자동으로 안정적인 저장소에 저장되어서 데이터가 안전하게 보존되죠. 그런데 직접 서버를 운영(셀프 호스팅)할 때는 ISR 캐시가 Next.js 서버 내의 파일 시스템(디스크)에 저장돼요. Pages Router와 App Router 둘 다 셀프 호스팅할 때 이 방식이 자동으로 적용됩니다.\u003c/p\u003e\n\u003cp\u003e또한 필요에 따라 Next.js 캐시 위치를 직접 설정할 수도 있어요. 이렇게 하면 캐시된 페이지와 데이터를 더 영속적인 저장소에 보관할 수 있고, 여러 컨테이너나 인스턴스에서 캐시를 공유하는 것도 가능해집니다. 더 자세한 설정 방법은 공식 문서를 참고해 보세요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e간단히 말해서!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eVercel 배포:\u003c/strong\u003e 캐시 자동 저장(내구성 있는 저장소)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e셀프 호스팅:\u003c/strong\u003e 캐시가 서버 디스크에 저장\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e캐시 위치 변경 가능:\u003c/strong\u003e 여러 서버 간 캐시 공유 및 데이터 보존 용도\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e만약 캐시 문제가 발생하거나 페이지가 예상대로 재검증되지 않는다면 캐시 설정을 점검해 보는 게 좋겠죠? 다음번에는 흔한 이슈와 해결법도 함께 소개할게요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003e로컬 개발 환경에서 캐시된 데이터 디버깅하기\u003c/h3\u003e\n\u003cp\u003efetch API를 사용할 때, 어떤 요청이 캐시된 것인지, 혹은 캐시되지 않은 것인지 확인하고 싶다면 추가적인 로깅(logging) 설정을 해보는 게 좋아요. 이렇게 하면 네트워크 요청이 실제로 어떻게 처리되는지 한눈에 파악할 수 있답니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 아래처럼 \u003ccode\u003elogging\u003c/code\u003e 옵션을 설정하면 모든 fetch 호출의 전체 URL(fullUrl)을 로그로 남길 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003elogging\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003efetches\u003c/span\u003e: {\n      \u003cspan class=\"hljs-attr\"\u003efullUrl\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n    },\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 설정을 통해 \"아, 이 요청은 캐시에서 바로 가져왔구나\", \"이 요청은 서버에 직접 다녀왔구나\" 같은 정보를 쉽게 알 수 있게 됩니다. 특히 복잡한 캐싱 로직을 다룰 때, 문제를 빠르게 찾아내는 데 정말 유용하죠.\u003c/p\u003e\n\u003cp\u003e또한, 브라우저 개발자 도구(Network 탭)를 열어 보거나, 서버에서 캐시 헤더(Cache-Control, ETag 등)를 확인하는 것도 도움이 됩니다. 이런 방법들을 병행하면 캐시 동작을 더 명확히 이해할 수 있어요.\u003c/p\u003e\n\u003ch3\u003e프로덕션 환경에서의 올바른 동작 확인하기\u003c/h3\u003e\n\u003cp\u003e로컬 환경에서 잘 작동한다고 해도, 프로덕션 환경에서는 다른 조건들이 작용할 수 있어요. 그렇기 때문에 실제 운영 서버에서 캐시가 제대로 동작하는지 반드시 확인해야 합니다. 다음과 같은 점들을 체크해 보세요.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e실제 네트워크 요청 확인\u003c/strong\u003e: 운영 중인 서버의 로그 혹은 브라우저 개발자 도구를 통해 매 요청마다 캐시가 제대로 적용되는지 봅니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eHTTP 캐시 헤더 점검\u003c/strong\u003e: 서버가 올바른 캐시 정책을 설정했는지 확인해 보세요. 캐시 만료시간, 재검증(ETag, Last-Modified) 관련 헤더들이 적절히 사용되는지 중요합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e캐시 무효화 전략 검토\u003c/strong\u003e: 업데이트가 필요한 데이터가 있을 때 캐시가 제대로 초기화(unset)되는지 테스트해 보아야 합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e콘텐츠 배포 네트워크(CDN) 설정\u003c/strong\u003e: 만약 CDN을 사용한다면 CDN 캐시 정책도 함께 고려해야 하니, CDN 로그나 설정도 꼭 살펴보세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이처럼 디버깅할 때 로컬 개발 환경뿐 아니라 프로덕션 환경에서의 케이스까지 살펴보면, 예상치 못한 캐싱 문제를 미리 차단할 수 있어서 안정적인 서비스를 운영할 수 있답니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e프로덕션 환경에서 페이지가 제대로 캐시되고 재검증되는지 확인하려면, 로컬에서 직접 테스트해보는 게 좋아요. 방법은 간단해요!\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e먼저 \u003ccode\u003enext build\u003c/code\u003e 명령어로 프로젝트를 빌드합니다.\u003c/li\u003e\n\u003cli\u003e그리고 \u003ccode\u003enext start\u003c/code\u003e로 프로덕션용 Next.js 서버를 실행해보세요.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e이렇게 하면 ISR(Incremental Static Regeneration) 동작을 실제 프로덕션 환경처럼 경험할 수 있어요.\u003c/p\u003e\n\u003cp\u003e그리고 개발하는 동안 캐시 동작을 좀 더 자세히 보고 싶다면, 프로젝트 루트에 있는 \u003ccode\u003e.env\u003c/code\u003e 파일에 아래 환경 변수를 추가해보세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eNEXT_PRIVATE_DEBUG_CACHE\u003c/span\u003e=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이걸 넣으면 Next.js 서버 콘솔에서 ISR 캐시 히트(hit)와 미스(miss) 정보를 출력해줍니다. 덕분에 빌드 과정에서 생성된 페이지들과, 사용자 요청에 따라 어떤 경로들이 새롭게 생성되는지 세세하게 확인할 수 있죠.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e추가로 팁 하나! 서버 로그를 보면서 페이지가 갱신되는 타이밍을 체크하면, 재검증 설정(\u003ccode\u003erevalidate\u003c/code\u003e 옵션)과 실제 동작이 잘 맞는지 쉽게 디버깅할 수 있어요. 혹시 ISR이 잘 작동하지 않는다고 느껴지면, 이 환경 변수 설정과 로그 확인부터 해보시길 추천합니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e주의할 점 (Caveats)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eISR(Incremental Static Regeneration)은 기본적으로 Node.js 런타임 환경에서만 지원돼요.\u003c/li\u003e\n\u003cli\u003eStatic Export 방식으로 프로젝트를 만들 때는 ISR을 사용할 수 없답니다.\u003c/li\u003e\n\u003cli\u003e정적으로 렌더링된 경로에서 여러 개의 fetch 요청을 하고 각각 다른 revalidate 주기를 설정했다면, 가장 짧은 시간이 ISR에 적용돼요. 하지만 Data Cache에서는 각각 설정한 재검증 주기가 따로 지켜진답니다.\u003c/li\u003e\n\u003cli\u003e만약 경로 내 fetch 요청 중에 revalidate 시간이 0이거나 명시적으로 no-store가 설정되어 있다면, 그 경로는 동적으로 렌더링돼요.\u003c/li\u003e\n\u003cli\u003e미들웨어(Middleware)는 on-demand ISR 요청에는 실행되지 않아요. 즉, 경로 재작성(path rewrites)이나 미들웨어 내 로직이 적용되지 않으니, 재검증할 때는 꼭 정확한 경로를 지정해야 해요. 예를 들어, /post-1로 rewrite된 경로가 아니라 /post/1과 같이 실제 경로를 사용해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003e버전 히스토리 (Version history)\u003c/h2\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e버전\u003c/th\u003e\u003cth\u003e변경 사항\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003ev14.1.0\u003c/td\u003e\u003ctd\u003e커스텀 \u003ccode\u003ecacheHandler\u003c/code\u003e가 안정화되었어요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003ev13.0.0\u003c/td\u003e\u003ctd\u003eApp Router가 도입되었답니다.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003ev12.2.0\u003c/td\u003e\u003ctd\u003ePages Router에서 On-Demand ISR이 안정화됐어요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003ev12.0.0\u003c/td\u003e\u003ctd\u003ePages Router에 \u003ca href=\"https://nextjs.org/blog/next-12#bot-aware-isr-fallback\" rel=\"nofollow\" target=\"_blank\"\u003eBot-aware ISR fallback\u003c/a\u003e이 추가되었죠.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003ev9.5.0\u003c/td\u003e\u003ctd\u003ePages Router에 \u003ca href=\"https://nextjs.org/blog/next-9-5\" rel=\"nofollow\" target=\"_blank\"\u003e안정화된 ISR\u003c/a\u003e이 도입되었어요.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003cp\u003e이번 내용에서는 Next.js에서 ISR을 사용할 때 주의해야 할 점들과 버전별 주요 업데이트 소식을 함께 정리했는데요, 보통 ISR을 잘 활용하면 성능과 SEO 모두 잡을 수 있어 굉장히 유용해요. 다만 위에서 언급한 몇 가지 제한사항들을 꼭 숙지해서 개발 중 예상치 못한 문제가 생기지 않도록 하는 게 중요해요.\u003c/p\u003e\n\u003cp\u003e또한, 버전업이 자주 되기 때문에 새로운 기능이나 안정화된 기능들은 공식 블로그나 문서를 꾸준히 체크하는 걸 추천드려요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2025-04-22-IncrementalStaticRegenerationISR"},"buildId":"X4OrKfmLtU3-3BijwfHe6","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>