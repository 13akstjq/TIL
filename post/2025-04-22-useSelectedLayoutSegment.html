<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Nextjs 15에서 useSelectedLayoutSegment 훅을 활용하는 방법 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-useSelectedLayoutSegment" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Nextjs 15에서 useSelectedLayoutSegment 훅을 활용하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:title" content="Nextjs 15에서 useSelectedLayoutSegment 훅을 활용하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-useSelectedLayoutSegment" data-gatsby-head="true"/><meta name="twitter:title" content="Nextjs 15에서 useSelectedLayoutSegment 훅을 활용하는 방법 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2025-04-22 12:56" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/0eef537492fed77a.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/0eef537492fed77a.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-8ded8b979ba73586.js" defer=""></script><script src="/TIL/_next/static/M7pU9hOcx8u_ZIFMf95sd/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/M7pU9hOcx8u_ZIFMf95sd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Nextjs 15에서 useSelectedLayoutSegment 훅을 활용하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Nextjs 15에서 useSelectedLayoutSegment 훅을 활용하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Apr 22, 2025</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>useSelectedLayoutSegment 훅이란?</h1>
<p><code>useSelectedLayoutSegment</code>는 클라이언트 컴포넌트에서 사용할 수 있는 훅으로, 호출한 레이아웃 바로 아래에 있는 활성화된(활성 상태인) 라우트 세그먼트를 읽을 수 있게 도와줘요.</p>
<h3>언제 쓰면 좋을까?</h3>
<p>예를 들면, 부모 레이아웃 안에 여러 자식 탭이 있을 때 각 탭의 활성화 여부에 따라 스타일을 바꾸고 싶을 때 유용해요. 즉, 현재 어떤 세그먼트(탭 혹은 페이지의 구간)가 활성화 되어 있는지 쉽게 알 수 있어서, 그 정보를 UI에 반영하면 됩니다.</p>
<h3>코드 예시</h3>
<pre><code class="hljs language-jsx"><span class="hljs-string">'use client'</span>

<span class="hljs-keyword">import</span> { useSelectedLayoutSegment } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/navigation'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ExampleClientComponent</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> segment = <span class="hljs-title function_">useSelectedLayoutSegment</span>()

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>Active segment: {segment}<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span></span>
}
</code></pre>
<p>이렇게 하면 현재 활성화된 세그먼트 이름이 화면에 출력되죠.</p>
<hr>
<h3>추가 팁!</h3>
<ul>
<li><code>useSelectedLayoutSegment</code>는 부모 레이아웃 아래 한 단계의 세그먼트만 읽어올 수 있다는 점을 기억하세요. 예를 들어 <code>/dashboard/settings/profile</code> 같은 경로에서, <code>dashboard</code> 레이아웃 내에서 이 훅을 쓰면 <code>settings</code> 세그먼트만 받아옵니다. <code>profile</code>까지 깔끔하게 가져오려면 다른 방식이 필요해요!</li>
<li>복수 개의 세그먼트가 활성화되는 상황(중첩 라우팅 등)에서는 <code>useSelectedLayoutSegments</code>라는 복수형 훅도 있어서, 필요하면 함께 살펴보시는 것도 좋습니다.</li>
<li>네비게이션 UI를 만들 때 이 훅 덕분에 상태 관리나 URL 파싱 없이도 현재 위치를 쉽게 파악할 수 있어 개발 효율이 훨씬 올라가요!</li>
</ul>
<p>Next.js의 App Router와 함께 쓸 때 특히 훌륭한 툴이니 다음 프로젝트에 바로 활용해보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<blockquote>
<p>알아두면 좋은 점:<br>
useSelectedLayoutSegment 훅은 클라이언트 컴포넌트에서 사용해야 합니다. 왜냐하면 레이아웃(Layout)은 기본적으로 서버 컴포넌트이기 때문이죠. 그래서 보통 useSelectedLayoutSegment는 레이아웃 안에 임포트된 클라이언트 컴포넌트에서 호출하게 됩니다.<br>
그리고 이 훅은 현재 활성화된 세그먼트 중 한 단계 아래(자식 레벨) 세그먼트만 반환해요. 만약 활성화된 모든 세그먼트를 한꺼번에 받고 싶다면 useSelectedLayoutSegments라는 훅을 참고하세요.</p>
</blockquote>
<h2>파라미터</h2>















<table><thead><tr><th>파라미터명</th><th>타입</th><th>설명</th></tr></thead><tbody><tr><td>parallelRoutesKey</td><td>string (옵션)</td><td>특정 슬롯 내에서 활성화된 경로 세그먼트를 읽고 싶을 때 사용합니다. 예를 들어 병렬 라우트가 여러 개인 경우 해당 슬롯을 지정할 수 있어요.</td></tr></tbody></table>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> segment = <span class="hljs-title function_">useSelectedLayoutSegment</span>(parallelRoutesKey?: string)
</code></pre>
<hr>
<h3>추가로 알려드릴 팁!</h3>
<p>Next.js의 앱 디렉토리 구조에서 라우트 세그먼트(segment)는 URL 경로의 일부를 의미합니다. 예를 들어 <code>/dashboard/settings</code>라면 <code>dashboard</code>와 <code>settings</code>가 각각 하나의 세그먼트죠.<br>
useSelectedLayoutSegment 훅을 활용하면 현재 화면에서 어느 경로 세그먼트가 활성화되어 있는지를 쉽게 알 수 있어서, 조건부 렌더링이나 UI 상태 관리에 굉장히 유용합니다.</p>
<p>또한, parallelRoutesKey를 지정하는 경우는 조금 특별한데요, 예를 들어 하나의 레이아웃에 여러 병렬 경로 슬롯이 있다면, 어느 슬롯의 세그먼트를 조회할지 명확히 할 수 있어 좋습니다. 예전에는 복잡한 라우팅 정보를 관리하기 위해 별도의 로직을 짜야 했던 점을 생각하면, 이 훅이 확실히 편리함을 더해주죠!</p>
<p>꼭 클라이언트 컴포넌트 안에서만 쓸 수 있다는 점 기억하시고, 서버 컴포넌트라면 클라이언트 컴포넌트를 분리해서 함께 사용하는 구조로 짜시면 됩니다. 이 부분은 Next.js 13 이후 앱 디렉토리 사용 시 자주 보게 될 패턴이라 익숙해지면 개발이 한결 수월해질 거예요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>Returns</h2>
<p><code>useSelectedLayoutSegment</code>은 현재 활성화된 세그먼트의 문자열을 반환하며, 만약 활성 세그먼트가 없다면 <code>null</code>을 반환합니다.</p>
<p>아래 표는 다양한 레이아웃과 방문한 URL에 따른 반환값 예시를 보여주는데요, 한눈에 이해하기 쉽게 정리해봤어요.</p>








































<table><thead><tr><th>Layout</th><th>방문한 URL</th><th>반환 값</th></tr></thead><tbody><tr><td><code>app/layout.js</code></td><td><code>/</code></td><td><code>null</code></td></tr><tr><td><code>app/layout.js</code></td><td><code>/dashboard</code></td><td><code>'dashboard'</code></td></tr><tr><td><code>app/dashboard/layout.js</code></td><td><code>/dashboard</code></td><td><code>null</code></td></tr><tr><td><code>app/dashboard/layout.js</code></td><td><code>/dashboard/settings</code></td><td><code>'settings'</code></td></tr><tr><td><code>app/dashboard/layout.js</code></td><td><code>/dashboard/analytics</code></td><td><code>'analytics'</code></td></tr><tr><td><code>app/dashboard/layout.js</code></td><td><code>/dashboard/analytics/monthly</code></td><td><code>'analytics'</code></td></tr></tbody></table>
<p>여기서 중요한 점은, 상위 레이아웃에서 <code>/dashboard</code> 같은 경로를 방문했을 때는 세그먼트가 바로 반환되지만, 하위 레이아웃에서는 경로에 따라 조금 다르게 동작한다는 거예요.</p>
<p>예를 들어, <code>app/dashboard/layout.js</code> 안에서 <code>/dashboard/analytics/monthly</code>를 방문하면 가장 가까운 하위 세그먼트인 <code>'analytics'</code>를 반환하죠. 이 부분은 레이아웃과 라우팅 계층 구조를 잘 이해하면 훨씬 더 효과적으로 활용할 수 있을 거예요.</p>
<p>추가 팁을 드리자면, 이 훅은 주로 동적으로 현재 경로에 따라 UI를 변경하거나, 세그먼트 기반으로 조건부 렌더링 해야 할 때 유용하게 사용할 수 있어요. React 내비게이션 상태 관리와 잘 결합하면 복잡한 네비게이션 로직을 훨씬 간결하고 명확하게 만들 수 있답니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>예제</h2>
<h3>활성화된 링크 컴포넌트 만들기</h3>
<p><code>useSelectedLayoutSegment</code> 훅을 활용해서 현재 활성화된 세그먼트에 따라 스타일이 바뀌는 활성 링크 컴포넌트를 만들 수 있어요. 예를 들어, 블로그 사이드바에 자주 보여주는 게시글 리스트를 구현할 때 유용하죠.</p>
<pre><code class="hljs language-js"><span class="hljs-string">'use client'</span>

<span class="hljs-keyword">import</span> <span class="hljs-title class_">Link</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'next/link'</span>
<span class="hljs-keyword">import</span> { useSelectedLayoutSegment } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/navigation'</span>

<span class="hljs-comment">// 이 *클라이언트* 컴포넌트는 블로그 레이아웃에 포함돼서 사용됩니다.</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">BlogNavLink</span>(<span class="hljs-params">{
  slug,
  children,
}: {
  slug: string
  children: React.ReactNode
}</span>) {
  <span class="hljs-comment">// 예를 들어 `/blog/hello-world` 에서 현재 선택된 레이아웃 세그먼트는 'hello-world'가 됩니다.</span>
  <span class="hljs-keyword">const</span> segment = <span class="hljs-title function_">useSelectedLayoutSegment</span>()
  <span class="hljs-keyword">const</span> isActive = slug === segment

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Link</span>
      <span class="hljs-attr">href</span>=<span class="hljs-string">{</span>`/<span class="hljs-attr">blog</span>/${<span class="hljs-attr">slug</span>}`}
      // <span class="hljs-attr">링크가</span> <span class="hljs-attr">활성화</span> <span class="hljs-attr">됐을</span> <span class="hljs-attr">때는</span> <span class="hljs-attr">폰트가</span> <span class="hljs-attr">굵게</span>, <span class="hljs-attr">그렇지</span> <span class="hljs-attr">않으면</span> <span class="hljs-attr">기본</span> <span class="hljs-attr">스타일로</span> <span class="hljs-attr">표시합니다.</span>
      <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">fontWeight:</span> <span class="hljs-attr">isActive</span> ? '<span class="hljs-attr">bold</span>' <span class="hljs-attr">:</span> '<span class="hljs-attr">normal</span>' }}
    ></span>
      {children}
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">Link</span>></span></span>
  )
}
</code></pre>
<hr>
<p>여기서 살짝 더 알려드리자면, <code>useSelectedLayoutSegment</code>는 현재 URL 경로 중 해당 레이아웃의 세그먼트를 반환해주기 때문에, 특정 경로가 선택됐는지 쉽게 알 수 있어요. 이걸 활용해 사이드바 메뉴, 탭 네비게이션 등에서 '현재 위치' 표시를 깔끔하게 할 수 있답니다.</p>
<p>또한, 스타일뿐만 아니라 클래스명을 바꾸거나 아이콘을 변경하는 방식 등으로도 확장할 수 있으니 필요한 UI에 맞게 조절해보세요! Next.js 13의 레이아웃과 내비게이션 시스템을 활용하면 이런 사용자 경험이 훨씬 자연스럽고 간편해집니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-comment">// 클라이언트 컴포넌트인 BlogNavLink를 부모 레이아웃(Server Component)에 임포트하는 예제입니다.</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">BlogNavLink</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./blog-nav-link'</span>
<span class="hljs-keyword">import</span> getFeaturedPosts <span class="hljs-keyword">from</span> <span class="hljs-string">'./get-featured-posts'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Layout</span>(<span class="hljs-params">{
  children,
}: {
  children: React.ReactNode
}</span>) {
  <span class="hljs-comment">// 비동기로 추천 포스트를 받아옵니다.</span>
  <span class="hljs-keyword">const</span> featuredPosts = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getFeaturedPosts</span>()

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      {/* 받아온 추천 포스트들을 하나씩 돌면서 BlogNavLink 컴포넌트에 slug와 제목을 넘겨 렌더링합니다. */}
      {featuredPosts.map((post) => (
        <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{post.id}</span>></span>
          <span class="hljs-tag">&#x3C;<span class="hljs-name">BlogNavLink</span> <span class="hljs-attr">slug</span>=<span class="hljs-string">{post.slug}</span>></span>{post.title}<span class="hljs-tag">&#x3C;/<span class="hljs-name">BlogNavLink</span>></span>
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
      ))}
      {/* 하위 컴포넌트(children)를 렌더링 합니다. */}
      <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>{children}<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  )
}
</code></pre>
<hr>
<h3>Version History</h3>













<table><thead><tr><th>Version</th><th>Changes</th></tr></thead><tbody><tr><td><code>v13.0.0</code></td><td><code>useSelectedLayoutSegment</code> 훅이 도입되었습니다.</td></tr></tbody></table>
<hr>
<h4>간단 팁!</h4>
<ul>
<li><code>Layout</code> 컴포넌트는 React의 **서버 컴포넌트(Server Component)**로 설계되어 있습니다. 서버에서 데이터를 받아오고 렌더링하는 데 최적화되어 있죠.</li>
<li>클라이언트 컴포넌트를 렌더링하려면(예: 여기서 <code>BlogNavLink</code>) 반드시 클라이언트 컴포넌트로 만들어야 하며, 이 부분은 "use client" 지시어를 파일 상단에 넣어야 합니다.</li>
<li>Next.js 13의 새로운 라우팅 시스템에서 레이아웃은 중첩 구조를 가질 수 있어, 이처럼 하위 컴포넌트(children)를 받는 패턴이 일반적입니다.</li>
<li><code>useSelectedLayoutSegment</code>는 라우트가 활성화되었는지 알 수 있게 해줘서, 네비게이션 메뉴 활성화 등에 자주 사용되는 커스텀 훅이에요!</li>
</ul>
<p>이 코드를 활용해서 동적인 네비게이션이나 블로그 포스트 목록 등을 서버 측에서 불러와서 쉽게 만들 수 있다는 점, 꼭 기억하세요 :)</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Nextjs 15에서 useSelectedLayoutSegment 훅을 활용하는 방법","description":"","date":"2025-04-22 12:56","slug":"2025-04-22-useSelectedLayoutSegment","content":"\n\n# useSelectedLayoutSegment 훅이란?\n\n`useSelectedLayoutSegment`는 클라이언트 컴포넌트에서 사용할 수 있는 훅으로, 호출한 레이아웃 바로 아래에 있는 활성화된(활성 상태인) 라우트 세그먼트를 읽을 수 있게 도와줘요.\n\n### 언제 쓰면 좋을까?\n\n예를 들면, 부모 레이아웃 안에 여러 자식 탭이 있을 때 각 탭의 활성화 여부에 따라 스타일을 바꾸고 싶을 때 유용해요. 즉, 현재 어떤 세그먼트(탭 혹은 페이지의 구간)가 활성화 되어 있는지 쉽게 알 수 있어서, 그 정보를 UI에 반영하면 됩니다.\n\n### 코드 예시\n\n```jsx\n'use client'\n\nimport { useSelectedLayoutSegment } from 'next/navigation'\n\nexport default function ExampleClientComponent() {\n  const segment = useSelectedLayoutSegment()\n\n  return \u003cp\u003eActive segment: {segment}\u003c/p\u003e\n}\n```\n\n이렇게 하면 현재 활성화된 세그먼트 이름이 화면에 출력되죠.\n\n---\n\n### 추가 팁!\n\n- `useSelectedLayoutSegment`는 부모 레이아웃 아래 한 단계의 세그먼트만 읽어올 수 있다는 점을 기억하세요. 예를 들어 `/dashboard/settings/profile` 같은 경로에서, `dashboard` 레이아웃 내에서 이 훅을 쓰면 `settings` 세그먼트만 받아옵니다. `profile`까지 깔끔하게 가져오려면 다른 방식이 필요해요!\n- 복수 개의 세그먼트가 활성화되는 상황(중첩 라우팅 등)에서는 `useSelectedLayoutSegments`라는 복수형 훅도 있어서, 필요하면 함께 살펴보시는 것도 좋습니다.\n- 네비게이션 UI를 만들 때 이 훅 덕분에 상태 관리나 URL 파싱 없이도 현재 위치를 쉽게 파악할 수 있어 개발 효율이 훨씬 올라가요!\n\nNext.js의 App Router와 함께 쓸 때 특히 훌륭한 툴이니 다음 프로젝트에 바로 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003e 알아두면 좋은 점:  \nuseSelectedLayoutSegment 훅은 클라이언트 컴포넌트에서 사용해야 합니다. 왜냐하면 레이아웃(Layout)은 기본적으로 서버 컴포넌트이기 때문이죠. 그래서 보통 useSelectedLayoutSegment는 레이아웃 안에 임포트된 클라이언트 컴포넌트에서 호출하게 됩니다.  \n그리고 이 훅은 현재 활성화된 세그먼트 중 한 단계 아래(자식 레벨) 세그먼트만 반환해요. 만약 활성화된 모든 세그먼트를 한꺼번에 받고 싶다면 useSelectedLayoutSegments라는 훅을 참고하세요.\n\n## 파라미터\n\n| 파라미터명          | 타입         | 설명                                                                                  |\n|------------------|------------|-------------------------------------------------------------------------------------|\n| parallelRoutesKey | string (옵션) | 특정 슬롯 내에서 활성화된 경로 세그먼트를 읽고 싶을 때 사용합니다. 예를 들어 병렬 라우트가 여러 개인 경우 해당 슬롯을 지정할 수 있어요. |\n\n```js\nconst segment = useSelectedLayoutSegment(parallelRoutesKey?: string)\n```\n\n---\n\n### 추가로 알려드릴 팁!  \nNext.js의 앱 디렉토리 구조에서 라우트 세그먼트(segment)는 URL 경로의 일부를 의미합니다. 예를 들어 `/dashboard/settings`라면 `dashboard`와 `settings`가 각각 하나의 세그먼트죠.  \nuseSelectedLayoutSegment 훅을 활용하면 현재 화면에서 어느 경로 세그먼트가 활성화되어 있는지를 쉽게 알 수 있어서, 조건부 렌더링이나 UI 상태 관리에 굉장히 유용합니다.\n\n또한, parallelRoutesKey를 지정하는 경우는 조금 특별한데요, 예를 들어 하나의 레이아웃에 여러 병렬 경로 슬롯이 있다면, 어느 슬롯의 세그먼트를 조회할지 명확히 할 수 있어 좋습니다. 예전에는 복잡한 라우팅 정보를 관리하기 위해 별도의 로직을 짜야 했던 점을 생각하면, 이 훅이 확실히 편리함을 더해주죠!\n\n꼭 클라이언트 컴포넌트 안에서만 쓸 수 있다는 점 기억하시고, 서버 컴포넌트라면 클라이언트 컴포넌트를 분리해서 함께 사용하는 구조로 짜시면 됩니다. 이 부분은 Next.js 13 이후 앱 디렉토리 사용 시 자주 보게 될 패턴이라 익숙해지면 개발이 한결 수월해질 거예요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Returns\n\n`useSelectedLayoutSegment`은 현재 활성화된 세그먼트의 문자열을 반환하며, 만약 활성 세그먼트가 없다면 `null`을 반환합니다.\n\n아래 표는 다양한 레이아웃과 방문한 URL에 따른 반환값 예시를 보여주는데요, 한눈에 이해하기 쉽게 정리해봤어요.\n\n| Layout                    | 방문한 URL              | 반환 값          |\n|---------------------------|-------------------------|------------------|\n| `app/layout.js`            | `/`                     | `null`           |\n| `app/layout.js`            | `/dashboard`            | `'dashboard'`    |\n| `app/dashboard/layout.js`  | `/dashboard`            | `null`           |\n| `app/dashboard/layout.js`  | `/dashboard/settings`   | `'settings'`     |\n| `app/dashboard/layout.js`  | `/dashboard/analytics`  | `'analytics'`    |\n| `app/dashboard/layout.js`  | `/dashboard/analytics/monthly` | `'analytics'` |\n\n여기서 중요한 점은, 상위 레이아웃에서 `/dashboard` 같은 경로를 방문했을 때는 세그먼트가 바로 반환되지만, 하위 레이아웃에서는 경로에 따라 조금 다르게 동작한다는 거예요.\n\n예를 들어, `app/dashboard/layout.js` 안에서 `/dashboard/analytics/monthly`를 방문하면 가장 가까운 하위 세그먼트인 `'analytics'`를 반환하죠. 이 부분은 레이아웃과 라우팅 계층 구조를 잘 이해하면 훨씬 더 효과적으로 활용할 수 있을 거예요.\n\n추가 팁을 드리자면, 이 훅은 주로 동적으로 현재 경로에 따라 UI를 변경하거나, 세그먼트 기반으로 조건부 렌더링 해야 할 때 유용하게 사용할 수 있어요. React 내비게이션 상태 관리와 잘 결합하면 복잡한 네비게이션 로직을 훨씬 간결하고 명확하게 만들 수 있답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 예제\n\n### 활성화된 링크 컴포넌트 만들기\n\n`useSelectedLayoutSegment` 훅을 활용해서 현재 활성화된 세그먼트에 따라 스타일이 바뀌는 활성 링크 컴포넌트를 만들 수 있어요. 예를 들어, 블로그 사이드바에 자주 보여주는 게시글 리스트를 구현할 때 유용하죠.\n\n```js\n'use client'\n\nimport Link from 'next/link'\nimport { useSelectedLayoutSegment } from 'next/navigation'\n\n// 이 *클라이언트* 컴포넌트는 블로그 레이아웃에 포함돼서 사용됩니다.\nexport default function BlogNavLink({\n  slug,\n  children,\n}: {\n  slug: string\n  children: React.ReactNode\n}) {\n  // 예를 들어 `/blog/hello-world` 에서 현재 선택된 레이아웃 세그먼트는 'hello-world'가 됩니다.\n  const segment = useSelectedLayoutSegment()\n  const isActive = slug === segment\n\n  return (\n    \u003cLink\n      href={`/blog/${slug}`}\n      // 링크가 활성화 됐을 때는 폰트가 굵게, 그렇지 않으면 기본 스타일로 표시합니다.\n      style={{ fontWeight: isActive ? 'bold' : 'normal' }}\n    \u003e\n      {children}\n    \u003c/Link\u003e\n  )\n}\n```\n\n---\n\n여기서 살짝 더 알려드리자면, `useSelectedLayoutSegment`는 현재 URL 경로 중 해당 레이아웃의 세그먼트를 반환해주기 때문에, 특정 경로가 선택됐는지 쉽게 알 수 있어요. 이걸 활용해 사이드바 메뉴, 탭 네비게이션 등에서 '현재 위치' 표시를 깔끔하게 할 수 있답니다.\n\n또한, 스타일뿐만 아니라 클래스명을 바꾸거나 아이콘을 변경하는 방식 등으로도 확장할 수 있으니 필요한 UI에 맞게 조절해보세요! Next.js 13의 레이아웃과 내비게이션 시스템을 활용하면 이런 사용자 경험이 훨씬 자연스럽고 간편해집니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n// 클라이언트 컴포넌트인 BlogNavLink를 부모 레이아웃(Server Component)에 임포트하는 예제입니다.\nimport { BlogNavLink } from './blog-nav-link'\nimport getFeaturedPosts from './get-featured-posts'\n\nexport default async function Layout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  // 비동기로 추천 포스트를 받아옵니다.\n  const featuredPosts = await getFeaturedPosts()\n\n  return (\n    \u003cdiv\u003e\n      {/* 받아온 추천 포스트들을 하나씩 돌면서 BlogNavLink 컴포넌트에 slug와 제목을 넘겨 렌더링합니다. */}\n      {featuredPosts.map((post) =\u003e (\n        \u003cdiv key={post.id}\u003e\n          \u003cBlogNavLink slug={post.slug}\u003e{post.title}\u003c/BlogNavLink\u003e\n        \u003c/div\u003e\n      ))}\n      {/* 하위 컴포넌트(children)를 렌더링 합니다. */}\n      \u003cdiv\u003e{children}\u003c/div\u003e\n    \u003c/div\u003e\n  )\n}\n```\n\n---\n\n### Version History\n\n| Version   | Changes                      |\n|-----------|------------------------------|\n| `v13.0.0` | `useSelectedLayoutSegment` 훅이 도입되었습니다. |\n\n---\n\n#### 간단 팁!\n\n- `Layout` 컴포넌트는 React의 **서버 컴포넌트(Server Component)**로 설계되어 있습니다. 서버에서 데이터를 받아오고 렌더링하는 데 최적화되어 있죠.\n- 클라이언트 컴포넌트를 렌더링하려면(예: 여기서 `BlogNavLink`) 반드시 클라이언트 컴포넌트로 만들어야 하며, 이 부분은 \"use client\" 지시어를 파일 상단에 넣어야 합니다.\n- Next.js 13의 새로운 라우팅 시스템에서 레이아웃은 중첩 구조를 가질 수 있어, 이처럼 하위 컴포넌트(children)를 받는 패턴이 일반적입니다.\n- `useSelectedLayoutSegment`는 라우트가 활성화되었는지 알 수 있게 해줘서, 네비게이션 메뉴 활성화 등에 자주 사용되는 커스텀 훅이에요!\n\n이 코드를 활용해서 동적인 네비게이션이나 블로그 포스트 목록 등을 서버 측에서 불러와서 쉽게 만들 수 있다는 점, 꼭 기억하세요 :)","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":8},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003euseSelectedLayoutSegment 훅이란?\u003c/h1\u003e\n\u003cp\u003e\u003ccode\u003euseSelectedLayoutSegment\u003c/code\u003e는 클라이언트 컴포넌트에서 사용할 수 있는 훅으로, 호출한 레이아웃 바로 아래에 있는 활성화된(활성 상태인) 라우트 세그먼트를 읽을 수 있게 도와줘요.\u003c/p\u003e\n\u003ch3\u003e언제 쓰면 좋을까?\u003c/h3\u003e\n\u003cp\u003e예를 들면, 부모 레이아웃 안에 여러 자식 탭이 있을 때 각 탭의 활성화 여부에 따라 스타일을 바꾸고 싶을 때 유용해요. 즉, 현재 어떤 세그먼트(탭 혹은 페이지의 구간)가 활성화 되어 있는지 쉽게 알 수 있어서, 그 정보를 UI에 반영하면 됩니다.\u003c/p\u003e\n\u003ch3\u003e코드 예시\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-string\"\u003e'use client'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useSelectedLayoutSegment } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/navigation'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eExampleClientComponent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e segment = \u003cspan class=\"hljs-title function_\"\u003euseSelectedLayoutSegment\u003c/span\u003e()\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003eActive segment: {segment}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 현재 활성화된 세그먼트 이름이 화면에 출력되죠.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e추가 팁!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003euseSelectedLayoutSegment\u003c/code\u003e는 부모 레이아웃 아래 한 단계의 세그먼트만 읽어올 수 있다는 점을 기억하세요. 예를 들어 \u003ccode\u003e/dashboard/settings/profile\u003c/code\u003e 같은 경로에서, \u003ccode\u003edashboard\u003c/code\u003e 레이아웃 내에서 이 훅을 쓰면 \u003ccode\u003esettings\u003c/code\u003e 세그먼트만 받아옵니다. \u003ccode\u003eprofile\u003c/code\u003e까지 깔끔하게 가져오려면 다른 방식이 필요해요!\u003c/li\u003e\n\u003cli\u003e복수 개의 세그먼트가 활성화되는 상황(중첩 라우팅 등)에서는 \u003ccode\u003euseSelectedLayoutSegments\u003c/code\u003e라는 복수형 훅도 있어서, 필요하면 함께 살펴보시는 것도 좋습니다.\u003c/li\u003e\n\u003cli\u003e네비게이션 UI를 만들 때 이 훅 덕분에 상태 관리나 URL 파싱 없이도 현재 위치를 쉽게 파악할 수 있어 개발 효율이 훨씬 올라가요!\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNext.js의 App Router와 함께 쓸 때 특히 훌륭한 툴이니 다음 프로젝트에 바로 활용해보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cblockquote\u003e\n\u003cp\u003e알아두면 좋은 점:\u003cbr\u003e\nuseSelectedLayoutSegment 훅은 클라이언트 컴포넌트에서 사용해야 합니다. 왜냐하면 레이아웃(Layout)은 기본적으로 서버 컴포넌트이기 때문이죠. 그래서 보통 useSelectedLayoutSegment는 레이아웃 안에 임포트된 클라이언트 컴포넌트에서 호출하게 됩니다.\u003cbr\u003e\n그리고 이 훅은 현재 활성화된 세그먼트 중 한 단계 아래(자식 레벨) 세그먼트만 반환해요. 만약 활성화된 모든 세그먼트를 한꺼번에 받고 싶다면 useSelectedLayoutSegments라는 훅을 참고하세요.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e파라미터\u003c/h2\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e파라미터명\u003c/th\u003e\u003cth\u003e타입\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eparallelRoutesKey\u003c/td\u003e\u003ctd\u003estring (옵션)\u003c/td\u003e\u003ctd\u003e특정 슬롯 내에서 활성화된 경로 세그먼트를 읽고 싶을 때 사용합니다. 예를 들어 병렬 라우트가 여러 개인 경우 해당 슬롯을 지정할 수 있어요.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e segment = \u003cspan class=\"hljs-title function_\"\u003euseSelectedLayoutSegment\u003c/span\u003e(parallelRoutesKey?: string)\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003e추가로 알려드릴 팁!\u003c/h3\u003e\n\u003cp\u003eNext.js의 앱 디렉토리 구조에서 라우트 세그먼트(segment)는 URL 경로의 일부를 의미합니다. 예를 들어 \u003ccode\u003e/dashboard/settings\u003c/code\u003e라면 \u003ccode\u003edashboard\u003c/code\u003e와 \u003ccode\u003esettings\u003c/code\u003e가 각각 하나의 세그먼트죠.\u003cbr\u003e\nuseSelectedLayoutSegment 훅을 활용하면 현재 화면에서 어느 경로 세그먼트가 활성화되어 있는지를 쉽게 알 수 있어서, 조건부 렌더링이나 UI 상태 관리에 굉장히 유용합니다.\u003c/p\u003e\n\u003cp\u003e또한, parallelRoutesKey를 지정하는 경우는 조금 특별한데요, 예를 들어 하나의 레이아웃에 여러 병렬 경로 슬롯이 있다면, 어느 슬롯의 세그먼트를 조회할지 명확히 할 수 있어 좋습니다. 예전에는 복잡한 라우팅 정보를 관리하기 위해 별도의 로직을 짜야 했던 점을 생각하면, 이 훅이 확실히 편리함을 더해주죠!\u003c/p\u003e\n\u003cp\u003e꼭 클라이언트 컴포넌트 안에서만 쓸 수 있다는 점 기억하시고, 서버 컴포넌트라면 클라이언트 컴포넌트를 분리해서 함께 사용하는 구조로 짜시면 됩니다. 이 부분은 Next.js 13 이후 앱 디렉토리 사용 시 자주 보게 될 패턴이라 익숙해지면 개발이 한결 수월해질 거예요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003eReturns\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003euseSelectedLayoutSegment\u003c/code\u003e은 현재 활성화된 세그먼트의 문자열을 반환하며, 만약 활성 세그먼트가 없다면 \u003ccode\u003enull\u003c/code\u003e을 반환합니다.\u003c/p\u003e\n\u003cp\u003e아래 표는 다양한 레이아웃과 방문한 URL에 따른 반환값 예시를 보여주는데요, 한눈에 이해하기 쉽게 정리해봤어요.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eLayout\u003c/th\u003e\u003cth\u003e방문한 URL\u003c/th\u003e\u003cth\u003e반환 값\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eapp/layout.js\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e/\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003enull\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eapp/layout.js\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e/dashboard\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e'dashboard'\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eapp/dashboard/layout.js\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e/dashboard\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003enull\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eapp/dashboard/layout.js\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e/dashboard/settings\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e'settings'\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eapp/dashboard/layout.js\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e/dashboard/analytics\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e'analytics'\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eapp/dashboard/layout.js\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e/dashboard/analytics/monthly\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e'analytics'\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e여기서 중요한 점은, 상위 레이아웃에서 \u003ccode\u003e/dashboard\u003c/code\u003e 같은 경로를 방문했을 때는 세그먼트가 바로 반환되지만, 하위 레이아웃에서는 경로에 따라 조금 다르게 동작한다는 거예요.\u003c/p\u003e\n\u003cp\u003e예를 들어, \u003ccode\u003eapp/dashboard/layout.js\u003c/code\u003e 안에서 \u003ccode\u003e/dashboard/analytics/monthly\u003c/code\u003e를 방문하면 가장 가까운 하위 세그먼트인 \u003ccode\u003e'analytics'\u003c/code\u003e를 반환하죠. 이 부분은 레이아웃과 라우팅 계층 구조를 잘 이해하면 훨씬 더 효과적으로 활용할 수 있을 거예요.\u003c/p\u003e\n\u003cp\u003e추가 팁을 드리자면, 이 훅은 주로 동적으로 현재 경로에 따라 UI를 변경하거나, 세그먼트 기반으로 조건부 렌더링 해야 할 때 유용하게 사용할 수 있어요. React 내비게이션 상태 관리와 잘 결합하면 복잡한 네비게이션 로직을 훨씬 간결하고 명확하게 만들 수 있답니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e예제\u003c/h2\u003e\n\u003ch3\u003e활성화된 링크 컴포넌트 만들기\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003euseSelectedLayoutSegment\u003c/code\u003e 훅을 활용해서 현재 활성화된 세그먼트에 따라 스타일이 바뀌는 활성 링크 컴포넌트를 만들 수 있어요. 예를 들어, 블로그 사이드바에 자주 보여주는 게시글 리스트를 구현할 때 유용하죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e'use client'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLink\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/link'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useSelectedLayoutSegment } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/navigation'\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 이 *클라이언트* 컴포넌트는 블로그 레이아웃에 포함돼서 사용됩니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eBlogNavLink\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{\n  slug,\n  children,\n}: {\n  slug: string\n  children: React.ReactNode\n}\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 예를 들어 `/blog/hello-world` 에서 현재 선택된 레이아웃 세그먼트는 'hello-world'가 됩니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e segment = \u003cspan class=\"hljs-title function_\"\u003euseSelectedLayoutSegment\u003c/span\u003e()\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isActive = slug === segment\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eLink\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003ehref\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e`/\u003cspan class=\"hljs-attr\"\u003eblog\u003c/span\u003e/${\u003cspan class=\"hljs-attr\"\u003eslug\u003c/span\u003e}`}\n      // \u003cspan class=\"hljs-attr\"\u003e링크가\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e활성화\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e됐을\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e때는\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e폰트가\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e굵게\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003e그렇지\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e않으면\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e기본\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e스타일로\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e표시합니다.\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{{\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003efontWeight:\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eisActive\u003c/span\u003e ? '\u003cspan class=\"hljs-attr\"\u003ebold\u003c/span\u003e' \u003cspan class=\"hljs-attr\"\u003e:\u003c/span\u003e '\u003cspan class=\"hljs-attr\"\u003enormal\u003c/span\u003e' }}\n    \u003e\u003c/span\u003e\n      {children}\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eLink\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003cp\u003e여기서 살짝 더 알려드리자면, \u003ccode\u003euseSelectedLayoutSegment\u003c/code\u003e는 현재 URL 경로 중 해당 레이아웃의 세그먼트를 반환해주기 때문에, 특정 경로가 선택됐는지 쉽게 알 수 있어요. 이걸 활용해 사이드바 메뉴, 탭 네비게이션 등에서 '현재 위치' 표시를 깔끔하게 할 수 있답니다.\u003c/p\u003e\n\u003cp\u003e또한, 스타일뿐만 아니라 클래스명을 바꾸거나 아이콘을 변경하는 방식 등으로도 확장할 수 있으니 필요한 UI에 맞게 조절해보세요! Next.js 13의 레이아웃과 내비게이션 시스템을 활용하면 이런 사용자 경험이 훨씬 자연스럽고 간편해집니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 클라이언트 컴포넌트인 BlogNavLink를 부모 레이아웃(Server Component)에 임포트하는 예제입니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eBlogNavLink\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./blog-nav-link'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e getFeaturedPosts \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./get-featured-posts'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eLayout\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{\n  children,\n}: {\n  children: React.ReactNode\n}\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 비동기로 추천 포스트를 받아옵니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e featuredPosts = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetFeaturedPosts\u003c/span\u003e()\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      {/* 받아온 추천 포스트들을 하나씩 돌면서 BlogNavLink 컴포넌트에 slug와 제목을 넘겨 렌더링합니다. */}\n      {featuredPosts.map((post) =\u003e (\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{post.id}\u003c/span\u003e\u003e\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eBlogNavLink\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eslug\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{post.slug}\u003c/span\u003e\u003e\u003c/span\u003e{post.title}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eBlogNavLink\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      ))}\n      {/* 하위 컴포넌트(children)를 렌더링 합니다. */}\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e{children}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003eVersion History\u003c/h3\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eVersion\u003c/th\u003e\u003cth\u003eChanges\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev13.0.0\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003euseSelectedLayoutSegment\u003c/code\u003e 훅이 도입되었습니다.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003ch4\u003e간단 팁!\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eLayout\u003c/code\u003e 컴포넌트는 React의 **서버 컴포넌트(Server Component)**로 설계되어 있습니다. 서버에서 데이터를 받아오고 렌더링하는 데 최적화되어 있죠.\u003c/li\u003e\n\u003cli\u003e클라이언트 컴포넌트를 렌더링하려면(예: 여기서 \u003ccode\u003eBlogNavLink\u003c/code\u003e) 반드시 클라이언트 컴포넌트로 만들어야 하며, 이 부분은 \"use client\" 지시어를 파일 상단에 넣어야 합니다.\u003c/li\u003e\n\u003cli\u003eNext.js 13의 새로운 라우팅 시스템에서 레이아웃은 중첩 구조를 가질 수 있어, 이처럼 하위 컴포넌트(children)를 받는 패턴이 일반적입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003euseSelectedLayoutSegment\u003c/code\u003e는 라우트가 활성화되었는지 알 수 있게 해줘서, 네비게이션 메뉴 활성화 등에 자주 사용되는 커스텀 훅이에요!\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 코드를 활용해서 동적인 네비게이션이나 블로그 포스트 목록 등을 서버 측에서 불러와서 쉽게 만들 수 있다는 점, 꼭 기억하세요 :)\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2025-04-22-useSelectedLayoutSegment"},"buildId":"M7pU9hOcx8u_ZIFMf95sd","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>