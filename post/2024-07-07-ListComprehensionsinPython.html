<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>파이썬 리스트 내포 쉽게 사용하는 방법 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2024-07-07-ListComprehensionsinPython" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="파이썬 리스트 내포 쉽게 사용하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:title" content="파이썬 리스트 내포 쉽게 사용하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-07-07-ListComprehensionsinPython_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2024-07-07-ListComprehensionsinPython" data-gatsby-head="true"/><meta name="twitter:title" content="파이썬 리스트 내포 쉽게 사용하는 방법 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-07-07-ListComprehensionsinPython_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-07 21:31" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-8ded8b979ba73586.js" defer=""></script><script src="/TIL/_next/static/o6AmBAY_j9v9JmbaRA39X/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/o6AmBAY_j9v9JmbaRA39X/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">파이썬 리스트 내포 쉽게 사용하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="파이썬 리스트 내포 쉽게 사용하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 7, 2024</span><span class="posts_reading_time__f7YPP">12<!-- --> min read</span></span></div></div></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/TIL/assets/img/2024-07-07-ListComprehensionsinPython_0.png" alt="이미지"></p>
<p>파이썬은 간결함과 가독성으로 유명하며, 그 중 가장 강력한 기능 중 하나는 리스트 컴프리헨션입니다. 리스트 컴프리헨션은 리스트를 생성하는 간결한 방법을 제공합니다. 이 글에서는 리스트 컴프리헨션을 자세히 살펴보고, 작동 방식을 설명하며, 사용 예시를 통해 그 활용을 설명할 것입니다.</p>
<h2>리스트 컴프리헨션이란?</h2>
<p>리스트 컴프리헨션은 기본적으로 반복문이나 다른 순회 가능한 것들을 작성하거나 표현하는 또 다른 방법입니다. 기존에 있는 리스트나 범위와 같은 순회 가능한 항목 각각에 표현식을 적용하여 새 리스트를 만들고 선택적으로 항목들을 필터링할 수 있습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>리스트 내포는 보통 for 루프의 "구문 설탕"이라고 생각할 수 있습니다. 그러나 어떤 경우에는 일반적인 루프보다 훨씬 우수한 성능을 발휘할 수 있습니다. 성능 부분에서 자세히 다루겠습니다.</p>
<p>기본 구문:</p>
<pre><code class="hljs language-js">[표현식 <span class="hljs-keyword">for</span> 항목 <span class="hljs-keyword">in</span> 반복 가능 객체 <span class="hljs-keyword">if</span> 조건]
</code></pre>
<p>구성 요소:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>표현: 각 항목에 적용되는 작업 또는 필요한 처리</li>
<li>항목: 반복 가능한 요소 중 각 요소를 나타내는 변수. 예: i는 for i in range(xyz)에서 항목을 나타냅니다.</li>
<li>반복 가능한 요소: 반복되는 항목의 모음 (예: 목록 또는 범위).</li>
<li>조건(선택 사항): 특정 항목만 처리하도록 허용하는 필터.</li>
</ul>
<h1>기본 예제</h1>
<h2>1. 다른 목록에서 목록 생성</h2>
<p>전통적인 For 루프:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
squared_numbers = []
<span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-attr">numbers</span>:
    # 숫자를 제곱합니다
    squared_numbers.<span class="hljs-title function_">append</span>(n ** <span class="hljs-number">2</span>)
<span class="hljs-title function_">print</span>(squared_numbers)
# 출력: [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>]
</code></pre>
<p>리스트 컴프리헨션:</p>
<pre><code class="hljs language-js">numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
squared_numbers = [n ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> numbers]
<span class="hljs-title function_">print</span>(squared_numbers)
# 출력: [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>]
</code></pre>
<p>이 예제에서 두 가지 방법 모두 동일한 결과를 얻지만, 리스트 컴프리헨션은 보다 간결합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>2. 아이템 필터링</h2>
<p>전통적인 for 루프를 사용한 필터링:</p>
<pre><code class="hljs language-js">numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]
even_numbers = []
<span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-attr">numbers</span>:
    <span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:
        even_numbers.<span class="hljs-title function_">append</span>(n)
<span class="hljs-title function_">print</span>(even_numbers)
# 출력: [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>]
</code></pre>
<p>필터링을 사용한 List Comprehension:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]
even_numbers = [n <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> numbers <span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]
<span class="hljs-title function_">print</span>(even_numbers)
# <span class="hljs-title class_">Output</span>: [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>]
</code></pre>
<p>여기서 리스트 컴프리헨션은 짝수만 필터링하는 조건을 포함하고 있습니다.</p>
<h1>고급 예제</h1>
<h2>1. 중첩된 반복문</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>리스트 컴프리헨션이 중첩된 루프를 포함할 수 있습니다. 중첩된 for 루프처럼 동작합니다.</p>
<p>전통적인 중첩된 For 룹:</p>
<pre><code class="hljs language-js">matrix = [
    [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],
    [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>],
    [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]
]
flattened = []
<span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-attr">matrix</span>:
    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> <span class="hljs-attr">row</span>:
        flattened.<span class="hljs-title function_">append</span>(item)
<span class="hljs-title function_">print</span>(flattened)
# <span class="hljs-title class_">Output</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]
</code></pre>
<p>중첩된 루프를 사용한 리스트 컴프리헨션:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">matrix = [
    [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],
    [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>],
    [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]
]
flattened = [item <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> matrix <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> row]
<span class="hljs-title function_">print</span>(flattened)
# <span class="hljs-title class_">Output</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]
</code></pre>
<p>이 리스트 컴프리헨션은 2차원 리스트(리스트의 리스트)를 하나의 리스트로 평탄화합니다.</p>
<h2>2. List Comprehensions에서 함수 사용하기</h2>
<p>리스트 컴프리헨션의 식 부분에서 함수를 호출할 수 있습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>예시:</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">square</span>(x):
    <span class="hljs-keyword">return</span> x ** <span class="hljs-number">2</span>
numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
squared_numbers = [<span class="hljs-title function_">square</span>(n) <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> numbers]
<span class="hljs-title function_">print</span>(squared_numbers)
# 출력: [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>]
</code></pre>
<p>이 예시는 리스트 컴프리헨션 내에서 사용자 정의 함수를 호출하는 방법을 보여줍니다.</p>
<h1>성능 비교: 리스트 컴프리헨션 대 반복문</h1>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>컴프리헨션은 동등한 루프보다 최적화된 구현으로 인해 종종 Python에서 더 빠릅니다.</p>
<p>성능 비교 예시:</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> time
<span class="hljs-comment"># 숫자 리스트</span>
numbers = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>))

<span class="hljs-comment"># for 루프 사용</span>
start_time = time.time()
squared_numbers_loop = []
<span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> numbers:
    squared_numbers_loop.append(n ** <span class="hljs-number">2</span>)
end_time = time.time()
<span class="hljs-built_in">print</span>(<span class="hljs-string">"For 루프 시간:"</span>, end_time - start_time)

<span class="hljs-comment"># 리스트 컴프리헨션 사용</span>
start_time = time.time()
squared_numbers_comprehension = [n ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> numbers]
end_time = time.time()
<span class="hljs-built_in">print</span>(<span class="hljs-string">"리스트 컴프리헨션 시간:"</span>, end_time - start_time)
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-title class_">For</span> 루프 시간: <span class="hljs-number">0.2</span> 초
리스트 내장 시간: <span class="hljs-number">0.1</span> 초
</code></pre>
<p>이 예에서 리스트 내장은 for 루프보다 훨씬 빠르며 효율성을 입증합니다.</p>
<h1>리스트 내포의 내부 작동 방식</h1>
<p>우리가 알다시피, Python은 기본 C 위에 구축된 해석형 언어입니다. 리스트 내장을 사용할 때 Python은 이를 반복 및 리스트 구성을 효율적으로 처리하는 일련의 바이트 코드 명령으로 변환합니다. append를 반복적으로 호출하는 대신, 리스트 내포는 리스트에 요소를 더하는 작업을 더욱 효율적으로 처리하는 특수화된 바이트 코드를 사용합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>내부 메커니즘</h1>
<p>여기서 뜰 속에서 무슨 일이 벌어지는지를 단계별로 설명해 드리겠습니다:</p>
<ul>
<li>바이트 코드 컴파일: 리스트 내포는 바이트 코드로 컴파일되며, 이는 리스트를 생성하고 채우는 특수한 일련의 명령어를 포함합니다.</li>
<li>리스트 생성: Python은 빈 리스트를 생성합니다.</li>
<li>요소 추가: iterable이 횡단될 때 최적화된 C 함수를 직접 사용하여 append를 호출하는 대신 리스트에 요소를 추가합니다.</li>
<li>반복 제어: 루프 제어(다음 항목 가져오고 루프를 계속해야 하는지 확인하는 것)가 이 특수화된 바이트 코드 내에서 효율적으로 처리됩니다.</li>
</ul>
<h1>예시 해체</h1>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>차이를 보려면 dis 모듈을 사용하여 전통적인 for 루프와 리스트 내포의 바이트코드를 분해할 수 있습니다.</p>
<p>For Loop Example:</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> dis
<span class="hljs-keyword">def</span> <span class="hljs-title function_">for_loop_example</span>():
    numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
    squared_numbers = []
    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> numbers:
        squared_numbers.append(n ** <span class="hljs-number">2</span>)
dis.dis(for_loop_example)
</code></pre>
<p>For Loop Bytecode Output:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">  <span class="hljs-number">2</span>           <span class="hljs-number">0</span> <span class="hljs-variable constant_">LOAD_CONST</span>               <span class="hljs-number">1</span> (<span class="hljs-number">1</span>)
              <span class="hljs-number">2</span> <span class="hljs-variable constant_">LOAD_CONST</span>               <span class="hljs-number">2</span> (<span class="hljs-number">2</span>)
              <span class="hljs-number">4</span> <span class="hljs-variable constant_">LOAD_CONST</span>               <span class="hljs-number">3</span> (<span class="hljs-number">3</span>)
              <span class="hljs-number">6</span> <span class="hljs-variable constant_">LOAD_CONST</span>               <span class="hljs-number">4</span> (<span class="hljs-number">4</span>)
              <span class="hljs-number">8</span> <span class="hljs-variable constant_">LOAD_CONST</span>               <span class="hljs-number">5</span> (<span class="hljs-number">5</span>)
             <span class="hljs-number">10</span> <span class="hljs-variable constant_">BUILD_LIST</span>               <span class="hljs-number">5</span>
             <span class="hljs-number">12</span> <span class="hljs-variable constant_">STORE_FAST</span>               <span class="hljs-number">0</span> (numbers)
  <span class="hljs-number">3</span>          <span class="hljs-number">14</span> <span class="hljs-variable constant_">BUILD_LIST</span>               <span class="hljs-number">0</span>
             <span class="hljs-number">16</span> <span class="hljs-variable constant_">STORE_FAST</span>               <span class="hljs-number">1</span> (squared_numbers)
  <span class="hljs-number">4</span>          <span class="hljs-number">18</span> <span class="hljs-variable constant_">LOAD_FAST</span>                <span class="hljs-number">0</span> (numbers)
             <span class="hljs-number">20</span> <span class="hljs-variable constant_">GET_ITER</span>
        >>   <span class="hljs-number">22</span> <span class="hljs-variable constant_">FOR_ITER</span>                <span class="hljs-number">12</span> (to <span class="hljs-number">36</span>)
             <span class="hljs-number">24</span> <span class="hljs-variable constant_">STORE_FAST</span>               <span class="hljs-number">2</span> (n)
  <span class="hljs-number">5</span>          <span class="hljs-number">26</span> <span class="hljs-variable constant_">LOAD_FAST</span>                <span class="hljs-number">1</span> (squared_numbers)
             <span class="hljs-number">28</span> <span class="hljs-variable constant_">LOAD_METHOD</span>              <span class="hljs-number">0</span> (append)
             <span class="hljs-number">30</span> <span class="hljs-variable constant_">LOAD_FAST</span>                <span class="hljs-number">2</span> (n)
             <span class="hljs-number">32</span> <span class="hljs-variable constant_">LOAD_CONST</span>               <span class="hljs-number">6</span> (<span class="hljs-number">2</span>)
             <span class="hljs-number">34</span> <span class="hljs-variable constant_">BINARY_POWER</span>
             <span class="hljs-number">36</span> <span class="hljs-variable constant_">CALL_METHOD</span>              <span class="hljs-number">1</span>
             <span class="hljs-number">38</span> <span class="hljs-variable constant_">POP_TOP</span>
             <span class="hljs-number">40</span> <span class="hljs-variable constant_">JUMP_ABSOLUTE</span>           <span class="hljs-number">22</span>
        >>   <span class="hljs-number">42</span> <span class="hljs-variable constant_">LOAD_CONST</span>               <span class="hljs-number">0</span> (<span class="hljs-title class_">None</span>)
             <span class="hljs-number">44</span> <span class="hljs-variable constant_">RETURN_VALUE</span>
</code></pre>
<p>리스트 컴프리헨션 예제:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> dis
def <span class="hljs-title function_">list_comprehension_example</span>():
    numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
    squared_numbers = [n ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> numbers]
dis.<span class="hljs-title function_">dis</span>(list_comprehension_example)
</code></pre>
<p>리스트 컴프리헨션 바이트코드 출력:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">특수화된 C 함수
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>효율성은 파이썬 인터프리터 내에서 전문화된 C 함수를 사용함으로써 얻어집니다. 이러한 함수들은 목록 구성과 같은 일반적인 작업을 처리하는 데 등가하는 파이썬 코드보다 훨씬 빠르게 설계되었습니다. 리스트 컴프리헨션을 작성할 때, 파이썬의 바이트코드 컴파일러는 이러한 함수들을 사용하여 메모리 내의 리스트를 직접 조작하여, 메서드 호출 및 루프 제어에 따른 오버헤드를 피할 수 있습니다.</p>
<h1>리스트 컴프리헨션이 왜 더 빠를까요??</h1>
<ul>
<li>
<p>오버헤드 감소:</p>
</li>
<li>
<p>for 루프: 각 for 루프 반복은 append 메서드와 루프 제어 작업에 따른 반복 호출로 인한 오버헤드가 발생합니다.</p>
</li>
<li>
<p>리스트 컴프리헨션: 반복적인 오버헤드를 피하고 연속된 단일 작업으로 리스트를 구성합니다.</p>
</li>
</ul>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ol start="2">
<li>최적화된 바이트 코드:</li>
</ol>
<p>Python 코드가 실행될 때, 먼저 바이트 코드로 컴파일됩니다. 이는 소스 코드의 더 낮은 수준이며 플랫폼에 독립적인 표현입니다. Python 인터프리터(C로 작성됨)가 이 바이트 코드를 실행합니다.</p>
<ul>
<li>For 루프: for 루프의 각 반복은 다음 항목을 가져오는 작업, 루프 조건을 확인하는 작업, append 메서드를 반복적으로 호출하는 등 여러 바이트 코드 명령으로 이루어집니다.</li>
<li>List Comprehensions: 전체 리스트 컴프리헨션은 더 효율적인 일련의 바이트 코드 명령으로 컴파일됩니다. 이러한 명령들은 오버헤드를 최소화하기 위해 최적화되어 있습니다.</li>
</ul>
<ol start="3">
<li>인플레이스 생성:</li>
</ol>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>리스트 컴프리헨션은 리스트를 직접 메모리에 생성하는 반면에 일반 루프는 메소드 호출과 변수 할당과 같은 추가 단계가 필요할 수 있습니다.</li>
</ul>
<h2>요약</h2>
<p>파이썬의 리스트 컴프리헨션은 리스트를 생성하는 간결하고 가독성이 높으며 효율적인 방법을 제공합니다. 이는 데이터 변환 및 필터링을 포함한 많은 사용 사례에서 전통적인 for 루프를 대체할 수 있습니다. 리스트 컴프리헨션을 효과적으로 이해하고 사용하면 더 우아하고 성능이 좋은 코드를 작성할 수 있습니다.</p>
<h2>기억해야 할 중요한 사항</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>문법: [조건식 for 요소 in 반복가능객체 if 조건문]</li>
<li>효율성: 리스트 컴프리헨션은 동등한 for 루프보다 종종 더 빠릅니다.</li>
<li>가독성: 코드를 더 간결하고 읽기 쉽게 만듭니다.</li>
<li>사용 예: 간단한 변형 및 필터링에 이상적이지만 복잡한 로직의 경우 가독성을 위해 전통적인 루프가 더 적합할 수 있습니다.</li>
</ul>
<p>리스트 컴프리헨션을 숙달함으로써 더 깔끔하고 빠르며 파이썬다운 코드를 작성할 수 있습니다.</p>
<p>즐거운 코딩 하세요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"파이썬 리스트 내포 쉽게 사용하는 방법","description":"","date":"2024-07-07 21:31","slug":"2024-07-07-ListComprehensionsinPython","content":"\n![이미지](/TIL/assets/img/2024-07-07-ListComprehensionsinPython_0.png)\n\n파이썬은 간결함과 가독성으로 유명하며, 그 중 가장 강력한 기능 중 하나는 리스트 컴프리헨션입니다. 리스트 컴프리헨션은 리스트를 생성하는 간결한 방법을 제공합니다. 이 글에서는 리스트 컴프리헨션을 자세히 살펴보고, 작동 방식을 설명하며, 사용 예시를 통해 그 활용을 설명할 것입니다.\n\n## 리스트 컴프리헨션이란?\n\n리스트 컴프리헨션은 기본적으로 반복문이나 다른 순회 가능한 것들을 작성하거나 표현하는 또 다른 방법입니다. 기존에 있는 리스트나 범위와 같은 순회 가능한 항목 각각에 표현식을 적용하여 새 리스트를 만들고 선택적으로 항목들을 필터링할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n리스트 내포는 보통 for 루프의 \"구문 설탕\"이라고 생각할 수 있습니다. 그러나 어떤 경우에는 일반적인 루프보다 훨씬 우수한 성능을 발휘할 수 있습니다. 성능 부분에서 자세히 다루겠습니다.\n\n기본 구문:\n\n```js\n[표현식 for 항목 in 반복 가능 객체 if 조건]\n```\n\n구성 요소:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 표현: 각 항목에 적용되는 작업 또는 필요한 처리\n- 항목: 반복 가능한 요소 중 각 요소를 나타내는 변수. 예: i는 for i in range(xyz)에서 항목을 나타냅니다.\n- 반복 가능한 요소: 반복되는 항목의 모음 (예: 목록 또는 범위).\n- 조건(선택 사항): 특정 항목만 처리하도록 허용하는 필터.\n\n# 기본 예제\n\n## 1. 다른 목록에서 목록 생성\n\n전통적인 For 루프:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nnumbers = [1, 2, 3, 4, 5]\nsquared_numbers = []\nfor n in numbers:\n    # 숫자를 제곱합니다\n    squared_numbers.append(n ** 2)\nprint(squared_numbers)\n# 출력: [1, 4, 9, 16, 25]\n```\n\n리스트 컴프리헨션:\n\n```js\nnumbers = [1, 2, 3, 4, 5]\nsquared_numbers = [n ** 2 for n in numbers]\nprint(squared_numbers)\n# 출력: [1, 4, 9, 16, 25]\n```\n\n이 예제에서 두 가지 방법 모두 동일한 결과를 얻지만, 리스트 컴프리헨션은 보다 간결합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 2. 아이템 필터링\n\n전통적인 for 루프를 사용한 필터링:\n\n```js\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\neven_numbers = []\nfor n in numbers:\n    if n % 2 == 0:\n        even_numbers.append(n)\nprint(even_numbers)\n# 출력: [2, 4, 6, 8, 10]\n```\n\n필터링을 사용한 List Comprehension:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\neven_numbers = [n for n in numbers if n % 2 == 0]\nprint(even_numbers)\n# Output: [2, 4, 6, 8, 10]\n```\n\n여기서 리스트 컴프리헨션은 짝수만 필터링하는 조건을 포함하고 있습니다.\n\n# 고급 예제\n\n## 1. 중첩된 반복문\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n리스트 컴프리헨션이 중첩된 루프를 포함할 수 있습니다. 중첩된 for 루프처럼 동작합니다.\n\n전통적인 중첩된 For 룹:\n\n```js\nmatrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\nflattened = []\nfor row in matrix:\n    for item in row:\n        flattened.append(item)\nprint(flattened)\n# Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n중첩된 루프를 사용한 리스트 컴프리헨션:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nmatrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\nflattened = [item for row in matrix for item in row]\nprint(flattened)\n# Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n이 리스트 컴프리헨션은 2차원 리스트(리스트의 리스트)를 하나의 리스트로 평탄화합니다.\n\n## 2. List Comprehensions에서 함수 사용하기\n\n리스트 컴프리헨션의 식 부분에서 함수를 호출할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예시:\n\n```js\ndef square(x):\n    return x ** 2\nnumbers = [1, 2, 3, 4, 5]\nsquared_numbers = [square(n) for n in numbers]\nprint(squared_numbers)\n# 출력: [1, 4, 9, 16, 25]\n```\n\n이 예시는 리스트 컴프리헨션 내에서 사용자 정의 함수를 호출하는 방법을 보여줍니다.\n\n# 성능 비교: 리스트 컴프리헨션 대 반복문\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n컴프리헨션은 동등한 루프보다 최적화된 구현으로 인해 종종 Python에서 더 빠릅니다.\n\n성능 비교 예시:\n\n```python\nimport time\n# 숫자 리스트\nnumbers = list(range(1000000))\n\n# for 루프 사용\nstart_time = time.time()\nsquared_numbers_loop = []\nfor n in numbers:\n    squared_numbers_loop.append(n ** 2)\nend_time = time.time()\nprint(\"For 루프 시간:\", end_time - start_time)\n\n# 리스트 컴프리헨션 사용\nstart_time = time.time()\nsquared_numbers_comprehension = [n ** 2 for n in numbers]\nend_time = time.time()\nprint(\"리스트 컴프리헨션 시간:\", end_time - start_time)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nFor 루프 시간: 0.2 초\n리스트 내장 시간: 0.1 초\n```\n\n이 예에서 리스트 내장은 for 루프보다 훨씬 빠르며 효율성을 입증합니다.\n\n# 리스트 내포의 내부 작동 방식\n\n우리가 알다시피, Python은 기본 C 위에 구축된 해석형 언어입니다. 리스트 내장을 사용할 때 Python은 이를 반복 및 리스트 구성을 효율적으로 처리하는 일련의 바이트 코드 명령으로 변환합니다. append를 반복적으로 호출하는 대신, 리스트 내포는 리스트에 요소를 더하는 작업을 더욱 효율적으로 처리하는 특수화된 바이트 코드를 사용합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 내부 메커니즘\n\n여기서 뜰 속에서 무슨 일이 벌어지는지를 단계별로 설명해 드리겠습니다:\n\n- 바이트 코드 컴파일: 리스트 내포는 바이트 코드로 컴파일되며, 이는 리스트를 생성하고 채우는 특수한 일련의 명령어를 포함합니다.\n- 리스트 생성: Python은 빈 리스트를 생성합니다.\n- 요소 추가: iterable이 횡단될 때 최적화된 C 함수를 직접 사용하여 append를 호출하는 대신 리스트에 요소를 추가합니다.\n- 반복 제어: 루프 제어(다음 항목 가져오고 루프를 계속해야 하는지 확인하는 것)가 이 특수화된 바이트 코드 내에서 효율적으로 처리됩니다.\n\n# 예시 해체\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n차이를 보려면 dis 모듈을 사용하여 전통적인 for 루프와 리스트 내포의 바이트코드를 분해할 수 있습니다.\n\nFor Loop Example:\n\n```python\nimport dis\ndef for_loop_example():\n    numbers = [1, 2, 3, 4, 5]\n    squared_numbers = []\n    for n in numbers:\n        squared_numbers.append(n ** 2)\ndis.dis(for_loop_example)\n```\n\nFor Loop Bytecode Output:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n  2           0 LOAD_CONST               1 (1)\n              2 LOAD_CONST               2 (2)\n              4 LOAD_CONST               3 (3)\n              6 LOAD_CONST               4 (4)\n              8 LOAD_CONST               5 (5)\n             10 BUILD_LIST               5\n             12 STORE_FAST               0 (numbers)\n  3          14 BUILD_LIST               0\n             16 STORE_FAST               1 (squared_numbers)\n  4          18 LOAD_FAST                0 (numbers)\n             20 GET_ITER\n        \u003e\u003e   22 FOR_ITER                12 (to 36)\n             24 STORE_FAST               2 (n)\n  5          26 LOAD_FAST                1 (squared_numbers)\n             28 LOAD_METHOD              0 (append)\n             30 LOAD_FAST                2 (n)\n             32 LOAD_CONST               6 (2)\n             34 BINARY_POWER\n             36 CALL_METHOD              1\n             38 POP_TOP\n             40 JUMP_ABSOLUTE           22\n        \u003e\u003e   42 LOAD_CONST               0 (None)\n             44 RETURN_VALUE\n```\n\n리스트 컴프리헨션 예제:\n\n```js\nimport dis\ndef list_comprehension_example():\n    numbers = [1, 2, 3, 4, 5]\n    squared_numbers = [n ** 2 for n in numbers]\ndis.dis(list_comprehension_example)\n```\n\n리스트 컴프리헨션 바이트코드 출력:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n특수화된 C 함수\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n효율성은 파이썬 인터프리터 내에서 전문화된 C 함수를 사용함으로써 얻어집니다. 이러한 함수들은 목록 구성과 같은 일반적인 작업을 처리하는 데 등가하는 파이썬 코드보다 훨씬 빠르게 설계되었습니다. 리스트 컴프리헨션을 작성할 때, 파이썬의 바이트코드 컴파일러는 이러한 함수들을 사용하여 메모리 내의 리스트를 직접 조작하여, 메서드 호출 및 루프 제어에 따른 오버헤드를 피할 수 있습니다.\n\n# 리스트 컴프리헨션이 왜 더 빠를까요??\n\n- 오버헤드 감소:\n\n- for 루프: 각 for 루프 반복은 append 메서드와 루프 제어 작업에 따른 반복 호출로 인한 오버헤드가 발생합니다.\n- 리스트 컴프리헨션: 반복적인 오버헤드를 피하고 연속된 단일 작업으로 리스트를 구성합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. 최적화된 바이트 코드:\n\nPython 코드가 실행될 때, 먼저 바이트 코드로 컴파일됩니다. 이는 소스 코드의 더 낮은 수준이며 플랫폼에 독립적인 표현입니다. Python 인터프리터(C로 작성됨)가 이 바이트 코드를 실행합니다.\n\n- For 루프: for 루프의 각 반복은 다음 항목을 가져오는 작업, 루프 조건을 확인하는 작업, append 메서드를 반복적으로 호출하는 등 여러 바이트 코드 명령으로 이루어집니다.\n- List Comprehensions: 전체 리스트 컴프리헨션은 더 효율적인 일련의 바이트 코드 명령으로 컴파일됩니다. 이러한 명령들은 오버헤드를 최소화하기 위해 최적화되어 있습니다.\n\n3. 인플레이스 생성:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 리스트 컴프리헨션은 리스트를 직접 메모리에 생성하는 반면에 일반 루프는 메소드 호출과 변수 할당과 같은 추가 단계가 필요할 수 있습니다.\n\n## 요약\n\n파이썬의 리스트 컴프리헨션은 리스트를 생성하는 간결하고 가독성이 높으며 효율적인 방법을 제공합니다. 이는 데이터 변환 및 필터링을 포함한 많은 사용 사례에서 전통적인 for 루프를 대체할 수 있습니다. 리스트 컴프리헨션을 효과적으로 이해하고 사용하면 더 우아하고 성능이 좋은 코드를 작성할 수 있습니다.\n\n## 기억해야 할 중요한 사항\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 문법: [조건식 for 요소 in 반복가능객체 if 조건문]\n- 효율성: 리스트 컴프리헨션은 동등한 for 루프보다 종종 더 빠릅니다.\n- 가독성: 코드를 더 간결하고 읽기 쉽게 만듭니다.\n- 사용 예: 간단한 변형 및 필터링에 이상적이지만 복잡한 로직의 경우 가독성을 위해 전통적인 루프가 더 적합할 수 있습니다.\n\n리스트 컴프리헨션을 숙달함으로써 더 깔끔하고 빠르며 파이썬다운 코드를 작성할 수 있습니다.\n\n즐거운 코딩 하세요!\n","ogImage":{"url":"/assets/img/2024-07-07-ListComprehensionsinPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-ListComprehensionsinPython_0.png","tag":["Tech"],"readingTime":12},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-07-ListComprehensionsinPython_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e파이썬은 간결함과 가독성으로 유명하며, 그 중 가장 강력한 기능 중 하나는 리스트 컴프리헨션입니다. 리스트 컴프리헨션은 리스트를 생성하는 간결한 방법을 제공합니다. 이 글에서는 리스트 컴프리헨션을 자세히 살펴보고, 작동 방식을 설명하며, 사용 예시를 통해 그 활용을 설명할 것입니다.\u003c/p\u003e\n\u003ch2\u003e리스트 컴프리헨션이란?\u003c/h2\u003e\n\u003cp\u003e리스트 컴프리헨션은 기본적으로 반복문이나 다른 순회 가능한 것들을 작성하거나 표현하는 또 다른 방법입니다. 기존에 있는 리스트나 범위와 같은 순회 가능한 항목 각각에 표현식을 적용하여 새 리스트를 만들고 선택적으로 항목들을 필터링할 수 있습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e리스트 내포는 보통 for 루프의 \"구문 설탕\"이라고 생각할 수 있습니다. 그러나 어떤 경우에는 일반적인 루프보다 훨씬 우수한 성능을 발휘할 수 있습니다. 성능 부분에서 자세히 다루겠습니다.\u003c/p\u003e\n\u003cp\u003e기본 구문:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e[표현식 \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e 항목 \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e 반복 가능 객체 \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e 조건]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e구성 요소:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e표현: 각 항목에 적용되는 작업 또는 필요한 처리\u003c/li\u003e\n\u003cli\u003e항목: 반복 가능한 요소 중 각 요소를 나타내는 변수. 예: i는 for i in range(xyz)에서 항목을 나타냅니다.\u003c/li\u003e\n\u003cli\u003e반복 가능한 요소: 반복되는 항목의 모음 (예: 목록 또는 범위).\u003c/li\u003e\n\u003cli\u003e조건(선택 사항): 특정 항목만 처리하도록 허용하는 필터.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e기본 예제\u003c/h1\u003e\n\u003ch2\u003e1. 다른 목록에서 목록 생성\u003c/h2\u003e\n\u003cp\u003e전통적인 For 루프:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enumbers = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e]\nsquared_numbers = []\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e n \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003enumbers\u003c/span\u003e:\n    # 숫자를 제곱합니다\n    squared_numbers.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(n ** \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(squared_numbers)\n# 출력: [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e리스트 컴프리헨션:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enumbers = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e]\nsquared_numbers = [n ** \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e n \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e numbers]\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(squared_numbers)\n# 출력: [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예제에서 두 가지 방법 모두 동일한 결과를 얻지만, 리스트 컴프리헨션은 보다 간결합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e2. 아이템 필터링\u003c/h2\u003e\n\u003cp\u003e전통적인 for 루프를 사용한 필터링:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enumbers = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e]\neven_numbers = []\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e n \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003enumbers\u003c/span\u003e:\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e n % \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e:\n        even_numbers.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(n)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(even_numbers)\n# 출력: [\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e필터링을 사용한 List Comprehension:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enumbers = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e]\neven_numbers = [n \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e n \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e numbers \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e n % \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(even_numbers)\n# \u003cspan class=\"hljs-title class_\"\u003eOutput\u003c/span\u003e: [\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 리스트 컴프리헨션은 짝수만 필터링하는 조건을 포함하고 있습니다.\u003c/p\u003e\n\u003ch1\u003e고급 예제\u003c/h1\u003e\n\u003ch2\u003e1. 중첩된 반복문\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e리스트 컴프리헨션이 중첩된 루프를 포함할 수 있습니다. 중첩된 for 루프처럼 동작합니다.\u003c/p\u003e\n\u003cp\u003e전통적인 중첩된 For 룹:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ematrix = [\n    [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e],\n    [\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e],\n    [\u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e]\n]\nflattened = []\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e row \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ematrix\u003c/span\u003e:\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e item \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003erow\u003c/span\u003e:\n        flattened.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(item)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(flattened)\n# \u003cspan class=\"hljs-title class_\"\u003eOutput\u003c/span\u003e: [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e중첩된 루프를 사용한 리스트 컴프리헨션:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ematrix = [\n    [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e],\n    [\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e],\n    [\u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e]\n]\nflattened = [item \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e row \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e matrix \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e item \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e row]\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(flattened)\n# \u003cspan class=\"hljs-title class_\"\u003eOutput\u003c/span\u003e: [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 리스트 컴프리헨션은 2차원 리스트(리스트의 리스트)를 하나의 리스트로 평탄화합니다.\u003c/p\u003e\n\u003ch2\u003e2. List Comprehensions에서 함수 사용하기\u003c/h2\u003e\n\u003cp\u003e리스트 컴프리헨션의 식 부분에서 함수를 호출할 수 있습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003esquare\u003c/span\u003e(x):\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e x ** \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\nnumbers = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e]\nsquared_numbers = [\u003cspan class=\"hljs-title function_\"\u003esquare\u003c/span\u003e(n) \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e n \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e numbers]\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(squared_numbers)\n# 출력: [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예시는 리스트 컴프리헨션 내에서 사용자 정의 함수를 호출하는 방법을 보여줍니다.\u003c/p\u003e\n\u003ch1\u003e성능 비교: 리스트 컴프리헨션 대 반복문\u003c/h1\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e컴프리헨션은 동등한 루프보다 최적화된 구현으로 인해 종종 Python에서 더 빠릅니다.\u003c/p\u003e\n\u003cp\u003e성능 비교 예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e time\n\u003cspan class=\"hljs-comment\"\u003e# 숫자 리스트\u003c/span\u003e\nnumbers = \u003cspan class=\"hljs-built_in\"\u003elist\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1000000\u003c/span\u003e))\n\n\u003cspan class=\"hljs-comment\"\u003e# for 루프 사용\u003c/span\u003e\nstart_time = time.time()\nsquared_numbers_loop = []\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e n \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e numbers:\n    squared_numbers_loop.append(n ** \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\nend_time = time.time()\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"For 루프 시간:\"\u003c/span\u003e, end_time - start_time)\n\n\u003cspan class=\"hljs-comment\"\u003e# 리스트 컴프리헨션 사용\u003c/span\u003e\nstart_time = time.time()\nsquared_numbers_comprehension = [n ** \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e n \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e numbers]\nend_time = time.time()\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"리스트 컴프리헨션 시간:\"\u003c/span\u003e, end_time - start_time)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eFor\u003c/span\u003e 루프 시간: \u003cspan class=\"hljs-number\"\u003e0.2\u003c/span\u003e 초\n리스트 내장 시간: \u003cspan class=\"hljs-number\"\u003e0.1\u003c/span\u003e 초\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예에서 리스트 내장은 for 루프보다 훨씬 빠르며 효율성을 입증합니다.\u003c/p\u003e\n\u003ch1\u003e리스트 내포의 내부 작동 방식\u003c/h1\u003e\n\u003cp\u003e우리가 알다시피, Python은 기본 C 위에 구축된 해석형 언어입니다. 리스트 내장을 사용할 때 Python은 이를 반복 및 리스트 구성을 효율적으로 처리하는 일련의 바이트 코드 명령으로 변환합니다. append를 반복적으로 호출하는 대신, 리스트 내포는 리스트에 요소를 더하는 작업을 더욱 효율적으로 처리하는 특수화된 바이트 코드를 사용합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e내부 메커니즘\u003c/h1\u003e\n\u003cp\u003e여기서 뜰 속에서 무슨 일이 벌어지는지를 단계별로 설명해 드리겠습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e바이트 코드 컴파일: 리스트 내포는 바이트 코드로 컴파일되며, 이는 리스트를 생성하고 채우는 특수한 일련의 명령어를 포함합니다.\u003c/li\u003e\n\u003cli\u003e리스트 생성: Python은 빈 리스트를 생성합니다.\u003c/li\u003e\n\u003cli\u003e요소 추가: iterable이 횡단될 때 최적화된 C 함수를 직접 사용하여 append를 호출하는 대신 리스트에 요소를 추가합니다.\u003c/li\u003e\n\u003cli\u003e반복 제어: 루프 제어(다음 항목 가져오고 루프를 계속해야 하는지 확인하는 것)가 이 특수화된 바이트 코드 내에서 효율적으로 처리됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e예시 해체\u003c/h1\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e차이를 보려면 dis 모듈을 사용하여 전통적인 for 루프와 리스트 내포의 바이트코드를 분해할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eFor Loop Example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e dis\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efor_loop_example\u003c/span\u003e():\n    numbers = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e]\n    squared_numbers = []\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e n \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e numbers:\n        squared_numbers.append(n ** \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\ndis.dis(for_loop_example)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor Loop Bytecode Output:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e  \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e           \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eLOAD_CONST\u003c/span\u003e               \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n              \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eLOAD_CONST\u003c/span\u003e               \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e (\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\n              \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eLOAD_CONST\u003c/span\u003e               \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e (\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e)\n              \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eLOAD_CONST\u003c/span\u003e               \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e (\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e)\n              \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eLOAD_CONST\u003c/span\u003e               \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e (\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e)\n             \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBUILD_LIST\u003c/span\u003e               \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e\n             \u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eSTORE_FAST\u003c/span\u003e               \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e (numbers)\n  \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e          \u003cspan class=\"hljs-number\"\u003e14\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBUILD_LIST\u003c/span\u003e               \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n             \u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eSTORE_FAST\u003c/span\u003e               \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e (squared_numbers)\n  \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e          \u003cspan class=\"hljs-number\"\u003e18\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eLOAD_FAST\u003c/span\u003e                \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e (numbers)\n             \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eGET_ITER\u003c/span\u003e\n        \u003e\u003e   \u003cspan class=\"hljs-number\"\u003e22\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eFOR_ITER\u003c/span\u003e                \u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e (to \u003cspan class=\"hljs-number\"\u003e36\u003c/span\u003e)\n             \u003cspan class=\"hljs-number\"\u003e24\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eSTORE_FAST\u003c/span\u003e               \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e (n)\n  \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e          \u003cspan class=\"hljs-number\"\u003e26\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eLOAD_FAST\u003c/span\u003e                \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e (squared_numbers)\n             \u003cspan class=\"hljs-number\"\u003e28\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eLOAD_METHOD\u003c/span\u003e              \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e (append)\n             \u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eLOAD_FAST\u003c/span\u003e                \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e (n)\n             \u003cspan class=\"hljs-number\"\u003e32\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eLOAD_CONST\u003c/span\u003e               \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e (\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\n             \u003cspan class=\"hljs-number\"\u003e34\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBINARY_POWER\u003c/span\u003e\n             \u003cspan class=\"hljs-number\"\u003e36\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eCALL_METHOD\u003c/span\u003e              \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n             \u003cspan class=\"hljs-number\"\u003e38\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003ePOP_TOP\u003c/span\u003e\n             \u003cspan class=\"hljs-number\"\u003e40\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eJUMP_ABSOLUTE\u003c/span\u003e           \u003cspan class=\"hljs-number\"\u003e22\u003c/span\u003e\n        \u003e\u003e   \u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eLOAD_CONST\u003c/span\u003e               \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e (\u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e)\n             \u003cspan class=\"hljs-number\"\u003e44\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eRETURN_VALUE\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e리스트 컴프리헨션 예제:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e dis\ndef \u003cspan class=\"hljs-title function_\"\u003elist_comprehension_example\u003c/span\u003e():\n    numbers = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e]\n    squared_numbers = [n ** \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e n \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e numbers]\ndis.\u003cspan class=\"hljs-title function_\"\u003edis\u003c/span\u003e(list_comprehension_example)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e리스트 컴프리헨션 바이트코드 출력:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e특수화된 C 함수\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e효율성은 파이썬 인터프리터 내에서 전문화된 C 함수를 사용함으로써 얻어집니다. 이러한 함수들은 목록 구성과 같은 일반적인 작업을 처리하는 데 등가하는 파이썬 코드보다 훨씬 빠르게 설계되었습니다. 리스트 컴프리헨션을 작성할 때, 파이썬의 바이트코드 컴파일러는 이러한 함수들을 사용하여 메모리 내의 리스트를 직접 조작하여, 메서드 호출 및 루프 제어에 따른 오버헤드를 피할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e리스트 컴프리헨션이 왜 더 빠를까요??\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e오버헤드 감소:\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003efor 루프: 각 for 루프 반복은 append 메서드와 루프 제어 작업에 따른 반복 호출로 인한 오버헤드가 발생합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e리스트 컴프리헨션: 반복적인 오버헤드를 피하고 연속된 단일 작업으로 리스트를 구성합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e최적화된 바이트 코드:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003ePython 코드가 실행될 때, 먼저 바이트 코드로 컴파일됩니다. 이는 소스 코드의 더 낮은 수준이며 플랫폼에 독립적인 표현입니다. Python 인터프리터(C로 작성됨)가 이 바이트 코드를 실행합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFor 루프: for 루프의 각 반복은 다음 항목을 가져오는 작업, 루프 조건을 확인하는 작업, append 메서드를 반복적으로 호출하는 등 여러 바이트 코드 명령으로 이루어집니다.\u003c/li\u003e\n\u003cli\u003eList Comprehensions: 전체 리스트 컴프리헨션은 더 효율적인 일련의 바이트 코드 명령으로 컴파일됩니다. 이러한 명령들은 오버헤드를 최소화하기 위해 최적화되어 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e인플레이스 생성:\u003c/li\u003e\n\u003c/ol\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e리스트 컴프리헨션은 리스트를 직접 메모리에 생성하는 반면에 일반 루프는 메소드 호출과 변수 할당과 같은 추가 단계가 필요할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e요약\u003c/h2\u003e\n\u003cp\u003e파이썬의 리스트 컴프리헨션은 리스트를 생성하는 간결하고 가독성이 높으며 효율적인 방법을 제공합니다. 이는 데이터 변환 및 필터링을 포함한 많은 사용 사례에서 전통적인 for 루프를 대체할 수 있습니다. 리스트 컴프리헨션을 효과적으로 이해하고 사용하면 더 우아하고 성능이 좋은 코드를 작성할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e기억해야 할 중요한 사항\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e문법: [조건식 for 요소 in 반복가능객체 if 조건문]\u003c/li\u003e\n\u003cli\u003e효율성: 리스트 컴프리헨션은 동등한 for 루프보다 종종 더 빠릅니다.\u003c/li\u003e\n\u003cli\u003e가독성: 코드를 더 간결하고 읽기 쉽게 만듭니다.\u003c/li\u003e\n\u003cli\u003e사용 예: 간단한 변형 및 필터링에 이상적이지만 복잡한 로직의 경우 가독성을 위해 전통적인 루프가 더 적합할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e리스트 컴프리헨션을 숙달함으로써 더 깔끔하고 빠르며 파이썬다운 코드를 작성할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e즐거운 코딩 하세요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-07-ListComprehensionsinPython"},"buildId":"o6AmBAY_j9v9JmbaRA39X","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>