<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>공간 보간을 위한 3가지 인기 있는 방법 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2024-07-09-3PopularMethodsforSpatialInterpolation" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="공간 보간을 위한 3가지 인기 있는 방법 | TIL" data-gatsby-head="true"/><meta property="og:title" content="공간 보간을 위한 3가지 인기 있는 방법 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2024-07-09-3PopularMethodsforSpatialInterpolation" data-gatsby-head="true"/><meta name="twitter:title" content="공간 보간을 위한 3가지 인기 있는 방법 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-09 19:17" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/TIL/_next/static/chunks/463-925361deb4cec4b1.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-9d7ebbd29b9e08ce.js" defer=""></script><script src="/TIL/_next/static/OY-qm1-_Mz9jLZ5863EbF/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/OY-qm1-_Mz9jLZ5863EbF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">공간 보간을 위한 3가지 인기 있는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="공간 보간을 위한 3가지 인기 있는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 9, 2024</span><span class="posts_reading_time__f7YPP">19<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-07-09-3PopularMethodsforSpatialInterpolation&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>처음부터, Python에서</h2>
<img src="/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_0.png">
<p>보간법은 데이터 과학자 뿐만 아니라 다양한 분야의 사람들에 의해 사용되는 매우 일반적인 수학적 개념입니다. 그러나 지리 공간 데이터를 다룰 때, 보간은 종종 희소한 관측치를 기반으로 대표적인 그리드를 만들어야 하기 때문에 더 복잡해집니다.</p>
<p>지리 공간 부분에 들어가기 전에, 선형 보간에 대해 간단히 되짚어 봅시다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>디자인을 보여드리기 위해 일반 다항 함수를 사용할 것입니다:</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">F</span>(x):
  <span class="hljs-keyword">return</span> -<span class="hljs-number">2</span>*x**<span class="hljs-number">3</span>+x**<span class="hljs-number">2</span>+<span class="hljs-number">2.1</span>

x = np.<span class="hljs-title function_">arange</span>(-<span class="hljs-number">5</span>,<span class="hljs-number">5</span>, <span class="hljs-number">0.1</span>)
y = <span class="hljs-title function_">F</span>(x)
</code></pre>
<img src="/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_1.png">
<p>이제 [-4.2, 0, 2.5]에서 몇 개의 점을 무작위로 샘플링하고 이를 연결해 보겠습니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_2.png" alt="이미지"></p>
<p>이것은 선형 보간법이라고 불립니다. 각 구간에서 직선으로 함수를 근사하고 있으며, 이제 3개의 점에서 함수의 값을 알고 있을 때 [-4.2;2.5] 구간 내의 값을 찾을 수 있습니다.</p>
<p>높은 정확도를 가진 많은 다른 방법들이 있지만, 그 뒤에 있는 아이디어는 동일합니다: 적어도 두 개의 알려진 점 사이에서 함수 값을 찾는 것입니다.</p>
<p>이제 지리 공간 부분으로 넘어갈 시간입니다. 이 자습서에서는 NOAA에서 제공한 스위스 전역의 기상 측정소에서 측정된 일일 평균 대기 온도의 공간 보간을 수행하는 것이 목표입니다. 기대되는 결과는 0.1° 해상도의 온도 그리드입니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>먼저, 스위스의 행정 경계를 얻어와서 geopandas를 사용하여 시각화해야 합니다:</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> geopandas <span class="hljs-keyword">as</span> gpd

shape = gpd.read_file(<span class="hljs-string">'gadm41_CHE_0.shp'</span>)
shape.plot()
</code></pre>
<img src="/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_3.png">
<p>정말 대단해요! 스위스인 것 같네요 =)</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이제 온도 관측치를 그래프로 표시하고 국가 모양과 겹쳐보겠습니다. 이를 위해 정기적인 판다 데이터프레임으로 기상 데이터를 로드한 다음 셰이프리 포인트로 변환한 지리 데이터프레임으로 변환하겠습니다:</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">from</span> shapely.geometry <span class="hljs-keyword">import</span> Point

df = pd.read_csv(<span class="hljs-string">'3639866.csv'</span>)

points = <span class="hljs-built_in">list</span>()
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(df)):
  point = Point(df.loc[i, <span class="hljs-string">'LONGITUDE'</span>], df.loc[i, <span class="hljs-string">'LATITUDE'</span>])
  points.append(point)

gdf = gpd.GeoDataFrame(geometry=points).set_crs(shape.crs)
</code></pre>
<p>그렇게 하면 matplotlib을 사용하여 두 데이터프레임을 쉽게 겹쳐 볼 수 있습니다.</p>
<pre><code class="hljs language-python">fig, ax = plt.subplots(figsize=(<span class="hljs-number">16</span>,<span class="hljs-number">9</span>))
shape.plot(ax=ax, color=<span class="hljs-string">'black'</span>)
gdf.plot(ax=ax, color=<span class="hljs-string">'r'</span>, markersize=<span class="hljs-number">85</span>)
plt.show()
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_4.png" alt="그리드 및 지도 오버레이를 시각화하기 위해 다음을 수행하겠습니다:"></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> matplotlib.<span class="hljs-property">ticker</span> <span class="hljs-keyword">as</span> mticker
<span class="hljs-keyword">import</span> cartopy.<span class="hljs-property">crs</span> <span class="hljs-keyword">as</span> ccrs
<span class="hljs-keyword">from</span> cartopy.<span class="hljs-property">mpl</span>.<span class="hljs-property">gridliner</span> <span class="hljs-keyword">import</span> <span class="hljs-variable constant_">LONGITUDE_FORMATTER</span>, <span class="hljs-variable constant_">LATITUDE_FORMATTER</span>

<span class="hljs-variable constant_">LAT</span>, <span class="hljs-variable constant_">LON</span> = np.<span class="hljs-title function_">arange</span>(<span class="hljs-number">45.75</span>, <span class="hljs-number">48</span>, <span class="hljs-number">0.1</span>), np.<span class="hljs-title function_">arange</span>(<span class="hljs-number">6</span>, <span class="hljs-number">10.81</span>, <span class="hljs-number">0.1</span>)

fig, ax = plt.<span class="hljs-title function_">subplots</span>(subplot_kw=<span class="hljs-title function_">dict</span>(projection=ccrs.<span class="hljs-title class_">PlateCarree</span>()), figsize=(<span class="hljs-number">16</span>, <span class="hljs-number">9</span>))
shape.<span class="hljs-title function_">plot</span>(ax=ax, color=<span class="hljs-string">'grey'</span>)
gdf.<span class="hljs-title function_">plot</span>(ax=ax, color=<span class="hljs-string">'r'</span>, markersize=<span class="hljs-number">85</span>)

gl = ax.<span class="hljs-title function_">gridlines</span>(draw_labels=<span class="hljs-title class_">True</span>,linewidth=<span class="hljs-number">2</span>, color=<span class="hljs-string">'black'</span>, alpha=<span class="hljs-number">0.5</span>, linestyle=<span class="hljs-string">'--'</span>)
gl.<span class="hljs-property">xlocator</span> = mticker.<span class="hljs-title class_">FixedLocator</span>(<span class="hljs-variable constant_">LON</span>)
gl.<span class="hljs-property">ylocator</span> = mticker.<span class="hljs-title class_">FixedLocator</span>(<span class="hljs-variable constant_">LAT</span>)
gl.<span class="hljs-property">xformatter</span> = <span class="hljs-variable constant_">LONGITUDE_FORMATTER</span>
gl.<span class="hljs-property">yformatter</span> = <span class="hljs-variable constant_">LATITUDE_FORMATTER</span>
plt.<span class="hljs-title function_">show</span>()
</code></pre>
<p><img src="/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_5.png" alt="결과 이미지"></p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>위 그림에 나타난 정규 그리드에 대해 보간을 수행하는 것이 목표입니다. 이 그리드에는 8개의 온도 관측치가 있습니다.</p>
<h1>I. 최근접 이웃 (NN)</h1>
<p>가장 직관적이고 간단한 방법 중 하나인 Nearest Neighbor (NN)에 대해 이야기하겠습니다. 이름에서 알 수 있듯이, 이 알고리즘은 각 그리드 노드에 가장 가까운 관측치의 값을 할당합니다.</p>
<p>이를 구현하기 위해 필요한 함수는 두 가지뿐입니다. 첫 번째 함수는 유클리드 함수이며, 다음 공식을 사용하여 두 점 사이의 거리를 계산합니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_6.png" alt="Image"></p>
<p>두 번째는 NN 메소드 자체입니다. 관측값을 저장할 빈 배열을 만든 후, 모든 위도와 경도를 반복하면서 각 포인트에서 현재 그리드 노드까지의 거리를 계산하고 그 그리드 노드에 가장 가까운 관측값을 할당합니다.</p>
<pre><code class="hljs language-js">def 유클리드(x1, x2, y1, y2):
  <span class="hljs-keyword">return</span> ((x1-x2)**<span class="hljs-number">2</span> + (y1-y2)**<span class="hljs-number">2</span>) ** <span class="hljs-number">0.5</span>

def <span class="hljs-title function_">NN</span>(data, <span class="hljs-variable constant_">LAT</span>, <span class="hljs-variable constant_">LON</span>):
  array = np.<span class="hljs-title function_">empty</span>((<span class="hljs-variable constant_">LAT</span>.<span class="hljs-property">shape</span>[<span class="hljs-number">0</span>], <span class="hljs-variable constant_">LON</span>.<span class="hljs-property">shape</span>[<span class="hljs-number">0</span>]))

  <span class="hljs-keyword">for</span> i, lat <span class="hljs-keyword">in</span> <span class="hljs-title function_">enumerate</span>(<span class="hljs-variable constant_">LAT</span>):
    <span class="hljs-keyword">for</span> j, lon <span class="hljs-keyword">in</span> <span class="hljs-title function_">enumerate</span>(<span class="hljs-variable constant_">LON</span>):
      idx = data.<span class="hljs-title function_">apply</span>(lambda <span class="hljs-attr">row</span>: 유클리드(row.<span class="hljs-property">LONGITUDE</span>, lon, row.<span class="hljs-property">LATITUDE</span>, lat), axis=<span class="hljs-number">1</span>).<span class="hljs-title function_">argmin</span>() 
      array[i, j] = data.<span class="hljs-property">loc</span>[idx, <span class="hljs-string">'TAVG'</span>]
  <span class="hljs-keyword">return</span> array
</code></pre>
<p>전체 아이디어는 이 한 줄에 있습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-python">idx = data.apply(<span class="hljs-keyword">lambda</span> row: Euclidean(row.LONGITUDE, lon, row.LATITUDE, lat), axis=<span class="hljs-number">1</span>).argmin()
</code></pre>
<p>변수 data는 각 행이 하나의 기상 장비 사이트를 나타내는 판다 데이터프레임입니다. 따라서 for 루프에서 거리를 계산하고 최소 거리를 가진 사이트의 인덱스를 찾습니다.</p>
<p>이제 알고리즘을 실행하고 결과를 xarray 데이터셋으로 래핑해 봅시다:</p>
<pre><code class="hljs language-python">t2m = NN(df, LAT, LON)
ds = xr.Dataset(
    {<span class="hljs-string">'TAVG'</span>: ([<span class="hljs-string">'lat'</span>, <span class="hljs-string">'lon'</span>], t2m)},
    coords={<span class="hljs-string">'lat'</span>: LAT, <span class="hljs-string">'lon'</span>: LON})
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이제 결과를 플로팅할 수 있습니다:</p>
<p><img src="/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_7.png" alt=""></p>
<p>보기 좋지만, regionmask 라이브러리를 사용하여 스위스 매스크를 만들어 플롯을 더 보기 좋게 변경해 보겠습니다:</p>
<pre><code class="hljs language-js">shape[<span class="hljs-string">'new_column'</span>] = <span class="hljs-number">0</span>
sw = shape.<span class="hljs-title function_">dissolve</span>(by=<span class="hljs-string">'new_column'</span>)[<span class="hljs-string">'geometry'</span>]
rg = regionmask.<span class="hljs-title function_">mask_3D_geopandas</span>(sw, lon_or_obj=ds.<span class="hljs-property">lon</span>, lat=ds.<span class="hljs-property">lat</span>)

fig, ax = plt.<span class="hljs-title function_">subplots</span>(subplot_kw=<span class="hljs-title function_">dict</span>(projection=ccrs.<span class="hljs-title class_">PlateCarree</span>()), figsize=(<span class="hljs-number">16</span>, <span class="hljs-number">9</span>))
#shape.<span class="hljs-title function_">plot</span>(ax=ax, color=<span class="hljs-string">'black'</span>)
ds.<span class="hljs-title function_">where</span>(rg).<span class="hljs-property">TAVG</span>.<span class="hljs-title function_">plot</span>(ax=ax, alpha=<span class="hljs-number">0.6</span>)
gdf.<span class="hljs-title function_">plot</span>(ax=ax, color=<span class="hljs-string">'r'</span>, markersize=<span class="hljs-number">85</span>)
ax.<span class="hljs-title function_">gridlines</span>(draw_labels=<span class="hljs-title class_">True</span>, linewidth=<span class="hljs-number">2</span>, color=<span class="hljs-string">'black'</span>, alpha=<span class="hljs-number">0.5</span>, linestyle=<span class="hljs-string">'--'</span>)
plt.<span class="hljs-title function_">show</span>()
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<img src="/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_8.png">
<p>보시다시피 이 방법은 범주형 데이터에만 적용될 수 있습니다. 우리가 다루는 것은 온도로, 이는 연속 변수로 어떤 범위 안에서 어떤 값이든 가질 수 있다는 것을 의미합니다. 이 보간은 혼동스러울 수 있습니다. 현실에서는 항상 그라데이션과 무작위성이 있습니다.</p>
<p>그래서 좀 더 고급 알고리즘을 살펴보겠습니다.</p>
<h1>II. 역 거리 가중 이동법 (IDW)</h1>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>기본적으로 역 거리 가중치(IDW)는 NN의 향상된 버전입니다:</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">IDW</span>(data, <span class="hljs-variable constant_">LAT</span>, <span class="hljs-variable constant_">LON</span>, betta=<span class="hljs-number">2</span>):
  array = np.<span class="hljs-title function_">empty</span>((<span class="hljs-variable constant_">LAT</span>.<span class="hljs-property">shape</span>[<span class="hljs-number">0</span>], <span class="hljs-variable constant_">LON</span>.<span class="hljs-property">shape</span>[<span class="hljs-number">0</span>]))

  <span class="hljs-keyword">for</span> i, lat <span class="hljs-keyword">in</span> <span class="hljs-title function_">enumerate</span>(<span class="hljs-variable constant_">LAT</span>):
    <span class="hljs-keyword">for</span> j, lon <span class="hljs-keyword">in</span> <span class="hljs-title function_">enumerate</span>(<span class="hljs-variable constant_">LON</span>):
      weights = data.<span class="hljs-title function_">apply</span>(lambda <span class="hljs-attr">row</span>: <span class="hljs-title class_">Euclidean</span>(row.<span class="hljs-property">LONGITUDE</span>, lon, row.<span class="hljs-property">LATITUDE</span>, lat)**(-betta), axis=<span class="hljs-number">1</span>)
      z = <span class="hljs-title function_">sum</span>(weights*data.<span class="hljs-property">TAVG</span>)/weights.<span class="hljs-title function_">sum</span>()
      array[i,j] = z
  <span class="hljs-keyword">return</span> array
</code></pre>
<p>가까운 알려진 점의 값을 할당하는 대신, 여기서는 가중치를 계산합니다. 그를 위해 앞서 언급한 유클리드 거리가 사용되지만, 이번에는 각 거리를 -β 승으로 제곱합니다 (β는 임의의 값입니다). 이러한 가중치는 각 지면 점이 특정 격자 노드에 미치는 기여를 나타냅니다. 거리가 멀수록 이 점이 노드 값에 미치는 영향이 적어집니다.</p>
<p>가중치를 얻은 후 가중 평균을 계산합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_9.png" alt="image"></p>
<p><img src="/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_10.png" alt="image"></p>
<p>Let’s plot it:</p>
<p><img src="/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_11.png" alt="image"></p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>보시는 대로, 지금 결과가 훨씬 현실적이고 부드럽습니다!</p>
<h2>III. 크리징</h2>
<p>오늘의 마지막 메서드는 크리징입니다. 이 세 가지 방법 중에서 가장 복잡한 방법 중 하나이며, 우리는 간단히 알아볼 것입니다. 의식적이고 효과적으로 사용하고 싶다면 문헌을 살펴볼 것을 고려해보세요!</p>
<p>그러므로 이 방법의 주요 아이디어는 바리오그램(또는 세미바리오그램)을 사용하는 것입니다. 본질적으로 바리오그램은 어떤 매개변수의 변이가 거리와 방향에 따라 어떻게 변하는지를 측정합니다. 이것이 바로 우리가 공기 온도를 다룰 때 필요한 부분입니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>크리징 알고리즘을 구현하려면 두 가지 유형의 변이로그램이 필요합니다: 실험적 변이로그램과 이론적 변이로그램입니다.</p>
<p>첫 번째는 정말 쉽게 계산할 수 있습니다. 감마 γ로 정의됩니다:</p>
<p>[ \gamma(h) = \frac{1}{2N(h)}\sum_{i=1}^{N(h)}[z(x_i) - z(x_i + h)]^2 ]</p>
<p>여기서,</p>
<ul>
<li>( h )는 두 점 사이의 지리적 거리,</li>
<li>(z)는 온도 함수입니다.</li>
</ul>
<p>간단히 말해 이것은 알려진 점에서 온도 차이의 평균입니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이론적 변이그램은 다소 복잡합니다. 먼저, 그런것이 많이 있습니다:</p>
<p><img src="/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_13.png" alt="Variogram"></p>
<p>여기서 p는 부분 재, d는 거리(h를 사용했었죠), n은 극소값, r은 범위를 나타냅니다.</p>
<p>CDT 콜롬비아에서 이러한 매개변수에 대한 정말 좋은 시각적 설명을 찾았어요. 저는 그들의 자료에서 γ와 거리 사이의 관계를 설명하는 이미지를 채택했습니다. 이제는 sill, partial sill, nugget 및 range가 무엇인지 명확해 보입니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_14.png" alt="Spatial Interpolation Method"></p>
<p>알고리즘의 전체 아이디어는 이론적 변이그램의 매개변수를 조정하여 실험적인 것에 맞게 맞추고, 그것을 사용하여 노드의 값을 예측하는 것입니다.</p>
<p>이 방법을 구현하려면 몇 가지 추가 라이브러리가 필요하며 OrdinaryKriging이라는 클래스를 생성해야합니다.</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">from</span> scipy.linalg <span class="hljs-keyword">import</span> solve
<span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> product
<span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_squared_error <span class="hljs-keyword">as</span> MSE

<span class="hljs-keyword">class</span> <span class="hljs-title class_">OrdinaryKriging</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, lats, lons, values</span>):
        self.lats = lats
        self.lons= lons
        self.values = values

        self.nugget_values = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
        self.sill_values = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
        self.range_values = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]

        <span class="hljs-comment"># 모수 값을 맞추기 위한 모든 조합 생성</span>
        self.parameter_combinations = <span class="hljs-built_in">list</span>(product(self.nugget_values, self.sill_values, self.range_values))
        self.optimal_pars = <span class="hljs-literal">None</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">theoretical_variogram</span>(<span class="hljs-params">self, h, nugget, sill, r</span>):
        <span class="hljs-keyword">return</span> nugget + (sill-nugget) * (<span class="hljs-number">1</span>-np.exp(-<span class="hljs-number">3</span>*h/r))

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">Euclidean</span>(<span class="hljs-params">self, X, Y</span>):
        all_dists, point_dists = [], []
        <span class="hljs-keyword">for</span> x,y <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(X, Y):
          k = <span class="hljs-number">0</span>
          <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(X)):
            h = np.linalg.norm(np.array([x, y]) - np.array([X[k], Y[k]))
            point_dists.append(h)
          all_dists.append(point_dists)
          point_dists = []
        <span class="hljs-keyword">return</span> all_dists

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">gamma</span>(<span class="hljs-params">self</span>):
        distances = self.Euclidean(self.lats, self.lons)
        differences = np.<span class="hljs-built_in">abs</span>(self.values.reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) - self.values)
        variogram_values = []
        <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> np.unique(distances):
            values_at_h = differences[(distances == h)]
            variogram_values.append(np.mean(values_at_h**<span class="hljs-number">2</span>))
        <span class="hljs-keyword">return</span> variogram_values, np.unique(distances)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fit</span>(<span class="hljs-params">self</span>):
        experimental_variogram, distances = self.gamma()
        fit_metrics = []
        <span class="hljs-keyword">for</span> nugget, sill, range_ <span class="hljs-keyword">in</span> self.parameter_combinations:
            theoretical_variogram_values = self.theoretical_variogram(distances, nugget, sill, range_)
            fit_metric = MSE(experimental_variogram, theoretical_variogram_values)
            fit_metrics.append((nugget, sill, range_, fit_metric))

        self.optimal_pars = <span class="hljs-built_in">min</span>(fit_metrics, key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">3</span>])[:<span class="hljs-number">3</span>]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">predict</span>(<span class="hljs-params">self, point</span>):
        points = np.array([(x,y) <span class="hljs-keyword">for</span> x,y <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(self.lats, self.lons)])
        distances = np.linalg.norm(points - point, axis=<span class="hljs-number">1</span>)
        pars = <span class="hljs-built_in">list</span>(self.optimal_pars)
        pars.insert(<span class="hljs-number">0</span>, distances)
        weights = self.theoretical_variogram(*pars)
        weights /= np.<span class="hljs-built_in">sum</span>(weights)
        <span class="hljs-keyword">return</span> np.dot(weights, self.values)

kriging = OrdinaryKriging(df.LATITUDE.values, df.LONGITUDE.values, df.TAVG.values)

kriging.fit()
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이제 각 함수를 따로 살펴봅시다.
<strong>init</strong> 함수는 좌표와 값의 초기화 외에 nugget, sill, range의 가능한 값으로 구성된 세 개의 리스트를 포함합니다. 모든 가능한 조합으로 섞어서 parameter_combinations 변수에 저장됩니다. 우리는 나중에 최적 값을 찾을 때 필요할 것입니다.</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, lats, lons, values</span>):
        self.lats = lats
        self.lons= lons
        self.values = values

        self.nugget_values = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
        self.sill_values = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
        self.range_values = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]

        <span class="hljs-comment"># 맞추기 위한 모든 파라미터 값 조합 생성</span>
        self.parameter_combinations = <span class="hljs-built_in">list</span>(product(self.nugget_values, self.sill_values, self.range_values))
        self.optimal_pars = <span class="hljs-literal">None</span>
</code></pre>
<p>두 번째 함수인 theoretical_variogram은 이전에 언급된 공식 중 하나를 파이썬으로 구현한 것에 불과합니다. 여기서는 지수 함수입니다 (하지만 다른 함수에 대한 코드를 작성하여 결과를 비교할 수도 있습니다):</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">theoretical_variogram</span>(<span class="hljs-params">self, h, nugget, sill, r</span>):
 <span class="hljs-keyword">return</span> nugget + (sill-nugget) * (<span class="hljs-number">1</span>-np.exp(-<span class="hljs-number">3</span>*h/r))
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>세 번째 클래스 메서드는 유클리디안입니다. 이것은 NN과 IDW를 위해 만든 함수의 변경된 버전입니다. 이번에는 점과 모든 다른 점 사이의 거리를 나타내는 (n,n) 행렬을 반환합니다 (각 행에서 하나의 값은 0이며, 점과 그 자신 사이의 거리는 0입니다).</p>
<pre><code class="hljs language-js">def <span class="hljs-title class_">Euclidean</span>(self, X, Y):
        all_dists, point_dists = [], []
        <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> <span class="hljs-title function_">zip</span>(X, Y):
          k = <span class="hljs-number">0</span>
          <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-title function_">len</span>(X)):
            h = np.<span class="hljs-property">linalg</span>.<span class="hljs-title function_">norm</span>(np.<span class="hljs-title function_">array</span>([x, y]) - np.<span class="hljs-title function_">array</span>([X[k], Y[k]))
            point_dists.<span class="hljs-title function_">append</span>(h)
          all_dists.<span class="hljs-title function_">append</span>(point_dists)
          point_dists = []
        <span class="hljs-keyword">return</span> all_dists
</code></pre>
<p>네 번째 함수는 fitting을 수행합니다. 여기서는 실험적 변리오그램 값과 유클리디안 거리를 얻습니다. 그런 다음 sill, range 및 nugget의 조합을 반복하면서 이론적 변리오그램 값과 실험적 값 사이의 평균 제곱 오차(Mean Squared Error, MSE) 추정을 계산합니다 (다른 메트릭을 사용할 수도 있습니다). 그런 다음 최적의 매개변수를 클래스 변수 optimal_pars에 저장합니다.</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">fit</span>(self):
        experimental_variogram, distances = self.<span class="hljs-title function_">gamma</span>()
        fit_metrics = []
        <span class="hljs-keyword">for</span> nugget, sill, range_ <span class="hljs-keyword">in</span> self.<span class="hljs-property">parameter_combinations</span>:
            theoretical_variogram_values = self.<span class="hljs-title function_">theoretical_variogram</span>(distances, nugget, sill, range_)
            fit_metric = <span class="hljs-title function_">MSE</span>(experimental_variogram, theoretical_variogram_values)
            fit_metrics.<span class="hljs-title function_">append</span>((nugget, sill, range_, fit_metric))

        self.<span class="hljs-property">optimal_pars</span> = <span class="hljs-title function_">min</span>(fit_metrics, key=lambda <span class="hljs-attr">x</span>: x[<span class="hljs-number">3</span>])[:<span class="hljs-number">3</span>]
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>마지막으로 가장 중요한 함수는 예측입니다. 입력으로 점 (lat;lon)을 받아서 해당 점과 다른 알려진 값들 사이의 거리를 추정합니다. 그런 다음, 앞서 얻은 최적 파라미터를 전달하여 이론적 변이그램 함수를 호출하고 가중치를 출력값으로 받습니다. 그런 다음 가중 평균을 계산하고 반환합니다.</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">predict</span>(self, point):
        points = np.<span class="hljs-title function_">array</span>([(x,y) <span class="hljs-keyword">for</span> x,y <span class="hljs-keyword">in</span> <span class="hljs-title function_">zip</span>(self.<span class="hljs-property">lats</span>, self.<span class="hljs-property">lons</span>)])
        distances = np.<span class="hljs-property">linalg</span>.<span class="hljs-title function_">norm</span>(points - point, axis=<span class="hljs-number">1</span>)
        pars = <span class="hljs-title function_">list</span>(self.<span class="hljs-property">optimal_pars</span>)
        pars.<span class="hljs-title function_">insert</span>(<span class="hljs-number">0</span>, distances)
        weights = self.<span class="hljs-title function_">theoretical_variogram</span>(*pars)
        weights /= np.<span class="hljs-title function_">sum</span>(weights)
        <span class="hljs-keyword">return</span> np.<span class="hljs-title function_">dot</span>(weights, self.<span class="hljs-property">values</span>)
</code></pre>
<p>이제 모든 예측값을 수집하고 지도를 시각화할 수 있습니다:</p>
<pre><code class="hljs language-js">row, grid = [], []
<span class="hljs-keyword">for</span> lat <span class="hljs-keyword">in</span> <span class="hljs-attr">LAT</span>:
  <span class="hljs-keyword">for</span> lon <span class="hljs-keyword">in</span> <span class="hljs-attr">LON</span>:
    row.<span class="hljs-title function_">append</span>(kriging.<span class="hljs-title function_">predict</span>(np.<span class="hljs-title function_">array</span>([lat, lon])))
  grid.<span class="hljs-title function_">append</span>(row)
  row=[]

ds = xr.<span class="hljs-title class_">Dataset</span>(
    {<span class="hljs-string">'TAVG'</span>: ([<span class="hljs-string">'lat'</span>, <span class="hljs-string">'lon'</span>], grid)},
    coords={<span class="hljs-string">'lat'</span>: <span class="hljs-variable constant_">LAT</span>, <span class="hljs-string">'lon'</span>: <span class="hljs-variable constant_">LON</span>})

fig, ax = plt.<span class="hljs-title function_">subplots</span>(subplot_kw=<span class="hljs-title function_">dict</span>(projection=ccrs.<span class="hljs-title class_">PlateCarree</span>()), figsize=(<span class="hljs-number">16</span>, <span class="hljs-number">9</span>))
ds.<span class="hljs-title function_">where</span>(rg).<span class="hljs-property">TAVG</span>.<span class="hljs-title function_">plot</span>(ax=ax, alpha=<span class="hljs-number">0.6</span>)
gdf.<span class="hljs-title function_">plot</span>(ax=ax, color=<span class="hljs-string">'r'</span>, markersize=<span class="hljs-number">85</span>)
ax.<span class="hljs-title function_">gridlines</span>(draw_labels=<span class="hljs-title class_">True</span>,linewidth=<span class="hljs-number">2</span>, color=<span class="hljs-string">'black'</span>, alpha=<span class="hljs-number">0.5</span>, linestyle=<span class="hljs-string">'--'</span>)
plt.<span class="hljs-title function_">show</span>()
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_15.png" alt="image"></p>
<p>위와 같이 결과가 IDW에서 얻은 것과는 꽤 다르다는 것을 알 수 있어요. 크리깅에서 가장 중요한 매개변수는 선택한 이론적 변이그램 종류인데, 이는 사실 상 예측된 값과 거리 간의 관계를 정의합니다. 코드를 사용하기 귀찮으시거나 직접 작성하고 싶지 않다면 많은 변이그램 모델의 구현을 갖고 있는 PyKrige 라이브러리를 살펴보세요.</p>
<p>이 글이 유익하고 통찰력을 줬으면 좋겠어요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>저의 Medium에 올린 모든 게시물은 무료로 공개되어 있습니다. 그래서 여기서 제를 팔로우해 주실 경우 정말 감사하겠습니다!</p>
<p>참고로, 저는 (지리)데이터 과학, 기계학습/인공지능, 그리고 기후 변화에 대해 열정적으로 공부하고 있습니다. 만약 함께 프로젝트를 진행하고 싶다면 LinkedIn에서 연락 주세요.</p>
<p>🛰️더 많은 소식을 위해 팔로우 해주세요🛰️</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"공간 보간을 위한 3가지 인기 있는 방법","description":"","date":"2024-07-09 19:17","slug":"2024-07-09-3PopularMethodsforSpatialInterpolation","content":"\n\n## 처음부터, Python에서\n\n\u003cimg src=\"/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_0.png\" /\u003e\n\n보간법은 데이터 과학자 뿐만 아니라 다양한 분야의 사람들에 의해 사용되는 매우 일반적인 수학적 개념입니다. 그러나 지리 공간 데이터를 다룰 때, 보간은 종종 희소한 관측치를 기반으로 대표적인 그리드를 만들어야 하기 때문에 더 복잡해집니다.\n\n지리 공간 부분에 들어가기 전에, 선형 보간에 대해 간단히 되짚어 봅시다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n디자인을 보여드리기 위해 일반 다항 함수를 사용할 것입니다:\n\n```js\ndef F(x):\n  return -2*x**3+x**2+2.1\n\nx = np.arange(-5,5, 0.1)\ny = F(x)\n```\n\n\u003cimg src=\"/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_1.png\" /\u003e\n\n이제 [-4.2, 0, 2.5]에서 몇 개의 점을 무작위로 샘플링하고 이를 연결해 보겠습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_2.png)\n\n이것은 선형 보간법이라고 불립니다. 각 구간에서 직선으로 함수를 근사하고 있으며, 이제 3개의 점에서 함수의 값을 알고 있을 때 [-4.2;2.5] 구간 내의 값을 찾을 수 있습니다.\n\n높은 정확도를 가진 많은 다른 방법들이 있지만, 그 뒤에 있는 아이디어는 동일합니다: 적어도 두 개의 알려진 점 사이에서 함수 값을 찾는 것입니다.\n\n이제 지리 공간 부분으로 넘어갈 시간입니다. 이 자습서에서는 NOAA에서 제공한 스위스 전역의 기상 측정소에서 측정된 일일 평균 대기 온도의 공간 보간을 수행하는 것이 목표입니다. 기대되는 결과는 0.1° 해상도의 온도 그리드입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저, 스위스의 행정 경계를 얻어와서 geopandas를 사용하여 시각화해야 합니다:\n\n```python\nimport geopandas as gpd\n\nshape = gpd.read_file('gadm41_CHE_0.shp')\nshape.plot()\n```\n\n\u003cimg src=\"/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_3.png\" /\u003e\n\n정말 대단해요! 스위스인 것 같네요 =)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 온도 관측치를 그래프로 표시하고 국가 모양과 겹쳐보겠습니다. 이를 위해 정기적인 판다 데이터프레임으로 기상 데이터를 로드한 다음 셰이프리 포인트로 변환한 지리 데이터프레임으로 변환하겠습니다:\n\n```python\nimport pandas as pd\nfrom shapely.geometry import Point\n\ndf = pd.read_csv('3639866.csv')\n\npoints = list()\nfor i in range(len(df)):\n  point = Point(df.loc[i, 'LONGITUDE'], df.loc[i, 'LATITUDE'])\n  points.append(point)\n\ngdf = gpd.GeoDataFrame(geometry=points).set_crs(shape.crs)\n```\n\n그렇게 하면 matplotlib을 사용하여 두 데이터프레임을 쉽게 겹쳐 볼 수 있습니다.\n\n```python\nfig, ax = plt.subplots(figsize=(16,9))\nshape.plot(ax=ax, color='black')\ngdf.plot(ax=ax, color='r', markersize=85)\nplt.show()\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![그리드 및 지도 오버레이를 시각화하기 위해 다음을 수행하겠습니다:](/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_4.png)\n\n```js\nimport matplotlib.ticker as mticker\nimport cartopy.crs as ccrs\nfrom cartopy.mpl.gridliner import LONGITUDE_FORMATTER, LATITUDE_FORMATTER\n\nLAT, LON = np.arange(45.75, 48, 0.1), np.arange(6, 10.81, 0.1)\n\nfig, ax = plt.subplots(subplot_kw=dict(projection=ccrs.PlateCarree()), figsize=(16, 9))\nshape.plot(ax=ax, color='grey')\ngdf.plot(ax=ax, color='r', markersize=85)\n\ngl = ax.gridlines(draw_labels=True,linewidth=2, color='black', alpha=0.5, linestyle='--')\ngl.xlocator = mticker.FixedLocator(LON)\ngl.ylocator = mticker.FixedLocator(LAT)\ngl.xformatter = LONGITUDE_FORMATTER\ngl.yformatter = LATITUDE_FORMATTER\nplt.show()\n```\n\n![결과 이미지](/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_5.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 그림에 나타난 정규 그리드에 대해 보간을 수행하는 것이 목표입니다. 이 그리드에는 8개의 온도 관측치가 있습니다.\n\n# I. 최근접 이웃 (NN)\n\n가장 직관적이고 간단한 방법 중 하나인 Nearest Neighbor (NN)에 대해 이야기하겠습니다. 이름에서 알 수 있듯이, 이 알고리즘은 각 그리드 노드에 가장 가까운 관측치의 값을 할당합니다.\n\n이를 구현하기 위해 필요한 함수는 두 가지뿐입니다. 첫 번째 함수는 유클리드 함수이며, 다음 공식을 사용하여 두 점 사이의 거리를 계산합니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Image](/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_6.png)\n\n두 번째는 NN 메소드 자체입니다. 관측값을 저장할 빈 배열을 만든 후, 모든 위도와 경도를 반복하면서 각 포인트에서 현재 그리드 노드까지의 거리를 계산하고 그 그리드 노드에 가장 가까운 관측값을 할당합니다.\n\n```js\ndef 유클리드(x1, x2, y1, y2):\n  return ((x1-x2)**2 + (y1-y2)**2) ** 0.5\n\ndef NN(data, LAT, LON):\n  array = np.empty((LAT.shape[0], LON.shape[0]))\n\n  for i, lat in enumerate(LAT):\n    for j, lon in enumerate(LON):\n      idx = data.apply(lambda row: 유클리드(row.LONGITUDE, lon, row.LATITUDE, lat), axis=1).argmin() \n      array[i, j] = data.loc[idx, 'TAVG']\n  return array\n```\n\n전체 아이디어는 이 한 줄에 있습니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nidx = data.apply(lambda row: Euclidean(row.LONGITUDE, lon, row.LATITUDE, lat), axis=1).argmin()\n```\n\n변수 data는 각 행이 하나의 기상 장비 사이트를 나타내는 판다 데이터프레임입니다. 따라서 for 루프에서 거리를 계산하고 최소 거리를 가진 사이트의 인덱스를 찾습니다.\n\n이제 알고리즘을 실행하고 결과를 xarray 데이터셋으로 래핑해 봅시다:\n\n```python\nt2m = NN(df, LAT, LON)\nds = xr.Dataset(\n    {'TAVG': (['lat', 'lon'], t2m)},\n    coords={'lat': LAT, 'lon': LON})\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 결과를 플로팅할 수 있습니다:\n\n![](/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_7.png)\n\n보기 좋지만, regionmask 라이브러리를 사용하여 스위스 매스크를 만들어 플롯을 더 보기 좋게 변경해 보겠습니다:\n\n```js\nshape['new_column'] = 0\nsw = shape.dissolve(by='new_column')['geometry']\nrg = regionmask.mask_3D_geopandas(sw, lon_or_obj=ds.lon, lat=ds.lat)\n\nfig, ax = plt.subplots(subplot_kw=dict(projection=ccrs.PlateCarree()), figsize=(16, 9))\n#shape.plot(ax=ax, color='black')\nds.where(rg).TAVG.plot(ax=ax, alpha=0.6)\ngdf.plot(ax=ax, color='r', markersize=85)\nax.gridlines(draw_labels=True, linewidth=2, color='black', alpha=0.5, linestyle='--')\nplt.show()\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_8.png\" /\u003e\n\n보시다시피 이 방법은 범주형 데이터에만 적용될 수 있습니다. 우리가 다루는 것은 온도로, 이는 연속 변수로 어떤 범위 안에서 어떤 값이든 가질 수 있다는 것을 의미합니다. 이 보간은 혼동스러울 수 있습니다. 현실에서는 항상 그라데이션과 무작위성이 있습니다.\n\n그래서 좀 더 고급 알고리즘을 살펴보겠습니다.\n\n# II. 역 거리 가중 이동법 (IDW)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기본적으로 역 거리 가중치(IDW)는 NN의 향상된 버전입니다:\n\n```js\ndef IDW(data, LAT, LON, betta=2):\n  array = np.empty((LAT.shape[0], LON.shape[0]))\n\n  for i, lat in enumerate(LAT):\n    for j, lon in enumerate(LON):\n      weights = data.apply(lambda row: Euclidean(row.LONGITUDE, lon, row.LATITUDE, lat)**(-betta), axis=1)\n      z = sum(weights*data.TAVG)/weights.sum()\n      array[i,j] = z\n  return array\n```\n\n가까운 알려진 점의 값을 할당하는 대신, 여기서는 가중치를 계산합니다. 그를 위해 앞서 언급한 유클리드 거리가 사용되지만, 이번에는 각 거리를 -β 승으로 제곱합니다 (β는 임의의 값입니다). 이러한 가중치는 각 지면 점이 특정 격자 노드에 미치는 기여를 나타냅니다. 거리가 멀수록 이 점이 노드 값에 미치는 영향이 적어집니다.\n\n가중치를 얻은 후 가중 평균을 계산합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_9.png)\n\n![image](/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_10.png)\n\nLet’s plot it:\n\n![image](/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_11.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n보시는 대로, 지금 결과가 훨씬 현실적이고 부드럽습니다!\n\n## III. 크리징\n\n오늘의 마지막 메서드는 크리징입니다. 이 세 가지 방법 중에서 가장 복잡한 방법 중 하나이며, 우리는 간단히 알아볼 것입니다. 의식적이고 효과적으로 사용하고 싶다면 문헌을 살펴볼 것을 고려해보세요!\n\n그러므로 이 방법의 주요 아이디어는 바리오그램(또는 세미바리오그램)을 사용하는 것입니다. 본질적으로 바리오그램은 어떤 매개변수의 변이가 거리와 방향에 따라 어떻게 변하는지를 측정합니다. 이것이 바로 우리가 공기 온도를 다룰 때 필요한 부분입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n크리징 알고리즘을 구현하려면 두 가지 유형의 변이로그램이 필요합니다: 실험적 변이로그램과 이론적 변이로그램입니다.\n\n첫 번째는 정말 쉽게 계산할 수 있습니다. 감마 γ로 정의됩니다:\n\n\\[ \\gamma(h) = \\frac{1}{2N(h)}\\sum_{i=1}^{N(h)}[z(x_i) - z(x_i + h)]^2 \\]\n\n여기서,\n- \\( h \\)는 두 점 사이의 지리적 거리,\n- \\(z\\)는 온도 함수입니다.\n\n간단히 말해 이것은 알려진 점에서 온도 차이의 평균입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이론적 변이그램은 다소 복잡합니다. 먼저, 그런것이 많이 있습니다:\n\n![Variogram](/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_13.png)\n\n여기서 p는 부분 재, d는 거리(h를 사용했었죠), n은 극소값, r은 범위를 나타냅니다.\n\nCDT 콜롬비아에서 이러한 매개변수에 대한 정말 좋은 시각적 설명을 찾았어요. 저는 그들의 자료에서 γ와 거리 사이의 관계를 설명하는 이미지를 채택했습니다. 이제는 sill, partial sill, nugget 및 range가 무엇인지 명확해 보입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Spatial Interpolation Method](/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_14.png)\n\n알고리즘의 전체 아이디어는 이론적 변이그램의 매개변수를 조정하여 실험적인 것에 맞게 맞추고, 그것을 사용하여 노드의 값을 예측하는 것입니다.\n\n이 방법을 구현하려면 몇 가지 추가 라이브러리가 필요하며 OrdinaryKriging이라는 클래스를 생성해야합니다.\n\n```python\nfrom scipy.linalg import solve\nfrom itertools import product\nfrom sklearn.metrics import mean_squared_error as MSE\n\nclass OrdinaryKriging:\n    def __init__(self, lats, lons, values):\n        self.lats = lats\n        self.lons= lons\n        self.values = values\n\n        self.nugget_values = [0, 1, 2, 3, 4]\n        self.sill_values = [1, 2, 3, 4, 5]\n        self.range_values = [1, 2, 3, 4, 5]\n\n        # 모수 값을 맞추기 위한 모든 조합 생성\n        self.parameter_combinations = list(product(self.nugget_values, self.sill_values, self.range_values))\n        self.optimal_pars = None\n\n    def theoretical_variogram(self, h, nugget, sill, r):\n        return nugget + (sill-nugget) * (1-np.exp(-3*h/r))\n\n    def Euclidean(self, X, Y):\n        all_dists, point_dists = [], []\n        for x,y in zip(X, Y):\n          k = 0\n          for k in range(len(X)):\n            h = np.linalg.norm(np.array([x, y]) - np.array([X[k], Y[k]))\n            point_dists.append(h)\n          all_dists.append(point_dists)\n          point_dists = []\n        return all_dists\n\n    def gamma(self):\n        distances = self.Euclidean(self.lats, self.lons)\n        differences = np.abs(self.values.reshape(-1,1) - self.values)\n        variogram_values = []\n        for h in np.unique(distances):\n            values_at_h = differences[(distances == h)]\n            variogram_values.append(np.mean(values_at_h**2))\n        return variogram_values, np.unique(distances)\n\n    def fit(self):\n        experimental_variogram, distances = self.gamma()\n        fit_metrics = []\n        for nugget, sill, range_ in self.parameter_combinations:\n            theoretical_variogram_values = self.theoretical_variogram(distances, nugget, sill, range_)\n            fit_metric = MSE(experimental_variogram, theoretical_variogram_values)\n            fit_metrics.append((nugget, sill, range_, fit_metric))\n\n        self.optimal_pars = min(fit_metrics, key=lambda x: x[3])[:3]\n\n    def predict(self, point):\n        points = np.array([(x,y) for x,y in zip(self.lats, self.lons)])\n        distances = np.linalg.norm(points - point, axis=1)\n        pars = list(self.optimal_pars)\n        pars.insert(0, distances)\n        weights = self.theoretical_variogram(*pars)\n        weights /= np.sum(weights)\n        return np.dot(weights, self.values)\n\nkriging = OrdinaryKriging(df.LATITUDE.values, df.LONGITUDE.values, df.TAVG.values)\n\nkriging.fit()\n```\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 각 함수를 따로 살펴봅시다.\n__init__ 함수는 좌표와 값의 초기화 외에 nugget, sill, range의 가능한 값으로 구성된 세 개의 리스트를 포함합니다. 모든 가능한 조합으로 섞어서 parameter_combinations 변수에 저장됩니다. 우리는 나중에 최적 값을 찾을 때 필요할 것입니다.\n\n```python\ndef __init__(self, lats, lons, values):\n        self.lats = lats\n        self.lons= lons\n        self.values = values\n\n        self.nugget_values = [0, 1, 2, 3, 4]\n        self.sill_values = [1, 2, 3, 4, 5]\n        self.range_values = [1, 2, 3, 4, 5]\n\n        # 맞추기 위한 모든 파라미터 값 조합 생성\n        self.parameter_combinations = list(product(self.nugget_values, self.sill_values, self.range_values))\n        self.optimal_pars = None\n```\n\n두 번째 함수인 theoretical_variogram은 이전에 언급된 공식 중 하나를 파이썬으로 구현한 것에 불과합니다. 여기서는 지수 함수입니다 (하지만 다른 함수에 대한 코드를 작성하여 결과를 비교할 수도 있습니다):\n\n```python\ndef theoretical_variogram(self, h, nugget, sill, r):\n return nugget + (sill-nugget) * (1-np.exp(-3*h/r))\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n세 번째 클래스 메서드는 유클리디안입니다. 이것은 NN과 IDW를 위해 만든 함수의 변경된 버전입니다. 이번에는 점과 모든 다른 점 사이의 거리를 나타내는 (n,n) 행렬을 반환합니다 (각 행에서 하나의 값은 0이며, 점과 그 자신 사이의 거리는 0입니다).\n\n```js\ndef Euclidean(self, X, Y):\n        all_dists, point_dists = [], []\n        for x, y in zip(X, Y):\n          k = 0\n          for k in range(len(X)):\n            h = np.linalg.norm(np.array([x, y]) - np.array([X[k], Y[k]))\n            point_dists.append(h)\n          all_dists.append(point_dists)\n          point_dists = []\n        return all_dists\n```\n\n네 번째 함수는 fitting을 수행합니다. 여기서는 실험적 변리오그램 값과 유클리디안 거리를 얻습니다. 그런 다음 sill, range 및 nugget의 조합을 반복하면서 이론적 변리오그램 값과 실험적 값 사이의 평균 제곱 오차(Mean Squared Error, MSE) 추정을 계산합니다 (다른 메트릭을 사용할 수도 있습니다). 그런 다음 최적의 매개변수를 클래스 변수 optimal_pars에 저장합니다.\n\n```js\ndef fit(self):\n        experimental_variogram, distances = self.gamma()\n        fit_metrics = []\n        for nugget, sill, range_ in self.parameter_combinations:\n            theoretical_variogram_values = self.theoretical_variogram(distances, nugget, sill, range_)\n            fit_metric = MSE(experimental_variogram, theoretical_variogram_values)\n            fit_metrics.append((nugget, sill, range_, fit_metric))\n\n        self.optimal_pars = min(fit_metrics, key=lambda x: x[3])[:3]\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마지막으로 가장 중요한 함수는 예측입니다. 입력으로 점 (lat;lon)을 받아서 해당 점과 다른 알려진 값들 사이의 거리를 추정합니다. 그런 다음, 앞서 얻은 최적 파라미터를 전달하여 이론적 변이그램 함수를 호출하고 가중치를 출력값으로 받습니다. 그런 다음 가중 평균을 계산하고 반환합니다.\n\n```js\ndef predict(self, point):\n        points = np.array([(x,y) for x,y in zip(self.lats, self.lons)])\n        distances = np.linalg.norm(points - point, axis=1)\n        pars = list(self.optimal_pars)\n        pars.insert(0, distances)\n        weights = self.theoretical_variogram(*pars)\n        weights /= np.sum(weights)\n        return np.dot(weights, self.values)\n```\n\n이제 모든 예측값을 수집하고 지도를 시각화할 수 있습니다:\n\n```js\nrow, grid = [], []\nfor lat in LAT:\n  for lon in LON:\n    row.append(kriging.predict(np.array([lat, lon])))\n  grid.append(row)\n  row=[]\n\nds = xr.Dataset(\n    {'TAVG': (['lat', 'lon'], grid)},\n    coords={'lat': LAT, 'lon': LON})\n\nfig, ax = plt.subplots(subplot_kw=dict(projection=ccrs.PlateCarree()), figsize=(16, 9))\nds.where(rg).TAVG.plot(ax=ax, alpha=0.6)\ngdf.plot(ax=ax, color='r', markersize=85)\nax.gridlines(draw_labels=True,linewidth=2, color='black', alpha=0.5, linestyle='--')\nplt.show()\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_15.png)\n\n위와 같이 결과가 IDW에서 얻은 것과는 꽤 다르다는 것을 알 수 있어요. 크리깅에서 가장 중요한 매개변수는 선택한 이론적 변이그램 종류인데, 이는 사실 상 예측된 값과 거리 간의 관계를 정의합니다. 코드를 사용하기 귀찮으시거나 직접 작성하고 싶지 않다면 많은 변이그램 모델의 구현을 갖고 있는 PyKrige 라이브러리를 살펴보세요.\n\n이 글이 유익하고 통찰력을 줬으면 좋겠어요!\n\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저의 Medium에 올린 모든 게시물은 무료로 공개되어 있습니다. 그래서 여기서 제를 팔로우해 주실 경우 정말 감사하겠습니다!\n\n참고로, 저는 (지리)데이터 과학, 기계학습/인공지능, 그리고 기후 변화에 대해 열정적으로 공부하고 있습니다. 만약 함께 프로젝트를 진행하고 싶다면 LinkedIn에서 연락 주세요.\n\n🛰️더 많은 소식을 위해 팔로우 해주세요🛰️","ogImage":{"url":"/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_0.png"},"coverImage":"/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_0.png","tag":["Tech"],"readingTime":19},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e처음부터, Python에서\u003c/h2\u003e\n\u003cimg src=\"/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_0.png\"\u003e\n\u003cp\u003e보간법은 데이터 과학자 뿐만 아니라 다양한 분야의 사람들에 의해 사용되는 매우 일반적인 수학적 개념입니다. 그러나 지리 공간 데이터를 다룰 때, 보간은 종종 희소한 관측치를 기반으로 대표적인 그리드를 만들어야 하기 때문에 더 복잡해집니다.\u003c/p\u003e\n\u003cp\u003e지리 공간 부분에 들어가기 전에, 선형 보간에 대해 간단히 되짚어 봅시다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e디자인을 보여드리기 위해 일반 다항 함수를 사용할 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003eF\u003c/span\u003e(x):\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e -\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e*x**\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e+x**\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e+\u003cspan class=\"hljs-number\"\u003e2.1\u003c/span\u003e\n\nx = np.\u003cspan class=\"hljs-title function_\"\u003earange\u003c/span\u003e(-\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.1\u003c/span\u003e)\ny = \u003cspan class=\"hljs-title function_\"\u003eF\u003c/span\u003e(x)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_1.png\"\u003e\n\u003cp\u003e이제 [-4.2, 0, 2.5]에서 몇 개의 점을 무작위로 샘플링하고 이를 연결해 보겠습니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이것은 선형 보간법이라고 불립니다. 각 구간에서 직선으로 함수를 근사하고 있으며, 이제 3개의 점에서 함수의 값을 알고 있을 때 [-4.2;2.5] 구간 내의 값을 찾을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e높은 정확도를 가진 많은 다른 방법들이 있지만, 그 뒤에 있는 아이디어는 동일합니다: 적어도 두 개의 알려진 점 사이에서 함수 값을 찾는 것입니다.\u003c/p\u003e\n\u003cp\u003e이제 지리 공간 부분으로 넘어갈 시간입니다. 이 자습서에서는 NOAA에서 제공한 스위스 전역의 기상 측정소에서 측정된 일일 평균 대기 온도의 공간 보간을 수행하는 것이 목표입니다. 기대되는 결과는 0.1° 해상도의 온도 그리드입니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e먼저, 스위스의 행정 경계를 얻어와서 geopandas를 사용하여 시각화해야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e geopandas \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e gpd\n\nshape = gpd.read_file(\u003cspan class=\"hljs-string\"\u003e'gadm41_CHE_0.shp'\u003c/span\u003e)\nshape.plot()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_3.png\"\u003e\n\u003cp\u003e정말 대단해요! 스위스인 것 같네요 =)\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이제 온도 관측치를 그래프로 표시하고 국가 모양과 겹쳐보겠습니다. 이를 위해 정기적인 판다 데이터프레임으로 기상 데이터를 로드한 다음 셰이프리 포인트로 변환한 지리 데이터프레임으로 변환하겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pandas \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pd\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e shapely.geometry \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e Point\n\ndf = pd.read_csv(\u003cspan class=\"hljs-string\"\u003e'3639866.csv'\u003c/span\u003e)\n\npoints = \u003cspan class=\"hljs-built_in\"\u003elist\u003c/span\u003e()\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(df)):\n  point = Point(df.loc[i, \u003cspan class=\"hljs-string\"\u003e'LONGITUDE'\u003c/span\u003e], df.loc[i, \u003cspan class=\"hljs-string\"\u003e'LATITUDE'\u003c/span\u003e])\n  points.append(point)\n\ngdf = gpd.GeoDataFrame(geometry=points).set_crs(shape.crs)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그렇게 하면 matplotlib을 사용하여 두 데이터프레임을 쉽게 겹쳐 볼 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003efig, ax = plt.subplots(figsize=(\u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e))\nshape.plot(ax=ax, color=\u003cspan class=\"hljs-string\"\u003e'black'\u003c/span\u003e)\ngdf.plot(ax=ax, color=\u003cspan class=\"hljs-string\"\u003e'r'\u003c/span\u003e, markersize=\u003cspan class=\"hljs-number\"\u003e85\u003c/span\u003e)\nplt.show()\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_4.png\" alt=\"그리드 및 지도 오버레이를 시각화하기 위해 다음을 수행하겠습니다:\"\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e matplotlib.\u003cspan class=\"hljs-property\"\u003eticker\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e mticker\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e cartopy.\u003cspan class=\"hljs-property\"\u003ecrs\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e ccrs\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e cartopy.\u003cspan class=\"hljs-property\"\u003empl\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003egridliner\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eLONGITUDE_FORMATTER\u003c/span\u003e, \u003cspan class=\"hljs-variable constant_\"\u003eLATITUDE_FORMATTER\u003c/span\u003e\n\n\u003cspan class=\"hljs-variable constant_\"\u003eLAT\u003c/span\u003e, \u003cspan class=\"hljs-variable constant_\"\u003eLON\u003c/span\u003e = np.\u003cspan class=\"hljs-title function_\"\u003earange\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e45.75\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e48\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.1\u003c/span\u003e), np.\u003cspan class=\"hljs-title function_\"\u003earange\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e10.81\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.1\u003c/span\u003e)\n\nfig, ax = plt.\u003cspan class=\"hljs-title function_\"\u003esubplots\u003c/span\u003e(subplot_kw=\u003cspan class=\"hljs-title function_\"\u003edict\u003c/span\u003e(projection=ccrs.\u003cspan class=\"hljs-title class_\"\u003ePlateCarree\u003c/span\u003e()), figsize=(\u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e))\nshape.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(ax=ax, color=\u003cspan class=\"hljs-string\"\u003e'grey'\u003c/span\u003e)\ngdf.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(ax=ax, color=\u003cspan class=\"hljs-string\"\u003e'r'\u003c/span\u003e, markersize=\u003cspan class=\"hljs-number\"\u003e85\u003c/span\u003e)\n\ngl = ax.\u003cspan class=\"hljs-title function_\"\u003egridlines\u003c/span\u003e(draw_labels=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e,linewidth=\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'black'\u003c/span\u003e, alpha=\u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e, linestyle=\u003cspan class=\"hljs-string\"\u003e'--'\u003c/span\u003e)\ngl.\u003cspan class=\"hljs-property\"\u003exlocator\u003c/span\u003e = mticker.\u003cspan class=\"hljs-title class_\"\u003eFixedLocator\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eLON\u003c/span\u003e)\ngl.\u003cspan class=\"hljs-property\"\u003eylocator\u003c/span\u003e = mticker.\u003cspan class=\"hljs-title class_\"\u003eFixedLocator\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eLAT\u003c/span\u003e)\ngl.\u003cspan class=\"hljs-property\"\u003exformatter\u003c/span\u003e = \u003cspan class=\"hljs-variable constant_\"\u003eLONGITUDE_FORMATTER\u003c/span\u003e\ngl.\u003cspan class=\"hljs-property\"\u003eyformatter\u003c/span\u003e = \u003cspan class=\"hljs-variable constant_\"\u003eLATITUDE_FORMATTER\u003c/span\u003e\nplt.\u003cspan class=\"hljs-title function_\"\u003eshow\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_5.png\" alt=\"결과 이미지\"\u003e\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e위 그림에 나타난 정규 그리드에 대해 보간을 수행하는 것이 목표입니다. 이 그리드에는 8개의 온도 관측치가 있습니다.\u003c/p\u003e\n\u003ch1\u003eI. 최근접 이웃 (NN)\u003c/h1\u003e\n\u003cp\u003e가장 직관적이고 간단한 방법 중 하나인 Nearest Neighbor (NN)에 대해 이야기하겠습니다. 이름에서 알 수 있듯이, 이 알고리즘은 각 그리드 노드에 가장 가까운 관측치의 값을 할당합니다.\u003c/p\u003e\n\u003cp\u003e이를 구현하기 위해 필요한 함수는 두 가지뿐입니다. 첫 번째 함수는 유클리드 함수이며, 다음 공식을 사용하여 두 점 사이의 거리를 계산합니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_6.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003e두 번째는 NN 메소드 자체입니다. 관측값을 저장할 빈 배열을 만든 후, 모든 위도와 경도를 반복하면서 각 포인트에서 현재 그리드 노드까지의 거리를 계산하고 그 그리드 노드에 가장 가까운 관측값을 할당합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef 유클리드(x1, x2, y1, y2):\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e ((x1-x2)**\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e + (y1-y2)**\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e) ** \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e\n\ndef \u003cspan class=\"hljs-title function_\"\u003eNN\u003c/span\u003e(data, \u003cspan class=\"hljs-variable constant_\"\u003eLAT\u003c/span\u003e, \u003cspan class=\"hljs-variable constant_\"\u003eLON\u003c/span\u003e):\n  array = np.\u003cspan class=\"hljs-title function_\"\u003eempty\u003c/span\u003e((\u003cspan class=\"hljs-variable constant_\"\u003eLAT\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e], \u003cspan class=\"hljs-variable constant_\"\u003eLON\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]))\n\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i, lat \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eenumerate\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eLAT\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e j, lon \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eenumerate\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eLON\u003c/span\u003e):\n      idx = data.\u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e(lambda \u003cspan class=\"hljs-attr\"\u003erow\u003c/span\u003e: 유클리드(row.\u003cspan class=\"hljs-property\"\u003eLONGITUDE\u003c/span\u003e, lon, row.\u003cspan class=\"hljs-property\"\u003eLATITUDE\u003c/span\u003e, lat), axis=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eargmin\u003c/span\u003e() \n      array[i, j] = data.\u003cspan class=\"hljs-property\"\u003eloc\u003c/span\u003e[idx, \u003cspan class=\"hljs-string\"\u003e'TAVG'\u003c/span\u003e]\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e array\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e전체 아이디어는 이 한 줄에 있습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003eidx = data.apply(\u003cspan class=\"hljs-keyword\"\u003elambda\u003c/span\u003e row: Euclidean(row.LONGITUDE, lon, row.LATITUDE, lat), axis=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e).argmin()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e변수 data는 각 행이 하나의 기상 장비 사이트를 나타내는 판다 데이터프레임입니다. 따라서 for 루프에서 거리를 계산하고 최소 거리를 가진 사이트의 인덱스를 찾습니다.\u003c/p\u003e\n\u003cp\u003e이제 알고리즘을 실행하고 결과를 xarray 데이터셋으로 래핑해 봅시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003et2m = NN(df, LAT, LON)\nds = xr.Dataset(\n    {\u003cspan class=\"hljs-string\"\u003e'TAVG'\u003c/span\u003e: ([\u003cspan class=\"hljs-string\"\u003e'lat'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'lon'\u003c/span\u003e], t2m)},\n    coords={\u003cspan class=\"hljs-string\"\u003e'lat'\u003c/span\u003e: LAT, \u003cspan class=\"hljs-string\"\u003e'lon'\u003c/span\u003e: LON})\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이제 결과를 플로팅할 수 있습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_7.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e보기 좋지만, regionmask 라이브러리를 사용하여 스위스 매스크를 만들어 플롯을 더 보기 좋게 변경해 보겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eshape[\u003cspan class=\"hljs-string\"\u003e'new_column'\u003c/span\u003e] = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\nsw = shape.\u003cspan class=\"hljs-title function_\"\u003edissolve\u003c/span\u003e(by=\u003cspan class=\"hljs-string\"\u003e'new_column'\u003c/span\u003e)[\u003cspan class=\"hljs-string\"\u003e'geometry'\u003c/span\u003e]\nrg = regionmask.\u003cspan class=\"hljs-title function_\"\u003emask_3D_geopandas\u003c/span\u003e(sw, lon_or_obj=ds.\u003cspan class=\"hljs-property\"\u003elon\u003c/span\u003e, lat=ds.\u003cspan class=\"hljs-property\"\u003elat\u003c/span\u003e)\n\nfig, ax = plt.\u003cspan class=\"hljs-title function_\"\u003esubplots\u003c/span\u003e(subplot_kw=\u003cspan class=\"hljs-title function_\"\u003edict\u003c/span\u003e(projection=ccrs.\u003cspan class=\"hljs-title class_\"\u003ePlateCarree\u003c/span\u003e()), figsize=(\u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e))\n#shape.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(ax=ax, color=\u003cspan class=\"hljs-string\"\u003e'black'\u003c/span\u003e)\nds.\u003cspan class=\"hljs-title function_\"\u003ewhere\u003c/span\u003e(rg).\u003cspan class=\"hljs-property\"\u003eTAVG\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(ax=ax, alpha=\u003cspan class=\"hljs-number\"\u003e0.6\u003c/span\u003e)\ngdf.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(ax=ax, color=\u003cspan class=\"hljs-string\"\u003e'r'\u003c/span\u003e, markersize=\u003cspan class=\"hljs-number\"\u003e85\u003c/span\u003e)\nax.\u003cspan class=\"hljs-title function_\"\u003egridlines\u003c/span\u003e(draw_labels=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e, linewidth=\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'black'\u003c/span\u003e, alpha=\u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e, linestyle=\u003cspan class=\"hljs-string\"\u003e'--'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eshow\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cimg src=\"/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_8.png\"\u003e\n\u003cp\u003e보시다시피 이 방법은 범주형 데이터에만 적용될 수 있습니다. 우리가 다루는 것은 온도로, 이는 연속 변수로 어떤 범위 안에서 어떤 값이든 가질 수 있다는 것을 의미합니다. 이 보간은 혼동스러울 수 있습니다. 현실에서는 항상 그라데이션과 무작위성이 있습니다.\u003c/p\u003e\n\u003cp\u003e그래서 좀 더 고급 알고리즘을 살펴보겠습니다.\u003c/p\u003e\n\u003ch1\u003eII. 역 거리 가중 이동법 (IDW)\u003c/h1\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e기본적으로 역 거리 가중치(IDW)는 NN의 향상된 버전입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003eIDW\u003c/span\u003e(data, \u003cspan class=\"hljs-variable constant_\"\u003eLAT\u003c/span\u003e, \u003cspan class=\"hljs-variable constant_\"\u003eLON\u003c/span\u003e, betta=\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e):\n  array = np.\u003cspan class=\"hljs-title function_\"\u003eempty\u003c/span\u003e((\u003cspan class=\"hljs-variable constant_\"\u003eLAT\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e], \u003cspan class=\"hljs-variable constant_\"\u003eLON\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]))\n\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i, lat \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eenumerate\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eLAT\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e j, lon \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eenumerate\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eLON\u003c/span\u003e):\n      weights = data.\u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e(lambda \u003cspan class=\"hljs-attr\"\u003erow\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eEuclidean\u003c/span\u003e(row.\u003cspan class=\"hljs-property\"\u003eLONGITUDE\u003c/span\u003e, lon, row.\u003cspan class=\"hljs-property\"\u003eLATITUDE\u003c/span\u003e, lat)**(-betta), axis=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n      z = \u003cspan class=\"hljs-title function_\"\u003esum\u003c/span\u003e(weights*data.\u003cspan class=\"hljs-property\"\u003eTAVG\u003c/span\u003e)/weights.\u003cspan class=\"hljs-title function_\"\u003esum\u003c/span\u003e()\n      array[i,j] = z\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e array\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e가까운 알려진 점의 값을 할당하는 대신, 여기서는 가중치를 계산합니다. 그를 위해 앞서 언급한 유클리드 거리가 사용되지만, 이번에는 각 거리를 -β 승으로 제곱합니다 (β는 임의의 값입니다). 이러한 가중치는 각 지면 점이 특정 격자 노드에 미치는 기여를 나타냅니다. 거리가 멀수록 이 점이 노드 값에 미치는 영향이 적어집니다.\u003c/p\u003e\n\u003cp\u003e가중치를 얻은 후 가중 평균을 계산합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_9.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_10.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003eLet’s plot it:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_11.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e보시는 대로, 지금 결과가 훨씬 현실적이고 부드럽습니다!\u003c/p\u003e\n\u003ch2\u003eIII. 크리징\u003c/h2\u003e\n\u003cp\u003e오늘의 마지막 메서드는 크리징입니다. 이 세 가지 방법 중에서 가장 복잡한 방법 중 하나이며, 우리는 간단히 알아볼 것입니다. 의식적이고 효과적으로 사용하고 싶다면 문헌을 살펴볼 것을 고려해보세요!\u003c/p\u003e\n\u003cp\u003e그러므로 이 방법의 주요 아이디어는 바리오그램(또는 세미바리오그램)을 사용하는 것입니다. 본질적으로 바리오그램은 어떤 매개변수의 변이가 거리와 방향에 따라 어떻게 변하는지를 측정합니다. 이것이 바로 우리가 공기 온도를 다룰 때 필요한 부분입니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e크리징 알고리즘을 구현하려면 두 가지 유형의 변이로그램이 필요합니다: 실험적 변이로그램과 이론적 변이로그램입니다.\u003c/p\u003e\n\u003cp\u003e첫 번째는 정말 쉽게 계산할 수 있습니다. 감마 γ로 정의됩니다:\u003c/p\u003e\n\u003cp\u003e[ \\gamma(h) = \\frac{1}{2N(h)}\\sum_{i=1}^{N(h)}[z(x_i) - z(x_i + h)]^2 ]\u003c/p\u003e\n\u003cp\u003e여기서,\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e( h )는 두 점 사이의 지리적 거리,\u003c/li\u003e\n\u003cli\u003e(z)는 온도 함수입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e간단히 말해 이것은 알려진 점에서 온도 차이의 평균입니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이론적 변이그램은 다소 복잡합니다. 먼저, 그런것이 많이 있습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_13.png\" alt=\"Variogram\"\u003e\u003c/p\u003e\n\u003cp\u003e여기서 p는 부분 재, d는 거리(h를 사용했었죠), n은 극소값, r은 범위를 나타냅니다.\u003c/p\u003e\n\u003cp\u003eCDT 콜롬비아에서 이러한 매개변수에 대한 정말 좋은 시각적 설명을 찾았어요. 저는 그들의 자료에서 γ와 거리 사이의 관계를 설명하는 이미지를 채택했습니다. 이제는 sill, partial sill, nugget 및 range가 무엇인지 명확해 보입니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_14.png\" alt=\"Spatial Interpolation Method\"\u003e\u003c/p\u003e\n\u003cp\u003e알고리즘의 전체 아이디어는 이론적 변이그램의 매개변수를 조정하여 실험적인 것에 맞게 맞추고, 그것을 사용하여 노드의 값을 예측하는 것입니다.\u003c/p\u003e\n\u003cp\u003e이 방법을 구현하려면 몇 가지 추가 라이브러리가 필요하며 OrdinaryKriging이라는 클래스를 생성해야합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e scipy.linalg \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e solve\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e itertools \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e product\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e sklearn.metrics \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e mean_squared_error \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e MSE\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eOrdinaryKriging\u003c/span\u003e:\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, lats, lons, values\u003c/span\u003e):\n        self.lats = lats\n        self.lons= lons\n        self.values = values\n\n        self.nugget_values = [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e]\n        self.sill_values = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e]\n        self.range_values = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e]\n\n        \u003cspan class=\"hljs-comment\"\u003e# 모수 값을 맞추기 위한 모든 조합 생성\u003c/span\u003e\n        self.parameter_combinations = \u003cspan class=\"hljs-built_in\"\u003elist\u003c/span\u003e(product(self.nugget_values, self.sill_values, self.range_values))\n        self.optimal_pars = \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etheoretical_variogram\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, h, nugget, sill, r\u003c/span\u003e):\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e nugget + (sill-nugget) * (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e-np.exp(-\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e*h/r))\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eEuclidean\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, X, Y\u003c/span\u003e):\n        all_dists, point_dists = [], []\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e x,y \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ezip\u003c/span\u003e(X, Y):\n          k = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n          \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e k \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(X)):\n            h = np.linalg.norm(np.array([x, y]) - np.array([X[k], Y[k]))\n            point_dists.append(h)\n          all_dists.append(point_dists)\n          point_dists = []\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e all_dists\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egamma\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e):\n        distances = self.Euclidean(self.lats, self.lons)\n        differences = np.\u003cspan class=\"hljs-built_in\"\u003eabs\u003c/span\u003e(self.values.reshape(-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) - self.values)\n        variogram_values = []\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e h \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e np.unique(distances):\n            values_at_h = differences[(distances == h)]\n            variogram_values.append(np.mean(values_at_h**\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e))\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e variogram_values, np.unique(distances)\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e):\n        experimental_variogram, distances = self.gamma()\n        fit_metrics = []\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e nugget, sill, range_ \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e self.parameter_combinations:\n            theoretical_variogram_values = self.theoretical_variogram(distances, nugget, sill, range_)\n            fit_metric = MSE(experimental_variogram, theoretical_variogram_values)\n            fit_metrics.append((nugget, sill, range_, fit_metric))\n\n        self.optimal_pars = \u003cspan class=\"hljs-built_in\"\u003emin\u003c/span\u003e(fit_metrics, key=\u003cspan class=\"hljs-keyword\"\u003elambda\u003c/span\u003e x: x[\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e])[:\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e]\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003epredict\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, point\u003c/span\u003e):\n        points = np.array([(x,y) \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e x,y \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ezip\u003c/span\u003e(self.lats, self.lons)])\n        distances = np.linalg.norm(points - point, axis=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n        pars = \u003cspan class=\"hljs-built_in\"\u003elist\u003c/span\u003e(self.optimal_pars)\n        pars.insert(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, distances)\n        weights = self.theoretical_variogram(*pars)\n        weights /= np.\u003cspan class=\"hljs-built_in\"\u003esum\u003c/span\u003e(weights)\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e np.dot(weights, self.values)\n\nkriging = OrdinaryKriging(df.LATITUDE.values, df.LONGITUDE.values, df.TAVG.values)\n\nkriging.fit()\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이제 각 함수를 따로 살펴봅시다.\n\u003cstrong\u003einit\u003c/strong\u003e 함수는 좌표와 값의 초기화 외에 nugget, sill, range의 가능한 값으로 구성된 세 개의 리스트를 포함합니다. 모든 가능한 조합으로 섞어서 parameter_combinations 변수에 저장됩니다. 우리는 나중에 최적 값을 찾을 때 필요할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, lats, lons, values\u003c/span\u003e):\n        self.lats = lats\n        self.lons= lons\n        self.values = values\n\n        self.nugget_values = [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e]\n        self.sill_values = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e]\n        self.range_values = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e]\n\n        \u003cspan class=\"hljs-comment\"\u003e# 맞추기 위한 모든 파라미터 값 조합 생성\u003c/span\u003e\n        self.parameter_combinations = \u003cspan class=\"hljs-built_in\"\u003elist\u003c/span\u003e(product(self.nugget_values, self.sill_values, self.range_values))\n        self.optimal_pars = \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e두 번째 함수인 theoretical_variogram은 이전에 언급된 공식 중 하나를 파이썬으로 구현한 것에 불과합니다. 여기서는 지수 함수입니다 (하지만 다른 함수에 대한 코드를 작성하여 결과를 비교할 수도 있습니다):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etheoretical_variogram\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, h, nugget, sill, r\u003c/span\u003e):\n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e nugget + (sill-nugget) * (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e-np.exp(-\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e*h/r))\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e세 번째 클래스 메서드는 유클리디안입니다. 이것은 NN과 IDW를 위해 만든 함수의 변경된 버전입니다. 이번에는 점과 모든 다른 점 사이의 거리를 나타내는 (n,n) 행렬을 반환합니다 (각 행에서 하나의 값은 0이며, 점과 그 자신 사이의 거리는 0입니다).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title class_\"\u003eEuclidean\u003c/span\u003e(self, X, Y):\n        all_dists, point_dists = [], []\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e x, y \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ezip\u003c/span\u003e(X, Y):\n          k = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n          \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e k \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(X)):\n            h = np.\u003cspan class=\"hljs-property\"\u003elinalg\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enorm\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e([x, y]) - np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e([X[k], Y[k]))\n            point_dists.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(h)\n          all_dists.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(point_dists)\n          point_dists = []\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e all_dists\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e네 번째 함수는 fitting을 수행합니다. 여기서는 실험적 변리오그램 값과 유클리디안 거리를 얻습니다. 그런 다음 sill, range 및 nugget의 조합을 반복하면서 이론적 변리오그램 값과 실험적 값 사이의 평균 제곱 오차(Mean Squared Error, MSE) 추정을 계산합니다 (다른 메트릭을 사용할 수도 있습니다). 그런 다음 최적의 매개변수를 클래스 변수 optimal_pars에 저장합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003efit\u003c/span\u003e(self):\n        experimental_variogram, distances = self.\u003cspan class=\"hljs-title function_\"\u003egamma\u003c/span\u003e()\n        fit_metrics = []\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e nugget, sill, range_ \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e self.\u003cspan class=\"hljs-property\"\u003eparameter_combinations\u003c/span\u003e:\n            theoretical_variogram_values = self.\u003cspan class=\"hljs-title function_\"\u003etheoretical_variogram\u003c/span\u003e(distances, nugget, sill, range_)\n            fit_metric = \u003cspan class=\"hljs-title function_\"\u003eMSE\u003c/span\u003e(experimental_variogram, theoretical_variogram_values)\n            fit_metrics.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e((nugget, sill, range_, fit_metric))\n\n        self.\u003cspan class=\"hljs-property\"\u003eoptimal_pars\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003emin\u003c/span\u003e(fit_metrics, key=lambda \u003cspan class=\"hljs-attr\"\u003ex\u003c/span\u003e: x[\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e])[:\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e마지막으로 가장 중요한 함수는 예측입니다. 입력으로 점 (lat;lon)을 받아서 해당 점과 다른 알려진 값들 사이의 거리를 추정합니다. 그런 다음, 앞서 얻은 최적 파라미터를 전달하여 이론적 변이그램 함수를 호출하고 가중치를 출력값으로 받습니다. 그런 다음 가중 평균을 계산하고 반환합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003epredict\u003c/span\u003e(self, point):\n        points = np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e([(x,y) \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e x,y \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ezip\u003c/span\u003e(self.\u003cspan class=\"hljs-property\"\u003elats\u003c/span\u003e, self.\u003cspan class=\"hljs-property\"\u003elons\u003c/span\u003e)])\n        distances = np.\u003cspan class=\"hljs-property\"\u003elinalg\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enorm\u003c/span\u003e(points - point, axis=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n        pars = \u003cspan class=\"hljs-title function_\"\u003elist\u003c/span\u003e(self.\u003cspan class=\"hljs-property\"\u003eoptimal_pars\u003c/span\u003e)\n        pars.\u003cspan class=\"hljs-title function_\"\u003einsert\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, distances)\n        weights = self.\u003cspan class=\"hljs-title function_\"\u003etheoretical_variogram\u003c/span\u003e(*pars)\n        weights /= np.\u003cspan class=\"hljs-title function_\"\u003esum\u003c/span\u003e(weights)\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e np.\u003cspan class=\"hljs-title function_\"\u003edot\u003c/span\u003e(weights, self.\u003cspan class=\"hljs-property\"\u003evalues\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 모든 예측값을 수집하고 지도를 시각화할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003erow, grid = [], []\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e lat \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eLAT\u003c/span\u003e:\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e lon \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eLON\u003c/span\u003e:\n    row.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(kriging.\u003cspan class=\"hljs-title function_\"\u003epredict\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e([lat, lon])))\n  grid.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(row)\n  row=[]\n\nds = xr.\u003cspan class=\"hljs-title class_\"\u003eDataset\u003c/span\u003e(\n    {\u003cspan class=\"hljs-string\"\u003e'TAVG'\u003c/span\u003e: ([\u003cspan class=\"hljs-string\"\u003e'lat'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'lon'\u003c/span\u003e], grid)},\n    coords={\u003cspan class=\"hljs-string\"\u003e'lat'\u003c/span\u003e: \u003cspan class=\"hljs-variable constant_\"\u003eLAT\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'lon'\u003c/span\u003e: \u003cspan class=\"hljs-variable constant_\"\u003eLON\u003c/span\u003e})\n\nfig, ax = plt.\u003cspan class=\"hljs-title function_\"\u003esubplots\u003c/span\u003e(subplot_kw=\u003cspan class=\"hljs-title function_\"\u003edict\u003c/span\u003e(projection=ccrs.\u003cspan class=\"hljs-title class_\"\u003ePlateCarree\u003c/span\u003e()), figsize=(\u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e))\nds.\u003cspan class=\"hljs-title function_\"\u003ewhere\u003c/span\u003e(rg).\u003cspan class=\"hljs-property\"\u003eTAVG\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(ax=ax, alpha=\u003cspan class=\"hljs-number\"\u003e0.6\u003c/span\u003e)\ngdf.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(ax=ax, color=\u003cspan class=\"hljs-string\"\u003e'r'\u003c/span\u003e, markersize=\u003cspan class=\"hljs-number\"\u003e85\u003c/span\u003e)\nax.\u003cspan class=\"hljs-title function_\"\u003egridlines\u003c/span\u003e(draw_labels=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e,linewidth=\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'black'\u003c/span\u003e, alpha=\u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e, linestyle=\u003cspan class=\"hljs-string\"\u003e'--'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eshow\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-09-3PopularMethodsforSpatialInterpolation_15.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e위와 같이 결과가 IDW에서 얻은 것과는 꽤 다르다는 것을 알 수 있어요. 크리깅에서 가장 중요한 매개변수는 선택한 이론적 변이그램 종류인데, 이는 사실 상 예측된 값과 거리 간의 관계를 정의합니다. 코드를 사용하기 귀찮으시거나 직접 작성하고 싶지 않다면 많은 변이그램 모델의 구현을 갖고 있는 PyKrige 라이브러리를 살펴보세요.\u003c/p\u003e\n\u003cp\u003e이 글이 유익하고 통찰력을 줬으면 좋겠어요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e저의 Medium에 올린 모든 게시물은 무료로 공개되어 있습니다. 그래서 여기서 제를 팔로우해 주실 경우 정말 감사하겠습니다!\u003c/p\u003e\n\u003cp\u003e참고로, 저는 (지리)데이터 과학, 기계학습/인공지능, 그리고 기후 변화에 대해 열정적으로 공부하고 있습니다. 만약 함께 프로젝트를 진행하고 싶다면 LinkedIn에서 연락 주세요.\u003c/p\u003e\n\u003cp\u003e🛰️더 많은 소식을 위해 팔로우 해주세요🛰️\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-09-3PopularMethodsforSpatialInterpolation"},"buildId":"OY-qm1-_Mz9jLZ5863EbF","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>