<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Yang-Zhang 방법으로 정확한 변동성 추정하기 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Yang-Zhang 방법으로 정확한 변동성 추정하기 | TIL" data-gatsby-head="true"/><meta property="og:title" content="Yang-Zhang 방법으로 정확한 변동성 추정하기 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator" data-gatsby-head="true"/><meta name="twitter:title" content="Yang-Zhang 방법으로 정확한 변동성 추정하기 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-12 19:34" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-5ecfd58aae5a7e3d.js" defer=""></script><script src="/TIL/_next/static/jKAIrnIuHBv4ZHjiQbX6i/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/jKAIrnIuHBv4ZHjiQbX6i/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Yang-Zhang 방법으로 정확한 변동성 추정하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Yang-Zhang 방법으로 정확한 변동성 추정하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 12, 2024</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_0.png" alt="Yang-Zhang volatility estimator"></p>
<p>양-장 변동성 추정자는 초고값 점프나 밤사이 갭을 가진 자산에 특히 유용한 역사적 변동성 측정값입니다. 이 추정자는 이전 게시된 로젤스-사첼과 가만-클라스 추정자의 장점을 결합해 단순한 변동성 측정값에서 발생하는 편향과 오류를 줄이도록 설계되었습니다.</p>
<p>이 기사에서는 이 변동성 측정치를 자세히 소개하고, 파이썬을 사용하여 시계열에 대한 롤링 계산 코드를 어떻게 작성하는지 보여줍니다.</p>
<h1>양-장 변동성 이해하기</h1>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>복잡한 변동성 모델에 대해 논의하기 전에, 항상 가장 기본적인 변동성 모델(또는 계산) 즉, 역사적 표준 편차에 대해 잘 이해하는 것이 좋습니다. 역사적 방법을 사용한 표준 편차는 금융 상품의 변동성을 측정하는 일반적인 방법으로, 과거 가격 데이터를 기반으로 합니다.</p>
<p>이는 일련의 값들의 변동이나 분산량을 정량화합니다. 금융에서는 일반적으로 일일 수익률이 그들의 평균 주변에서 얼마나 퍼져있는지를 측정합니다. 표준 편차를 계산하는 단계는 다음과 같습니다:</p>
<ul>
<li>차분(첫 번째 함수) 또는 로그 방법(두 번째 함수)을 사용하여 수익률을 계산합니다.</li>
</ul>
<p><img src="/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_1.png" alt="image"></p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_2.png" alt="이미지"></p>
<ul>
<li>수익률의 평균(평균)을 계산하세요:</li>
</ul>
<p><img src="/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_3.png" alt="이미지"></p>
<ul>
<li>일일 수익률의 분산을 계산하세요:</li>
</ul>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_4.png" alt="이미지"></p>
<ul>
<li>표준 편차는 분산의 제곱근이다:</li>
</ul>
<p><img src="/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_5.png" alt="이미지"></p>
<p>어떤 통계적 측정 값처럼 장단점이 있습니다. 역사적 표준 편차는 쉽게 계산할 수 있습니다. 스프레드시트 및 프로그래밍 언어에서 쉽게 구현할 수 있는 기본 통계 작업이 필요합니다. 변동성에 대한 공식적인 측정 방법으로 이해되며, 깊은 통계 배경을 갖지 않을 수 있는 이해관계자들에게 쉽게 설명할 수 있습니다. 많은 금융 모델 및 위험 지표(예: 샤프 비율)는 리스크 측정 값으로서 표준 편차를 의존합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>샘플 크기가 작은 경우, 역사적 표준 편차는 실제 변동성을 과소평가하는 경향이 있습니다. 이 편향은 자산의 리스크에 대한 잘못된 결론으로 이어질 수 있습니다. 이 방법은 분석 기간 동안 자산의 기저 변동성이 일정하다고 가정합니다. 실제로 변동성은 시간이 지남에 따라 변할 수 있으므로 이 가정은 현실적이지 않습니다.</p>
<p>게다가, 금융 수익은 종종 꼬리가 두꺼운 경향(leptokurtosis)과 비뚤림을 나타내며, 이는 정규 분포를 따르지 않음을 의미합니다. 표준 편차는 이러한 특성을 포착하지 못하며, 결과적으로 리스크를 과소평가할 수 있습니다.</p>
<p>Nvidia의 일일 수익에 대한 롤링 5일 변동성 측정치를 계산하기 위해 Python에서 다음 코드를 사용해보세요:</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">import</span> yfinance <span class="hljs-keyword">as</span> yf

<span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_rolling_historical_volatility</span>(<span class="hljs-params">data, window</span>):
    <span class="hljs-comment"># 수익률 계산 (차분 방법 사용)</span>
    returns = data[<span class="hljs-string">'Close'</span>] - data[<span class="hljs-string">'Close'</span>].shift(<span class="hljs-number">1</span>).dropna()
    
    <span class="hljs-comment"># 수익률의 롤링 표준 편차 계산</span>
    rolling_volatility = returns.rolling(window=window).std()
    
    <span class="hljs-comment"># 표준 편차 측정 값을 포함하는 변수 반환</span>
    <span class="hljs-keyword">return</span> rolling_volatility

<span class="hljs-comment"># Nvidia의 역사적 값 다운로드</span>
df = yf.download(<span class="hljs-string">"NVDA"</span>, start=<span class="hljs-string">"2022-01-01"</span>, end=<span class="hljs-string">"2024-06-30"</span>)

<span class="hljs-comment"># 롤링 윈도우 크기 정의</span>
window_size = <span class="hljs-number">5</span>

<span class="hljs-comment"># 공식 적용 및 변동성 데이터프레임 얻기</span>
rolling_volatility = calculate_rolling_historical_volatility(df, window=window_size)

<span class="hljs-comment"># 시간에 따른 변동성 플로팅</span>
plt.plot(rolling_volatility, color=<span class="hljs-string">'black'</span>, label=<span class="hljs-string">'5일 주기 역사적 표준 편차'</span>)
plt.legend()
plt.grid()
plt.axhline(y=np.mean(rolling_volatility), color=<span class="hljs-string">'red'</span>, linestyle=<span class="hljs-string">'dashed'</span>)
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Yang-Zhang 변동성 추정기는 Rogers-Satchell 및 Garman-Klass 추정기의 장점을 결합한 과거 변동성 측정치이다. 이는 특히 고개를 넘는 높은 가격 변동이나 야간 갭이 있는 자산에 유용하다. 이 추정기는 더 간단한 변동성 추정기에 존재하는 편향 및 오차를 줄이도록 설계되었다.</p>
<p>Yang-Zhang 변동성 추정기는 다음 공식을 사용하여 계산된다:</p>
<p><img src="/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_6.png" alt="equation"></p>
<p>참고:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<img src="/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_7.png">
<p>첫 번째 표준 편차 용어는 open-close 변동성을 나타내고, 두 번째는 close-close 변동성을 나타내며, 세 번째는 Rogers-Satchell 변동성 추정값입니다.</p>
<p>K factor는 open-close 변동성과 close-close 변동성의 기여도를 균형 있게 조정하며, 표본 크기 n에 대한 보정을 합니다. 양-장(Estimators) 추정자는 다른 추정자들과 비교하여 개시 가격의 급등과 종가 변동에 덜 민감하며, 상당한 야간 갭을 경험하는 자산에 대해 더 견고합니다.</p>
<p>더 많은 작업을 보려면, 그림에 첨부된 링크를 따라 가면 PDF 책 카탈로그를 찾을 수 있는 제 웹사이트를 방문해주세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_8.png" alt="image"></p>
<h1>Python에서 Yang-Zhang 변동성 계산하기</h1>
<p>이제 Python을 사용하여 Yang-Zhang 변동성을 계산해 보겠습니다. 같은 예시를 사용할 것입니다 (즉, lookback 기간이 5인 Nvidia의 일일 수익률):</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">import</span> yfinance <span class="hljs-keyword">as</span> yf
<span class="hljs-keyword">import</span> math

<span class="hljs-keyword">def</span> <span class="hljs-title function_">yang_zhang</span>(<span class="hljs-params">price_data, window_size=<span class="hljs-number">30</span>, periods=<span class="hljs-number">252</span>, clean=<span class="hljs-literal">True</span></span>):

    log_ho = (price_data[<span class="hljs-string">"High"</span>] / price_data[<span class="hljs-string">"Open"</span>]).apply(np.log)
    log_lo = (price_data[<span class="hljs-string">"Low"</span>] / price_data[<span class="hljs-string">"Open"</span>]).apply(np.log)
    log_co = (price_data[<span class="hljs-string">"Close"</span>] / price_data[<span class="hljs-string">"Open"</span>]).apply(np.log)

    log_oc = (price_data[<span class="hljs-string">"Open"</span>] / price_data[<span class="hljs-string">"Close"</span>].shift(<span class="hljs-number">1</span>)).apply(np.log)
    log_oc_sq = log_oc ** <span class="hljs-number">2</span>

    log_cc = (price_data[<span class="hljs-string">"Close"</span>] / price_data[<span class="hljs-string">"Close"</span>].shift(<span class="hljs-number">1</span>)).apply(np.log)
    log_cc_sq = log_cc ** <span class="hljs-number">2</span>

    rs = log_ho * (log_ho - log_co) + log_lo * (log_lo - log_co)

    close_vol = log_cc_sq.rolling(window=window_size, center=<span class="hljs-literal">False</span>).<span class="hljs-built_in">sum</span>() * (
        <span class="hljs-number">1.0</span> / (window_size - <span class="hljs-number">1.0</span>)
    )
    open_vol = log_oc_sq.rolling(window=window_size, center=<span class="hljs-literal">False</span>).<span class="hljs-built_in">sum</span>() * (
        <span class="hljs-number">1.0</span> / (window_size - <span class="hljs-number">1.0</span>)
    )
    window_rs = rs.rolling(window=window_size, center=<span class="hljs-literal">False</span>).<span class="hljs-built_in">sum</span>() * (<span class="hljs-number">1.0</span> / (window_size - <span class="hljs-number">1.0</span>))

    k = <span class="hljs-number">0.34</span> / (<span class="hljs-number">1.34</span> + (window_size + <span class="hljs-number">1</span>) / (window_size - <span class="hljs-number">1</span>))
    result = (open_vol + k * close_vol + (<span class="hljs-number">1</span> - k) * window_rs).apply(
        np.sqrt
    ) * math.sqrt(periods)

    <span class="hljs-keyword">if</span> clean:
        <span class="hljs-keyword">return</span> result.dropna()
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> result

<span class="hljs-comment"># Nvidia의 과거 값 다운로드</span>
df = yf.download(<span class="hljs-string">"NVDA"</span>, start=<span class="hljs-string">"2020-01-01"</span>, end=<span class="hljs-string">"2024-06-30"</span>)
<span class="hljs-comment"># Rolling window 크기 정의</span>
window_size = <span class="hljs-number">5</span>
<span class="hljs-comment"># 식 적용 및 변동성 데이터 프레임 가져오기</span>
rolling_volatility = yang_zhang(df)
<span class="hljs-comment"># 시간대별 변동성 플롯</span>
plt.plot(rolling_volatility, color=<span class="hljs-string">'black'</span>, label=<span class="hljs-string">'5-period Yang-Zhang 변동성'</span>)
plt.legend()
plt.grid()
plt.axhline(y=np.mean(rolling_volatility), color=<span class="hljs-string">'red'</span>, linestyle=<span class="hljs-string">'dashed)
</span></code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_9.png" alt="이미지"></p>
<p>과거 표준 편차는 변동성의 유용하고 널리 채택된 측정 방법이며, 간단함, 계산의 용이성 및 금융 산업에서의 일반적인 수용으로 인해 가치가 있습니다. 그러나 작은 표본 크기, 비정상적 변동성 및 수익의 비정규 분포를 처리하는 데 있어서 특히 한계가 있어 조심해서 사용해야 합니다.</p>
<p>정확성이 중요하거나 표본 크기가 작은 경우, 대안적인 변동성 모델이 더 나은 리스크 평가를 제공할 수 있습니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Yang-Zhang 방법으로 정확한 변동성 추정하기","description":"","date":"2024-07-12 19:34","slug":"2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator","content":"\n\n\n![Yang-Zhang volatility estimator](/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_0.png)\n\n양-장 변동성 추정자는 초고값 점프나 밤사이 갭을 가진 자산에 특히 유용한 역사적 변동성 측정값입니다. 이 추정자는 이전 게시된 로젤스-사첼과 가만-클라스 추정자의 장점을 결합해 단순한 변동성 측정값에서 발생하는 편향과 오류를 줄이도록 설계되었습니다.\n\n이 기사에서는 이 변동성 측정치를 자세히 소개하고, 파이썬을 사용하여 시계열에 대한 롤링 계산 코드를 어떻게 작성하는지 보여줍니다.\n\n# 양-장 변동성 이해하기\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n복잡한 변동성 모델에 대해 논의하기 전에, 항상 가장 기본적인 변동성 모델(또는 계산) 즉, 역사적 표준 편차에 대해 잘 이해하는 것이 좋습니다. 역사적 방법을 사용한 표준 편차는 금융 상품의 변동성을 측정하는 일반적인 방법으로, 과거 가격 데이터를 기반으로 합니다.\n\n이는 일련의 값들의 변동이나 분산량을 정량화합니다. 금융에서는 일반적으로 일일 수익률이 그들의 평균 주변에서 얼마나 퍼져있는지를 측정합니다. 표준 편차를 계산하는 단계는 다음과 같습니다:\n\n- 차분(첫 번째 함수) 또는 로그 방법(두 번째 함수)을 사용하여 수익률을 계산합니다.\n\n![image](/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_1.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![이미지](/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_2.png)\n\n- 수익률의 평균(평균)을 계산하세요:\n\n![이미지](/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_3.png)\n\n- 일일 수익률의 분산을 계산하세요:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![이미지](/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_4.png)\n\n- 표준 편차는 분산의 제곱근이다:\n\n![이미지](/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_5.png)\n\n어떤 통계적 측정 값처럼 장단점이 있습니다. 역사적 표준 편차는 쉽게 계산할 수 있습니다. 스프레드시트 및 프로그래밍 언어에서 쉽게 구현할 수 있는 기본 통계 작업이 필요합니다. 변동성에 대한 공식적인 측정 방법으로 이해되며, 깊은 통계 배경을 갖지 않을 수 있는 이해관계자들에게 쉽게 설명할 수 있습니다. 많은 금융 모델 및 위험 지표(예: 샤프 비율)는 리스크 측정 값으로서 표준 편차를 의존합니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n샘플 크기가 작은 경우, 역사적 표준 편차는 실제 변동성을 과소평가하는 경향이 있습니다. 이 편향은 자산의 리스크에 대한 잘못된 결론으로 이어질 수 있습니다. 이 방법은 분석 기간 동안 자산의 기저 변동성이 일정하다고 가정합니다. 실제로 변동성은 시간이 지남에 따라 변할 수 있으므로 이 가정은 현실적이지 않습니다.\n\n게다가, 금융 수익은 종종 꼬리가 두꺼운 경향(leptokurtosis)과 비뚤림을 나타내며, 이는 정규 분포를 따르지 않음을 의미합니다. 표준 편차는 이러한 특성을 포착하지 못하며, 결과적으로 리스크를 과소평가할 수 있습니다.\n\nNvidia의 일일 수익에 대한 롤링 5일 변동성 측정치를 계산하기 위해 Python에서 다음 코드를 사용해보세요:\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport yfinance as yf\n\ndef calculate_rolling_historical_volatility(data, window):\n    # 수익률 계산 (차분 방법 사용)\n    returns = data['Close'] - data['Close'].shift(1).dropna()\n    \n    # 수익률의 롤링 표준 편차 계산\n    rolling_volatility = returns.rolling(window=window).std()\n    \n    # 표준 편차 측정 값을 포함하는 변수 반환\n    return rolling_volatility\n\n# Nvidia의 역사적 값 다운로드\ndf = yf.download(\"NVDA\", start=\"2022-01-01\", end=\"2024-06-30\")\n\n# 롤링 윈도우 크기 정의\nwindow_size = 5\n\n# 공식 적용 및 변동성 데이터프레임 얻기\nrolling_volatility = calculate_rolling_historical_volatility(df, window=window_size)\n\n# 시간에 따른 변동성 플로팅\nplt.plot(rolling_volatility, color='black', label='5일 주기 역사적 표준 편차')\nplt.legend()\nplt.grid()\nplt.axhline(y=np.mean(rolling_volatility), color='red', linestyle='dashed')\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nYang-Zhang 변동성 추정기는 Rogers-Satchell 및 Garman-Klass 추정기의 장점을 결합한 과거 변동성 측정치이다. 이는 특히 고개를 넘는 높은 가격 변동이나 야간 갭이 있는 자산에 유용하다. 이 추정기는 더 간단한 변동성 추정기에 존재하는 편향 및 오차를 줄이도록 설계되었다.\n\nYang-Zhang 변동성 추정기는 다음 공식을 사용하여 계산된다:\n\n![equation](/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_6.png)\n\n참고:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_7.png\" /\u003e\n\n첫 번째 표준 편차 용어는 open-close 변동성을 나타내고, 두 번째는 close-close 변동성을 나타내며, 세 번째는 Rogers-Satchell 변동성 추정값입니다.\n\nK factor는 open-close 변동성과 close-close 변동성의 기여도를 균형 있게 조정하며, 표본 크기 n에 대한 보정을 합니다. 양-장(Estimators) 추정자는 다른 추정자들과 비교하여 개시 가격의 급등과 종가 변동에 덜 민감하며, 상당한 야간 갭을 경험하는 자산에 대해 더 견고합니다.\n\n더 많은 작업을 보려면, 그림에 첨부된 링크를 따라 가면 PDF 책 카탈로그를 찾을 수 있는 제 웹사이트를 방문해주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_8.png)\n\n# Python에서 Yang-Zhang 변동성 계산하기\n\n이제 Python을 사용하여 Yang-Zhang 변동성을 계산해 보겠습니다. 같은 예시를 사용할 것입니다 (즉, lookback 기간이 5인 Nvidia의 일일 수익률):\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport yfinance as yf\nimport math\n\ndef yang_zhang(price_data, window_size=30, periods=252, clean=True):\n\n    log_ho = (price_data[\"High\"] / price_data[\"Open\"]).apply(np.log)\n    log_lo = (price_data[\"Low\"] / price_data[\"Open\"]).apply(np.log)\n    log_co = (price_data[\"Close\"] / price_data[\"Open\"]).apply(np.log)\n\n    log_oc = (price_data[\"Open\"] / price_data[\"Close\"].shift(1)).apply(np.log)\n    log_oc_sq = log_oc ** 2\n\n    log_cc = (price_data[\"Close\"] / price_data[\"Close\"].shift(1)).apply(np.log)\n    log_cc_sq = log_cc ** 2\n\n    rs = log_ho * (log_ho - log_co) + log_lo * (log_lo - log_co)\n\n    close_vol = log_cc_sq.rolling(window=window_size, center=False).sum() * (\n        1.0 / (window_size - 1.0)\n    )\n    open_vol = log_oc_sq.rolling(window=window_size, center=False).sum() * (\n        1.0 / (window_size - 1.0)\n    )\n    window_rs = rs.rolling(window=window_size, center=False).sum() * (1.0 / (window_size - 1.0))\n\n    k = 0.34 / (1.34 + (window_size + 1) / (window_size - 1))\n    result = (open_vol + k * close_vol + (1 - k) * window_rs).apply(\n        np.sqrt\n    ) * math.sqrt(periods)\n\n    if clean:\n        return result.dropna()\n    else:\n        return result\n\n# Nvidia의 과거 값 다운로드\ndf = yf.download(\"NVDA\", start=\"2020-01-01\", end=\"2024-06-30\")\n# Rolling window 크기 정의\nwindow_size = 5\n# 식 적용 및 변동성 데이터 프레임 가져오기\nrolling_volatility = yang_zhang(df)\n# 시간대별 변동성 플롯\nplt.plot(rolling_volatility, color='black', label='5-period Yang-Zhang 변동성')\nplt.legend()\nplt.grid()\nplt.axhline(y=np.mean(rolling_volatility), color='red', linestyle='dashed)\n```\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_9.png)\n\n과거 표준 편차는 변동성의 유용하고 널리 채택된 측정 방법이며, 간단함, 계산의 용이성 및 금융 산업에서의 일반적인 수용으로 인해 가치가 있습니다. 그러나 작은 표본 크기, 비정상적 변동성 및 수익의 비정규 분포를 처리하는 데 있어서 특히 한계가 있어 조심해서 사용해야 합니다.\n\n정확성이 중요하거나 표본 크기가 작은 경우, 대안적인 변동성 모델이 더 나은 리스크 평가를 제공할 수 있습니다.","ogImage":{"url":"/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_0.png","tag":["Tech"],"readingTime":8},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_0.png\" alt=\"Yang-Zhang volatility estimator\"\u003e\u003c/p\u003e\n\u003cp\u003e양-장 변동성 추정자는 초고값 점프나 밤사이 갭을 가진 자산에 특히 유용한 역사적 변동성 측정값입니다. 이 추정자는 이전 게시된 로젤스-사첼과 가만-클라스 추정자의 장점을 결합해 단순한 변동성 측정값에서 발생하는 편향과 오류를 줄이도록 설계되었습니다.\u003c/p\u003e\n\u003cp\u003e이 기사에서는 이 변동성 측정치를 자세히 소개하고, 파이썬을 사용하여 시계열에 대한 롤링 계산 코드를 어떻게 작성하는지 보여줍니다.\u003c/p\u003e\n\u003ch1\u003e양-장 변동성 이해하기\u003c/h1\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e복잡한 변동성 모델에 대해 논의하기 전에, 항상 가장 기본적인 변동성 모델(또는 계산) 즉, 역사적 표준 편차에 대해 잘 이해하는 것이 좋습니다. 역사적 방법을 사용한 표준 편차는 금융 상품의 변동성을 측정하는 일반적인 방법으로, 과거 가격 데이터를 기반으로 합니다.\u003c/p\u003e\n\u003cp\u003e이는 일련의 값들의 변동이나 분산량을 정량화합니다. 금융에서는 일반적으로 일일 수익률이 그들의 평균 주변에서 얼마나 퍼져있는지를 측정합니다. 표준 편차를 계산하는 단계는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e차분(첫 번째 함수) 또는 로그 방법(두 번째 함수)을 사용하여 수익률을 계산합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_1.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e수익률의 평균(평균)을 계산하세요:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e일일 수익률의 분산을 계산하세요:\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_4.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e표준 편차는 분산의 제곱근이다:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_5.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e어떤 통계적 측정 값처럼 장단점이 있습니다. 역사적 표준 편차는 쉽게 계산할 수 있습니다. 스프레드시트 및 프로그래밍 언어에서 쉽게 구현할 수 있는 기본 통계 작업이 필요합니다. 변동성에 대한 공식적인 측정 방법으로 이해되며, 깊은 통계 배경을 갖지 않을 수 있는 이해관계자들에게 쉽게 설명할 수 있습니다. 많은 금융 모델 및 위험 지표(예: 샤프 비율)는 리스크 측정 값으로서 표준 편차를 의존합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e샘플 크기가 작은 경우, 역사적 표준 편차는 실제 변동성을 과소평가하는 경향이 있습니다. 이 편향은 자산의 리스크에 대한 잘못된 결론으로 이어질 수 있습니다. 이 방법은 분석 기간 동안 자산의 기저 변동성이 일정하다고 가정합니다. 실제로 변동성은 시간이 지남에 따라 변할 수 있으므로 이 가정은 현실적이지 않습니다.\u003c/p\u003e\n\u003cp\u003e게다가, 금융 수익은 종종 꼬리가 두꺼운 경향(leptokurtosis)과 비뚤림을 나타내며, 이는 정규 분포를 따르지 않음을 의미합니다. 표준 편차는 이러한 특성을 포착하지 못하며, 결과적으로 리스크를 과소평가할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eNvidia의 일일 수익에 대한 롤링 5일 변동성 측정치를 계산하기 위해 Python에서 다음 코드를 사용해보세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e numpy \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e np\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e matplotlib.pyplot \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e plt\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e yfinance \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e yf\n\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecalculate_rolling_historical_volatility\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edata, window\u003c/span\u003e):\n    \u003cspan class=\"hljs-comment\"\u003e# 수익률 계산 (차분 방법 사용)\u003c/span\u003e\n    returns = data[\u003cspan class=\"hljs-string\"\u003e'Close'\u003c/span\u003e] - data[\u003cspan class=\"hljs-string\"\u003e'Close'\u003c/span\u003e].shift(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e).dropna()\n    \n    \u003cspan class=\"hljs-comment\"\u003e# 수익률의 롤링 표준 편차 계산\u003c/span\u003e\n    rolling_volatility = returns.rolling(window=window).std()\n    \n    \u003cspan class=\"hljs-comment\"\u003e# 표준 편차 측정 값을 포함하는 변수 반환\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e rolling_volatility\n\n\u003cspan class=\"hljs-comment\"\u003e# Nvidia의 역사적 값 다운로드\u003c/span\u003e\ndf = yf.download(\u003cspan class=\"hljs-string\"\u003e\"NVDA\"\u003c/span\u003e, start=\u003cspan class=\"hljs-string\"\u003e\"2022-01-01\"\u003c/span\u003e, end=\u003cspan class=\"hljs-string\"\u003e\"2024-06-30\"\u003c/span\u003e)\n\n\u003cspan class=\"hljs-comment\"\u003e# 롤링 윈도우 크기 정의\u003c/span\u003e\nwindow_size = \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e# 공식 적용 및 변동성 데이터프레임 얻기\u003c/span\u003e\nrolling_volatility = calculate_rolling_historical_volatility(df, window=window_size)\n\n\u003cspan class=\"hljs-comment\"\u003e# 시간에 따른 변동성 플로팅\u003c/span\u003e\nplt.plot(rolling_volatility, color=\u003cspan class=\"hljs-string\"\u003e'black'\u003c/span\u003e, label=\u003cspan class=\"hljs-string\"\u003e'5일 주기 역사적 표준 편차'\u003c/span\u003e)\nplt.legend()\nplt.grid()\nplt.axhline(y=np.mean(rolling_volatility), color=\u003cspan class=\"hljs-string\"\u003e'red'\u003c/span\u003e, linestyle=\u003cspan class=\"hljs-string\"\u003e'dashed'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eYang-Zhang 변동성 추정기는 Rogers-Satchell 및 Garman-Klass 추정기의 장점을 결합한 과거 변동성 측정치이다. 이는 특히 고개를 넘는 높은 가격 변동이나 야간 갭이 있는 자산에 유용하다. 이 추정기는 더 간단한 변동성 추정기에 존재하는 편향 및 오차를 줄이도록 설계되었다.\u003c/p\u003e\n\u003cp\u003eYang-Zhang 변동성 추정기는 다음 공식을 사용하여 계산된다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_6.png\" alt=\"equation\"\u003e\u003c/p\u003e\n\u003cp\u003e참고:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_7.png\"\u003e\n\u003cp\u003e첫 번째 표준 편차 용어는 open-close 변동성을 나타내고, 두 번째는 close-close 변동성을 나타내며, 세 번째는 Rogers-Satchell 변동성 추정값입니다.\u003c/p\u003e\n\u003cp\u003eK factor는 open-close 변동성과 close-close 변동성의 기여도를 균형 있게 조정하며, 표본 크기 n에 대한 보정을 합니다. 양-장(Estimators) 추정자는 다른 추정자들과 비교하여 개시 가격의 급등과 종가 변동에 덜 민감하며, 상당한 야간 갭을 경험하는 자산에 대해 더 견고합니다.\u003c/p\u003e\n\u003cp\u003e더 많은 작업을 보려면, 그림에 첨부된 링크를 따라 가면 PDF 책 카탈로그를 찾을 수 있는 제 웹사이트를 방문해주세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_8.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch1\u003ePython에서 Yang-Zhang 변동성 계산하기\u003c/h1\u003e\n\u003cp\u003e이제 Python을 사용하여 Yang-Zhang 변동성을 계산해 보겠습니다. 같은 예시를 사용할 것입니다 (즉, lookback 기간이 5인 Nvidia의 일일 수익률):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e numpy \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e np\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e matplotlib.pyplot \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e plt\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e yfinance \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e yf\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e math\n\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eyang_zhang\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eprice_data, window_size=\u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e, periods=\u003cspan class=\"hljs-number\"\u003e252\u003c/span\u003e, clean=\u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e\u003c/span\u003e):\n\n    log_ho = (price_data[\u003cspan class=\"hljs-string\"\u003e\"High\"\u003c/span\u003e] / price_data[\u003cspan class=\"hljs-string\"\u003e\"Open\"\u003c/span\u003e]).apply(np.log)\n    log_lo = (price_data[\u003cspan class=\"hljs-string\"\u003e\"Low\"\u003c/span\u003e] / price_data[\u003cspan class=\"hljs-string\"\u003e\"Open\"\u003c/span\u003e]).apply(np.log)\n    log_co = (price_data[\u003cspan class=\"hljs-string\"\u003e\"Close\"\u003c/span\u003e] / price_data[\u003cspan class=\"hljs-string\"\u003e\"Open\"\u003c/span\u003e]).apply(np.log)\n\n    log_oc = (price_data[\u003cspan class=\"hljs-string\"\u003e\"Open\"\u003c/span\u003e] / price_data[\u003cspan class=\"hljs-string\"\u003e\"Close\"\u003c/span\u003e].shift(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)).apply(np.log)\n    log_oc_sq = log_oc ** \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\n\n    log_cc = (price_data[\u003cspan class=\"hljs-string\"\u003e\"Close\"\u003c/span\u003e] / price_data[\u003cspan class=\"hljs-string\"\u003e\"Close\"\u003c/span\u003e].shift(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)).apply(np.log)\n    log_cc_sq = log_cc ** \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\n\n    rs = log_ho * (log_ho - log_co) + log_lo * (log_lo - log_co)\n\n    close_vol = log_cc_sq.rolling(window=window_size, center=\u003cspan class=\"hljs-literal\"\u003eFalse\u003c/span\u003e).\u003cspan class=\"hljs-built_in\"\u003esum\u003c/span\u003e() * (\n        \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e / (window_size - \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e)\n    )\n    open_vol = log_oc_sq.rolling(window=window_size, center=\u003cspan class=\"hljs-literal\"\u003eFalse\u003c/span\u003e).\u003cspan class=\"hljs-built_in\"\u003esum\u003c/span\u003e() * (\n        \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e / (window_size - \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e)\n    )\n    window_rs = rs.rolling(window=window_size, center=\u003cspan class=\"hljs-literal\"\u003eFalse\u003c/span\u003e).\u003cspan class=\"hljs-built_in\"\u003esum\u003c/span\u003e() * (\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e / (window_size - \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e))\n\n    k = \u003cspan class=\"hljs-number\"\u003e0.34\u003c/span\u003e / (\u003cspan class=\"hljs-number\"\u003e1.34\u003c/span\u003e + (window_size + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) / (window_size - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e))\n    result = (open_vol + k * close_vol + (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - k) * window_rs).apply(\n        np.sqrt\n    ) * math.sqrt(periods)\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e clean:\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e result.dropna()\n    \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e result\n\n\u003cspan class=\"hljs-comment\"\u003e# Nvidia의 과거 값 다운로드\u003c/span\u003e\ndf = yf.download(\u003cspan class=\"hljs-string\"\u003e\"NVDA\"\u003c/span\u003e, start=\u003cspan class=\"hljs-string\"\u003e\"2020-01-01\"\u003c/span\u003e, end=\u003cspan class=\"hljs-string\"\u003e\"2024-06-30\"\u003c/span\u003e)\n\u003cspan class=\"hljs-comment\"\u003e# Rolling window 크기 정의\u003c/span\u003e\nwindow_size = \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e# 식 적용 및 변동성 데이터 프레임 가져오기\u003c/span\u003e\nrolling_volatility = yang_zhang(df)\n\u003cspan class=\"hljs-comment\"\u003e# 시간대별 변동성 플롯\u003c/span\u003e\nplt.plot(rolling_volatility, color=\u003cspan class=\"hljs-string\"\u003e'black'\u003c/span\u003e, label=\u003cspan class=\"hljs-string\"\u003e'5-period Yang-Zhang 변동성'\u003c/span\u003e)\nplt.legend()\nplt.grid()\nplt.axhline(y=np.mean(rolling_volatility), color=\u003cspan class=\"hljs-string\"\u003e'red'\u003c/span\u003e, linestyle=\u003cspan class=\"hljs-string\"\u003e'dashed)\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_9.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e과거 표준 편차는 변동성의 유용하고 널리 채택된 측정 방법이며, 간단함, 계산의 용이성 및 금융 산업에서의 일반적인 수용으로 인해 가치가 있습니다. 그러나 작은 표본 크기, 비정상적 변동성 및 수익의 비정규 분포를 처리하는 데 있어서 특히 한계가 있어 조심해서 사용해야 합니다.\u003c/p\u003e\n\u003cp\u003e정확성이 중요하거나 표본 크기가 작은 경우, 대안적인 변동성 모델이 더 나은 리스크 평가를 제공할 수 있습니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator"},"buildId":"jKAIrnIuHBv4ZHjiQbX6i","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>