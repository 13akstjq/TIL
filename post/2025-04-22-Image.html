<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Next.js 15에서 이미지 최적화하는 5가지 방법 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-Image" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Next.js 15에서 이미지 최적화하는 5가지 방법 | TIL" data-gatsby-head="true"/><meta property="og:title" content="Next.js 15에서 이미지 최적화하는 5가지 방법 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-Image" data-gatsby-head="true"/><meta name="twitter:title" content="Next.js 15에서 이미지 최적화하는 5가지 방법 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2025-04-22 02:20" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/0eef537492fed77a.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/0eef537492fed77a.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-8ded8b979ba73586.js" defer=""></script><script src="/TIL/_next/static/KUC9M_yIlA1Ugo01xmkHL/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/KUC9M_yIlA1Ugo01xmkHL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Next.js 15에서 이미지 최적화하는 5가지 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Next.js 15에서 이미지 최적화하는 5가지 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Apr 22, 2025</span><span class="posts_reading_time__f7YPP">99<!-- --> min read</span></span></div></div></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>Image 컴포넌트 사용법</h1>
<p>이번에는 Next.js에서 제공하는 <code>Image</code> 컴포넌트에 대해서 알아볼게요. 이미지 최적화에 신경 써야 할 때 직접 <code>&#x3C;img></code> 태그를 쓰기보다는 이 컴포넌트를 활용하면 자동으로 다양한 최적화가 진행되어 성능 향상에 도움이 된답니다.</p>
<p>아래는 <code>Image</code> 컴포넌트를 사용하는 기본적인 예시입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Image</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'next/image'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Image</span>
      <span class="hljs-attr">src</span>=<span class="hljs-string">"/profile.png"</span>       // <span class="hljs-attr">이미지</span> <span class="hljs-attr">경로</span>
      <span class="hljs-attr">width</span>=<span class="hljs-string">{500}</span>              // <span class="hljs-attr">이미지</span> <span class="hljs-attr">너비</span>(<span class="hljs-attr">px</span>)
      <span class="hljs-attr">height</span>=<span class="hljs-string">{500}</span>             // <span class="hljs-attr">이미지</span> <span class="hljs-attr">높이</span>(<span class="hljs-attr">px</span>)
      <span class="hljs-attr">alt</span>=<span class="hljs-string">"Picture of the author"</span> // <span class="hljs-attr">대체</span> <span class="hljs-attr">텍스트</span> (<span class="hljs-attr">접근성에</span> <span class="hljs-attr">필수</span>!)
    /></span></span>
  )
}
</code></pre>
<p><code>Image</code> 컴포넌트의 기본적인 사용법은 이렇게 <code>src</code>, <code>width</code>, <code>height</code>, <code>alt</code> 속성을 넘겨주는 거에요. 이 외에도 여러 유용한 props들이 있는데, 이어서 자세히 살펴볼게요.</p>
<h2>Image 컴포넌트 주요 Props</h2>























































<table><thead><tr><th>Prop</th><th>타입</th><th>설명</th></tr></thead><tbody><tr><td>src</td><td>string</td><td>불러올 이미지 경로 또는 URL</td></tr><tr><td>width</td><td>number/string</td><td>이미지 너비</td></tr><tr><td>height</td><td>number/string</td><td>이미지 높이</td></tr><tr><td>alt</td><td>string</td><td>이미지 설명 텍스트 (웹 접근성 측면에서 매우 중요)</td></tr><tr><td>layout</td><td>string</td><td>이미지 레이아웃 (<code>fixed</code>, <code>intrinsic</code>, <code>responsive</code>, <code>fill</code>) 설정</td></tr><tr><td>priority</td><td>boolean</td><td>true일 경우 우선 로딩, 주로 초기 페이지에 사용</td></tr><tr><td>placeholder</td><td>string</td><td>이미지 로딩 전 보여줄 플레이스홀더 (<code>blur</code> 가능)</td></tr><tr><td>quality</td><td>number</td><td>이미지 품질 설정 (1~100)</td></tr><tr><td>loader</td><td>function</td><td>커스텀 이미지 로더 함수 설정</td></tr></tbody></table>
<h3>layout 옵션 간단 설명</h3>
<ul>
<li><code>fixed</code>: 지정한 크기에서 고정</li>
<li><code>intrinsic</code>: 원본 비율 유지하며 최대 크기까지 늘어남</li>
<li><code>responsive</code>: 부모 컨테이너의 크기에 맞게 반응형 조절</li>
<li><code>fill</code>: 부모 컨테이너를 가득 채움 (position: absolute 필요)</li>
</ul>
<h3>Tip</h3>
<p><code>priority</code> 속성을 설정하면 페이지 로딩 시 해당 이미지가 우선적으로 로드되어 사용자 경험이 개선됩니다. 예를 들어, 프로필 사진이나 메인 배너 이미지에 사용하는 게 좋아요.</p>
<p>또한 <code>placeholder="blur"</code>와 함께 <code>blurDataURL</code> 속성을 사용하면 이미지를 불러오는 동안 흐릿한 미리보기 이미지를 보여줄 수 있어 깔끔한 로딩 효과를 줄 수 있답니다.</p>
<hr>
<p>추가로 궁금한 점이나 더 자세한 사용법이 필요하면 언제든지 알려주세요! Next.js는 이미지 핸들링을 꽤 잘 처리해주니까 꼭 활용해보시길 추천해요.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Image 컴포넌트에 사용할 수 있는 주요 props를 정리해봤어요. 이 내용을 참고하면 이미지 컴포넌트를 사용할 때 어떤 옵션들을 넣을 수 있는지 한눈에 확인할 수 있을 거예요.</p>

















































































































<table><thead><tr><th>Prop</th><th>Example</th><th>Type</th><th>Status</th></tr></thead><tbody><tr><td><code>src</code></td><td><code>src="/profile.png"</code></td><td>String</td><td>Required</td></tr><tr><td><code>width</code></td><td><code>width={500}</code></td><td>Integer (px)</td><td>Required</td></tr><tr><td><code>height</code></td><td><code>height={500}</code></td><td>Integer (px)</td><td>Required</td></tr><tr><td><code>alt</code></td><td><code>alt="Picture of the author"</code></td><td>String</td><td>Required</td></tr><tr><td><code>loader</code></td><td><code>loader={imageLoader}</code></td><td>Function</td><td>-</td></tr><tr><td><code>fill</code></td><td><code>fill={true}</code></td><td>Boolean</td><td>-</td></tr><tr><td><code>sizes</code></td><td><code>sizes="(max-width: 768px) 100vw, 33vw"</code></td><td>String</td><td>-</td></tr><tr><td><code>quality</code></td><td><code>quality={80}</code></td><td>Integer (1-100)</td><td>-</td></tr><tr><td><code>priority</code></td><td><code>priority={true}</code></td><td>Boolean</td><td>-</td></tr><tr><td><code>placeholder</code></td><td><code>placeholder="blur"</code></td><td>String</td><td>-</td></tr><tr><td><code>style</code></td><td><code>style={{objectFit: "contain"}}</code></td><td>Object</td><td>-</td></tr><tr><td><code>onLoadingComplete</code></td><td><code>onLoadingComplete={img => done()}</code></td><td>Function</td><td>Deprecated</td></tr><tr><td><code>onLoad</code></td><td><code>onLoad={event => done()}</code></td><td>Function</td><td>-</td></tr><tr><td><code>onError</code></td><td><code>onError={event => fail()}</code></td><td>Function</td><td>-</td></tr><tr><td><code>loading</code></td><td><code>loading="lazy"</code></td><td>String</td><td>-</td></tr><tr><td><code>blurDataURL</code></td><td><code>blurDataURL="data:image/jpeg..."</code></td><td>String</td><td>-</td></tr><tr><td><code>overrideSrc</code></td><td><code>overrideSrc="/seo.png"</code></td><td>String</td><td>-</td></tr></tbody></table>
<hr>
<h3>필수로 꼭 들어가야 하는 props</h3>
<p>Image 컴포넌트를 쓸 때는 최소한 다음 네 가지는 꼭 지정해줘야 해요.</p>
<ul>
<li><code>src</code>: 이미지 경로 (예: <code>/profile.png</code>)</li>
<li><code>alt</code>: 이미지가 로드되지 않을 때 대체 텍스트 역할을 하는 설명</li>
<li><code>width</code>: 이미지 너비 (픽셀 단위)</li>
<li><code>height</code>: 이미지 높이 (픽셀 단위)</li>
</ul>
<p><code>width</code>와 <code>height</code> 대신에 <code>fill={true}</code> 옵션을 사용하는 방법도 있는데, 이 경우 이미지가 부모 요소의 크기에 맞춰서 자동으로 채워지게 돼요.</p>
<hr>
<h3>그 외에 알아두면 좋은 점들</h3>
<ul>
<li><code>loader</code>: 커스텀 이미지 로더를 만들 때 유용해요. 기본 로더 대신 내가 원하는 로딩 방식을 정의할 수 있어요.</li>
<li><code>priority</code>: 중요한 이미지는 이 옵션을 true로 설정해서 퍼포먼스를 개선할 수 있어요. React 내장 lazy loading과 다르게 우선 로드되게 할 수 있답니다.</li>
<li><code>placeholder</code>와 <code>blurDataURL</code>: 이미지를 불러오기 전에 흐릿한 이미지(blur 효과)를 보여 주는 용도로 자주 쓰여요. 사용자 경험을 한층 부드럽게 만들어주죠.</li>
<li><code>sizes</code>: 반응형 이미지에서 매우 유용해요. 화면 크기에 따라 적절한 이미지 크기를 제공할 수 있게 도와줍니다.</li>
<li><code>onLoad</code>와 <code>onError</code>: 이미지가 로드되었을 때나 에러가 났을 때 적절한 콜백 처리를 하고 싶으면 이 props들을 활용하세요.</li>
</ul>
<p><code>onLoadingComplete</code>는 요즘은 사용을 권장하지 않는 Deprecated 상태니까, 가능하면 <code>onLoad</code>를 사용하시는 걸 추천해요.</p>
<hr>
<p>실제 프로젝트에서 이미지를 최적화하고 싶을 때 이 컴포넌트의 다양한 옵션들을 잘 활용하면 훨씬 효율적이고 깔끔한 구현이 가능해집니다. 저는 개인적으로 <code>priority</code>, <code>placeholder</code>, 그리고 <code>sizes</code> 옵션을 자주 사용해서 사용자 경험이 좋아지는 걸 체감했어요.</p>
<p>필요한 부분만 잘 골라서 쓰면 되니 너무 걱정 말고 하나씩 시도해보면서 익혀보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>안녕하세요! 오늘은 Next.js에서 <code>Image</code> 컴포넌트를 사용할 때 <code>src</code> 속성에 대해 알아볼게요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Image</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'next/image'</span>
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">Image</span>
        <span class="hljs-attr">src</span>=<span class="hljs-string">"/profile.png"</span>
        <span class="hljs-attr">width</span>=<span class="hljs-string">{500}</span>
        <span class="hljs-attr">height</span>=<span class="hljs-string">{500}</span>
        <span class="hljs-attr">alt</span>=<span class="hljs-string">"Picture of the author"</span>
      /></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  )
}
</code></pre>
<p>위 예제에서 <code>src</code>는 이미지 경로를 나타내는데요, Next.js에서는 <code>src</code>에 사용할 수 있는 값이 제한되어 있습니다. 그 조건을 한번 살펴볼게요.</p>

















<table><thead><tr><th>src 값 유형</th><th>설명</th></tr></thead><tbody><tr><td>정적으로 import된 이미지 파일</td><td>예를 들어, <code>import profilePic from '../public/profile.png'</code> 처럼 미리 불러온 이미지 파일을 사용할 수 있어요.</td></tr><tr><td>경로 문자열</td><td>URL 형태의 문자열로, 다음 두 경우로 나뉘어요: <br> - 외부 URL: <code>https://example.com/image.png</code> <br> - 내부 경로: <code>/profile.png</code> 等</td></tr></tbody></table>
<p>여기서 중요한 점! 내부 경로를 쓸 때는 <code>loader</code> 속성에 따라서 다음과 같이 처리되는데요,</p>
<ul>
<li>기본 <code>loader</code>를 사용할 때는 <code>/public</code> 폴더 내의 자원을 지정할 때는 경로가 <code>/</code> 로 시작해야 해요.즉, <code>/profile.png</code>는 <code>public/profile.png</code>에 위치한 파일을 가리킵니다.</li>
<li>외부 이미지 URL을 쓸 땐 반드시 도메인을 <code>next.config.js</code>의 <code>images.domains</code> 배열에 추가해줘야 정상적으로 최적화가 이루어져요.</li>
</ul>
<p>또한, Next.js의 <code>Image</code> 컴포넌트는 이미지 최적화나 lazy loading 등 다양한 이점을 주는데요, 그래서 <code>width</code>와 <code>height</code>를 꼭 명시해주는 게 좋아요. 그래야 이미지가 로드되기 전에도 레이아웃이 안정적으로 잡히고, 화면이 덜 흔들리게 되거든요.</p>
<p>추가 팁으로, 만약 이미지를 자바스크립트에서 직접 import 한다면 이렇게 쓸 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> profilePic <span class="hljs-keyword">from</span> <span class="hljs-string">'../public/profile.png'</span>

&#x3C;<span class="hljs-title class_">Image</span>
  src={profilePic}
  alt=<span class="hljs-string">"Profile"</span>
  width={<span class="hljs-number">500</span>}
  height={<span class="hljs-number">500</span>}
/>
</code></pre>
<p>이렇게 하면 Next.js가 빌드 타임에 이미지 사이즈를 정확히 파악해서 최적화에 도움을 줄 거예요.</p>
<p>요약하면, <code>src</code>에 들어가는 값은 크게 두 가지! <strong>정적 import한 이미지</strong> 또는 <strong>경로 문자열</strong>이에요. 외부 이미지를 쓸 때는 꼭 <code>next.config.js</code>에 도메인 등록 잊지 마시고, 내부 경로는 <code>public</code> 폴더를 기준으로 적절하게 작성하면 된답니다.</p>
<p>Next.js에서 이미지 다루기를 조금 더 편하고 효율적으로 하려면 이 부분을 잘 이해하시면 큰 도움이 될 거예요! 😊</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>기본 로더(default loader)를 사용할 때는 다음 사항도 꼭 참고하세요:</p>
<ul>
<li>src가 외부 URL일 경우에는 <code>remotePatterns</code> 설정도 함께 해줘야 합니다.</li>
<li>src가 애니메이션 이미지거나 JPEG, PNG, WebP, AVIF, GIF, TIFF 같은 알려진 포맷이 아닐 때는, 이미지는 있는 그대로(served as-is) 서빙됩니다.</li>
<li>src가 SVG 형식이면 기본적으로 차단됩니다. SVG를 사용하려면 <code>unoptimized</code> 또는 <code>dangerouslyAllowSVG</code> 옵션을 활성화해야 해요.</li>
</ul>
<hr>
<h3>width 속성</h3>
<p><code>width</code> 속성은 이미지의 실제 픽셀 너비를 나타내는 값이에요. 이 값은 이미지가 로드될 때 레이아웃이 흔들리는 걸 막기 위해 적절한 종횡비(aspect ratio)를 계산하는 데 쓰입니다. 하지만 이게 곧 화면에 표시되는 크기를 결정하는 건 아니에요! 화면에 보이는 크기는 CSS로 조절하게 돼요. 쉽게 말해, HTML의 <code>img</code> 태그에서 <code>width</code> 속성과 비슷한 역할을 한다고 생각하시면 됩니다.</p>
<p>요즘 반응형 이미지 대응이나 레이아웃 안정성을 위해 width, height 같은 실제 이미지 크기 정보를 명확히 지정해주는 게 권장되고 있으니 꼭 기억해 주세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>필수 항목입니다. 단, 정적으로 임포트된 이미지나 fill 속성이 적용된 이미지의 경우는 예외입니다.</p>
<h3>height (높이)</h3>
<p>height 속성은 이미지의 본래 높이를 픽셀 단위로 나타냅니다. 이 값은 이미지의 올바른 가로세로 비율을 추론하는 데 사용되며, 로딩 중에 레이아웃이 흔들리는 현상(layout shift)을 방지하는 효과가 있어요. 다만, 실제 화면에 렌더링되는 이미지 크기를 결정하는 속성은 아니에요. 렌더링 크기는 CSS에서 제어하며, HTML <code>img</code> 태그의 height 속성과 비슷한 역할을 한다고 생각하시면 됩니다.</p>
<p>이 부분에서 중요한 점은, height 속성을 명시해두면 브라우저가 이미지 로딩 시점에 공간을 미리 확보하기 때문에 “레이아웃 점프” 현상을 줄여 사용자 경험을 개선할 수 있다는 것입니다. 특히 페이지 내 이미지가 많거나 이미지가 느리게 로드되는 환경에서 이 점이 큰 도움이 됩니다.</p>
<p>추가로, 만약 정적으로 임포트된 이미지라면 빌드 시점에 이미지 크기 정보가 이미 포함되어 있어 직접 height를 명시하지 않아도 되고, fill 속성(부모 요소의 크기에 맞춰 이미지를 꽉 채우는 스타일)을 사용하는 경우에도 마찬가지로 height를 직접 지정할 필요가 없습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<blockquote>
<p>알아두면 좋은 점:
width와 height 속성은 이미지의 가로세로 비율(종횡비)을 결정하는 데 함께 사용돼요. 브라우저는 이 정보를 바탕으로 이미지가 로딩되기 전에 미리 공간을 확보하죠.<br>
하지만 intrinsic size(내재적 크기)가 항상 브라우저에 렌더링되는 크기와 같지는 않아요. 부모 컨테이너 크기에 따라 이미지가 그 안에 맞게 조절되거든요. 예를 들어, 부모 컨테이너가 이미지 intrinsic size보다 작으면, 이미지는 자동으로 축소되어 컨테이너에 맞춰지는 거죠.<br>
만약 width와 height가 애초에 알려지지 않았다면, <code>fill</code> 속성을 활용할 수도 있어요.</p>
</blockquote>
<h3>alt 속성</h3>
<p>이미지의 alt 속성은 화면 읽기 기기(screen reader)와 검색 엔진을 위한 설명 역할을 해요. 이미지가 비활성화되어 있거나 로딩 오류가 발생했을 때는 대체 텍스트로 나타나죠.</p>
<p>alt 텍스트는 페이지의 의미를 바꾸지 않고 이미지를 대신할 수 있는 내용을 담아야 합니다.<br>
즉, 이미지를 보완하는 용도가 아니라, 이미지 캡션이나 주변 텍스트에서 이미 설명한 내용을 반복하면 안 돼요.</p>
<p>요즘은 웹 접근성의 중요성이 부각되면서, 올바른 alt 속성 작성이 필수로 권장되고 있어요. 특히 시각장애인들이 사용하는 스크린 리더에서는 이미지가 제공하는 정보를 alt가 대신 전달하기 때문에, 간결하면서도 핵심을 담는 것이 좋답니다.</p>

























<table><thead><tr><th>속성</th><th>설명</th></tr></thead><tbody><tr><td>width, height</td><td>이미지의 가로세로 비율 결정, 브라우저가 공간 미리 확보</td></tr><tr><td>intrinsic size</td><td>실제 이미지 파일의 원본 크기, 부모 컨테이너에 따라 조정됨</td></tr><tr><td>fill</td><td>width, height 미지정 시 공간에 꽉 채우기 위한 옵션</td></tr><tr><td>alt</td><td>이미지 설명, 스크린 리더와 검색 엔진에 활용되며 대체 텍스트 역할</td></tr></tbody></table>
<p>이미지 태그를 작성할 때는 위 내용을 참고해서, 디자인 뿐 아니라 접근성과 SEO까지 한 번에 챙겨보시면 좋아요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이미지가 단순히 장식용이거나
사용자에게 중요한 정보 전달 목적이 아니라면,
alt 속성은 빈 문자열로 설정하는 게 좋아요 (alt="").</p>
<p>더 알아보기</p>
<h2>선택적 속성(Optional Props)</h2>
<p><code>Image /</code> 컴포넌트는 필수 속성 외에도 다양한 추가 속성을 지원해요.<br>
이번 섹션에서는 가장 자주 쓰이는 속성들을 소개할게요.<br>
좀 더 특별하거나 덜 자주 쓰이는 속성들은 '고급 속성(Advanced Props)' 섹션에서 확인할 수 있어요.</p>
<hr>
<p>참고로, alt 속성은 이미지가 로드되지 않을 때 대체 텍스트로 보여주기도 하고, 시각장애인들이 스크린 리더를 사용할 때 이미지 내용을 설명해줘서 접근성 측면에서 매우 중요하답니다.<br>
하지만 장식용인 경우에는 오히려 의미 없는 텍스트가 읽히면서 사용자에게 혼란을 줄 수 있으니, 빈 문자열로 두는 게 맞아요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>loader</h3>
<p>이미지 URL을 처리할 때 사용하는 커스텀 함수예요.</p>
<p>loader 함수는 이미지에 필요한 URL을 직접 만들어내는데, 함수에 넘겨지는 주요 인자는 다음과 같아요:</p>
<ul>
<li><code>src</code>: 이미지 경로 또는 파일명</li>
<li><code>width</code>: 이미지 너비 (픽셀 단위)</li>
<li><code>quality</code>: 이미지 품질 (보통 압축률이나 화질 조절에 사용)</li>
</ul>
<p>이걸 기억하면, 원하는 대로 이미지 URL을 동적으로 생성할 수 있답니다! 예를 들어, CDN에서 이미지를 받아올 때 너비나 품질에 맞게 URL을 조합해서 요청할 수 있죠.</p>
<p>추가로, 로더를 직접 만들면 기본 이미지 최적화 방식을 바꾸거나, 외부 이미지 서비스(예: Cloudinary, Imgix 등)를 쓸 때 유용해요. 그런 경우 URL 생성 규칙이 다르니까 loader 함수에서 그에 맞게 처리하면 되죠.</p>
<hr>
<p>만약 간단한 예시가 궁금하다면 이렇게 써볼 수 있어요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myLoader</span>(<span class="hljs-params">{ src, width, quality }</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">`https://mycdn.com/<span class="hljs-subst">${src}</span>?w=<span class="hljs-subst">${width}</span>&#x26;q=<span class="hljs-subst">${quality || <span class="hljs-number">75</span>}</span>`</span>;
}
</code></pre>
<p>위처럼 <code>src</code>, <code>width</code>, <code>quality</code>를 받아서 URL을 조합하고, 이 URL을 이미지 컴포넌트에 넘겨주면 돼요.<br>
그럼 필요한 크기와 품질에 맞춰서 이미지를 호출하니 네트워크 비용도 아끼고 페이지 속도도 좋아져요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>여기 커스텀 로더(custom loader)를 사용하는 예제가 있어요:</p>
<pre><code class="hljs language-js"><span class="hljs-string">'use client'</span>

<span class="hljs-keyword">import</span> <span class="hljs-title class_">Image</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'next/image'</span>

<span class="hljs-keyword">const</span> <span class="hljs-title function_">imageLoader</span> = (<span class="hljs-params">{ src, width, quality }</span>) => {
  <span class="hljs-keyword">return</span> <span class="hljs-string">`https://example.com/<span class="hljs-subst">${src}</span>?w=<span class="hljs-subst">${width}</span>&#x26;q=<span class="hljs-subst">${quality || <span class="hljs-number">75</span>}</span>`</span>
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Image</span>
      <span class="hljs-attr">loader</span>=<span class="hljs-string">{imageLoader}</span>
      <span class="hljs-attr">src</span>=<span class="hljs-string">"me.png"</span>
      <span class="hljs-attr">alt</span>=<span class="hljs-string">"Picture of the author"</span>
      <span class="hljs-attr">width</span>=<span class="hljs-string">{500}</span>
      <span class="hljs-attr">height</span>=<span class="hljs-string">{500}</span>
    /></span></span>
  )
}
</code></pre>
<h3>핵심 포인트</h3>
<ul>
<li><code>loader</code>라는 프로퍼티에 함수 형태로 로더를 넣을 때는 <strong>클라이언트 컴포넌트(Client Components)</strong> 안에서 사용해야 해요. 이유는 Next.js가 이 함수를 직렬화(serialization)해야 하기 때문입니다.</li>
<li>즉, <code>'use client'</code> 지시어를 꼭 컴포넌트 상단에 추가해줘야 오류가 안 납니다.</li>
</ul>
<hr>
<h3>참고!</h3>
<p>만약 앱 전역에 걸쳐서 모든 <code>next/image</code> 컴포넌트에 대해 같은 커스텀 로더를 쓰고 싶다면, <code>next.config.js</code>의 <code>loaderFile</code> 옵션을 설정하는 방법도 있어요. 그러면 매번 개별 컴포넌트에서 <code>loader</code> prop을 넘겨주지 않아도 되죠.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// next.config.js</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">experimental</span>: {
    <span class="hljs-attr">images</span>: {
      <span class="hljs-attr">loaderFile</span>: <span class="hljs-string">'./my-custom-loader.js'</span>,
    },
  },
}
</code></pre>
<p><code>my-custom-loader.js</code>에 로더 함수를 작성해두면 Next.js가 자동으로 이걸 참조합니다.</p>
<hr>
<h3>커스텀 로더 쓸 때 알아두면 좋은 점</h3>

























<table><thead><tr><th>내용</th><th>설명</th></tr></thead><tbody><tr><td>로더에서 다루는 인자</td><td><code>src</code>, <code>width</code>, <code>quality</code> 등 이미지 최적화에 중요한 값들</td></tr><tr><td>기본 품질 값</td><td><code>quality</code>가 없으면 75로 기본 세팅되는 경우가 많음</td></tr><tr><td>'use client' 필요</td><td>로더 함수를 컴포넌트 안에서 직접 넘길 땐 클라이언트 컴포넌트여야 함</td></tr><tr><td>전역 설정 가능</td><td><code>loaderFile</code> 옵션으로 앱 전체에 일괄 적용 가능</td></tr></tbody></table>
<hr>
<p>커스텀 로더는 외부 CDN이나 이미지 서버에서 동적으로 크기 조절, 품질 조절이 가능할 때 특히 유용해요. 이렇게 하면 필요한 사이즈로 딱 맞는 이미지를 받아와서 페이지 로딩 속도를 개선할 수 있답니다.</p>
<p>혹시 이미지 최적화 관련해서 더 궁금한 점 있으면 언제든 질문 주세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>fill</h3>
<pre><code class="hljs language-js">fill={<span class="hljs-literal">true</span>} <span class="hljs-comment">// {true} | {false}</span>
</code></pre>
<p><code>fill</code>은 이미지가 부모 요소를 꽉 채우도록 하는 불리언 값이에요. 특히, 이미지의 너비와 높이를 미리 지정하기 어려울 때 유용하죠.</p>
<p>단, 이 기능을 제대로 사용하려면 부모 요소에 <code>position: "relative"</code>, <code>position: "fixed"</code>, 또는 <code>position: "absolute"</code> 스타일을 꼭 지정해줘야 해요. 그래야 이미지가 부모 요소 안에서 정확하게 위치하고 크기가 맞춰지니까요.</p>
<p>예를 들어 이렇게 쓸 수 있겠죠:</p>
<pre><code class="hljs language-jsx">&#x3C;div style={{ <span class="hljs-attr">position</span>: <span class="hljs-string">'relative'</span>, <span class="hljs-attr">width</span>: <span class="hljs-string">'100%'</span>, <span class="hljs-attr">height</span>: <span class="hljs-string">'300px'</span> }}>
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Image</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/example.jpg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"Example"</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">{true}</span> /></span></span>
&#x3C;/div>
</code></pre>
<p>여기서 <code>div</code>에 <code>position: 'relative'</code>를 줌으로써 이미지가 그 영역을 꽉 채우게 만들 수 있어요.</p>
<p>이 점 꼭 기억하고 활용하면, 반응형 이미지 배치 때 꽤 편리하답니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>기본적으로 img 태그에는 position: "absolute" 스타일이 자동으로 적용돼요.</p>
<p>만약 이미지에 별도의 스타일이 지정되지 않았다면, 이미지는 컨테이너 크기에 맞춰 늘어나게 돼요. 그런데 이럴 때 이미지가 찌그러지거나 비율이 이상해질 수 있죠. 그래서 보통은 object-fit: "contain" 스타일을 주는 게 좋아요. 이걸 주면 이미지가 컨테이너 안에 딱 맞게 맞춰지고, 빈 공간이 있을 때는 레터박스(검은 여백)가 생기면서 원본 비율을 유지해 줍니다.</p>
<p>반대로 object-fit: "cover"를 사용하면 이미지가 컨테이너를 꽉 채우도록 잘리면서 보여줘요. 원본 비율은 지키지만, 이미지 일부가 잘릴 수 있다는 점 명심하세요.</p>
<p>이렇게 object-fit을 적절히 활용하면 웹에서 이미지가 깨지거나 비율이 이상해지는 걸 방지할 수 있어요. 특히 반응형 웹이나 다양한 크기의 컨테이너에 이미지를 넣을 때 꼭 알아두면 좋은 CSS 속성이죠.</p>

























<table><thead><tr><th>속성</th><th>설명</th></tr></thead><tbody><tr><td>position</td><td>이미지 위치 지정, 기본값은 "absolute"</td></tr><tr><td>object-fit</td><td>이미지의 컨테이너 내 맞춤 방식 지정</td></tr><tr><td>contain</td><td>이미지 비율 유지하며 컨테이너 안에 모두 보여줌</td></tr><tr><td>cover</td><td>비율 유지하며 컨테이너를 완전히 덮되 일부 잘림</td></tr></tbody></table>
<p>더 자세한 내용은 CSS의 object-fit 관련 문서를 참고하면 도움이 될 거예요.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>오늘은 웹 개발할 때 이미지 다룰 때 꼭 알아두면 좋은 CSS 속성 몇 가지와 함께, 특히 <code>sizes</code> 속성에 대해 이야기해볼게요. 이미지 로딩 성능과 반응형 디자인에 큰 영향을 주기 때문에 이해하면 꽤 유용하답니다.</p>
<hr>
<h3>position, object-fit, object-position 간단 정리</h3>
<ul>
<li>
<p><strong>position</strong><br>
이미지나 요소의 위치를 설정할 때 쓰이는 CSS 속성이죠. 예를 들어, <code>relative</code>, <code>absolute</code> 같은 값을 줘요. 이미지가 컨테이너 내에서 어떻게 배치될지 결정할 때 많이 씁니다.</p>
</li>
<li>
<p><strong>object-fit</strong><br>
이미지를 컨테이너 크기에 맞게 어떻게 맞출지 정하는 속성이에요. 대표값으로는 <code>cover</code> (이미지 꽉 채우기, 잘릴 수 있음), <code>contain</code> (이미지 전체 보이도록 축소/확대), <code>fill</code> (비율 무시하고 꽉 채움), <code>none</code> (원본 크기 유지) 등이 있어요.</p>
</li>
<li>
<p><strong>object-position</strong><br>
<code>object-fit</code>이 <code>cover</code>나 <code>contain</code>일 때, 이미지가 컨테이너 안에서 어디에 위치할지 정하는 속성이에요. 기본값은 <code>center center</code>죠. 간단히 <code>top left</code>, <code>bottom right</code> 등으로 조절할 수 있어요.</p>
</li>
</ul>
<p>이 세 가지 조합하면, 이미지가 반응형일 때 원하는 방식으로 나타나게 할 수 있어요!</p>
<hr>
<h3>sizes 속성 이해하기 (이미지 로딩 최적화에 핵심!)</h3>
<p><code>&#x3C;img></code> 태그에서 특히 <code>&#x3C;source></code>와 함께 쓰면서 '지금 이 화면 사이즈에서 이미지가 실제로 얼마나 크게 보여질지' 브라우저에 알려주는 역할을 해요. 사실, 브라우저가 이미지 크기를 미리 알고 있으면, 가장 적합한 크기의 이미지를 요청할 수 있어 성능이 팍 좋아집니다.</p>
<h4>sizes 정의 방식</h4>
<ul>
<li>문자열 형태로 쓰고, CSS 미디어 쿼리랑 비슷해요.</li>
<li>화면 너비 기준으로 '어떤 상황에 이미지가 몇 픽셀 너비만큼 보여질지'를 지정해줘요.</li>
<li>여러 조건을 콤마(,)로 구분해 순서대로 해석합니다.</li>
</ul>
<p>예를 들어,</p>
<pre><code class="hljs language-css">sizes="(<span class="hljs-attribute">max-width</span>: <span class="hljs-number">600px</span>) <span class="hljs-number">480px</span>, <span class="hljs-number">800px</span><span class="hljs-string">"
</span></code></pre>
<p>이렇게 하면, 화면 너비가 600px 이하일 땐 이미지가 480px 크기로 보여지고, 그 이상일 땐 800px 크기로 보여질 거란 걸 알려주는 거죠.</p>
<h4>sizes가 중요한 이유</h4>
<ul>
<li><code>fill</code> 또는 반응형 크기를 가진 이미지를 사용할 때 특히 효과적입니다.</li>
<li>화면 크기에 맞춘 적절한 이미지 해상도를 요청해 불필요한 데이터 낭비를 줄여줍니다.</li>
<li>결국, 로딩 속도 개선과 데이터 절약으로 이어지니 모바일 환경에선 필수!</li>
</ul>
<hr>
<h3>간단 요약 테이블</h3>






























<table><thead><tr><th>속성</th><th>설명</th><th>대표값 및 의미</th></tr></thead><tbody><tr><td>position</td><td>요소의 위치 설정</td><td>relative, absolute 등</td></tr><tr><td>object-fit</td><td>이미지가 컨테이너 내에서 크기 조절 방법</td><td>cover, contain, fill, none</td></tr><tr><td>object-position</td><td>이미지 내부에서 위치 지정</td><td>center center (기본), top left 등</td></tr><tr><td>sizes</td><td>여러 화면 크기에 맞춘 이미지 출력 크기 안내</td><td>(media query) 크기, 최종 이미지 너비</td></tr></tbody></table>
<hr>
<h3>마무리 팁</h3>
<ul>
<li>
<p><strong><code>sizes</code>가 없으면?</strong><br>
브라우저는 디폴트로 전체 이미지 크기를 사용하거나 해상도에 맞춘 이미지를 선택 못해, 큰 이미지 불필요하게 다운받을 수 있어요.</p>
</li>
<li>
<p><strong><code>srcset</code>과 함께 쓰기!</strong><br>
<code>sizes</code>는 주로 <code>srcset</code>과 같이 써서 여러 해상도 이미지를 상황에 맞게 불러오도록 해요.</p>
</li>
<li>
<p><strong>반응형 이미지 사용시 필수!</strong><br>
화면 크기별로 이미지를 다르게 하고 싶으면, <code>sizes</code>에 익숙해지는 게 좋습니다.</p>
</li>
</ul>
<hr>
<p>이미지를 효율적으로 다루는 건 작은 것 같지만 웹 페이지 속도와 사용자 경험에 큰 차이를 만듭니다. <code>position</code>, <code>object-fit</code>, <code>object-position</code>으로 디자인을 잡고, <code>sizes</code>로 똑똑하게 이미지 로딩 관리해보세요! 앞으로도 계속 실용적인 웹 테크닉 알려드릴게요. 궁금한 점 있으면 댓글 남겨주세요~ 😊</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>next/image의 sizes 속성, 제대로 이해하고 있나요?<br>
이미지를 좀 더 똑똑하게 불러오고 싶다면 sizes 속성만큼 중요한 것도 없어요. 이번 글에서는 sizes가 왜 필요한지, 그리고 어떻게 활용하면 좋은지 쉽게 풀어볼게요.</p>
<hr>
<h3>1. sizes는 "얼마나 크게 이미지를 보여줄 건지" 알려주는 역할이에요.</h3>
<p>브라우저는 <code>&#x3C;Image></code> 컴포넌트에 자동으로 만들어지는 srcset(다양한 크기의 이미지 묶음)을 보고 어떤 이미지를 다운받을지 결정하는데요. 이때 sizes 속성 값이 중요한 역할을 해요.</p>
<ul>
<li>
<p>sizes가 없다면?<br>
기본값인 <code>100vw</code>(화면 가로 너비 100%)로 인식해서, <strong>화면 크기만큼 큰 이미지를 다운받아요</strong>.<br>
즉, 모바일 화면이라도 큰 데스크톱용 이미지를 받을 수도 있다는 뜻이죠. 낭비 그 자체...!</p>
</li>
<li>
<p>sizes가 있으면?<br>
화면 크기나 레이아웃에 맞는 이미지를 미리 알려서, 그에 적합한 크기의 이미지를 똑똑하게 골라 다운받을 수 있어요.</p>
</li>
</ul>
<hr>
<h3>2. sizes는 srcset을 어떻게 만들어내느냐에도 영향을 줘요.</h3>
<p>자동 생성되는 srcset이 크게 두 가지로 나뉘는데요.</p>
<ul>
<li>sizes가 없을 때는, 고정 크기 이미지용으로 작은 srcset이 만들어져요 (예: 1x, 2x...)</li>
<li>sizes가 있으면, 반응형 이미지를 위한 큰 srcset이 생성돼요(예: 640w, 750w 같은 픽셀 너비 단위)</li>
</ul>
<p>특히 sizes에 <code>50vw</code>처럼 뷰포트의 % 단위가 들어가면, 불필요하게 작은 이미지 옵션들이 걸러져서 srcset이 간결해지고, 진짜 필요한 이미지들만 주로 다운받게 되죠.</p>
<hr>
<h3>실제 사례로 살펴볼게요!</h3>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Image</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'next/image'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"grid-element"</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">Image</span>
        <span class="hljs-attr">fill</span>
        <span class="hljs-attr">src</span>=<span class="hljs-string">"/example.png"</span>
        <span class="hljs-attr">sizes</span>=<span class="hljs-string">"(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"</span>
      /></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  )
}
</code></pre>
<ul>
<li>화면이 최대 768px이면? 이미지가 화면 최대 너비(<code>100vw</code>)로 보여져요 - 주로 모바일용</li>
<li>768px 초과, 1200px 이하 화면이면? 이미지가 화면 너비의 절반(<code>50vw</code>)</li>
<li>1200px 초과면? 이미지가 화면 너비의 33%(<code>33vw</code>)만 차지한다는 의미</li>
</ul>
<hr>
<h3>sizes의 위력: 성능에 미치는 영향</h3>
<p>만약 <code>sizes</code>를 위 예시처럼 적절히 지정하지 않으면, 특히 데스크톱에서 <strong>실제로 1/3 크기만 필요한 이미지를 3배 크기(가로 기준) 이미지로 다운받게 되겠죠</strong>?<br>
이미지 파일 크기는 가로 * 세로이기 때문에, 파일 크기는 대략 가로 크기의 제곱에 비례해요.<br>
즉, 3배 큰 이미지를 받으면, 용량은 9배가 될 수 있다는 말입니다!</p>
<hr>
<h3>정리!</h3>

























<table><thead><tr><th>포인트</th><th>설명</th></tr></thead><tbody><tr><td>sizes의 역할</td><td>이미지가 실제로 렌더링될 크기를 브라우저에 알려서 적합한 이미지 선택 유도</td></tr><tr><td>sizes 없을 때</td><td>기본 <code>100vw</code>로 간주, 무조건 화면 가로폭만큼 큰 이미지 다운</td></tr><tr><td>sizes가 있으면</td><td>반응형 srcset 선택 가능, 불필요한 큰 이미지 다운로드 억제</td></tr><tr><td>권장 활용</td><td>뷰포트 크기별 예상 이미지 크기를 sizes에 정의해두기</td></tr></tbody></table>
<hr>
<h3>추가 팁!</h3>
<ul>
<li>
<p><code>fill</code> 속성을 사용할 때는 특히 sizes 설정 꼭 해주세요.<br>
그 이유는 fill일 때 이미지가 부모 요소에 맞춰 꽉 채워지는데, sizes가 없으면 무조건 화면 가로 크기로 판단하기 때문이에요.</p>
</li>
<li>
<p>복잡한 레이아웃 환경이라면, media query 같은 복수 조건으로 sizes를 꼭 세분화해서 지정하는 습관을!</p>
</li>
</ul>
<hr>
<p>이처럼 sizes가 제한적으로 보이지만, 성능 최적화에 있어선 꽤나 강력한 역할을 해요.<br>
앞으로 next/image 쓸 때는 <strong>sizes 설정 잊지 말고 성능도 챙기는 스마트한 개발자</strong>가 되어봅시다!<br>
궁금한 점 있으면 댓글로 알려주세요~</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>srcset과 sizes 속성에 대해 조금 더 재미있게 파헤쳐보도록 할게요!</p>
<hr>
<h2>srcset과 sizes: 이미지 최적화를 위한 든든한 친구들</h2>
<p>웹에서 이미지가 너무 크거나 작게 나오면 사용자 경험이 떨어지잖아요? 그래서 요즘은 반응형 이미지를 쉽게 구현할 수 있도록 srcset과 sizes라는 속성을 많이 사용해요.</p>
<h3>srcset이란?</h3>
<p>이미지를 다양한 크기로 준비해두고, 브라우저가 화면 크기나 해상도에 맞게 적절한 이미지를 골라서 보여주도록 해주는 역할이에요.</p>
<p>예를 들어:</p>
<pre><code class="hljs language-html"><span class="hljs-tag">&#x3C;<span class="hljs-name">img</span> 
  <span class="hljs-attr">src</span>=<span class="hljs-string">"small.jpg"</span> 
  <span class="hljs-attr">srcset</span>=<span class="hljs-string">"small.jpg 500w, medium.jpg 1000w, large.jpg 1500w"</span> 
  <span class="hljs-attr">alt</span>=<span class="hljs-string">"예쁜 고양이"</span> 
/></span>
</code></pre>
<p>위에서 500w, 1000w, 1500w는 각각 이미지의 가로 너비(pixel) 크기를 의미해요. 브라우저가 화면에 맞게 적절한 이미지를 골라서 내려받겠죠.</p>
<h3>sizes란?</h3>
<p>sizes는 브라우저에게 "내 이미지는 이렇게 크기로 보여질 거야"라고 미리 알려주는 역할을 해요. 예를 들어, 내가 이미지가 보통 뷰포트의 50% 정도 차지한다면 그에 맞게 알려주면 크기를 더 정확하게 고를 수 있습니다.</p>
<pre><code class="hljs language-html"><span class="hljs-tag">&#x3C;<span class="hljs-name">img</span>
  <span class="hljs-attr">src</span>=<span class="hljs-string">"small.jpg"</span>
  <span class="hljs-attr">srcset</span>=<span class="hljs-string">"small.jpg 500w, medium.jpg 1000w, large.jpg 1500w"</span>
  <span class="hljs-attr">sizes</span>=<span class="hljs-string">"(max-width: 600px) 100vw, 50vw"</span>
  <span class="hljs-attr">alt</span>=<span class="hljs-string">"예쁜 강아지"</span>
/></span>
</code></pre>
<ul>
<li><code>(max-width: 600px) 100vw</code>: 뷰포트가 600px 이하일 때는 이미지가 화면 너비 전체(100vw)를 차지한다는 뜻이에요.</li>
<li><code>50vw</code>: 그 외에는 화면 너비의 50%만 쓰인다는 뜻이에요.</li>
</ul>
<h3>quality 속성도 알아두자!</h3>
<p>위에서 언급된 quality는 이미지 처리 라이브러리(예: Next.js 이미지 컴포넌트)에서 이미지를 압축할 때 몇 퍼센트 품질로 줄일 건지를 나타내요. 1<del>100까지 숫자를 받는데, 너무 낮으면 이미지가 뭉개지고, 너무 높으면 용량도 커져서 로딩이 느려져요. 보통 70</del>80 수준에서 적절히 타협하는 편입니다.</p>
<pre><code class="hljs language-js">quality={<span class="hljs-number">75</span>} <span class="hljs-comment">// 적당한 화질과 용량의 밸런스를 잡을 수 있어요</span>
</code></pre>
<hr>
<h3>참고하면 좋은 사이트</h3>
<ul>
<li><a href="https://web.dev/learn/design/responsive-images/" rel="nofollow" target="_blank">web.dev의 srcset 설명</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images" rel="nofollow" target="_blank">MDN 이미지 반응형 가이드</a></li>
</ul>
<hr>
<p>이제부터 이미지 태그 예쁘게 짜서 웹사이트 속도도 챙기고 사용자 경험도 쏙쏙 높여보아요!<br>
궁금한 점 있으면 언제든 댓글로 물어봐 주세요~</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이미지 최적화에서 quality(품질) 값은 1부터 100 사이의 정수로 설정할 수 있는데요, 100이 가장 높은 품질이자 가장 큰 파일 크기를 의미합니다. 기본값은 75로 설정되어 있어요.</p>
<p>만약 next.config.js 파일에서 qualities 설정을 따로 정의해뒀다면, quality 속성 값은 그 중 하나와 꼭 일치해야 한다는 점 기억하세요.</p>
<blockquote>
<p>참고할 내용: 원본 이미지가 이미 저품질이라면, quality 값을 너무 높게 설정할 경우 최적화된 이미지가 오히려 원본 파일보다 용량이 더 커질 수 있으니 주의가 필요합니다.</p>
</blockquote>
<hr>
<h3>priority (우선순위)</h3>
<p>여기서 priority는 Next.js에서 이미지 로딩 시, 어느 이미지를 더 빨리 불러올지 우선순위를 정하는 속성입니다. 예를 들어, 페이지 상단에 보이는 히어로 이미지 같은 경우 priority를 true로 설정하면, 브라우저가 페이지 렌더링 시 해당 이미지를 더 빨리 불러오게 됩니다.</p>
<p>속성을 간단히 정리하면:</p>













<table><thead><tr><th>속성명</th><th>설명</th></tr></thead><tbody><tr><td>priority</td><td>true로 설정하면 해당 이미지에 우선순위를 줘 빠르게 로드</td></tr></tbody></table>
<p>적절하게 priority를 설정하면 사용자 경험이 한층 더 좋아질 수 있으니, 중요한 이미지는 꼭 체크해보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">priority={<span class="hljs-literal">false</span>} <span class="hljs-comment">// {false} | {true}</span>
</code></pre>
<p>이 옵션이 <code>true</code>일 때, Next.js는 해당 이미지를 미리(preload) 불러옵니다. 즉, 이미지가 더 빨리 로드되도록 하는 기능이죠. <strong>중요한 점은, priority가 true일 경우 lazy loading(지연 로딩)이 자동으로 비활성화된다는 것</strong>입니다. 만약 <code>loading</code> 속성을 사용하면서 <code>lazy</code>로 설정하면 <code>priority</code>와 함께 쓸 수 없어요. 그래서 priority가 필요한 이미지에서는 <code>loading</code> 속성을 제거하는 게 좋습니다.</p>
<p>이 속성은 <strong>Largest Contentful Paint(LCP)</strong> 요소로 감지되는 이미지에 주로 사용해야 합니다. LCP란 페이지 로드 시 사용자에게 가장 크게 보이는 콘텐츠를 의미하는데, 이미지가 이 역할을 한다면 빠르게 불러오는 것이 UX 개선에 도움이 되거든요.</p>
<p>뷰포트 크기에 따라 LCP 요소가 달라질 수 있어서, 여러 개의 이미지를 priority로 설정하는 것도 괜찮습니다. 다만, 이 속성은 화면 상단(above the fold)에 보이는 이미지에만 사용하는 게 효과적입니다. 기본값은 <code>false</code>로 설정돼 있어요.</p>
<hr>
<h3>추가 팁!</h3>
<ul>
<li>
<p><strong>priority 이미지가 너무 많으면 어떻게 될까요?</strong><br>
너무 많은 이미지를 미리 불러오면 네트워크에 부담이 갈 수 있으니, 정말 필요한 이미지만 우선순위를 주는 게 좋아요.</p>
</li>
<li>
<p><strong>Next.js의 <code>Image</code> 컴포넌트와 함께 사용</strong><br>
Next.js의 <code>&#x3C;Image /></code> 컴포넌트에서 이 옵션을 쓰면 자동으로 적절한 최적화도 같이 해줘서, 별도로 신경 쓰지 않아도 됩니다.</p>
</li>
<li>
<p><strong>LCP 개선은 SEO에도 좋아요!</strong><br>
페이지 로딩 속도와 사용자 경험 개선은 검색 엔진 최적화(SEO)에도 긍정적인 영향을 주니, 중요한 이미지에는 꼭 priority를 고려해보세요.</p>
</li>
</ul>
<hr>
<p>우리 웹 페이지가 빠르게 렌더링되고, 사용자들이 이미지 때문에 답답해하지 않게 하는 작은 팁 하나였어요! 다음 번에도 더 유용한 개발 꿀팁 가지고 올게요 :)</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>placeholder</h3>
<pre><code class="hljs language-js">placeholder = <span class="hljs-string">'empty'</span> <span class="hljs-comment">// "empty" | "blur" | "data:image/..."</span>
</code></pre>
<p>이미지가 로딩되는 동안 보여줄 자리 표시자(플레이스홀더)를 설정하는 속성입니다. 사용할 수 있는 값은 <code>'empty'</code>, <code>'blur'</code>, 또는 <code>'data:image/...'</code> 형태입니다. 기본값은 <code>'empty'</code>입니다.</p>
<ul>
<li><code>'empty'</code>: 아무 것도 표시하지 않고 그냥 빈 공간으로 둡니다.</li>
<li><code>'blur'</code>: 이미지가 로딩되는 동안 블러 처리된 저해상도 이미지를 보여줍니다. 이때 <code>blurDataURL</code> 속성에 지정된 데이터 URL이 플레이스홀더로 사용돼요.</li>
<li><code>'data:image/...'</code>: 직접 데이터 URL 형태의 이미지를 넣어서 커스텀 플레이스홀더를 설정할 수도 있습니다.</li>
</ul>
<p>특히, <code>blur</code> 옵션은 정적 임포트(static import)로 불러온 <code>.jpg</code>, <code>.png</code>, <code>.webp</code>, <code>.avif</code> 같은 이미지 포맷의 경우 자동으로 <code>blurDataURL</code>이 채워지는데, 만약 애니메이션 이미지라면 이 기능이 적용되지 않습니다.</p>
<p>이 기능 덕분에 이미지가 화면에 깜빡이거나 완전히 로드될 때까지 기다리지 않고, 자연스러운 흐릿한 미리보기를 보여줘서 UX가 훨씬 부드러워진답니다. 요즘 웹사이트에서 흔히 볼 수 있는 '더 좋은 사용자 경험'을 위한 작은 팁이죠!</p>
<p>추가로, <strong>blurDataURL</strong>은 보통 아주 작은 크기의 저해상도 이미지 정보를 base64로 인코딩한 문자열을 의미해요. 직접 생성하기 번거롭다면 자동 생성 도구나 라이브러리를 활용하는 것도 방법입니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>동적 이미지(dynamic images)를 사용할 때는 반드시 <code>blurDataURL</code> 속성을 제공해줘야 해요. 이 속성은 이미지가 로딩되는 동안 보여줄 흐릿한(blurred) 이미지 데이터를 뜻하는데요, 이걸 넣어주면 사용자가 이미지가 완전히 로딩될 때까지 깜빡임 없이 부드러운 경험을 할 수 있답니다.</p>
<p>그런데 이 <code>blurDataURL</code> 값을 직접 만들기 번거로울 수 있죠? 그래서 Plaiceholder 같은 솔루션이 인기를 끌고 있어요. Plaiceholder는 이미지를 자동으로 Base64 포맷으로 변환해서 흐릿한 이미지로 만들어주니까, 요긴하게 쓸 수 있어요.</p>
<p>그리고 만약 이미지 URL이 <code>data:image/...</code> 형식이라면, 이 데이터 URL이 그대로 로딩 중인 플레이스홀더(placeholder)로 사용돼요. 반면에 <code>blurDataURL</code>을 비워두면 로딩 중에 아무 것도 보이지 않고 빈 공간만 남게 되니 주의해야 해요.</p>
<p>쉽게 말해 이런 느낌이에요:</p>





















<table><thead><tr><th><code>blurDataURL</code> 상태</th><th>결과</th></tr></thead><tbody><tr><td>값이 세팅된 경우</td><td>로딩 중 흐릿한 이미지 표시</td></tr><tr><td><code>data:image/...</code> 포맷</td><td>해당 데이터가 로딩 플레이스홀더로 사용됨</td></tr><tr><td>비워둔 경우(빈값)</td><td>로딩 중 빈 공간</td></tr></tbody></table>
<p>직접 써보면서 확인해보세요. 이미지의 로딩 경험이 훨씬 부드러워질 거예요! 혹시 더 자세한 설정 방법이나 Plaiceholder 사용법이 궁금하면 알려주세요~</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>블러(blur) 플레이스홀더 데모</li>
<li>데이터 URL을 이용한 플레이스홀더 프로퍼티로 쉐이머(shimmer) 효과 데모</li>
<li>blurDataURL 프로퍼티를 활용한 컬러 효과 데모</li>
</ul>
<h2>고급 속성 사용법</h2>
<p>때로는 더 복잡한 사용이 필요할 때가 있죠. <code>Image /</code> 컴포넌트는 선택적으로 아래와 같은 고급 속성들을 받을 수 있습니다.</p>
<h3>style (스타일)</h3>
<p>여기서 스타일을 지정해서 이미지에 다양한 시각적 효과를 줄 수 있어요. 예를 들어, 이미지 모서리를 둥글게 하거나, 그림자를 넣는 등 CSS를 직접 적용할 수 있답니다.</p>
<p>이런 고급 props들을 잘 활용하면 더 세련되고 사용자 친화적인 이미지 로딩 경험을 만들 수 있어요!</p>
<p>필요하면 다음에 <code>blurDataURL</code>이나 쉐이머 효과 만들 때 사용하는 데이터 URL 생성 방법도 같이 소개할게요.<br>
편하게 알려드릴 테니 기대해 주세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이미지에 CSS 스타일을 직접 전달할 수 있어요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> imageStyle = {
  <span class="hljs-attr">borderRadius</span>: <span class="hljs-string">'50%'</span>,
  <span class="hljs-attr">border</span>: <span class="hljs-string">'1px solid #fff'</span>,
}
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ProfileImage</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Image</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"..."</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{imageStyle}</span> /></span></span>
}
</code></pre>
<p>여기서 중요한 점! 이미지의 <code>width</code>와 <code>height</code> 속성은 스타일링에 영향을 줄 수 있어요. 만약 CSS 스타일로 이미지의 너비를 조절한다면, 높이는 <code>auto</code>로 설정해줘야 원래 비율을 유지할 수 있습니다. 안 그러면 이미지가 찌그러져 보일 수 있거든요.</p>
<p>예를 들면 이렇게 하면 좋아요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> imageStyle = {
  <span class="hljs-attr">width</span>: <span class="hljs-string">'100px'</span>,
  <span class="hljs-attr">height</span>: <span class="hljs-string">'auto'</span>,
  <span class="hljs-attr">borderRadius</span>: <span class="hljs-string">'50%'</span>,
  <span class="hljs-attr">border</span>: <span class="hljs-string">'1px solid #fff'</span>,
}
</code></pre>
<p>이렇게 하면 너비는 100px로 고정하고, 높이는 자동으로 조절되어 이미지 비율이 깨지지 않죠.</p>
<hr>
<h3>onLoadingComplete</h3>
<p><code>onLoadingComplete</code>는 이미지가 모두 로드된 후에 실행되는 콜백 함수입니다. 이미지 처리나 로딩 상태 관리를 할 때 유용해요.</p>
<p>예를 들어, 이미지가 로드 완료되면 어떤 작업을 하고 싶을 때 이렇게 쓸 수 있어요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ProfileImage</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleLoadingComplete</span> = (<span class="hljs-params"></span>) => {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'이미지가 성공적으로 로드되었습니다!'</span>);
    <span class="hljs-comment">// 여기서 로딩 스피너 숨기기 등 다른 작업을 할 수 있겠죠</span>
  }

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Image</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"..."</span> <span class="hljs-attr">onLoadingComplete</span>=<span class="hljs-string">{handleLoadingComplete}</span> /></span></span>
}
</code></pre>
<p>이 콜백 함수를 활용해서 사용자 경험을 좀 더 부드럽게 만들 수 있어요. 예를 들어 이미지가 로드 중일 때 스피너를 표시하고, 완료되면 스피너를 숨기는 식으로요.</p>
<p>이 부분도 꼭 기억해두세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>안녕하세요, 여러분! 오늘은 Next.js 14에서 Image 컴포넌트의 새로운 변화에 대해 짧게 이야기해보려고 해요.</p>
<p>기존에 아래처럼 <code>onLoadingComplete</code>를 썼던 분들 많으시죠?</p>
<pre><code class="hljs language-js"><span class="hljs-string">'use client'</span>

&#x3C;<span class="hljs-title class_">Image</span> onLoadingComplete={<span class="hljs-function">(<span class="hljs-params">img</span>) =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(img.<span class="hljs-property">naturalWidth</span>)} />
</code></pre>
<p>그런데 Next.js 14부터는 이 <code>onLoadingComplete</code>가 deprecated(더 이상 권장되지 않음) 되었어요. 대신 <code>onLoad</code>라는 새로운 콜백 함수가 도입됐답니다.</p>
<h3>그럼 뭐가 달라졌을까요?</h3>
<ul>
<li><strong><code>onLoad</code></strong> 콜백은 이미지가 완전히 로드되고, 플레이스홀더(placeholder)가 제거된 후에 호출돼요.</li>
<li>이 함수는 실제 <code>&#x3C;img></code> 요소를 인자로 받아요. 그래서 이미지의 크기 정보나 기타 속성을 쉽게 가져올 수 있죠.</li>
</ul>
<h3>바뀐 사용법은 이렇게!</h3>
<pre><code class="hljs language-js"><span class="hljs-string">'use client'</span>

<span class="hljs-keyword">import</span> <span class="hljs-title class_">Image</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'next/image'</span>;

<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Image</span>
  <span class="hljs-attr">src</span>=<span class="hljs-string">"/example.jpg"</span>
  <span class="hljs-attr">width</span>=<span class="hljs-string">{500}</span>
  <span class="hljs-attr">height</span>=<span class="hljs-string">{300}</span>
  <span class="hljs-attr">onLoad</span>=<span class="hljs-string">{(img)</span> =></span> console.log('Image width:', img.naturalWidth)}
/></span>
</code></pre>
<h3>참고!</h3>
<ul>
<li><code>onLoad</code> 안에서 받는 인자는 실제 HTML의 <code>&#x3C;img></code> 엘리먼트이므로, <code>naturalWidth</code>, <code>naturalHeight</code>, <code>currentSrc</code> 같은 DOM 속성에 접근 가능해요.</li>
<li>이전과 달리 <code>onLoadingComplete</code>는 더 이상 공식 문서에서 지원하지 않으니, 꼭 <code>onLoad</code>로 바꾸시는 걸 추천드려요.</li>
</ul>
<hr>
<p>사실 이런 변화는 Next.js가 내부에서 이미지 로딩 과정을 더 효율적이고 통제하기 쉽게 만들기 위한 거라 생각하면 좋아요. 새로운 버전 나오면 공식 문서 체크와 함께 이렇게 바뀐 부분도 챙겨주면 프로젝트 유지보수가 훨씬 편하답니다.</p>
<p>혹시 이미지 로딩과 관련해서 더 궁금한 점 있으면 댓글로 알려주세요! 그럼 즐거운 개발 되세요~ 😊</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<blockquote>
<p>참고할 점: onLoadingComplete 같은 함수 형태의 props를 사용할 때는, 전달한 함수를 직렬화하기 위해 클라이언트 컴포넌트를 사용해야 한다는 점을 기억하세요.</p>
</blockquote>
<h3>onLoad</h3>
<pre><code class="hljs language-js">&#x3C;<span class="hljs-title class_">Image</span> onLoad={<span class="hljs-function">(<span class="hljs-params">e</span>) =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">naturalWidth</span>)} />
</code></pre>
<p>이미지가 완전히 로드되고 플레이스홀더가 사라진 후에 실행되는 콜백 함수입니다.</p>
<hr>
<p>여기에 덧붙여서, onLoad 이벤트는 이미지가 화면에 렌더링 되는 순간을 알 수 있어서, 예를 들어 이미지 크기에 따라 레이아웃을 조절하거나 로딩 상태를 업데이트 하는 데 쓸 수 있어요. 또한, 네트워크 상황이 느릴 때 사용자에게 로딩 완료 시점을 알려주는 용도로도 활용할 수 있답니다.</p>
<p>하지만 Next.js의 Image 컴포넌트를 사용할 때는 내장된 최적화 특징 때문에, "onLoadingComplete"라는 비슷한 이벤트도 함께 제공되니 필요에 따라 적절히 선택해서 사용하세요.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>콜백 함수는 이벤트 객체 하나를 인자로 받게 되는데, 여기서 이벤트의 <code>target</code>은 실제로 렌더된 <code>img</code> 요소를 가리키게 돼요.</p>
<blockquote>
<p>참고할 점: onLoad처럼 함수 형태의 prop을 사용할 때는, 이 함수를 직렬화하기 위해 클라이언트 컴포넌트(Client Components)를 사용해야 해요.</p>
</blockquote>
<h3>onError</h3>
<pre><code class="hljs language-jsx">&#x3C;<span class="hljs-title class_">Image</span> onError={<span class="hljs-function">(<span class="hljs-params">e</span>) =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">id</span>)} />
</code></pre>
<p><code>onError</code>는 이미지 로드에 문제가 생겼을 때 호출되는 콜백 함수예요. 예를 들면, 이미지 URL이 잘못됐거나 서버에서 이미지를 불러올 수 없을 때 이 함수가 실행되죠. 위 코드에서는 에러가 발생한 이미지 엘리먼트의 id 값을 콘솔에 출력하고 있네요.</p>
<p>참고로, 이런 이벤트 핸들러를 사용할 땐 해당 컴포넌트가 클라이언트에서 동작하도록 설정돼 있어야 한다는 점 기억하세요. 특히 Next.js 같은 프레임워크에서는 서버 컴포넌트와 클라이언트 컴포넌트가 구분되어 있어서, 함수가 전달되는 이벤트 핸들러는 클라이언트 컴포넌트에서만 제대로 동작합니다.</p>
<p>혹시 이미지 로드 실패 시 사용자에게 다른 이미지를 보여주거나, 오류 메시지를 띄우고 싶다면 <code>onError</code> 안에서 상태를 변경하거나 별도의 로직을 구현하면 돼요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이미지 로딩에 실패했을 때 호출되는 콜백 함수에 대해 이야기해볼게요.</p>
<hr>
<h3>onError</h3>
<p>이미지 로딩 중 문제가 발생하면 실행되는 함수예요. 예를 들어, 이미지 URL이 잘못되었거나, 서버에 이미지가 없을 때 호출할 수 있죠.</p>
<blockquote>
<p>참고로 알아두면 좋은 점!<br>
<code>onError</code> 같은 콜백 함수를 프로퍼티로 넘기려면, 이 함수를 직렬화(serialization)할 수 있는 <strong>클라이언트 컴포넌트(Client Components)</strong> 안에서 사용해야 해요. 즉, 서버 컴포넌트에서 바로 함수 형태로 넘기면 동작하지 않을 수 있다는 뜻입니다.</p>
</blockquote>
<hr>
<h3>loading 속성</h3>
<pre><code class="hljs language-js">loading = <span class="hljs-string">'lazy'</span> <span class="hljs-comment">// 'lazy' 또는 'eager' 중 선택 가능</span>
</code></pre>
<ul>
<li><code>lazy</code> (지연 로딩): 이미지를 사용자가 실제로 볼 때까지 미뤄서 로딩해요. 페이지 초기 로딩 속도 향상에 도움을 줍니다.</li>
<li><code>eager</code> (즉시 로딩): 페이지가 로드될 때 이미지를 바로 불러와요. 빠른 렌더링이 필요할 때 쓰면 좋아요.</li>
</ul>
<hr>
<p>요즘 웹에서는 지연 로딩이 기본 트렌드인데요, 특히 이미지를 많이 쓰는 페이지는 <code>loading='lazy'</code>를 적용하는 게 퍼포먼스 향상에 크게 이바지한답니다.</p>
<p>간단한 예제도 같이 볼까요?</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">ImageWithFallback</span>(<span class="hljs-params">{ src, alt }</span>) {
  <span class="hljs-keyword">const</span> [error, setError] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;></span>
      {!error ? (
        <span class="hljs-tag">&#x3C;<span class="hljs-name">img</span>
          <span class="hljs-attr">src</span>=<span class="hljs-string">{src}</span>
          <span class="hljs-attr">alt</span>=<span class="hljs-string">{alt}</span>
          <span class="hljs-attr">loading</span>=<span class="hljs-string">"lazy"</span>
          <span class="hljs-attr">onError</span>=<span class="hljs-string">{()</span> =></span> setError(true)}
        />
      ) : (
        <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>이미지를 불러올 수 없습니다.<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
      )}
    <span class="hljs-tag">&#x3C;/></span></span>
  );
}
</code></pre>
<p>이렇게 하면 이미지가 실패할 때 텍스트로 대체 표시도 할 수 있죠.</p>
<hr>
<p>필요에 따라서 <code>onError</code>를 활용해 이미지 교체, 오류 기록, 사용자 알림 등 다양한 작업을 할 수 있으니 기억해두세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이미지 로딩 동작에 대해 이야기해볼게요. 기본값은 <code>lazy</code>인데요, 쉽게 말해 이미지는 화면에 보이기 직전에야 로드되도록 지연시켜서 페이지 로딩 속도를 높여주는 거예요.</p>
<ul>
<li><code>lazy</code>: 이미지가 화면에 가까워질 때까지 로딩을 미뤄요. 예를 들어, 사용자가 스크롤을 내려서 이미지가 보일 타이밍에 이미지를 불러오는 방식이죠. 데이터 소모도 줄이고 페이지가 훨씬 빨리 뜹니다.</li>
<li><code>eager</code>: 이미지가 페이지가 로드될 때 바로 불러와요. 중요한 이미지나 빠르게 보여줘야 할 때 유용하답니다.</li>
</ul>
<p>이 <code>loading</code> 속성 덕분에 개발자들이 웹사이트 성능을 최적화하기가 한결 쉬워졌어요. 자세한 내용을 더 보고 싶다면 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#loading" rel="nofollow" target="_blank">loading attribute에 대해 알아보기</a>에서 확인할 수 있어요.</p>
<p>참고로, <code>lazy</code> 로딩은 모든 브라우저가 지원하는 건 아니라서 필요에 따라 자바스크립트로 폴리필을 적용하는 경우도 있어요. 또한, 이미지가 중요한 정보라면 <code>eager</code>를 선택하는 게 사용자 경험에 더 좋을 수 있으니 상황에 맞게 잘 활용해보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>blurDataURL</h3>
<p>blurDataURL은 이미지가 로드되기 전에 임시로 보여줄 작은 이미지를 Base64 형태로 지정할 때 사용해요. 쉽게 말해서, 실제 이미지가 로딩되기 전 잠깐 나타나는 ‘흐릿한 미리보기’ 같은 역할이죠.</p>
<p>주의할 점은 이 값이 반영되려면 꼭 placeholder="blur"와 함께 써야 한다는 거예요!</p>
<p>또, blurDataURL에 넣는 이미지는 아주 작고 간단한 게 좋아요. 보통 10px 이하 크기의 이미지가 적당한데요, 그 이유는 이 이미지가 화면에 확대되고 흐려지면서 보여지기 때문이에요. 너무 큰 이미지를 넣으면 앱 성능에 안 좋을 수 있거든요.</p>
<p>예를 들어 마크다운으로 표현하면 이렇게 써볼 수 있어요:</p>

















<table><thead><tr><th>속성명</th><th>설명</th></tr></thead><tbody><tr><td>blurDataURL</td><td>로드 전에 쓰이는 미리보기 이미지의 Base64 인코딩 데이터</td></tr><tr><td>placeholder</td><td><code>'blur'</code>으로 설정해서 blurDataURL과 함께 사용해야 효과를 볼 수 있음</td></tr></tbody></table>
<p>이걸 활용하면 사용자 경험이 조금 더 매끄러워져서, 이미지가 늦게 뜰 때도 갑자기 빈 화면이 나오는 걸 방지할 수 있어요. 웹이나 앱에서 이미지가 무거워 딜레이가 있을 때 정말 유용하답니다.</p>
<p>직접 써보는 것도 추천해요! 예를 들어, Next.js의 Image 컴포넌트에서 자주 쓰이는 기능이라, 관심 있으면 찾아보시면 도움이 많이 될 겁니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>기본 blurDataURL prop 사용법 데모</li>
<li>blurDataURL prop를 이용한 색상 효과 데모</li>
</ul>
<p>이미지와 어울리는 단색 색상 Data URL도 생성할 수 있어요.</p>
<h3>unoptimized 옵션</h3>
<pre><code class="hljs language-js">unoptimized = {<span class="hljs-literal">false</span>} <span class="hljs-comment">// false 또는 true 값 사용 가능</span>
</code></pre>
<hr>
<p>조금 더 설명을 덧붙이자면, <code>blurDataURL</code>은 이미지가 로딩되기 전까지 잠깐 보여줄 작은 저해상도 이미지의 URL이에요. 흔히 ‘로딩 플레이스홀더’로 활용하죠. 특히 네트워크 속도가 느릴 때 사용자에게 부드러운 경험을 선사할 수 있어요.</p>
<p><code>unoptimized</code> 옵션은 Next.js에서 이미지 최적화를 끌지 말지를 결정하는 건데요. 기본값은 <code>false</code>로 최적화 기능을 켜둔 상태고, <code>true</code>로 설정하면 최적화를 끄고 원본 이미지를 그대로 사용하게 돼요. 개발 과정에서 최적화 문제를 피하거나 특정 상황에서 이미지를 그대로 사용하고 싶을 때 유용합니다.</p>
<p>그리고 색상 효과를 내는 blurDataURL도 많이 활용되는데요, 실제 이미지와 비슷한 톤의 단색을 blurDataURL로 만들어 놓으면 로딩 시 배경색처럼 자연스럽게 보일 수 있어요. 이 방법은 이미지가 로딩되는 동안 사용자 시각 경험을 더 좋게 만들어주니까 개발할 때 한 번쯤 적용해 보는 걸 추천드려요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>원본 이미지를 <code>src</code>에서 그대로 내보내고 싶을 때, 즉 퀄리티나 크기, 포맷을 변경하지 않을 때는 <code>unoptimized</code> 속성을 <code>true</code>로 설정하면 됩니다. 기본값은 <code>false</code>입니다.</p>
<p>이렇게 하는 게 특히 좋은 경우는 최적화를 해도 큰 이점이 없는 이미지들이에요. 예를 들어, 아주 작은 이미지(1KB 이하), 벡터 이미지(SVG), 또는 움직이는 이미지(GIF) 등이 그 예입니다.</p>
<p>아래는 간단한 사용 예시입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Image</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'next/image'</span>

<span class="hljs-keyword">const</span> <span class="hljs-title function_">UnoptimizedImage</span> = (<span class="hljs-params">props</span>) => {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Image</span> {<span class="hljs-attr">...props</span>} <span class="hljs-attr">unoptimized</span> /></span></span>
}
</code></pre>
<p>그리고 Next.js 12.3.0부터는 모든 이미지에 대해 <code>unoptimized</code> 옵션을 기본으로 적용하려면 <code>next.config.js</code> 파일에 다음과 같은 설정을 추가하면 됩니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// next.config.js</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">images</span>: {
    <span class="hljs-attr">unoptimized</span>: <span class="hljs-literal">true</span>,
  },
}
</code></pre>
<p>이렇게 설정하면 개별 이미지마다 <code>unoptimized</code> 속성을 일일이 지정하지 않아도 되니 관리가 훨씬 편해져요.</p>
<p>추가로, 최적화를 비활성화하면 이미지가 CDN이나 외부 최적화 서비스 없이 그대로 제공되므로, 속도나 용량 활용 측면에서 체크가 필요합니다. 그래서 보통은 작은 이미지나 이미 최적화된 SVG, GIF에만 적용하는 것을 추천드려요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>여러분, Next.js에서 이미지 최적화 관련 설정해보셨나요? 오늘은 간단하게 <code>next.config.js</code>에서 이미지 최적화를 비활성화하는 법과, <code>Image</code> 컴포넌트에 <code>src</code>를 넘겨줄 때 어떤 일이 일어나는지 살펴보겠습니다.</p>
<hr>
<h3>이미지 최적화 끄기</h3>
<p>Next.js는 기본적으로 이미지 최적화를 자동으로 해주는데요, 가끔은 직접 최적화하지 않고 원본 이미지를 그대로 쓰고 싶을 때가 있죠. 그럴 때 <code>next.config.js</code> 파일에 이렇게 설정하면 됩니다:</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">images</span>: {
    <span class="hljs-attr">unoptimized</span>: <span class="hljs-literal">true</span>,
  },
}
</code></pre>
<p>이렇게 하면 Next.js가 이미지 최적화를 건너뛰고, 여러분이 지정한 이미지가 그대로 사용돼요.</p>
<hr>
<h3><code>Image</code> 컴포넌트의 <code>src</code> 프로퍼티</h3>
<p>그리고 <code>Image</code> 컴포넌트에 <code>src</code> 값을 넘기면, 내부적으로 <code>srcset</code> 과 <code>src</code> 속성이 자동으로 생성돼서 결국 HTML의 <code>&#x3C;img></code> 태그로 변환됩니다.</p>
<p>예를 들어:</p>
<pre><code class="hljs language-js">&#x3C;<span class="hljs-title class_">Image</span> src=<span class="hljs-string">"/me.jpg"</span> />
</code></pre>
<p>이렇게 쓰면 Next.js가 자동으로 화면 크기에 맞는 여러 해상도의 이미지 URL을 만들어서 <code>srcset</code>에 넣어주고, 동시에 기본 <code>src</code> 도 넣어줘서 브라우저가 가장 적합한 이미지를 골라서 보여주게 하는 거죠.</p>
<p>이 부분이 왜 좋냐면, 반응형 이미지 처리가 훨씬 편하고, 성능도 좋아진다는 점입니다!</p>
<hr>
<h3>팁! 이미지 최적화 관련 기억할 점</h3>
<ul>
<li><code>unoptimized: true</code>를 쓰면 캐싱이나 최적화가 없기 때문에, 프로덕션에서 할 때는 성능 저하가 있을 수 있으니 주의하세요.</li>
<li><code>next/image</code> 컴포넌트를 쓸 때는 반드시 <code>width</code>와 <code>height</code>를 지정하는 게 좋습니다. 그래야 레이아웃이 안정적으로 잡히고 CLS(Cumulative Layout Shift)를 줄일 수 있어요.</li>
<li>외부 도메인의 이미지를 쓸 때는 <code>next.config.js</code>에 도메인 허용 설정을 해줘야 합니다.</li>
</ul>
<blockquote>
<p>그리고 혹시 더 깊게 이미지 최적화를 알아보고 싶으면, <code>next/image</code> 공식 문서도 한번 들여다보시면 정말 많은 팁들이 숨어있답니다!</p>
</blockquote>
<p>오늘은 여기까지! 필요할 때마다 참고하시고, 이미지 최적화도 똑똑하게 활용해 보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>안녕하세요! 오늘은 Next.js 이미지 컴포넌트(Image) 사용 시, <code>src</code> 속성 자동 생성 문제와 이를 우회하는 방법에 대해 알아볼게요.</p>
<p>보통 <code>&#x3C;img></code> 태그를 사용하면 이렇게 srcset과 src를 직접 지정하잖아요?</p>
<pre><code class="hljs language-html"><span class="hljs-tag">&#x3C;<span class="hljs-name">img</span>
  <span class="hljs-attr">srcset</span>=<span class="hljs-string">"
    /_next/image?url=%2Fme.jpg&#x26;w=640&#x26;q=75 1x,
    /_next/image?url=%2Fme.jpg&#x26;w=828&#x26;q=75 2x
  "</span>
  <span class="hljs-attr">src</span>=<span class="hljs-string">"/_next/image?url=%2Fme.jpg&#x26;w=828&#x26;q=75"</span>
/></span>
</code></pre>
<p>근데 Next.js의 <code>&#x3C;Image></code> 컴포넌트를 쓰면 내부적으로 <code>src</code>와 <code>srcset</code>을 자동으로 생성해줘요. 다 좋은데, 가끔은 이 자동 생성된 <code>src</code>를 우리가 직접 지정하고 싶을 때가 있죠. 예를 들어, 기존 웹사이트를 <code>img</code>에서 <code>Image</code> 컴포넌트로 바꿀 때, SEO 최적화를 위해 이미지 URL을 그대로 유지하고 싶을 수도 있어요. (검색엔진 최적화, 이미지 랭킹 유지 및 재크롤 방지 목적 등)</p>
<p>그럴 때 사용하는 게 바로 <code>overrideSrc</code> prop 입니다.</p>
<pre><code class="hljs language-jsx">&#x3C;<span class="hljs-title class_">Image</span> src=<span class="hljs-string">"/me.jpg"</span> overrideSrc=<span class="hljs-string">"/override.jpg"</span> />
</code></pre>
<p>이렇게 하면 내부적으로는 <code>/me.jpg</code>로 이미지 최적화 및 로딩 처리를 하면서도, 실제 <code>src</code> 속성은 <code>/override.jpg</code>로 지정할 수 있어요.</p>
<p>🎯 핵심 정리!</p>

















<table><thead><tr><th>상황</th><th>해결법</th></tr></thead><tbody><tr><td>기본적으로 자동 생성된 src 쓰기 원함</td><td>그냥 <code>&#x3C;Image src="..." /></code> 사용</td></tr><tr><td>SEO 등 이미지 URL을 유지해야 할 때</td><td><code>&#x3C;Image src="..." overrideSrc="..." /></code> 사용</td></tr></tbody></table>
<hr>
<p>추가 팁!</p>
<ul>
<li>이미지 최적화는 Next.js가 자동으로 해주지만, SEO를 위해 실제 보여지는 HTML 속성 값을 직접 관리해야 할 때가 있어서 이렇게 <code>overrideSrc</code>가 유용해요.</li>
<li>오버라이드 한 URL이 실제 이미지가 맞는지, 접근 가능 여부는 미리 확인하는 게 좋습니다.</li>
<li><code>overrideSrc</code>는 Next.js 공식 문서에 나오는 기능은 아닌 경우가 많아서, 직접 구현하거나 커스텀 이미지 컴포넌트를 만들어 사용하는 방법도 있어요!</li>
</ul>
<p>Next.js 이미지 컴포넌트를 다룰 때 이런 작은 팁들이 개발 생산성도 올려주고, SEO 챙기는데도 크게 도움 된답니다. 다음에도 유용한 정보로 찾아올게요! 😄</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>아래 코드는 <code>&#x3C;img></code> 태그에서 <code>srcset</code>과 <code>src</code> 속성을 활용하는 예시입니다.</p>
<pre><code class="hljs language-js">&#x3C;img
  srcset=<span class="hljs-string">"
    /_next/image?url=%2Fme.jpg&#x26;w=640&#x26;q=75 1x,
    /_next/image?url=%2Fme.jpg&#x26;w=828&#x26;q=75 2x
  "</span>
  src=<span class="hljs-string">"/override.jpg"</span>
/>
</code></pre>
<h3>간단 정리</h3>
<ul>
<li><code>srcset</code>은 브라우저가 디바이스 해상도에 맞는 이미지를 선택해서 로드할 수 있도록 도와줘요.</li>
<li>위 예시에서는 1배(640px)와 2배(828px) 해상도의 이미지를 준비해뒀죠.</li>
<li><code>src</code>는 기본 이미지 URL로, <code>srcset</code>을 지원하지 않는 구형 브라우저에서 사용돼요.</li>
</ul>
<hr>
<h3>decoding 속성에 대해서</h3>
<p>브라우저에 이미지의 디코딩(화면에 보여주기 위해 이미지 데이터를 해석하는 과정)을 어떻게 처리할지 힌트를 주는 속성이에요. 기본값은 <code>async</code>로, 비동기적으로 디코딩해서 페이지 렌더링 속도에 도움을 줘요.</p>





















<table><thead><tr><th>속성값</th><th>설명</th></tr></thead><tbody><tr><td>sync</td><td>이미지 디코딩이 끝날 때까지 렌더링을 중단해요. 주요 이미지에 적합.</td></tr><tr><td>async</td><td>디코딩을 비동기 처리해요. 기본값이며, 렌더링에 지장 없어요.</td></tr><tr><td>auto</td><td>브라우저가 최적의 전략으로 디코딩 방식을 결정해요.</td></tr></tbody></table>
<h3>왜 <code>decoding</code>을 신경 써야 할까?</h3>
<p>이미지가 많은 페이지에서 디코딩 방식을 잘 설정하면, 페이지 렌더링이 훨씬 부드러워지고 사용자 경험이 좋아집니다. 특히 중요한 이미지나 첫 화면에 노출되는 이미지가 있다면 <code>sync</code>로 설정해서 바로 보이게 하는 것도 방법이에요.</p>
<hr>
<h3>한 가지 팁!</h3>
<p><code>loading="lazy"</code> 속성과 함께 쓰면, 이미지가 화면 근처에 올 때만 로드하고, 디코딩도 적절히 조절할 수 있어서 성능 최적화에 더 도움이 됩니다.</p>
<pre><code class="hljs language-html"><span class="hljs-tag">&#x3C;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"image.jpg"</span> <span class="hljs-attr">decoding</span>=<span class="hljs-string">"async"</span> <span class="hljs-attr">loading</span>=<span class="hljs-string">"lazy"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"example"</span> /></span>
</code></pre>
<hr>
<p>이렇게 이미지 관련 속성들을 적절히 이해하고 사용하면, 웹 페이지의 성능과 사용자 경험을 크게 개선할 수 있어요. 다음에도 좋은 팁으로 또 만나요! 😊</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>async: 이미지를 비동기적으로 디코딩해서, 이미지 로딩이 완료되기 전에도 다른 콘텐츠가 먼저 렌더링될 수 있게 해줘요.</li>
<li>sync: 이미지를 동기적으로 디코딩해서, 다른 콘텐츠와 함께 완전하게 한 번에 보여주고 싶을 때 사용해요.</li>
<li>auto: 디코딩 모드에 대한 특별한 선호 없이 브라우저가 가장 적절하다고 판단하는 방식을 선택하게 합니다.</li>
</ul>
<p>디코딩 속성(decoding attribute)에 대해 더 궁금하다면, 자세한 정보를 찾아보는 것도 좋아요. 이미지 로딩 방식에 따라 페이지 렌더링 속도나 사용자 경험이 달라질 수 있으니까요.</p>
<h3>다른 속성들 (Other Props)</h3>
<p><code>Image</code> 컴포넌트에 넣는 다른 모든 속성들은, 특별히 제한된 몇 가지를 제외한 채로 실제 <code>&#x3C;img></code> 태그에 그대로 전달됩니다.<br>
즉, 일반적인 <code>alt</code>, <code>width</code>, <code>height</code> 같은 속성들은 걱정 없이 사용할 수 있죠.</p>
<hr>
<p>추가로 알려드리자면, 이미지 디코딩 방식은 특히 페이지가 많이 복잡하거나 이미지가 많은 경우 성능에 꽤 큰 영향을 줄 수 있어요. 예를 들어, <code>async</code>로 둬서 텍스트 같은 중요한 콘텐츠가 먼저 보이게 하면 사용자 경험이 더 좋아질 수 있답니다. 반면, UI가 깔끔하게 한꺼번에 보여지는 게 중요한 경우엔 <code>sync</code>를 선택하는 게 좋고요.</p>
<p>꼭 상황에 맞게 선택해 주세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>srcSet 대신 Device Sizes를 사용하세요.</li>
</ul>
<h2>설정 옵션</h2>
<p>다음은 props 외에 next.config.js 파일에서 Image 컴포넌트를 설정할 수 있는 옵션들입니다. 이 옵션들을 통해 이미지 최적화 동작을 세밀하게 조절할 수 있어요.</p>
<h3>localPatterns</h3>
<p>(localPatterns 옵션에 대한 설명이 더 있으면 여기에 추가하면 좋겠지만, 지금은 제목만 주셨네요. 만약 이미지 경로나 패턴을 로컬 이미지 관리에 사용한다면, 이 옵션이 어떤 역할을 하는지 간단히 정리해볼게요.)</p>
<p>localPatterns는 로컬 이미지 파일 경로나 패턴들을 지정하는 옵션입니다. 예를 들어, 특정 폴더 내 이미지 파일만 이미지 최적화 대상에 포함하거나 특정 형식의 파일만 처리하도록 할 때 유용하답니다. 이렇게 하면 불필요한 파일까지 빌드 과정에 포함되는 걸 막아 최적화를 더욱 깔끔하게 할 수 있어요.</p>
<hr>
<p>추가로 srcSet과 Device Sizes에 대해 조금 더 알려드릴게요.</p>
<h3>srcSet 대신 Device Sizes 사용하기</h3>
<p>예전에는 이미지 태그에 srcSet 속성을 직접 지정해서 여러 해상도 대응 이미지를 넘겨주곤 했는데요, Next.js Image 컴포넌트에서는 deviceSizes 배열을 통해 대응할 화면 너비별 이미지 사이즈를 미리 지정합니다. 그러면 Next.js가 자동으로 가장 적합한 이미지 크기를 골라 srcSet을 만들어서 넣어줘 개발자가 직접 일일이 srcSet을 관리할 필요가 사라지죠.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// next.config.js 예시</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">images</span>: {
    <span class="hljs-attr">deviceSizes</span>: [<span class="hljs-number">320</span>, <span class="hljs-number">420</span>, <span class="hljs-number">768</span>, <span class="hljs-number">1024</span>, <span class="hljs-number">1200</span>],
  },
};
</code></pre>
<p>이런 식으로 설정하면 각 기기별 스크린 크기에 맞는 이미지가 제공되어 더욱 빠르고 효율적인 이미지 로딩이 가능해져요.</p>
<p>어려운 설정 같아 보여도, Next.js가 알아서 다 해주니까 걱정하지 마세요. 대신 나만의 이미지 정책에 맞게 deviceSizes 같은 옵션을 적절히 조정해주면 됩니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Next.js에서 이미지 최적화를 할 때, 특정 경로만 최적화 대상으로 지정하고 싶다면 <code>next.config.js</code> 파일에서 <code>localPatterns</code> 옵션을 활용할 수 있어요. 이 옵션을 사용하면 내가 원하는 경로만 이미지를 최적화하고, 그 외의 경로에 대해서는 요청을 차단할 수 있답니다.</p>
<p>예를 들어, 아래처럼 설정하면 <code>/assets/images/</code>로 시작하는 로컬 이미지 경로만 최적화가 허용되고, 쿼리 스트링이 붙은 경로는 허용되지 않아요.</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">images</span>: {
    <span class="hljs-attr">localPatterns</span>: [
      {
        <span class="hljs-attr">pathname</span>: <span class="hljs-string">'/assets/images/**'</span>,
        <span class="hljs-attr">search</span>: <span class="hljs-string">''</span>,
      },
    ],
  },
}
</code></pre>
<blockquote>
<p>참고로, 위 설정을 적용하면 <code>next/image</code> 컴포넌트의 <code>src</code> 속성이 <code>/assets/images/</code>로 시작하지 않거나 쿼리 스트링이 포함된 경우, 요청이 400 Bad Request로 처리됩니다. 따라서 불필요한 경로나 잘못된 요청을 막는 데 유용해요.</p>
</blockquote>
<p>또한, <code>localPatterns</code> 외에도 <code>remotePatterns</code>라는 옵션도 있는데, 이것은 외부 도메인의 이미지를 최적화 대상으로 설정할 때 사용됩니다. 다음에 이어서 <code>remotePatterns</code>에 대해서도 알아볼게요.</p>
<p>이렇게 경로를 명확하게 지정해주면 보안 측면에서도 도움이 되고, 최적화 대상이 한정되니 관리도 편해지니 꼭 활용해보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Next.js에서 외부 이미지를 사용할 때, 보안을 위해 외부 이미지에 대한 설정이 필요해요. 이렇게 해야 악의적인 사용자가 다른 도메인의 이미지를 마음대로 불러오는 걸 막을 수 있답니다.</p>
<p>Next.js는 외부 이미지를 Next.js Image Optimization API를 통해 제공하는데, 이때 <code>remotePatterns</code> 설정을 통해 내 계정에서 사용할 수 있는 외부 이미지 URL 패턴을 지정할 수 있어요. 이렇게 지정하면 지정된 도메인과 경로에 해당하는 이미지들만 안전하게 불러올 수 있습니다.</p>
<h3>Next.js 15.3.0 이상 버전</h3>
<p>아래처럼 <code>next.config.js</code> 파일에 <code>remotePatterns</code>에 <code>new URL</code> 객체로 패턴을 지정해주면 돼요.</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">images</span>: {
    <span class="hljs-attr">remotePatterns</span>: [<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'https://example.com/account123/**'</span>)],
  },
}
</code></pre>
<h3>Next.js 15.3.0 미만 버전</h3>
<p>이전 버전에서는 <code>remotePatterns</code>를 객체 형태로 설정해줘야 하는데, 조금 더 자세하게 프로토콜, 호스트명, 포트, 경로 등을 나눠서 작성해줍니다.</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">images</span>: {
    <span class="hljs-attr">remotePatterns</span>: [
      {
        <span class="hljs-attr">protocol</span>: <span class="hljs-string">'https'</span>,
        <span class="hljs-attr">hostname</span>: <span class="hljs-string">'example.com'</span>,
        <span class="hljs-attr">port</span>: <span class="hljs-string">''</span>,
        <span class="hljs-attr">pathname</span>: <span class="hljs-string">'/account123/**'</span>,
        <span class="hljs-attr">search</span>: <span class="hljs-string">''</span>,
      },
    ],
  },
}
</code></pre>
<hr>
<h3>추가 팁</h3>
<ul>
<li><code>pathname</code>에서 <code>/**</code>는 와일드카드로, 해당 경로 이하의 모든 이미지 경로를 허용한다는 뜻이에요. 필요에 따라 경로를 더 구체적으로 설정해주세요.</li>
<li>만약 여러 도메인에서 이미지를 불러와야 한다면, <code>remotePatterns</code> 안에 여러 패턴을 배열 형태로 추가하면 됩니다.</li>
<li>보안을 위해 믿을 수 있는 도메인만 허용하는 게 가장 좋아요! 나중에 이미지 도메인이 바뀐다면 꼭 이 설정도 함께 업데이트해줘야 합니다.</li>
</ul>
<p>앱에서 이미지를 최적화하면서도 보안도 챙기려면 이런 설정, 꼭 잊지 말고 해주세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>next/image 컴포넌트를 사용할 때 외부 이미지 도메인을 어떻게 안전하게 설정할 수 있는지 아시나요? 이번에 알려드릴 내용은 Next.js의 <code>next.config.js</code> 파일에 <code>remotePatterns</code> 옵션을 활용하는 방법입니다.</p>
<hr>
<p>먼저, 이렇게 설정하면 이미지 URL이 꼭 <code>https://example.com/account123/</code>로 시작해야 하고, 쿼리 스트링은 없어야 해요. 다른 프로토콜(예: http), 호스트 이름, 포트 번호, 혹은 경로가 일치하지 않으면 400 Bad Request 에러가 발생합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">images</span>: {
    <span class="hljs-attr">remotePatterns</span>: [
      {
        <span class="hljs-attr">protocol</span>: <span class="hljs-string">'https'</span>,
        <span class="hljs-attr">hostname</span>: <span class="hljs-string">'example.com'</span>,
        <span class="hljs-attr">port</span>: <span class="hljs-string">''</span>,
        <span class="hljs-attr">pathname</span>: <span class="hljs-string">'/account123/**'</span>,
        <span class="hljs-attr">search</span>: <span class="hljs-string">''</span>,
      },
    ],
  },
}
</code></pre>
<p>이렇게 해두면 고정된 경로 패턴을 안전하게 지정할 수 있어요. 근데 만약 여러 서브도메인이 있는 경우라면 어떻게 할까요?</p>
<hr>
<p>그럴 때는 와일드카드 패턴을 활용할 수 있어요! 예를 들어, 아래 설정은 https 프로토콜에, <code>img1.example.com</code> 또는 <code>me.avatar.example.com</code> 같은 여러 서브도메인을 모두 허용합니다. 하지만 포트는 없고 쿼리 스트링도 없어야 하죠.</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">images</span>: {
    <span class="hljs-attr">remotePatterns</span>: [
      {
        <span class="hljs-attr">protocol</span>: <span class="hljs-string">'https'</span>,
        <span class="hljs-attr">hostname</span>: <span class="hljs-string">'**.example.com'</span>,
        <span class="hljs-attr">port</span>: <span class="hljs-string">''</span>,
        <span class="hljs-attr">search</span>: <span class="hljs-string">''</span>,
      },
    ],
  },
}
</code></pre>
<hr>



































<table><thead><tr><th>속성</th><th>의미</th><th>예시 값</th></tr></thead><tbody><tr><td>protocol</td><td>허용할 프로토콜 (http, https 등)</td><td>'https'</td></tr><tr><td>hostname</td><td>호스트 이름, 와일드카드 가능(**)</td><td>'**.example.com'</td></tr><tr><td>port</td><td>포트 번호 (빈 문자열은 포트 없음)</td><td>''</td></tr><tr><td>pathname</td><td>경로 (글로벌 와일드카드 /** 가능)</td><td>'/account123/**'</td></tr><tr><td>search</td><td>쿼리 스트링 (빈 문자열은 쿼리 없음)</td><td>''</td></tr></tbody></table>
<hr>
<blockquote>
<p>참고로, <code>remotePatterns</code> 안에 경로를 지정하려면 <code>pathname</code> 속성을 꼭 써야 해요. 위 첫번째 예제에서 <code>/account123/**</code>처럼 사용하구요!</p>
</blockquote>
<p>이 기능 덕분에 보안도 챙기면서 다양한 도메인에서 이미지를 마음껏 불러올 수 있답니다. 특히 외부 이미지가 많은 프로젝트에서는 꼭 살펴봐야 할 설정이에요.</p>
<hr>
<p>요약하자면,</p>
<ul>
<li><code>remotePatterns</code>를 쓰면 이미지 허용 도메인을 세밀하게 설정할 수 있어요.</li>
<li>와일드카드를 활용해 여러 서브도메인도 한방에 통제 가능합니다.</li>
<li>프로토콜, 포트, 쿼리스트링까지 꼼꼼히 설정 가능해 오류를 줄이고 보안도 강화할 수 있죠.</li>
</ul>
<p>이렇게 하시면 Next.js 프로젝트에서 안전하게 외부 이미지를 관리할 수 있어서, 성능과 안정성을 함께 챙길 수 있답니다! 혹시 더 궁금한 점 있으면 언제든지 댓글로 물어봐 주세요~</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>와일드카드 패턴은 경로 이름(pathname)과 호스트 이름(hostname) 모두에 사용할 수 있는데, 다음과 같은 문법을 가지고 있어요:</p>
<ul>
<li><code>*</code> : 한 개의 경로 세그먼트(path segment) 또는 서브도메인(subdomain)에 대응해요.</li>
<li><code>**</code> : 경로 세그먼트가 끝부분에 여러 개 있을 때, 또는 서브도메인이 시작 부분에 여러 개 있을 때 모두 매칭해요.</li>
</ul>
<p>단, <code>**</code> 문법은 패턴 중간에는 사용할 수 없다는 점 참고하세요!</p>
<blockquote>
<p><strong>알아두면 좋은 점</strong>: 프로토콜, 포트, 경로(pathname), 검색(search) 정보를 생략하면 자동으로 와일드카드 <code>**</code>가 포함된 것으로 간주돼요. 하지만 이 방법은 권장하지 않아요. 왜냐하면 의도치 않은 URL까지 매칭되어 악의적인 사용자의 공격에 노출될 수 있기 때문이에요.</p>
</blockquote>
<hr>
<p>조금 더 부연하자면, 와일드카드를 사용할 때는 어떤 부분에 얼마만큼 유연함을 줄지 꼭 신중히 결정해야 해요. 특히, <code>**</code>는 매우 강력한 매칭이 되기 때문에 보안상 위험할 수 있으니, 가능한 최소한으로 사용하는 걸 추천합니다.</p>
<p>예를 들어, 호스트네임에 <code>*.example.com</code>은 <code>abc.example.com</code>에는 매칭되지만, <code>xyz.abc.example.com</code>까지는 포함하지 않아요. 반면 <code>**.example.com</code>이라면 여러 개의 서브도메인을 복수로 포함하는 경우에 사용하죠.</p>
<p>이런 와일드카드 패턴 활용법을 잘 이해하면, URL 필터링이나 라우팅 기능을 구현할 때 훨씬 편리하게 조건을 작성할 수 있어요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>next.config.js에서 remotePatterns 속성에 search 옵션을 사용하는 예시를 보여드릴게요:</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">images</span>: {
    <span class="hljs-attr">remotePatterns</span>: [
      {
        <span class="hljs-attr">protocol</span>: <span class="hljs-string">'https'</span>,
        <span class="hljs-attr">hostname</span>: <span class="hljs-string">'assets.example.com'</span>,
        <span class="hljs-attr">search</span>: <span class="hljs-string">'?v=1727111025337'</span>,
      },
    ],
  },
}
</code></pre>
<blockquote>
<p>참고할 점: 위 예시는 next/image 컴포넌트의 src 값이 <code>https://assets.example.com</code>으로 시작해야 하고, 쿼리 스트링이 정확히 <code>?v=1727111025337</code> 로 일치해야만 이미지를 불러올 수 있다는 뜻이에요. 만약 프로토콜이나 쿼리 스트링이 다르면 400 Bad Request 오류가 발생할 수 있습니다.</p>
</blockquote>
<p>이렇게 remotePatterns에 search 값을 명시하면, URL 매칭 조건을 엄격하게 설정할 수 있어서 보안이나 캐시 관리를 조금 더 세밀하게 할 수 있어요.</p>
<h3>domains와의 차이점</h3>
<p><code>domains</code> 속성은 단순히 hostname 기반으로 이미지를 허용하는 반면, <code>remotePatterns</code>는 프로토콜, 호스트명, 경로, 포트, 검색(쿼리)까지 좀 더 자세히 지정할 수 있다는 점에서 훨씬 유연해요. 만약 특정 쿼리를 포함한 URL만 받고 싶다면 <code>remotePatterns</code>를 사용하세요.</p>
<p>예를 들어, 다음은 domains와 remotePatterns의 비교입니다:</p>




















<table><thead><tr><th>속성명</th><th>설명</th><th>유연성</th></tr></thead><tbody><tr><td>domains</td><td>도메인 이름만 지정, 간단히 허용 목록 작성 가능</td><td>낮음</td></tr><tr><td>remotePatterns</td><td>프로토콜, 호스트, 경로, 검색 등 세부적으로 지정 가능</td><td>매우 높음</td></tr></tbody></table>
<p>개발할 때 이렇게 쿼리 스트링까지 조건에 넣으면, 이미지 요청에서 인증 토큰이나 버전 관리 같은 정보를 활용할 때도 편리해요.</p>
<p>필요에 따라 여러분 프로젝트에 맞는 방식을 선택해서 사용해 보면 좋겠네요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Next.js 14부터는 remotePatterns라는 엄격한 설정 방식을 권장하면서, 기존의 domains 설정이 점점 Deprecated(사용 중단)되고 있다는 경고가 나오는 경우가 많아요.</p>
<p>왜 그러냐면, domains 설정은 외부 이미지 도메인을 허용하는 데는 편리하지만, 와일드카드 패턴 매칭이 안 되고, 프로토콜(https, http), 포트, 경로나 쿼리 스트링 같은 세밀한 조건을 제한할 수가 없거든요. 즉, 보안 측면에서 좀 허술할 수 있어요. 특히 도메인의 모든 콘텐츠를 소유하지 않은 경우에는 위험할 수도 있어요.</p>
<p>대신 remotePatterns는 이런 부분을 세밀하게 지정할 수 있어서, 악성 사용자가 이미지 요청을 조작해 공격하는 걸 막아줄 수 있답니다.</p>
<hr>
<h3>domains 설정 예시 (next.config.js)</h3>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">images</span>: {
    <span class="hljs-attr">domains</span>: [<span class="hljs-string">'example.com'</span>, <span class="hljs-string">'cdn.example.com'</span>],
  },
};
</code></pre>
<p>위처럼 도메인을 배열로 넣어주면, 해당 도메인에 있는 외부 이미지들을 Next.js 이미지 최적화 기능과 함께 쓸 수 있어요. 하지만 프로토콜이나 경로는 제한하지 못하고, 와일드카드(*)도 안 돼서 살짝 아쉽죠.</p>
<hr>
<h3>추가로, remotePatterns 설정법은?</h3>
<p>만약 <code>remotePatterns</code>를 써보고 싶다면, 이렇게 쓸 수 있어요:</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">images</span>: {
    <span class="hljs-attr">remotePatterns</span>: [
      {
        <span class="hljs-attr">protocol</span>: <span class="hljs-string">'https'</span>,
        <span class="hljs-attr">hostname</span>: <span class="hljs-string">'example.com'</span>,
        <span class="hljs-attr">port</span>: <span class="hljs-string">''</span>,
        <span class="hljs-attr">pathname</span>: <span class="hljs-string">'/images/**'</span>,
      },
    ],
  },
};
</code></pre>
<p>이렇게 하면 <code>https://example.com/images/</code> 하위 경로만 허용하는 식으로 훨씬 정밀한 제어가 가능해요. 물론, Next.js 14 이상이어야 지원됩니다.</p>
<hr>
<h3>정리하자면</h3>
<ul>
<li>domains는 간단하지만 제한적이고 보안 취약점이 있을 수 있으니 조심!</li>
<li>remotePatterns는 더 엄격하고 안전한 설정 방법</li>
<li>여러분이 도메인 소유주가 아니면 remotePatterns 추천!</li>
</ul>
<p>개발하면서 이미지 도메인 설정할 때 참고하시고, 가능하면 최신 방식인 remotePatterns로 업데이트해보세요! 안전한 앱 만드는 데 큰 도움이 될 거예요.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>여러분, Next.js에서 이미지 최적화를 할 때 기본 API 대신 클라우드 제공업체를 이용하고 싶을 때가 있죠? 그럴 땐 next.config.js 파일에서 loaderFile 옵션을 활용해서 커스텀 로더를 설정할 수 있어요.</p>
<p>먼저 기본적으로 도메인을 설정해주는 예제를 볼게요:</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">images</span>: {
    <span class="hljs-attr">domains</span>: [<span class="hljs-string">'assets.acme.com'</span>], <span class="hljs-comment">// 여기서 외부 이미지 도메인을 지정해줘요.</span>
  },
}
</code></pre>
<p>이렇게 하면 Next.js가 <code>assets.acme.com</code>에서 가져오는 이미지를 허용하고 최적화할 수 있게 됩니다.</p>
<p>그런데 만약 클라우드 제공업체(예: Cloudinary, Imgix 등)를 직접 써서 이미지 최적화를 맡기고 싶으면 어떻게 할까요? 이때는 <code>loaderFile</code> 옵션을 사용해서 커스텀 이미지 로더를 지정하면 돼요. 예시는 아래와 같습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">images</span>: {
    <span class="hljs-attr">loader</span>: <span class="hljs-string">'custom'</span>,               <span class="hljs-comment">// 커스텀 로더 사용 선언</span>
    <span class="hljs-attr">loaderFile</span>: <span class="hljs-string">'./my/image/loader.js'</span>, <span class="hljs-comment">// 직접 만든 로더 파일 경로</span>
  },
}
</code></pre>
<h3>여기서 중요한 점</h3>
<ul>
<li><code>loader</code>는 <code>'default'</code>, <code>'imgix'</code>, <code>'cloudinary'</code>, <code>'akamai'</code> 등 미리 준비된 옵션도 있지만, <code>custom</code>을 쓰면 직접 로더 코드를 만들어 제어할 수 있습니다.</li>
<li><code>loaderFile</code>에 적힌 파일에서는 함수가 export되어 있어야 하며, 이미지 URL과 원하는 크기 등을 인자로 받아 최종 이미지 URL을 반환해야 해요.</li>
</ul>
<p>예를 들어, <code>./my/image/loader.js</code> 파일은 대략 이런 모양일 수 있어요:</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">(<span class="hljs-params">{ src, width, quality }</span>) =></span> {
  <span class="hljs-keyword">return</span> <span class="hljs-string">`https://your-cloud-provider.com/<span class="hljs-subst">${src}</span>?w=<span class="hljs-subst">${width}</span>&#x26;q=<span class="hljs-subst">${quality || <span class="hljs-number">75</span>}</span>`</span>
}
</code></pre>
<p>이렇게 하면 Next.js가 이미지 최적화를 요청할 때 이 커스텀 로더를 거쳐 이미지 URL을 생성하고, 클라우드에서 최적화된 이미지를 받아 올 수 있습니다.</p>
<hr>
<p>요약하자면, Next.js의 이미지 컴포넌트는 기본 제공 API로도 훌륭하지만, 자신만의 클라우드 서비스나 특별한 최적화 방식을 쓰고 싶을 땐 <code>loader</code>를 <code>'custom'</code>으로 설정하고, <code>loaderFile</code>에서 직접 URL 생성 방식을 관리하면 완전 내 맘대로 컨트롤할 수 있어 편리하답니다!</p>
<p>더 궁금하면 언제든 질문 주세요~</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Next.js에서 이미지 로더를 설정할 때, <code>loader</code> 파일은 반드시 Next.js 애플리케이션 루트 기준으로 상대 경로를 가리켜야 합니다. 이 파일에서는 기본(default)로 문자열을 반환하는 함수 하나를 export해야 하는데요, 예를 들어 아래처럼 작성할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-string">'use client'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">myImageLoader</span>(<span class="hljs-params">{ src, width, quality }</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">`https://example.com/<span class="hljs-subst">${src}</span>?w=<span class="hljs-subst">${width}</span>&#x26;q=<span class="hljs-subst">${quality || <span class="hljs-number">75</span>}</span>`</span>
}
</code></pre>
<p>여기서 <code>src</code>는 이미지 경로, <code>width</code>는 요청할 이미지의 너비, <code>quality</code>는 이미지 품질(기본 75)인데요, 함수가 최종적으로 반환하는 문자열은 이미지 URL이 됩니다. 이 방식을 쓰면 이미지 요청을 커스터마이징할 수 있어서 CDN이나 외부 이미지 서버와 연동할 때 아주 유용하답니다.</p>
<hr>
<p>그리고 꼭 파일 하나에 넣어야 한다고 생각하지 마세요! Next.js <code>next/image</code> 컴포넌트의 <code>loader</code> 프롭에도 직접 함수를 넘겨줄 수 있어요. 이렇게 하면 각 이미지마다 다른 로더를 쓸 수도 있어서 더욱 유연한 관리가 가능합니다.</p>
<p>아래는 두 가지 예시입니다:</p>




















<table><thead><tr><th>구분</th><th>설명</th><th>코드</th></tr></thead><tbody><tr><td>1. loader 파일 사용</td><td>루트에 파일 만들어서 재사용</td><td>js 'use client' export default function myImageLoader({ src, width, quality }) { return `<a href="https://example.com/$%7Bsrc%7D?w=$%7Bwidth%7D&#x26;q=$%7Bquality" rel="nofollow" target="_blank">https://example.com/${src}?w=${width}&#x26;q=${quality</a></td></tr><tr><td>2. loader prop 사용</td><td>이미지 컴포넌트마다 다르게 설정</td><td>jsx import Image from 'next/image'; const myImageLoader = ({ src, width, quality }) => { return `<a href="https://example.com/$%7Bsrc%7D?w=$%7Bwidth%7D&#x26;q=$%7Bquality" rel="nofollow" target="_blank">https://example.com/${src}?w=${width}&#x26;q=${quality</a></td></tr></tbody></table>
<hr>
<p>Tip!</p>
<ul>
<li><code>loader</code> 함수가 반환하는 URL은 클라이언트가 실제로 접근 가능한 주소여야 해요. 내부 경로나 상대 경로를 그대로 쓰면 안 됩니다.</li>
<li>품질(<code>quality</code>) 옵션을 넣는 이유는 이미지 크기와 품질간 밸런스를 맞추기 위해서인데, 기본값은 75이지만 필요에 따라 조절하세요.</li>
<li>공식 Next.js 문서(<a href="https://nextjs.org/docs/api-reference/next/image#loader)%EC%97%90%EC%84%9C%EB%8F%84" rel="nofollow" target="_blank">https://nextjs.org/docs/api-reference/next/image#loader)에서도</a> 다양한 예제를 참고할 수 있어요.</li>
</ul>
<p>이미지 요청 경로 다루는 게 어렵게 느껴질 수 있는데, 이런 사용자 정의 로더를 잘 활용하면 서버 부담도 줄이고, 이미지 로딩 속도도 개선할 수 있답니다! 궁금하면 꼭 한 번 시도해 보세요.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>커스텀 이미지 로더 설정</li>
</ul>
<blockquote>
<p>참고할 점: 이미지 로더 파일을 커스터마이징할 때 함수(function)를 넘겨줘야 하는데, 이 함수는 Client Components에서 직렬화(serialization) 과정을 거쳐야 제대로 작동해요.</p>
</blockquote>
<h2>고급 설정</h2>
<p>아래 설정들은 주로 고급 사용자들을 위한 내용이에요. 보통은 건드릴 필요가 없고, 만약 이 설정들을 직접 바꾸면 향후 Next.js 업데이트 시 기본 설정이 변경돼도 자동 반영되지 않으니 주의가 필요해요.</p>
<hr>
<p>사실 이미지 로더를 직접 커스터마이징하는 경우는 주로 이미지 처리 방식을 세밀하게 조정하고 싶을 때입니다. 예를 들면, 이미지 CDN을 직접 지정하거나, 특정 포맷 변환, 압축 옵션을 다루고 싶을 때 쓰이죠. 하지만 대부분 프로젝트에서는 Next.js가 제공하는 기본 이미지 로더로 충분한 성능과 편리함을 느낄 수 있으니, 특별한 이유가 없다면 기본 설정을 유지하는 게 안정적입니다.</p>
<p>필요하다면 Client Component에서 커스텀 함수를 어떻게 직렬화하는지 추가 예제도 나중에 소개할게요.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>deviceSizes</h3>
<p>만약 여러분이 타겟하려는 사용자들이 주로 사용하는 디바이스의 화면 너비를 알고 있다면, <code>next.config.js</code> 파일에서 <code>deviceSizes</code>라는 속성에 해당 너비들을 지정할 수 있어요. 이렇게 지정해주면, <code>next/image</code> 컴포넌트가 <code>sizes</code> 속성을 사용할 때 사용자의 디바이스에 가장 적합한 이미지 크기를 골라서 제공할 수 있게 됩니다.</p>
<p>만약 별도로 설정하지 않으면, Next.js는 기본값으로 아래와 같은 디바이스 크기들을 사용해요.</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">images</span>: {
    <span class="hljs-attr">deviceSizes</span>: [<span class="hljs-number">640</span>, <span class="hljs-number">750</span>, <span class="hljs-number">828</span>, <span class="hljs-number">1080</span>, <span class="hljs-number">1200</span>, <span class="hljs-number">1920</span>, <span class="hljs-number">2048</span>, <span class="hljs-number">3840</span>],
  },
}
</code></pre>
































<table><thead><tr><th>기본 deviceSizes 값</th></tr></thead><tbody><tr><td>640</td></tr><tr><td>750</td></tr><tr><td>828</td></tr><tr><td>1080</td></tr><tr><td>1200</td></tr><tr><td>1920</td></tr><tr><td>2048</td></tr><tr><td>3840</td></tr></tbody></table>
<hr>
<p>이걸 설정하는 가장 큰 장점은 이미지 최적화에서 효율성! 예를 들어, 모바일 사용자에게 굳이 큰 해상도의 이미지를 내려주면 데이터 낭비가 심하잖아요. 그런데 이걸 활용하면 크고 작은 여러 버전의 이미지가 준비되어서, 각각의 디바이스에 최적화된 이미지를 업로드 없이 자동으로 빠르게 제공해주니까요.</p>
<p>추가로, <code>deviceSizes</code>와 비슷하게 <code>imageSizes</code>라는 옵션도 있는데요, 이건 고정된 이미지 크기(아이콘 같은 작은 이미지)들을 지정할 때 유용해요. 보통 <code>deviceSizes</code>는 반응형 이미지에, <code>imageSizes</code>는 고정 사이즈 이미지에 활용한다고 이해하시면 좋아요.</p>
<p>실제로 프로젝트에 맞춰 이 값들을 잘 조절하면 성능이 확연히 개선되는 걸 체감할 수 있으니 한 번 프로젝트에 적용해보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>imageSizes란?</h3>
<p>Next.js에서 <code>next.config.js</code> 파일 안에 <code>images.imageSizes</code>라는 속성을 통해 <strong>이미지 너비 리스트를 직접 지정</strong>할 수 있어요. 이 리스트는 <code>deviceSizes</code>라는 또 다른 배열과 합쳐져서, 이미지의 <code>srcset</code>을 생성할 때 사용되는 전체 크기 배열을 만든답니다.</p>
<p>그런데 왜 두 개의 리스트가 따로 있냐고요? 그 이유는, <code>imageSizes</code>는 <strong>이미지에 <code>sizes</code> 속성이 제공될 때만 사용</strong>돼요. 즉, <code>sizes</code> prop이 있으면 이 이미지는 화면 전체 너비를 쓰는 게 아니라, 화면보다 작은 크기로 보여준다는 의미거든요. 그래서 <code>imageSizes</code>에 들어가는 값들은 항상 <code>deviceSizes</code>의 가장 작은 크기보다 작아야 해요. 이것은 이미지가 너무 커서 불필요한 리소스를 쓰는 걸 방지해줍니다.</p>
<p>만약 여러분이 따로 설정을 안 해주면 Next.js가 기본값을 사용하게 돼요.</p>
<hr>
<h4>추가로 알아두면 좋은 점!</h4>
<ul>
<li><code>deviceSizes</code>는 주로 일반적인 기기 화면 크기를 기준으로 하며, Next.js가 자동으로 기본값을 제공하지만, 상황에 맞게 조정할 수도 있어요.</li>
<li>예를 들어, 모바일 최적화가 매우 중요하거나, 특정 컴포넌트가 작은 이미지 크기를 주로 쓴다면, <code>imageSizes</code>를 알맞게 지정해주면 네트워크 대역폭 절약과 빠른 로딩에 도움이 됩니다.</li>
<li>또한, Image 컴포넌트에서 <code>sizes</code> prop을 사용하면, 당신이 지정한 <code>imageSizes</code> 배열에 맞게 다양한 이미지를 브라우저가 선택하게 됩니다.</li>
</ul>
<hr>
<p>아래는 각 속성별 기본값이 어떻게 설정되어 있는지 참고해보세요.</p>




















<table><thead><tr><th>속성 이름</th><th>기본값</th><th>설명</th></tr></thead><tbody><tr><td>deviceSizes</td><td>[640, 750, 828, 1080, 1200, 1920, 2048, 3840]</td><td>대표적인 기기 너비 배열</td></tr><tr><td>imageSizes</td><td>[16, 32, 48, 64, 96]</td><td><code>sizes</code> prop이 있는 이미지에 사용되는 작고 세밀한 너비 배열</td></tr></tbody></table>
<p>요렇게 이해하면 Next.js 이미지 최적화가 좀 더 명확해지실 거예요! 혹시 이미지 로딩 최적화 팁에 관심 있으면 또 알려드릴게요~</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>오늘은 Next.js에서 이미지 최적화 설정하는 방법에 대해 쉽고 간단하게 알아볼게요. 이미지 크기와 퀄리티(quality)를 직접 설정해서 웹사이트 로딩 속도와 사용자 경험을 개선할 수 있답니다.</p>
<hr>
<h3>이미지 크기 (<code>imageSizes</code>) 설정하기</h3>
<p>Next.js의 기본 이미지 최적화 API는 여러 크기의 이미지를 자동으로 만드는데요. 만약 이 크기를 내가 원하는 크기로 지정하고 싶다면 <code>next.config.js</code> 파일에 <code>imageSizes</code>를 설정하면 돼요.</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">images</span>: {
    <span class="hljs-attr">imageSizes</span>: [<span class="hljs-number">16</span>, <span class="hljs-number">32</span>, <span class="hljs-number">48</span>, <span class="hljs-number">64</span>, <span class="hljs-number">96</span>, <span class="hljs-number">128</span>, <span class="hljs-number">256</span>, <span class="hljs-number">384</span>],
  },
}
</code></pre>
<p>위 코드에서 이미지 사이즈 배열에 들어간 숫자들은 픽셀 단위의 너비를 의미해요. 예를 들어 16은 16px 너비의 이미지를 생성한단 뜻이죠. 이 설정을 참고해서 사이트에 필요한 크기만 지정하면 불필요한 이미지 생성과 트래픽을 줄일 수 있어요.</p>
<hr>
<h3>이미지 퀄리티 (<code>qualities</code>) 제한하기</h3>
<p>기본적으로 Next.js는 이미지 퀄리티를 1부터 100까지 모두 허용해요. 근데 세부적으로 퀄리티를 제한하고 싶을 때는 이렇게 해볼 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">images</span>: {
    <span class="hljs-attr">qualities</span>: [<span class="hljs-number">25</span>, <span class="hljs-number">50</span>, <span class="hljs-number">75</span>],
  },
}
</code></pre>
<p>이렇게 하면 오직 25%, 50%, 75% 퀄리티만 이미지 최적화 API에서 허용하게 돼요. 덕분에 최대한 이미지 품질과 용량을 조절할 수 있죠. 예를 들어, 퀄리티를 너무 낮게 하면 화질이 떨어져 사용자 경험이 나빠질 수 있으니, 적당한 균형을 찾는 게 중요해요!</p>
<hr>
<h3>참고로 더 알아두면 좋은 팁</h3>
<ul>
<li><code>imageSizes</code>는 기본적으로 <code>[16, 32, 48, 64, 96, 128, 256, 384]</code> 크기들이 포함돼 있지만, 커스텀 사이즈 추가 가능해요.</li>
<li><code>imageSizes</code>는 사이즈 지정에 사용하고, 실제 사용할 수 있는 이미지 최대 크기는 <code>deviceSizes</code>에서 설정할 수 있어요.</li>
<li>퀄리티 제한을 할 때는 일반적으로 75~80 정도가 적당히 고화질과 적당한 용량의 밸런스로 추천됩니다.</li>
<li>더 나아가 <code>formats</code> 설정을 이용해서 WebP, AVIF 등 최신 이미지 포맷으로 변환하는 것도 가능하니까 같이 고려해보세요!</li>
</ul>
<hr>
<h3>마무리</h3>
<p>Next.js 이미지 최적화 세팅은 웹 속도를 개선하고 사용자 경험을 올리는 데 적절한 이미지 크기와 퀄리티를 직접 정할 수 있어 정말 편리해요. 사이트 규모와 용도에 맞춰서 적절하게 설정해 보시길 추천드려요!</p>
<p>앞으로도 이런 실용적인 팁들 많이 공유할게요. 언제든 질문 주세요~!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>위 예시에서는 허용되는 품질 값이 25, 50, 75 세 가지로 정해져 있어요. quality prop에 이 배열에 없는 값이 들어가면, 이미지 요청이 실패하면서 400 Bad Request 에러가 발생합니다. 그러니까 품질 설정할 때는 꼭 허용된 값 중에서 선택해야 한다는 점 꼭 기억하세요!</p>
<h3>formats</h3>
<p>기본적으로 Image Optimization API는 요청에 포함된 브라우저의 Accept 헤더를 통해 어떤 이미지 포맷을 지원하는지 자동으로 감지합니다. 이 정보를 바탕으로 가장 최적화된 출력 포맷을 선택해주는 거죠.</p>
<p>여기서 중요한 점은 만약 Accept 헤더에 여러 개의 지원 포맷이 포함되어 있다면, 미리 설정된 formats 배열에서 가장 먼저 일치하는 포맷을 사용한다는 것입니다. 즉, 배열의 순서가 정말 중요해요! 만약 일치하는 포맷이 없거나, 원본 이미지가 애니메이션 GIF 같은 특수한 경우라면, API는 원본 이미지 포맷을 그대로 반환합니다.</p>
<p>이 부분을 이해하면, 이미지 최적화를 하면서도 호환성을 최대한 보장할 수 있고, 불필요한 에러도 막을 수 있으니 꼭 참고하세요!</p>
<p>아래는 요점 정리한 표예요:</p>

























<table><thead><tr><th>키워드</th><th>설명</th></tr></thead><tbody><tr><td>quality</td><td>허용값은 25, 50, 75. 배열 외 값 입력 시 400 Bad Request 발생</td></tr><tr><td>Accept 헤더</td><td>브라우저가 지원하는 이미지 포맷 정보를 포함하는 HTTP 헤더</td></tr><tr><td>formats 배열</td><td>Accept 헤더와 비교해 출력 포맷을 결정. 배열 내 순서가 최종 포맷 선택에 중요</td></tr><tr><td>Fallback</td><td>일치하는 포맷 없거나 애니메이션 이미지일 경우 원본 포맷 사용</td></tr></tbody></table>
<p>이렇게 정리해두면 이미지 최적화 설정할 때 훨씬 이해가 쉬워질 거예요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>설정을 따로 해주지 않으면 기본값으로 아래와 같은 설정이 적용돼요.</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">images</span>: {
    <span class="hljs-attr">formats</span>: [<span class="hljs-string">'image/webp'</span>],
  },
}
</code></pre>
<p>여기서 <code>formats</code>는 이미지 최적화를 위해 어떤 포맷을 사용할지 지정하는 옵션인데요, 기본값은 <code>webp</code> 포맷이에요. <code>webp</code>는 구글에서 만든 이미지 포맷으로, JPG나 PNG보다 용량을 줄이면서도 화질 손실이 적어 많이 쓰이죠.</p>
<p>그리고 만약 AVIF 포맷을 사용해보고 싶다면, 이렇게 바꿔주면 돼요.</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">images</span>: {
    <span class="hljs-attr">formats</span>: [<span class="hljs-string">'image/avif'</span>],
  },
}
</code></pre>
<p>AVIF는 최근에 각광받는 이미지 포맷으로, <code>webp</code>보다 압축률이 더 좋고 화질도 뛰어나지만 아직 모든 브라우저에서 완벽하게 지원하는 건 아니에요. 그래서 위 설정처럼 넣으면, 브라우저가 AVIF를 지원하지 않을 땐 원본 이미지 포맷을 대신 보여줘서 큰 문제가 없답니다.</p>
<p>참고로, <code>formats</code> 배열에 여러 포맷을 넣어서 동시에 지원하게 할 수도 있어요. 예를 들어 내비게이션이 상황에 맞게 최적화된 포맷을 골라주도록 하려면 이렇게 할 수 있죠.</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">images</span>: {
    <span class="hljs-attr">formats</span>: [<span class="hljs-string">'image/avif'</span>, <span class="hljs-string">'image/webp'</span>],
  },
}
</code></pre>
<p>이렇게 하면 AVIF를 우선 시도하고, 지원하지 않으면 webp, 또 그마저 지원하지 않으면 원본 이미지로 자동으로 fallback 해준답니다.</p>
<p>요즘은 이미지 최적화를 하는 게 페이지 로딩 속도 개선에 큰 도움이 되니까, 이런 포맷 지정은 꼭 활용해보길 추천해요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<blockquote>
<p>참고할 점:
대부분의 경우에는 여전히 WebP 형식을 사용하는 것을 추천해요.
AVIF는 인코딩하는 데 WebP보다 약 50% 더 시간이 걸리지만, 압축률은 약 20% 더 좋아서 파일 크기가 더 작아진답니다. 그래서 이미지를 처음 요청할 때는 속도가 조금 느릴 수 있지만, 캐시된 이후에는 훨씬 빠르게 로드돼요.
만약 Next.js 앞에 Proxy나 CDN을 직접 운영한다면, 반드시 Proxy가 <code>Accept</code> 헤더를 전달하도록 설정해줘야 해요. 이 부분을 놓치면 최적화된 이미지가 제대로 제공되지 않을 수 있거든요.</p>
</blockquote>
<h2>캐싱 동작 방식</h2>
<p>기본 이미지 로더의 캐싱 알고리즘은 다음과 같아요. 다른 로더를 사용한다면 클라우드 제공업체의 문서를 참고하는 게 좋아요.</p>
<p>이미지는 요청 시 동적으로 최적화되고, 프로젝트의 <code>distDir/cache/images</code> 디렉터리에 저장돼요. 이렇게 최적화된 이미지는 만료 시간이 도달할 때까지 이후 요청에 동일하게 제공됩니다. 만약 요청한 이미지가 캐시돼있지만 만료되었다면, 서버는 만료된(오래된) 이미지를 바로 보여주고, 백그라운드에서는 이미지를 다시 최적화(재검증)해서 새 캐시와 만료 시간으로 업데이트합니다.</p>
<hr>
<p>이렇게 하면 처음 사용자에게도 최소한의 지연만 주면서 최신 이미지를 유지하는 효율적인 캐싱 전략이 구현되는 거죠. 실제로 운영할 때는 압축률과 인코딩 속도, 그리고 캐시 만료 정책을 적절히 조절하는 게 중요해요. CDN이나 프록시를 쓴다면, <code>Accept</code> 헤더가 제대로 전달되는지 꼭 확인해서 원하는 포맷으로 이미지를 제공받도록 하는 것도 핵심입니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이미지 캐시 상태를 확인할 때는 <code>x-nextjs-cache</code>라는 응답 헤더 값을 보면 됩니다. 이 헤더가 가리키는 값은 보통 다음 세 가지 중 하나예요:</p>





















<table><thead><tr><th>캐시 상태</th><th>설명</th></tr></thead><tbody><tr><td>MISS</td><td>경로가 캐시에 없다는 뜻이에요. 보통 이건 처음 한번, 첫 방문할 때 발생해요.</td></tr><tr><td>STALE</td><td>경로가 캐시에 있긴 한데, 재검증(revalidate) 시간이 초과돼서 백그라운드에서 업데이트가 진행 중인 경우입니다.</td></tr><tr><td>HIT</td><td>경로가 캐시에 있고, 재검증 시간이 지나지 않았을 때를 의미해요.</td></tr></tbody></table>
<p>캐시 만료 시간(정확히 말하면 Max Age)은 <code>minimumCacheTTL</code> 설정값과 업스트림 이미지의 <code>Cache-Control</code> 헤더 중 더 큰 값으로 정해집니다. 여기서 <code>Cache-Control</code> 헤더의 <code>max-age</code> 값을 기준으로 하는데, 만약 <code>s-maxage</code>와 <code>max-age</code> 둘 다 있으면 <code>s-maxage</code>가 우선입니다. 그리고 이 <code>max-age</code> 값은 CDN이나 브라우저 같은 하위 클라이언트에게도 그대로 전달돼요.</p>
<p>그리고 몇 가지 팁을 드리면:</p>
<ul>
<li><code>minimumCacheTTL</code>을 설정하면, 업스트림 이미지에서 Cache-Control 헤더가 없거나 너무 낮을 때 캐시 지속 시간을 인위적으로 늘릴 수 있어요.</li>
<li><code>deviceSizes</code>와 <code>imageSizes</code>를 잘 설정해서 생성되는 이미지 종류(사이즈)를 줄이면 서버의 부하도 줄이고 캐시 효율도 높일 수 있어요.</li>
<li><code>formats</code> 설정으로 여러 이미지 포맷 생성을 끄고, 한 가지 포맷만 사용하도록 할 수도 있어요. 이건 클라이언트의 호환성이나 트래픽 관리에 도움됩니다.</li>
</ul>
<p>이렇게 캐시 설정을 적절히 조절하면, 이미지 로딩 속도 향상과 서버 비용 절감 두 마리 토끼를 잡을 수 있으니, 꼭 한 번 살펴보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>minimumCacheTTL</h3>
<p>이미지 최적화 캐시의 TTL(Time to Live), 즉 이미지가 캐시에서 살아있는 시간을 초 단위로 설정할 수 있어요.</p>
<p>사실 대부분의 경우에는 <strong>Static Image Import</strong> 방식을 쓰는 게 더 좋아요. 이 방법은 파일 내용을 자동으로 해시(hash)해서 캐시를 사실상 영구적으로 유지하는 효과가 있고, <code>Cache-Control</code> 헤더에 <code>immutable</code>이 설정돼서 브라우저가 굳이 자주 새로 다운로드하지 않게 해주거든요.</p>
<p>만약 따로 설정하지 않으면 기본값으로 아래 설정이 사용됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">images</span>: {
    <span class="hljs-attr">minimumCacheTTL</span>: <span class="hljs-number">60</span>, <span class="hljs-comment">// 1분 간 캐시 유지</span>
  },
}
</code></pre>
<h3>추가 팁!</h3>
<ul>
<li>TTL을 너무 짧게 하면 캐시를 자주 새로 받아서 서버 부하가 늘어나고, 반대로 너무 길게 설정하면 오래된 이미지가 사용될 수도 있어요.</li>
<li>그래서 가능하면 정적 이미지(import 방식)를 활용하는 게 좋고, 동적으로 변경될 가능성이 있는 이미지만 TTL을 적절히 조절하는 방식을 추천드립니다.</li>
<li>만약 이미지가 자주 변경되는 편이라면 TTL을 짧게, 그렇지 않으면 길게 잡는 게 무난해요.</li>
</ul>
<p>이렇게 적절한 캐시 설정으로 웹사이트 속도와 사용자 경험을 더 좋게 만들어 보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이미지 최적화할 때 TTL(Time To Live)을 늘려서 재검증(revalidation) 횟수를 줄이고, 그 결과 비용 절감 효과를 기대할 수 있어요. 예를 들어, Next.js 내 설정 파일에서 이렇게 써주면 돼요:</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">images</span>: {
    <span class="hljs-attr">minimumCacheTTL</span>: <span class="hljs-number">2678400</span>, <span class="hljs-comment">// 31일 (초 단위)</span>
  },
};
</code></pre>
<p>여기서 <code>minimumCacheTTL</code>은 이미지가 캐시에 머무르는 최소 시간을 의미해요. 최적화된 이미지의 만료 시간(또는 Max Age)은 이 값과 원본 이미지 서버가 보내는 <code>Cache-Control</code> 헤더 중 더 긴 쪽을 따르게 됩니다.</p>
<p>만약 이미지마다 캐싱 정책을 다르게 하고 싶다면, 최적화 요청이 가는 <code>/_next/image</code> 경로가 아니라 원본 이미지 경로(예: <code>/some-asset.jpg</code>)에 직접 <code>Cache-Control</code> 헤더를 설정해야 합니다. 그렇지 않으면 모든 이미지가 같은 캐시 정책을 따르게 돼요.</p>
<p>참고로, TTL을 너무 길게 잡으면 업데이트된 이미지가 바로 반영되지 않을 수 있으니, 상황에 맞게 적절한 기간을 선택하는 게 좋아요. 개발 중에는 짧게, 배포 환경에선 길게 설정하는 방식도 괜찮겠죠? 그리고 이미지 캐싱 전략은 비용뿐만 아니라 사용자 경험에도 큰 영향을 주니 신중하게 고민해보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>지금은 캐시를 무효화할 수 있는 별도의 방법이 없기 때문에, minimumCacheTTL 값을 낮게 설정하는 게 좋아요. 그렇지 않으면 src 속성을 직접 변경하거나, <code>distDir</code>/cache/images 폴더를 수동으로 삭제해야 할 수도 있어요.</p>
<h3>disableStaticImages</h3>
<p>기본 설정으로는 <code>import icon from './icon.png'</code>처럼 정적 파일을 임포트해서 src 속성에 바로 전달할 수 있어요.</p>
<p>하지만 어떤 경우에는, 다른 플러그인과 충돌이 일어나서 임포트가 다르게 동작해야 할 때가 있어요. 그럴 때 이 기능을 끄는 옵션이 바로 <code>disableStaticImages</code>입니다.</p>
<hr>
<p>한 가지 팁을 더 드리자면, 이미지 캐시를 적절히 관리하지 않으면 개발 중에 변경 사항이 바로 반영되지 않아 꽤 답답할 수 있어요. 그래서 개발 모드에서는 캐시 TTL을 낮게 설정하거나, 필요할 땐 수동으로 캐시를 삭제하는 습관을 들이면 좋습니다. 또한, 플러그인 간 충돌을 미리 파악해서 <code>disableStaticImages</code> 옵션을 활용하면 예상치 못한 문제도 피할 수 있답니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Next.js에서 static 이미지 임포트를 비활성화하고 싶다면, <code>next.config.js</code> 파일에 아래와 같이 설정할 수 있어요:</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">images</span>: {
    <span class="hljs-attr">disableStaticImages</span>: <span class="hljs-literal">true</span>,
  },
}
</code></pre>
<p>이 설정을 하면 정적 이미지 임포트를 끄게 되어, 이미지 파일들을 직접 import 하는 방식 대신 다른 방법으로 이미지를 다루게 돼요. 예를 들어, public 폴더에 이미지를 두고 경로로만 접근하는 방식이죠.</p>
<hr>
<h3>dangerouslyAllowSVG 옵션에 대해</h3>
<p>Next.js 기본 이미지 로더는 SVG 최적화를 지원하지 않는데, 그 이유는 두 가지가 있어요.</p>
<ol>
<li><strong>SVG는 벡터 이미지라서 크기를 조절해도 화질 손실이 없어요.</strong> 그렇기 때문에 변형 과정이 딱히 필요 없죠.</li>
<li><strong>SVG 파일은 HTML/CSS와 비슷한 특성을 갖고 있어서, 제대로 된 Content Security Policy(CSP) 헤더 없이는 보안 취약점이 생길 수 있어요.</strong></li>
</ol>
<p>그래서 <code>dangerouslyAllowSVG</code> 옵션이 있긴 하지만, 이걸 사용할 땐 보안에 특히 신경 써야 해요. SVG를 사용하면서 보안 문제가 걱정된다면, SVG를 컴포넌트 형태로 다루거나 외부에서 안전하게 처리한 뒤 사용하는 걸 추천합니다.</p>
<hr>
<h3>추가 팁!</h3>
<ul>
<li>만약 SVG를 React 컴포넌트처럼 사용하고 싶다면, <code>@svgr/webpack</code>을 쓰는 방법도 있어요. 이걸 쓰면 SVG를 import 해서 SVG 컴포넌트로 만들 수 있죠.</li>
<li>그리고 이미지 최적화는 Next.js 이미지 컴포넌트의 핵심 기능 중 하나니까, 가능하면 static 이미지 임포트 기능을 끄기보다는 제대로 활용하는 걸 추천해요.</li>
</ul>
<p>이런 설정 하나하나 이해하고 적용하다 보면 Next.js에서 이미지 다루는 법에 자신감이 생길 거예요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그래서 src 속성이 SVG임이 확실할 때는 unoptimized 속성을 사용하는 걸 추천해요. 실제로 src가 ".svg"로 끝날 때는 이 부분이 자동으로 적용됩니다.</p>
<p>하지만 만약 기본 이미지 최적화 API를 사용해서 SVG 이미지를 제공해야 한다면, next.config.js 파일 안에 dangerouslyAllowSVG 옵션을 설정할 수 있어요:</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">images</span>: {
    <span class="hljs-attr">dangerouslyAllowSVG</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">contentDispositionType</span>: <span class="hljs-string">'attachment'</span>,
    <span class="hljs-attr">contentSecurityPolicy</span>: <span class="hljs-string">"default-src 'self'; script-src 'none'; sandbox;"</span>,
  },
}
</code></pre>
<p>여기서 주의할 점은, SVG 이미지가 종종 악성 스크립트를 포함할 수 있어서 보안 면에서 취약할 수 있다는 거예요. 그래서 contentDispositionType을 'attachment'로 설정해서 브라우저가 이미지를 그냥 보여주는 게 아니라 다운로드하도록 강제하는 걸 추천하고, contentSecurityPolicy를 지정해서 이미지 안에 숨어있는 스크립트가 실행되지 못하도록 막는 것이 매우 중요하답니다.</p>
<p>참고로, SVG는 벡터 이미지라서 해상도에 상관없이 선명한 장점이 있지만, 안전하지 않은 SVG를 그대로 사용하면 XSS 공격에 노출될 수 있으니, 가능하면 신뢰할 수 있는 SVG만 쓰거나 이런 보안 설정을 꼭 해주세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>contentDispositionType</h3>
<p>기본적으로 이미지 로더(loader)는 <code>Content-Disposition</code> 헤더를 <code>attachment</code>로 설정합니다. 이 설정이 중요한 이유는 API가 원격 이미지를 임의로 불러올 수 있기 때문에 보안을 강화하기 위해서예요.</p>

















<table><thead><tr><th>설정값</th><th>설명</th></tr></thead><tbody><tr><td>attachment</td><td>브라우저가 이미지를 직접 방문하면 다운로드하도록 강제함 (기본값)</td></tr><tr><td>inline</td><td>브라우저가 이미지를 직접 방문했을 때 바로 렌더링해서 보여줌</td></tr></tbody></table>
<p>특히, <code>dangerouslyAllowSVG</code> 옵션이 켜져 있을 경우 <code>attachment</code>로 설정하는 것이 더 안전합니다. SVG 파일은 악성코드로 악용될 수 있기 때문에, 무조건 다운받게 만들어서 브라우저가 바로 실행하지 못하게 하는 거죠.</p>
<p>하지만 경우에 따라서는 직접 이미지를 방문했을 때 다운로드 받는 게 아니라 바로 화면에 표시되길 원할 수도 있어요. 이런 때는 <code>contentDispositionType</code>을 <code>inline</code>으로 설정하면 됩니다. 그러면 URL을 브라우저에 직접 입력했을 때도 이미지가 바로 보이게 되죠.</p>
<hr>
<h3>추가 팁!</h3>
<ul>
<li>만약 내 서비스에서 외부에서 임의로 이미지를 불러오는걸 허용한다면, 보안에 신경 써서 꼭 <code>attachment</code>로 두세요.</li>
<li>SVG는 특히 조심해야 하니, 내장 SVG가 아닌 외부 SVG를 불러올 때는 <code>inline</code>보다는 <code>attachment</code>를 추천해요.</li>
<li>하지만 사용자 경험(UX)을 고려해 이미지 바로 보기가 자주 필요한 서비스라면 <code>inline</code> 설정을 고려해볼 수 있습니다. 이럴 땐 SVG 보안 이슈도 신경 써주세요!</li>
</ul>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>자, 이번에는 Next.js에서 이미지 최적화와 애니메이션 이미지 다루는 방법에 대해 살펴볼게요.</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">images</span>: {
    <span class="hljs-attr">contentDispositionType</span>: <span class="hljs-string">'inline'</span>,
  },
}
</code></pre>
<p>위 설정 코드는 이미지 응답 시 <code>Content-Disposition</code> 헤더를 'inline'으로 설정해주는 거예요. 이렇게 하면 브라우저가 이미지를 다운로드하지 않고, 바로 화면에 표시하도록 하는 역할을 해요. 이미지를 웹페이지 내에서 자연스럽게 보여주고 싶을 때 유용하죠.</p>
<hr>
<h2>애니메이션 이미지 처리</h2>
<p>Next.js의 기본 이미지 로더는 애니메이션이 들어간 이미지(예: GIF, APNG, WebP)가 들어오면 자동으로 이미지 최적화를 건너뛰고 원본 그대로 이미지를 서빙해줍니다. 왜냐면 애니메이션 이미지 최적화는 조금 까다롭고, 최적화 과정에서 애니메이션이 깨질 위험이 있거든요.</p>
<p>자동으로 애니메이션인지 판단하는 기능은 완벽하진 않지만, 대부분의 경우 GIF, APNG, WebP 파일 포맷을 기준으로 잘 감지해 줍니다.</p>
<p>만약 특정 애니메이션 이미지에 대해서 확실하게 최적화를 건너뛰고 싶다면, Next.js의 <code>Image</code> 컴포넌트에 <code>unoptimized</code> 속성을 추가해주면 돼요.</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Image</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'next/image'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Image</span>
      <span class="hljs-attr">src</span>=<span class="hljs-string">"/animated-image.gif"</span>
      <span class="hljs-attr">alt</span>=<span class="hljs-string">"애니메이션 이미지"</span>
      <span class="hljs-attr">width</span>=<span class="hljs-string">{500}</span>
      <span class="hljs-attr">height</span>=<span class="hljs-string">{300}</span>
      <span class="hljs-attr">unoptimized</span> // <span class="hljs-attr">이</span> <span class="hljs-attr">속성</span> <span class="hljs-attr">덕분에</span> <span class="hljs-attr">해당</span> <span class="hljs-attr">이미지는</span> <span class="hljs-attr">최적화</span> <span class="hljs-attr">없이</span> <span class="hljs-attr">바로</span> <span class="hljs-attr">서빙됩니다.</span>
    /></span></span>
  )
}
</code></pre>
<h3>추가 팁!</h3>
<ul>
<li>GIF 대신 WebP 포맷으로 애니메이션 이미지를 사용하는 것도 좋은 방법이에요. WebP는 파일 크기는 훨씬 작으면서도 화질을 잘 유지하거든요.</li>
<li>Next.js에서 자동 최적화를 사용하면 성능이 좋아지지만, 애니메이션 이미지 때문에 어쩔 수 없이 건너뛰는 경우가 있으니, 애니메이션 이미지가 많다면 CDN 또는 별도의 외부 이미지 서버를 사용하는 것도 고려해보세요.</li>
</ul>
<hr>
<p>요약하면, Next.js는 애니메이션 이미지에 대해 친절한 자동 최적화를 제공하지만, 100% 완벽하진 않아서 직접 <code>unoptimized</code> 플래그를 활용하는 게 좋고, <code>contentDispositionType: 'inline'</code> 설정으로 이미지를 웹 내에서 부드럽게 다룰 수 있다는 이야기였습니다!</p>
<p>필요하면 언제든지 더 구체적인 사용법도 알려드릴게요 :)</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>반응형 이미지 만들기</h2>
<p>웹 개발하다 보면 다양한 기기별 해상도를 지원하기 위해 이미지도 그에 맞게 잘 보여줘야 할 때가 많죠. 기본적으로 srcset 속성에는 1x, 2x 해상도 이미지가 들어가서 화면의 픽셀 밀도에 맞춰 이미지를 바꿔주는데요. 하지만, 뷰포트 크기에 따라 이미지 크기도 유동적으로 바꾸고 싶다면, srcset 뿐만 아니라 sizes 속성도 함께 설정해줘야 합니다. 그리고 스타일이나 className으로 이미지 크기를 조정하는 것도 중요하죠.</p>
<p>아래는 반응형 이미지를 만드는 몇 가지 방법 중 하나인 '정적 import 사용하기' 예시입니다.</p>
<hr>
<h3>정적 임포트로 반응형 이미지 만들기</h3>
<p>React나 Next.js 같은 환경에서 자주 쓰이는 방식인데요, 이미지를 프로젝트 안에서 import 해서 쓸 때 유용합니다.</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">import</span> responsiveImg <span class="hljs-keyword">from</span> <span class="hljs-string">'../public/images/responsive-image.jpg'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">img</span>
      <span class="hljs-attr">src</span>=<span class="hljs-string">{responsiveImg.src}</span>
      <span class="hljs-attr">srcSet</span>=<span class="hljs-string">{</span>`${<span class="hljs-attr">responsiveImg.src</span>} <span class="hljs-attr">1x</span>, ${<span class="hljs-attr">responsiveImg.src.replace</span>('<span class="hljs-attr">.jpg</span>', '@<span class="hljs-attr">2x.jpg</span>')} <span class="hljs-attr">2x</span>`}
      <span class="hljs-attr">sizes</span>=<span class="hljs-string">"(max-width: 600px) 100vw, 50vw"</span>
      <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">width:</span> '<span class="hljs-attr">100</span>%', <span class="hljs-attr">height:</span> '<span class="hljs-attr">auto</span>' }}
      <span class="hljs-attr">alt</span>=<span class="hljs-string">"Responsive example"</span>
    /></span></span>
  );
}
</code></pre>
<hr>
<p>여기서 sizes 속성은 뷰포트 너비가 600px 이하일 때 이미지가 화면 너비(100vw)의 100%를 차지하고, 그 이상일 땐 50%를 차지하도록 지정하는 거예요. 이렇게 하면 작은 화면에선 이미지가 꽉 차 보이고, 큰 화면에선 절반 크기로 나란히 배치하기 좋아요.</p>
<p>그리고 style이나 className으로 <code>width: 100%</code>를 주면 이미지가 부모 컨테이너의 크기에 맞게 늘어나거나 줄어듭니다. height는 auto로 하면 비율이 유지돼서 이미지가 찌그러지지 않죠.</p>
<hr>
<p><strong>팁!</strong></p>
<ul>
<li>이미지를 더 다양하게 반응형으로 다루고 싶으면 picture 태그와 함께 여러 해상도, 형식(webp, jpeg 등)을 srcSet에 넣어주는 것도 좋은 방법이에요.</li>
<li>Next.js를 쓰는 분들이라면 내장된 Image 컴포넌트를 활용하면 알아서 최적화 해주니 더 쉽게 반응형 이미지를 만들 수 있습니다.</li>
</ul>
<p>이제 images 태그만 써도 다양한 기기에서 딱 예쁘게 보여줄 수 있으니 꼭 sizes값과 css 조합도 함께 고려해보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>만약 이미지가 정적(변하지 않는) 소스라면, 이렇게 statically import해서 반응형 이미지(Responsive Image)를 쉽게 만들 수 있어요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Image</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'next/image'</span>
<span class="hljs-keyword">import</span> me <span class="hljs-keyword">from</span> <span class="hljs-string">'../photos/me.jpg'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Author</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Image</span>
      <span class="hljs-attr">src</span>=<span class="hljs-string">{me}</span>
      <span class="hljs-attr">alt</span>=<span class="hljs-string">"Picture of the author"</span>
      <span class="hljs-attr">sizes</span>=<span class="hljs-string">"100vw"</span>
      <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span>
        <span class="hljs-attr">width:</span> '<span class="hljs-attr">100</span>%',
        <span class="hljs-attr">height:</span> '<span class="hljs-attr">auto</span>',
      }}
    /></span></span>
  )
}
</code></pre>
<p>이 코드에서 중요한 점은 <code>sizes="100vw"</code>예요. 이 설정 덕분에 이미지가 뷰포트(Viewport) 너비 100%에 맞춰서 크기가 조절돼요. 그리고 <code>style</code>로 <code>width: '100%'</code> 그리고 <code>height: 'auto'</code>를 줘서 이미지 비율을 유지하며 폭에 맞게 크기가 변하게 됩니다.</p>
<hr>
<h3>왜 이렇게 하는 걸까?</h3>
<ul>
<li><strong>정적 import</strong>는 번들링할 때 이미지 정보를 미리 알아서, 최적화된 사이즈를 자동으로 만들어줘서 페이지 로딩 속도가 빨라져요.</li>
<li><code>next/image</code> 컴포넌트 자체가 여러 크기의 이미지를 제공해주고, 뷰포트에 따라 적절한 사이즈의 이미지를 불러오기 때문에 데이터 사용량도 줄일 수 있답니다.</li>
<li><code>sizes</code> 속성은 반응형 이미지에서 어떤 폭에서 이미지를 얼마나 크게 보여줄 지 브라우저에 알려주는 역할을 해요.</li>
</ul>
<hr>
<h3>한번 해보세요!</h3>
<p>위 코드를 페이지에 넣고 브라우저 창 크기를 조절해서 이미지가 폭에 맞춰 잘 변하는지 확인해 보면 정말 반응형 이미지임을 체감할 수 있을 거예요.</p>
<hr>
<p>만약 이미지를 동적으로 불러야 한다면, 다음 시간에 그 방법도 알려드릴게요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>반응형 이미지에 비율 맞추기</h3>
<p>웹에서 이미지를 쓸 때 특히 원본 이미지가 동적이거나 외부 URL일 경우, 반응형으로 잘 보여주려면 이미지의 가로(width)와 세로(height)를 꼭 지정해줘야 해요. 그래야 이미지가 비율을 유지하면서 화면 크기에 맞게 조절되거든요.</p>
<p>Next.js의 <code>next/image</code> 컴포넌트를 예로 들어볼게요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Image</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'next/image'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params">{ photoUrl }</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Image</span>
      <span class="hljs-attr">src</span>=<span class="hljs-string">{photoUrl}</span>            // <span class="hljs-attr">동적</span> <span class="hljs-attr">혹은</span> <span class="hljs-attr">외부</span> <span class="hljs-attr">주소로</span> <span class="hljs-attr">이미지</span> <span class="hljs-attr">호출</span>
      <span class="hljs-attr">alt</span>=<span class="hljs-string">"Picture of the author"</span>
      <span class="hljs-attr">sizes</span>=<span class="hljs-string">"100vw"</span>             // <span class="hljs-attr">화면</span> <span class="hljs-attr">전체</span> <span class="hljs-attr">폭에</span> <span class="hljs-attr">맞춰서</span> <span class="hljs-attr">크기를</span> <span class="hljs-attr">조절</span>
      <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span>
        <span class="hljs-attr">width:</span> '<span class="hljs-attr">100</span>%',          // <span class="hljs-attr">가로는</span> <span class="hljs-attr">부모</span> <span class="hljs-attr">컨테이너에</span> <span class="hljs-attr">딱</span> <span class="hljs-attr">맞게</span>
        <span class="hljs-attr">height:</span> '<span class="hljs-attr">auto</span>',         // <span class="hljs-attr">세로는</span> <span class="hljs-attr">비율에</span> <span class="hljs-attr">맞게</span> <span class="hljs-attr">자동</span> <span class="hljs-attr">조절</span>
      }}
      <span class="hljs-attr">width</span>=<span class="hljs-string">{500}</span>               // <span class="hljs-attr">이미지의</span> <span class="hljs-attr">원본</span> <span class="hljs-attr">가로</span> <span class="hljs-attr">크기</span>
      <span class="hljs-attr">height</span>=<span class="hljs-string">{300}</span>              // <span class="hljs-attr">이미지의</span> <span class="hljs-attr">원본</span> <span class="hljs-attr">세로</span> <span class="hljs-attr">크기</span>
    /></span></span>
  )
}
</code></pre>
<p>여기서 <code>width={500}</code>과 <code>height={300}</code>은 원본 이미지의 가로, 세로 크기를 나타내고, <code>style</code>에서 <code>width: 100%</code>로 설정해주면 화면 크기에 딱 맞춰서 이미지 크기가 바뀌면서도 가로세로 비율이 깨지지 않아요.</p>
<blockquote>
<p>실제로 <code>next/image</code>는 <code>width</code>, <code>height</code> 정보가 있어야 이미지 사이즈 계산과 레이아웃 잡는 데 도움을 줘서 CLS(Cumulative Layout Shift) 같은 레이아웃 깨짐 문제도 예방할 수 있답니다.</p>
</blockquote>
<hr>
<p>추가로, 반응형 이미지를 만들 때 기억하면 좋은 점!</p>





















<table><thead><tr><th>팁</th><th>설명</th></tr></thead><tbody><tr><td><code>sizes</code> 속성</td><td>뷰포트(viewport) 크기에 따라 어떤 크기의 이미지를 로딩할지 브라우저에 알려줍니다. <code>100vw</code>는 화면 전체 너비를 뜻해요.</td></tr><tr><td><code>style</code></td><td>CSS로 가로 세로 비율을 조절하지만 원본 비율과 다르면 이미지가 찌그러질 수 있어 비율 맞추는 게 중요해요.</td></tr><tr><td>원본 크기 지정</td><td><code>width</code>와 <code>height</code>를 지정해야 브라우저가 최적의 이미지를 불러오고 레이아웃이 안정적이에요!</td></tr></tbody></table>
<p>필요하다면, CSS로 부모 요소에 <code>max-width</code>를 정해서 너무 커지지 않도록 제한하는 것도 좋아요.</p>
<p>오늘은 이렇게 동적 이미지로 반응형 이미지를 깔끔하게 다루는 방법을 알아봤어요. 실무에서 꽤 자주 쓰이니 한번 써보시면서 감 잡아보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>뷰포트에 반응하는 이미지 데모</h3>
<h4>이미지의 가로세로 비율(aspect ratio)을 모를 때 - <code>fill</code> 속성 활용법</h4>
<p>이미지를 반응형으로 만들고 싶은데, 이미지의 정확한 가로세로 비율을 모를 경우가 있죠? 그럴 땐 부모 요소에 <code>position: relative</code>를 주고, Next.js의 <code>Image</code> 컴포넌트에 <code>fill</code> 속성을 사용하면 꽉 차게 이미지가 들어가요. 이때 <code>object-fit</code> 스타일로 이미지가 어떻게 맞춰질지 정할 수 있는데, <code>'contain'</code>으로 하면 이미지가 찌그러지거나 잘리지 않고 꽉 차도록 조절해 줍니다.</p>
<p>아래 예시 코드를 보시면 이해가 빠르실 거에요:</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Image</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'next/image'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params">{ photoUrl }</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">position:</span> '<span class="hljs-attr">relative</span>', <span class="hljs-attr">width:</span> '<span class="hljs-attr">300px</span>', <span class="hljs-attr">height:</span> '<span class="hljs-attr">500px</span>' }}></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">Image</span>
        <span class="hljs-attr">src</span>=<span class="hljs-string">{photoUrl}</span>
        <span class="hljs-attr">alt</span>=<span class="hljs-string">"Picture of the author"</span>
        <span class="hljs-attr">sizes</span>=<span class="hljs-string">"300px"</span>
        <span class="hljs-attr">fill</span>
        <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span>
          <span class="hljs-attr">objectFit:</span> '<span class="hljs-attr">contain</span>',
        }}
      /></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  )
}
</code></pre>
<ul>
<li><code>div</code>에 <code>position: relative</code>를 줘야 <code>fill</code>로 설정된 이미지가 부모 영역을 기준으로 꽉 채울 수 있어요.</li>
<li><code>width</code>와 <code>height</code>를 고정 또는 반응형 단위로 지정해주면 이미지 크기가 결정되고, 그 안에서 <code>fill</code>이 동작하는 거죠.</li>
<li><code>objectFit</code>을 <code>'contain'</code>으로 하면 이미지가 영역 내에 꽉 차면서 비율이 유지되고, <code>'cover'</code>로 설정하면 영역을 가득 채우되 일부 잘릴 수도 있습니다.</li>
</ul>
<blockquote>
<p>추가 팁!<br>
만약 이미지가 부모 크기에 맞춰 유연하게 크기가 변하길 원한다면, 부모 요소를 미디어 쿼리나 CSS 그리드/플렉스를 활용해 동적으로 크기를 조절하는 방법도 있어요. 그러면 <code>fill</code>과 함께 더 자연스러운 반응형 이미지를 구현할 수 있습니다!</p>
</blockquote>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>한번 해볼까요?</p>
<ul>
<li>fill prop을 활용하는 데모</li>
</ul>
<h2>테마 감지 CSS</h2>
<p>웹사이트를 만들 때, 라이트 모드와 다크 모드에 따라 다른 이미지를 보여주고 싶을 때가 있죠? 이럴 때는 두 개의 <code>Image</code> 컴포넌트를 감싸는 새로운 컴포넌트를 만들어서 CSS 미디어 쿼리를 활용해 적절한 이미지만 보여주도록 할 수 있어요.</p>
<p>예를 들어, CSS의 <code>prefers-color-scheme</code> 미디어 쿼리를 사용하면 사용자가 설정한 테마(라이트 or 다크)에 따라 다른 스타일이나 이미지를 적용할 수 있답니다. 이를 이용하면 자바스크립트로 복잡한 조건문을 작성하지 않아도, 아주 깔끔하게 테마별 이미지를 처리할 수 있어요.</p>
<p>아래는 이 개념을 활용한 간단한 예시입니다.</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Image</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'next/image'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">ThemeImage</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">Image</span>
        <span class="hljs-attr">src</span>=<span class="hljs-string">"/images/light-mode.png"</span>
        <span class="hljs-attr">alt</span>=<span class="hljs-string">"라이트 모드 이미지"</span>
        <span class="hljs-attr">className</span>=<span class="hljs-string">"light-image"</span>
        <span class="hljs-attr">width</span>=<span class="hljs-string">{200}</span>
        <span class="hljs-attr">height</span>=<span class="hljs-string">{200}</span>
      /></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">Image</span>
        <span class="hljs-attr">src</span>=<span class="hljs-string">"/images/dark-mode.png"</span>
        <span class="hljs-attr">alt</span>=<span class="hljs-string">"다크 모드 이미지"</span>
        <span class="hljs-attr">className</span>=<span class="hljs-string">"dark-image"</span>
        <span class="hljs-attr">width</span>=<span class="hljs-string">{200}</span>
        <span class="hljs-attr">height</span>=<span class="hljs-string">{200}</span>
      /></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">style</span> <span class="hljs-attr">jsx</span>></span><span class="css">{`
        <span class="hljs-selector-class">.light-image</span> {
          <span class="hljs-attribute">display</span>: block;
        }
        <span class="hljs-selector-class">.dark-image</span> {
          <span class="hljs-attribute">display</span>: none;
        }
        <span class="hljs-keyword">@media</span> (<span class="hljs-attribute">prefers-color-scheme</span>: dark) {
          <span class="hljs-selector-class">.light-image</span> {
            <span class="hljs-attribute">display</span>: none;
          }
          <span class="hljs-selector-class">.dark-image</span> {
            <span class="hljs-attribute">display</span>: block;
          }
        }
      `}</span><span class="hljs-tag">&#x3C;/<span class="hljs-name">style</span>></span>
    <span class="hljs-tag">&#x3C;/></span></span>
  );
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">ThemeImage</span>;
</code></pre>
<p>위 코드에서는 기본적으로 라이트 모드 이미지를 보여주고, 다크 모드가 감지되면 다크 모드 이미지만 보이도록 CSS로 조절해줍니다.</p>
<hr>
<p>추가로 팁 하나!</p>
<p>만약 이미지가 너무 많아서 이렇게 일일이 컴포넌트를 만들기 번거롭다면, <a href="https://developer.mozilla.org/ko/docs/Web/HTML/Element/picture" rel="nofollow" target="_blank">picture 태그</a>와 <code>source</code> 태그를 활용하는 방법도 있어요. <code>source</code>의 <code>media</code> 속성에 <code>prefers-color-scheme</code> 조건을 넣으면 브라우저가 자동으로 맞는 이미지를 골라줍니다.</p>
<pre><code class="hljs language-jsx">&#x3C;picture>
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">source</span> <span class="hljs-attr">srcSet</span>=<span class="hljs-string">"/images/dark-mode.png"</span> <span class="hljs-attr">media</span>=<span class="hljs-string">"(prefers-color-scheme: dark)"</span> /></span></span>
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/images/light-mode.png"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"테마별 이미지"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{200}</span> <span class="hljs-attr">height</span>=<span class="hljs-string">{200}</span> /></span></span>
&#x3C;/picture>
</code></pre>
<p>이렇게 하면 자바스크립트나 추가 CSS 없이도 손쉽게 테마별 이미지를 관리할 수 있어서 더 깔끔하니 참고해보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이번 시간에는 다크모드 지원을 할 때 이미지도 알아서 라이트모드용, 다크모드용 이미지를 잘 보여주게 하는 간단한 방법을 소개해 드릴게요. CSS와 Next.js를 함께 활용한 스타일링과 컴포넌트 설계법을 보면서, 실제로 어떻게 이미지 로딩이 최적화되는지도 짚어보려 합니다.</p>
<hr>
<h3>1. CSS로 다크모드에 따라 보이기/숨기기 설정하기</h3>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.imgDark</span> {
  <span class="hljs-attribute">display</span>: none;
}

<span class="hljs-keyword">@media</span> (<span class="hljs-attribute">prefers-color-scheme</span>: dark) {
  <span class="hljs-selector-class">.imgLight</span> {
    <span class="hljs-attribute">display</span>: none;
  }
  <span class="hljs-selector-class">.imgDark</span> {
    <span class="hljs-attribute">display</span>: unset;
  }
}
</code></pre>
<ul>
<li><code>.imgDark</code> 이미지는 기본적으로 숨겨져 있어요.</li>
<li>사용자의 OS나 브라우저가 다크모드를 감지하면(<code>prefers-color-scheme: dark</code>), <code>.imgLight</code> 이미지는 숨기고 <code>.imgDark</code> 이미지는 보여주게 됩니다.</li>
</ul>
<p>이렇게만 해줘도 다크모드 감지 시 자동으로 이미지를 바꿔서 보여줄 수 있죠.</p>
<hr>
<h3>2. Next.js 컴포넌트로 깔끔하게 관리하기</h3>
<pre><code class="hljs language-tsx"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">'./theme-image.module.css'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Image</span>, { <span class="hljs-title class_">ImageProps</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/image'</span>

<span class="hljs-keyword">type</span> <span class="hljs-title class_">Props</span> = <span class="hljs-title class_">Omit</span>&#x3C;<span class="hljs-title class_">ImageProps</span>, <span class="hljs-string">'src'</span> | <span class="hljs-string">'priority'</span> | <span class="hljs-string">'loading'</span>> &#x26; {
  <span class="hljs-attr">srcLight</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">srcDark</span>: <span class="hljs-built_in">string</span>
}

<span class="hljs-keyword">const</span> <span class="hljs-title function_">ThemeImage</span> = (<span class="hljs-params">props: Props</span>) => {
  <span class="hljs-keyword">const</span> { srcLight, srcDark, ...rest } = props

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">Image</span> {<span class="hljs-attr">...rest</span>} <span class="hljs-attr">src</span>=<span class="hljs-string">{srcLight}</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.imgLight}</span> /></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">Image</span> {<span class="hljs-attr">...rest</span>} <span class="hljs-attr">src</span>=<span class="hljs-string">{srcDark}</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.imgDark}</span> /></span>
    <span class="hljs-tag">&#x3C;/></span></span>
  )
}
</code></pre>
<ul>
<li>Next.js의 <code>Image</code> 컴포넌트를 한 번에 두 개 넣고, CSS로 어느 이미지를 보여줄지 제어하는 방식입니다.</li>
<li><code>Priority</code>나 <code>loading="eager"</code>를 쓰면 이미지가 모두 로드되어 버려서 비효율적이므로 <strong>기본 <code>loading="lazy"</code> 속성을 이용</strong>하거나 **<code>fetchPriority="high"</code>**를 활용하세요.</li>
</ul>
<hr>
<h3>3. 핵심 포인트: 이미지 로딩 최적화</h3>





















<table><thead><tr><th>고려사항</th><th>설명</th></tr></thead><tbody><tr><td>기본 로딩 방식</td><td><code>loading="lazy"</code>는 스크롤 등 사용자 행동에 맞게 이미지를 불러옵니다. 이 덕분에 안 보이는 이미지는 바로 로드되지 않아요.</td></tr><tr><td><code>priority</code> 속성 사용 제한</td><td>라이트/다크용 이미지가 동시에 로드되기 때문에 <code>priority</code>를 쓰면 번거로워질 수 있습니다.</td></tr><tr><td><code>fetchPriority</code> 활용</td><td>Next.js 13부터 새로 도입된 <code>fetchPriority="high"</code>를 이용하면 우선순위 지정이 가능하지만, 옮겨서 써야 하는 상황이라는 점 참고!</td></tr></tbody></table>
<hr>
<h3>간단 요약</h3>
<ul>
<li>CSS 미디어 쿼리로 라이트/다크 이미지를 제어하자.</li>
<li><code>next/image</code>를 두 개 겹쳐서 쓰되, 실제 보여줄 이미지만 노출되도록 CSS로 관리하자.</li>
<li>불필요한 이미지 로딩을 막기 위해 기본 <code>loading="lazy"</code>를 사용하자. 필요할 땐 <code>fetchPriority="high"</code>도 써보자.</li>
</ul>
<hr>
<h3>덧붙여서 알려드리는 팁!</h3>
<ul>
<li>만약 이미지가 너무 많거나 용량이 크다면, 라이트/다크 모드 전환 시 자바스크립트로 이미지를 동적으로 교체하는 방법도 고려할 수 있습니다.</li>
<li>또 CSS <code>image-set</code> 같은 기능도 사용해볼 수 있지만, 브라우저 지원이 조금씩 다르니 꼭 테스트하세요!</li>
</ul>
<hr>
<p>다크모드 시대에 잘 맞춰 사용자 경험을 선물해주는 테마별 이미지 처리, 어렵지 않지요? 직접 코드를 돌려보면서 이미지 교체가 매끄럽게 되는 걸 느껴보시면 이해가 훨씬 쉬워집니다.</p>
<p>그럼 즐거운 개발 하세요! 🚀</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>데모: 라이트/다크 모드 테마 감지</li>
</ul>
<h2>getImageProps 함수</h2>
<p>조금 더 고급 활용법을 원할 때는 getImageProps() 함수를 호출해서, 실제 <code>img</code> 태그에 들어갈 props들을 받아올 수 있어요. 그리고 이 props들을 다른 컴포넌트나 스타일, 혹은 캔버스 등에 넘겨서 자유롭게 사용할 수 있죠.</p>
<p>이 방법의 좋은 점은 React의 useState()를 사용하지 않기 때문에 퍼포먼스가 좀 더 좋아질 수 있다는 거예요. (useState를 쓰면 상태 변경으로 리렌더링이 발생할 수 있거든요.) 하지만 여기서 주의할 점은 placeholder prop과 함께 사용할 수 없다는 겁니다! 왜냐하면 placeholder가 한 번 설정되면 절대 사라지지 않거든요.</p>
<p>즉, 이미지 로딩 상태를 직접 관리하거나, 커스텀한 방식으로 이미지를 표시하고 싶을 때 이 함수를 쓰면 꽤 유용하겠죠? 다만, 나중에 placeholder 효과를 구현하고 싶다면 다른 방법을 고민해야 합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>테마 감지용 이미지 바꾸기</h3>
<p>웹사이트를 만들 때, 라이트 모드와 다크 모드에 따라 다른 이미지를 보여주고 싶을 때가 있죠? 이럴 때 유용한 방법이 바로 <code>picture</code> 태그를 활용하는 거예요. 사용자 브라우저가 선호하는 색상 모드(라이트/다크)를 감지해서 그에 맞는 이미지를 자동으로 보여줄 수 있답니다.</p>
<p>아래는 Next.js에서 <code>next/image</code>의 <code>getImageProps</code>를 활용해, 라이트/다크 모드별로 서로 다른 이미지를 설정하는 예시 코드입니다.</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">import</span> { getImageProps } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/image'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> common = { <span class="hljs-attr">alt</span>: <span class="hljs-string">'Theme Example'</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">800</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">400</span> }

  <span class="hljs-keyword">const</span> {
    <span class="hljs-attr">props</span>: { <span class="hljs-attr">srcSet</span>: dark },
  } = <span class="hljs-title function_">getImageProps</span>({ ...common, <span class="hljs-attr">src</span>: <span class="hljs-string">'/dark.png'</span> })

  <span class="hljs-keyword">const</span> {
    <span class="hljs-attr">props</span>: { <span class="hljs-attr">srcSet</span>: light, ...rest },
  } = <span class="hljs-title function_">getImageProps</span>({ ...common, <span class="hljs-attr">src</span>: <span class="hljs-string">'/light.png'</span> })

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">picture</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">source</span> <span class="hljs-attr">media</span>=<span class="hljs-string">"(prefers-color-scheme: dark)"</span> <span class="hljs-attr">srcSet</span>=<span class="hljs-string">{dark}</span> /></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">source</span> <span class="hljs-attr">media</span>=<span class="hljs-string">"(prefers-color-scheme: light)"</span> <span class="hljs-attr">srcSet</span>=<span class="hljs-string">{light}</span> /></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">img</span> {<span class="hljs-attr">...rest</span>} /></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">picture</span>></span></span>
  )
}
</code></pre>
<hr>
<h3>여기서 알아두면 좋은 점!</h3>
<ul>
<li><strong><code>picture</code> 태그</strong>: 여러 이미지를 상황에 맞게 골라 보여주기 위해 쓰여요. <code>&#x3C;source></code>에 조건(미디어쿼리)을 걸고, 마지막 <code>&#x3C;img></code> 태그가 기본 이미지 역할을 해주죠.</li>
<li><strong><code>prefers-color-scheme</code> 미디어 쿼리</strong>: 사용자 기기의 모드 설정을 감지해 <code>dark</code>나 <code>light</code> 여부를 판단해요.</li>
<li><strong>Next.js의 <code>getImageProps</code></strong>: 이미지를 최적화하고 메타 정보를 제공해서, 별도의 수동 작업 없이도 쉽게 이미지 관련 속성을 얻을 수 있어요.</li>
</ul>
<hr>
<h3>추가 팁!</h3>
<ol>
<li>
<p>이미지 파일을 많이 만드는 게 번거롭다면, CSS 필터(예: <code>filter: invert(1)</code>)를 활용해 이미지 색상을 조절하는 방법도 있어요. 단, 복잡한 이미지엔 적용하기 어려울 수 있답니다.</p>
</li>
<li>
<p>다크 모드 이미지를 SVG로 만들면 색상 변경도 더 자유롭고, 용량도 줄일 수 있으니 참고하세요.</p>
</li>
<li>
<p><code>picture</code> 태그가 구형 브라우저에서는 지원되지 않을 수 있으니, 꼭 호환성 체크도 해보시면서 사용하시길 추천드립니다.</p>
</li>
</ol>
<hr>
<p>다음에는 ‘아트 디렉션’(Art Direction)을 위해서 어떻게 이미지 크기나 구성을 바꾸는지에 대해 다뤄볼게요! 디자인 변화에 따라 이미지를 컨트롤하는 재미난 방법들이 많이 있답니다. 기대해주세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>데스크탑과 모바일에서 각각 다른 이미지를 보여주고 싶을 때, 흔히 'Art Direction(아트 디렉션)'이라고 불러요.<br>
이럴 때는 <code>getImageProps()</code> 함수에 각 기기별로 다른 <code>src</code>, <code>width</code>, <code>height</code>, <code>quality</code> 값을 넘겨줘서 손쉽게 처리할 수 있답니다.</p>
<p>아래 예제를 보면 조금 더 이해하기 쉬울 거예요:</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">import</span> { getImageProps } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/image'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Home</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> common = { <span class="hljs-attr">alt</span>: <span class="hljs-string">'Art Direction Example'</span>, <span class="hljs-attr">sizes</span>: <span class="hljs-string">'100vw'</span> }

  <span class="hljs-comment">// 데스크탑용 이미지 속성 가져오기</span>
  <span class="hljs-keyword">const</span> {
    <span class="hljs-attr">props</span>: { <span class="hljs-attr">srcSet</span>: desktop },
  } = <span class="hljs-title function_">getImageProps</span>({
    ...common,
    <span class="hljs-attr">width</span>: <span class="hljs-number">1440</span>,
    <span class="hljs-attr">height</span>: <span class="hljs-number">875</span>,
    <span class="hljs-attr">quality</span>: <span class="hljs-number">80</span>,
    <span class="hljs-attr">src</span>: <span class="hljs-string">'/desktop.jpg'</span>,
  })

  <span class="hljs-comment">// 모바일용 이미지 속성 가져오기</span>
  <span class="hljs-keyword">const</span> {
    <span class="hljs-attr">props</span>: { <span class="hljs-attr">srcSet</span>: mobile, ...rest },
  } = <span class="hljs-title function_">getImageProps</span>({
    ...common,
    <span class="hljs-attr">width</span>: <span class="hljs-number">750</span>,
    <span class="hljs-attr">height</span>: <span class="hljs-number">1334</span>,
    <span class="hljs-attr">quality</span>: <span class="hljs-number">70</span>,
    <span class="hljs-attr">src</span>: <span class="hljs-string">'/mobile.jpg'</span>,
  })

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">picture</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">source</span> <span class="hljs-attr">media</span>=<span class="hljs-string">"(min-width: 1000px)"</span> <span class="hljs-attr">srcSet</span>=<span class="hljs-string">{desktop}</span> /></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">source</span> <span class="hljs-attr">media</span>=<span class="hljs-string">"(min-width: 500px)"</span> <span class="hljs-attr">srcSet</span>=<span class="hljs-string">{mobile}</span> /></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">img</span> {<span class="hljs-attr">...rest</span>} <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">width:</span> '<span class="hljs-attr">100</span>%', <span class="hljs-attr">height:</span> '<span class="hljs-attr">auto</span>' }} /></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">picture</span>></span></span>
  )
}
</code></pre>
<p><code>&#x3C;picture></code> 태그와 <code>&#x3C;source></code>를 사용해서 화면 크기에 맞는 이미지를 선택하도록 해주는데요, 브라우저가 조건에 맞는 첫 번째 <code>&#x3C;source></code>를 찾아 이미지를 보여주고, 맞는 게 없으면 <code>&#x3C;img></code> 태그에 있는 이미지가 기본으로 나옵니다.</p>
<p>그리고 여기서 <code>getImageProps()</code>로 반환받은 <code>srcSet</code>은 여러 해상도 이미지를 브라우저가 자동으로 선택하게 도와줘서, 고해상도 기기에서도 선명한 이미지를 볼 수 있습니다.</p>
<hr>
<h3>CSS 배경 이미지에 활용하기</h3>
<p>사실 이미지를 태그로만 쓰는 게 아니라, CSS <code>background-image</code>로도 활용할 수 있어요.<br>
이때 <code>srcSet</code> 문자열을 CSS의 <code>image-set()</code> 함수로 변환해서 반응형 배경 이미지를 만들 수 있답니다.</p>
<p>예를 들어, 이렇게 쓸 수 있어요:</p>
<pre><code class="hljs language-css"><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">image-set</span>(
  <span class="hljs-built_in">url</span>(<span class="hljs-string">'/image-1x.png'</span>) <span class="hljs-number">1</span>x,
  <span class="hljs-built_in">url</span>(<span class="hljs-string">'/image-2x.png'</span>) <span class="hljs-number">2</span>x
);
</code></pre>
<p><code>image-set()</code> 함수는 해상도에 따라 다른 이미지를 로드하도록 도와주는데, 그렇게 하면 모바일과 데스크탑의 배경 이미지를 각각 최적화할 수 있어요.</p>
<hr>
<h3>이렇게 활용해보세요!</h3>
<ul>
<li>이미지 용량과 해상도를 따로 조절해서 모바일에서는 가볍고, 데스크탑에서는 선명한 이미지를 제공할 수 있어요.</li>
<li><code>&#x3C;picture></code> 태그를 활용하면 SEO와 접근성에도 좋아요. <code>&#x3C;img></code>의 <code>alt</code> 속성을 꼭 챙기는 것도 잊지 말고요!</li>
<li>CSS <code>image-set()</code>으로 배경 이미지에 반응형을 적용해보면 디자인 퀄리티가 더 좋아질 수 있답니다.</li>
</ul>
<p>이미지 아트 디렉션, 처음에는 조금 복잡해 보여도 차근차근 손에 익으면서 효과를 톡톡히 볼 수 있을 거예요.<br>
필요하면 제가 배경 이미지용 <code>image-set()</code> 변환법도 예제로 한번 더 알려드릴게요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>JS와 Next.js의 next/image 컴포넌트를 활용해서 배경 이미지를 다루는 예제와, 관련한 브라우저 호환 이슈를 알아볼게요.</p>
<hr>
<h2>배경 이미지로 next/image srcSet 활용하기</h2>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { getImageProps } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/image'</span>;
 
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getBackgroundImage</span>(<span class="hljs-params">srcSet = <span class="hljs-string">''</span></span>) {
  <span class="hljs-keyword">const</span> imageSet = srcSet
    .<span class="hljs-title function_">split</span>(<span class="hljs-string">', '</span>)
    .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">str</span>) =></span> {
      <span class="hljs-keyword">const</span> [url, dpi] = str.<span class="hljs-title function_">split</span>(<span class="hljs-string">' '</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-string">`url("<span class="hljs-subst">${url}</span>") <span class="hljs-subst">${dpi}</span>`</span>;
    })
    .<span class="hljs-title function_">join</span>(<span class="hljs-string">', '</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-string">`image-set(<span class="hljs-subst">${imageSet}</span>)`</span>;
}
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Home</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> {
    <span class="hljs-attr">props</span>: { srcSet },
  } = <span class="hljs-title function_">getImageProps</span>({ <span class="hljs-attr">alt</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">128</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">128</span>, <span class="hljs-attr">src</span>: <span class="hljs-string">'/img.png'</span> });
  
  <span class="hljs-keyword">const</span> backgroundImage = <span class="hljs-title function_">getBackgroundImage</span>(srcSet);
  
  <span class="hljs-keyword">const</span> style = { <span class="hljs-attr">height</span>: <span class="hljs-string">'100vh'</span>, <span class="hljs-attr">width</span>: <span class="hljs-string">'100vw'</span>, backgroundImage };
 
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">main</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{style}</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>Hello World<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">main</span>></span></span>
  );
}
</code></pre>
<h3>설명을 덧붙이자면</h3>
<ul>
<li><code>getImageProps</code>는 next/image가 이미지 로딩에 최적화된 속성들(<code>srcSet</code>, <code>src</code>, <code>sizes</code> 등)을 생성해주는 함수입니다.</li>
<li>여기서는 <code>srcSet</code> 문자열을 받아서 CSS <code>image-set()</code> 구문에 맞게 변환해줍니다.</li>
<li><code>image-set</code>은 여러 해상도에 맞는 이미지들을 선언해서 브라우저가 상황에 맞게 선택적으로 로딩할 수 있게 합니다.</li>
<li>이걸 스타일 객체에 바로 <code>backgroundImage</code>로 넣어서 배경으로 활용하는 거죠.</li>
</ul>
<h3>작은 팁!</h3>
<ul>
<li>CSS <code>image-set()</code> 지원은 아직 일부 브라우저에서 제한적이라 실제로 쓸 땐 호환성 체크 꼭 하세요.</li>
<li>여기선 inline style로 썼지만, css-in-js나 external css로 작성하면 유지보수가 더 좋을 수 있어요.</li>
<li>next/image 기본 컴포넌트는 <code>&#x3C;img></code> 태그에 최적화되어 있기 때문에 배경 이미지로 쓰긴 다소 변칙적이라, 상황에 따라 직접 이미지 태그를 쓰는 것도 고민해보세요.</li>
</ul>
<hr>
<h2>알려진 브라우저 버그 및 주의점</h2>



































<table><thead><tr><th>브라우저</th><th>이슈 내용</th><th>해결법 / 참고</th></tr></thead><tbody><tr><td>Safari 15 ~ 16.3</td><td>이미지 로딩 시 회색 테두리 표시</td><td>- CSS @supports로 특정 스타일 적용<br>- <code>priority</code> 속성으로 위쪽 영역 이미지 우선 로딩</td></tr><tr><td>Safari &#x3C; 15.4</td><td>native lazy loading 미지원 (eager fallback)</td><td>최신 버전으로 업데이트 권장</td></tr><tr><td>Safari &#x3C; 12</td><td>blur-up placeholder 빈 상태 fallback</td><td>blur-up 효과 대신 다른 placeholder 사용 고려</td></tr><tr><td>Safari &#x3C; 15</td><td>width/height auto 스타일 사용 시 레이아웃 시프트 발생 가능</td><td>고정 크기 사용 추천</td></tr><tr><td>Firefox 67+</td><td>로딩 중 흰색 배경 표시</td><td>- AVIF 포맷 활성화<br>- placeholder 사용</td></tr></tbody></table>
<h3>알아두면 좋은 점</h3>
<ul>
<li>Next.js의 next/image는 기본적으로 lazy loading을 지원하지만, 브라우저마다 native 지원 범위가 다릅니다.</li>
<li>특히 구형 브라우저에서는 eager로 강제 변경되거나 placeholder가 제대로 보이지 않는 등 UX가 달라질 수 있어요.</li>
<li>blur-up placeholder 효과가 안되는 구형 사파리는 사용자 눈에 빈 화면이 되는 단점이 있습니다.</li>
<li>Firefox에서 흰색 배경 문제는 AVIF 사용 및 placeholder 설정으로 완화할 수 있으니 가능하면 이미지를 AVIF 포맷으로 변환하는 게 좋아요.</li>
<li>Layout Shift (레이아웃 변화)를 막으려면 기본적으로 이미지 영역의 크기를 미리 지정해주는 게 중요합니다.</li>
</ul>
<hr>
<h3>마무리</h3>
<p>next/image는 편리한 이미지 최적화 도구지만, 브라우저 별로 미묘한 차이가 있어서 꼼꼼한 테스트가 필요해요.<br>
특히 배경 이미지로 변형하거나 레거시 브라우저를 지원한다면, 위 이슈들을 참고해서 적절히 대응하세요!</p>
<p>더 궁금한 점 있으면 언제든 질문해 주세요~<br>
개발할 때 자주 쓰는 팁도 하나씩 알려 드릴게요 :)</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>버전 히스토리</h2>





































































































<table><thead><tr><th>버전</th><th>변경사항</th></tr></thead><tbody><tr><td><code>v15.3.0</code></td><td><code>remotePatterns</code>에서 <code>URL</code> 객체 배열을 지원하도록 추가됨.</td></tr><tr><td><code>v15.0.0</code></td><td><code>contentDispositionType</code> 설정 기본값이 <code>attachment</code>으로 변경됨.</td></tr><tr><td><code>v14.2.23</code></td><td><code>qualities</code> 설정이 추가됨.</td></tr><tr><td><code>v14.2.15</code></td><td><code>decoding</code> prop과 <code>localPatterns</code> 설정이 추가됨.</td></tr><tr><td><code>v14.2.14</code></td><td><code>remotePatterns.search</code> prop이 추가됨.</td></tr><tr><td><code>v14.2.0</code></td><td><code>overrideSrc</code> prop이 추가됨.</td></tr><tr><td><code>v14.1.0</code></td><td><code>getImageProps()</code>가 안정화됨.</td></tr><tr><td><code>v14.0.0</code></td><td><code>onLoadingComplete</code> prop과 <code>domains</code> 설정이 deprecated됨.</td></tr><tr><td><code>v13.4.14</code></td><td><code>placeholder</code> prop이 <code>data:/image...</code> URI를 지원하도록 추가됨.</td></tr><tr><td><code>v13.2.0</code></td><td><code>contentDispositionType</code> 설정이 추가됨.</td></tr><tr><td><code>v13.0.6</code></td><td><code>ref</code> prop이 추가됨.</td></tr><tr><td><code>v13.0.0</code></td><td>- <code>next/image</code> 임포트가 <code>next/legacy/image</code>로 이름 변경됨.<br>- <code>next/future/image</code> 임포트가 <code>next/image</code>로 이름 변경됨.<br>- <a href="/docs/app/guides/upgrading/codemods#next-image-to-legacy-image">안전하고 자동으로 임포트를 변경해주는 codemod 제공</a>.<br>- <code>&#x3C;span></code> 래퍼 제거.<br>- <code>layout</code>, <code>objectFit</code>, <code>objectPosition</code>, <code>lazyBoundary</code>, <code>lazyRoot</code> prop 삭제.<br>- <code>alt</code> prop 필수화.<br>- <code>onLoadingComplete</code>이 <code>img</code> 엘리먼트 레퍼런스를 받음.<br>- 기본 내장 로더 설정 제거됨.</td></tr><tr><td><code>v12.3.0</code></td><td><code>remotePatterns</code> 및 <code>unoptimized</code> 설정이 안정화됨.</td></tr><tr><td><code>v12.2.0</code></td><td>실험적 <code>remotePatterns</code>와 <code>unoptimized</code> 설정 추가.<br><code>layout="raw"</code> 삭제됨.</td></tr><tr><td><code>v12.1.1</code></td><td><code>style</code> prop 추가.<br>실험적 <code>layout="raw"</code> 지원 추가.</td></tr><tr><td><code>v12.1.0</code></td><td><code>dangerouslyAllowSVG</code>와 <code>contentSecurityPolicy</code> 설정 추가됨.</td></tr><tr><td><code>v12.0.9</code></td><td><code>lazyRoot</code> prop 추가됨.</td></tr><tr><td><code>v12.0.0</code></td><td>- <code>formats</code> 설정 추가.<br>- AVIF 이미지 포맷 지원 추가.<br>- 래퍼 엘리먼트가 <code>&#x3C;div></code>에서 <code>&#x3C;span></code>으로 변경됨.</td></tr><tr><td><code>v11.1.0</code></td><td><code>onLoadingComplete</code>과 <code>lazyBoundary</code> prop 추가됨.</td></tr><tr><td><code>v11.0.0</code></td><td>- <code>src</code> prop이 정적 임포트를 지원.<br>- <code>placeholder</code> prop 추가.<br>- <code>blurDataURL</code> prop 추가.</td></tr><tr><td><code>v10.0.5</code></td><td><code>loader</code> prop 추가됨.</td></tr><tr><td><code>v10.0.1</code></td><td><code>layout</code> prop 추가됨.</td></tr><tr><td><code>v10.0.0</code></td><td><code>next/image</code> 컴포넌트 도입됨.</td></tr></tbody></table>
<hr>
<p>이렇게 버전별로 주요 업데이트가 정리되어 있으니, 특히 <code>v13</code>에서 큰 변화가 있었던 점 잊지 마세요! <code>alt</code>가 필수로 변경된 점이라든지 <code>next/image</code>의 경로가 달라진 부분은 프로젝트 마이그레이션 시 꼭 체크하세요. 그리고 최신 버전에서는 AVIF 포맷 지원 등 이미지 최적화 기능도 점점 좋아지고 있어서, 가능하면 최신 버전을 쓰는 게 좋습니다.</p>
<p>필요하면 각 버전에 있는 새로운 prop이나 설정을 활용해 성능과 사용자 경험을 개선해보시길 추천합니다!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Next.js 15에서 이미지 최적화하는 5가지 방법","description":"","date":"2025-04-22 02:20","slug":"2025-04-22-Image","content":"\n\n# Image 컴포넌트 사용법\n\n이번에는 Next.js에서 제공하는 `Image` 컴포넌트에 대해서 알아볼게요. 이미지 최적화에 신경 써야 할 때 직접 `\u003cimg\u003e` 태그를 쓰기보다는 이 컴포넌트를 활용하면 자동으로 다양한 최적화가 진행되어 성능 향상에 도움이 된답니다.\n\n아래는 `Image` 컴포넌트를 사용하는 기본적인 예시입니다.\n\n```js\nimport Image from 'next/image'\n\nexport default function Page() {\n  return (\n    \u003cImage\n      src=\"/profile.png\"       // 이미지 경로\n      width={500}              // 이미지 너비(px)\n      height={500}             // 이미지 높이(px)\n      alt=\"Picture of the author\" // 대체 텍스트 (접근성에 필수!)\n    /\u003e\n  )\n}\n```\n\n`Image` 컴포넌트의 기본적인 사용법은 이렇게 `src`, `width`, `height`, `alt` 속성을 넘겨주는 거에요. 이 외에도 여러 유용한 props들이 있는데, 이어서 자세히 살펴볼게요.\n\n## Image 컴포넌트 주요 Props\n\n| Prop        | 타입          | 설명                                               |\n|-------------|---------------|--------------------------------------------------|\n| src         | string        | 불러올 이미지 경로 또는 URL                        |\n| width       | number/string | 이미지 너비                                       |\n| height      | number/string | 이미지 높이                                       |\n| alt         | string        | 이미지 설명 텍스트 (웹 접근성 측면에서 매우 중요)  |\n| layout      | string        | 이미지 레이아웃 (`fixed`, `intrinsic`, `responsive`, `fill`) 설정 |\n| priority    | boolean       | true일 경우 우선 로딩, 주로 초기 페이지에 사용      |\n| placeholder | string        | 이미지 로딩 전 보여줄 플레이스홀더 (`blur` 가능)  |\n| quality     | number        | 이미지 품질 설정 (1~100)                          |\n| loader      | function      | 커스텀 이미지 로더 함수 설정                      |\n\n### layout 옵션 간단 설명\n\n- `fixed`: 지정한 크기에서 고정\n- `intrinsic`: 원본 비율 유지하며 최대 크기까지 늘어남\n- `responsive`: 부모 컨테이너의 크기에 맞게 반응형 조절\n- `fill`: 부모 컨테이너를 가득 채움 (position: absolute 필요)\n\n### Tip\n`priority` 속성을 설정하면 페이지 로딩 시 해당 이미지가 우선적으로 로드되어 사용자 경험이 개선됩니다. 예를 들어, 프로필 사진이나 메인 배너 이미지에 사용하는 게 좋아요.\n\n또한 `placeholder=\"blur\"`와 함께 `blurDataURL` 속성을 사용하면 이미지를 불러오는 동안 흐릿한 미리보기 이미지를 보여줄 수 있어 깔끔한 로딩 효과를 줄 수 있답니다.\n\n---\n\n추가로 궁금한 점이나 더 자세한 사용법이 필요하면 언제든지 알려주세요! Next.js는 이미지 핸들링을 꽤 잘 처리해주니까 꼭 활용해보시길 추천해요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nImage 컴포넌트에 사용할 수 있는 주요 props를 정리해봤어요. 이 내용을 참고하면 이미지 컴포넌트를 사용할 때 어떤 옵션들을 넣을 수 있는지 한눈에 확인할 수 있을 거예요.\n\n| Prop             | Example                          | Type               | Status     |\n|------------------|---------------------------------|--------------------|------------|\n| `src`            | `src=\"/profile.png\"`             | String             | Required   |\n| `width`          | `width={500}`                   | Integer (px)       | Required   |\n| `height`         | `height={500}`                  | Integer (px)       | Required   |\n| `alt`            | `alt=\"Picture of the author\"`  | String             | Required   |\n| `loader`         | `loader={imageLoader}`          | Function           | -          |\n| `fill`           | `fill={true}`                   | Boolean            | -          |\n| `sizes`          | `sizes=\"(max-width: 768px) 100vw, 33vw\"` | String   | -          |\n| `quality`        | `quality={80}`                  | Integer (1-100)    | -          |\n| `priority`       | `priority={true}`               | Boolean            | -          |\n| `placeholder`    | `placeholder=\"blur\"`            | String             | -          |\n| `style`          | `style={{objectFit: \"contain\"}}`| Object             | -          |\n| `onLoadingComplete` | `onLoadingComplete={img =\u003e done()}` | Function       | Deprecated |\n| `onLoad`         | `onLoad={event =\u003e done()}`      | Function           | -          |\n| `onError`        | `onError={event =\u003e fail()}`     | Function           | -          |\n| `loading`        | `loading=\"lazy\"`                | String             | -          |\n| `blurDataURL`    | `blurDataURL=\"data:image/jpeg...\"` | String         | -          |\n| `overrideSrc`    | `overrideSrc=\"/seo.png\"`         | String             | -          |\n\n---\n\n### 필수로 꼭 들어가야 하는 props\nImage 컴포넌트를 쓸 때는 최소한 다음 네 가지는 꼭 지정해줘야 해요.\n\n- `src`: 이미지 경로 (예: `/profile.png`)  \n- `alt`: 이미지가 로드되지 않을 때 대체 텍스트 역할을 하는 설명  \n- `width`: 이미지 너비 (픽셀 단위)  \n- `height`: 이미지 높이 (픽셀 단위)  \n\n`width`와 `height` 대신에 `fill={true}` 옵션을 사용하는 방법도 있는데, 이 경우 이미지가 부모 요소의 크기에 맞춰서 자동으로 채워지게 돼요.\n\n---\n\n### 그 외에 알아두면 좋은 점들\n- `loader`: 커스텀 이미지 로더를 만들 때 유용해요. 기본 로더 대신 내가 원하는 로딩 방식을 정의할 수 있어요.  \n- `priority`: 중요한 이미지는 이 옵션을 true로 설정해서 퍼포먼스를 개선할 수 있어요. React 내장 lazy loading과 다르게 우선 로드되게 할 수 있답니다.  \n- `placeholder`와 `blurDataURL`: 이미지를 불러오기 전에 흐릿한 이미지(blur 효과)를 보여 주는 용도로 자주 쓰여요. 사용자 경험을 한층 부드럽게 만들어주죠.  \n- `sizes`: 반응형 이미지에서 매우 유용해요. 화면 크기에 따라 적절한 이미지 크기를 제공할 수 있게 도와줍니다.  \n- `onLoad`와 `onError`: 이미지가 로드되었을 때나 에러가 났을 때 적절한 콜백 처리를 하고 싶으면 이 props들을 활용하세요.  \n\n`onLoadingComplete`는 요즘은 사용을 권장하지 않는 Deprecated 상태니까, 가능하면 `onLoad`를 사용하시는 걸 추천해요.\n\n---\n\n실제 프로젝트에서 이미지를 최적화하고 싶을 때 이 컴포넌트의 다양한 옵션들을 잘 활용하면 훨씬 효율적이고 깔끔한 구현이 가능해집니다. 저는 개인적으로 `priority`, `placeholder`, 그리고 `sizes` 옵션을 자주 사용해서 사용자 경험이 좋아지는 걸 체감했어요.\n\n필요한 부분만 잘 골라서 쓰면 되니 너무 걱정 말고 하나씩 시도해보면서 익혀보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! 오늘은 Next.js에서 `Image` 컴포넌트를 사용할 때 `src` 속성에 대해 알아볼게요.\n\n```js\nimport Image from 'next/image'\n \nexport default function Page() {\n  return (\n    \u003cdiv\u003e\n      \u003cImage\n        src=\"/profile.png\"\n        width={500}\n        height={500}\n        alt=\"Picture of the author\"\n      /\u003e\n    \u003c/div\u003e\n  )\n}\n```\n\n위 예제에서 `src`는 이미지 경로를 나타내는데요, Next.js에서는 `src`에 사용할 수 있는 값이 제한되어 있습니다. 그 조건을 한번 살펴볼게요.\n\n| src 값 유형         | 설명                                                                                         |\n|--------------------|--------------------------------------------------------------------------------------------|\n| 정적으로 import된 이미지 파일 | 예를 들어, `import profilePic from '../public/profile.png'` 처럼 미리 불러온 이미지 파일을 사용할 수 있어요.          |\n| 경로 문자열              | URL 형태의 문자열로, 다음 두 경우로 나뉘어요: \u003cbr\u003e - 외부 URL: `https://example.com/image.png` \u003cbr\u003e - 내부 경로: `/profile.png` 等 |\n\n여기서 중요한 점! 내부 경로를 쓸 때는 `loader` 속성에 따라서 다음과 같이 처리되는데요,\n\n- 기본 `loader`를 사용할 때는 `/public` 폴더 내의 자원을 지정할 때는 경로가 `/` 로 시작해야 해요.즉, `/profile.png`는 `public/profile.png`에 위치한 파일을 가리킵니다.\n- 외부 이미지 URL을 쓸 땐 반드시 도메인을 `next.config.js`의 `images.domains` 배열에 추가해줘야 정상적으로 최적화가 이루어져요.\n\n또한, Next.js의 `Image` 컴포넌트는 이미지 최적화나 lazy loading 등 다양한 이점을 주는데요, 그래서 `width`와 `height`를 꼭 명시해주는 게 좋아요. 그래야 이미지가 로드되기 전에도 레이아웃이 안정적으로 잡히고, 화면이 덜 흔들리게 되거든요.\n\n추가 팁으로, 만약 이미지를 자바스크립트에서 직접 import 한다면 이렇게 쓸 수 있습니다:\n\n```js\nimport profilePic from '../public/profile.png'\n\n\u003cImage\n  src={profilePic}\n  alt=\"Profile\"\n  width={500}\n  height={500}\n/\u003e\n```\n\n이렇게 하면 Next.js가 빌드 타임에 이미지 사이즈를 정확히 파악해서 최적화에 도움을 줄 거예요.\n\n요약하면, `src`에 들어가는 값은 크게 두 가지! **정적 import한 이미지** 또는 **경로 문자열**이에요. 외부 이미지를 쓸 때는 꼭 `next.config.js`에 도메인 등록 잊지 마시고, 내부 경로는 `public` 폴더를 기준으로 적절하게 작성하면 된답니다.\n\nNext.js에서 이미지 다루기를 조금 더 편하고 효율적으로 하려면 이 부분을 잘 이해하시면 큰 도움이 될 거예요! 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기본 로더(default loader)를 사용할 때는 다음 사항도 꼭 참고하세요:\n\n- src가 외부 URL일 경우에는 `remotePatterns` 설정도 함께 해줘야 합니다.\n- src가 애니메이션 이미지거나 JPEG, PNG, WebP, AVIF, GIF, TIFF 같은 알려진 포맷이 아닐 때는, 이미지는 있는 그대로(served as-is) 서빙됩니다.\n- src가 SVG 형식이면 기본적으로 차단됩니다. SVG를 사용하려면 `unoptimized` 또는 `dangerouslyAllowSVG` 옵션을 활성화해야 해요.\n\n---\n\n### width 속성\n\n`width` 속성은 이미지의 실제 픽셀 너비를 나타내는 값이에요. 이 값은 이미지가 로드될 때 레이아웃이 흔들리는 걸 막기 위해 적절한 종횡비(aspect ratio)를 계산하는 데 쓰입니다. 하지만 이게 곧 화면에 표시되는 크기를 결정하는 건 아니에요! 화면에 보이는 크기는 CSS로 조절하게 돼요. 쉽게 말해, HTML의 `img` 태그에서 `width` 속성과 비슷한 역할을 한다고 생각하시면 됩니다.\n\n요즘 반응형 이미지 대응이나 레이아웃 안정성을 위해 width, height 같은 실제 이미지 크기 정보를 명확히 지정해주는 게 권장되고 있으니 꼭 기억해 주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n필수 항목입니다. 단, 정적으로 임포트된 이미지나 fill 속성이 적용된 이미지의 경우는 예외입니다.\n\n### height (높이)\n\nheight 속성은 이미지의 본래 높이를 픽셀 단위로 나타냅니다. 이 값은 이미지의 올바른 가로세로 비율을 추론하는 데 사용되며, 로딩 중에 레이아웃이 흔들리는 현상(layout shift)을 방지하는 효과가 있어요. 다만, 실제 화면에 렌더링되는 이미지 크기를 결정하는 속성은 아니에요. 렌더링 크기는 CSS에서 제어하며, HTML `img` 태그의 height 속성과 비슷한 역할을 한다고 생각하시면 됩니다.\n\n이 부분에서 중요한 점은, height 속성을 명시해두면 브라우저가 이미지 로딩 시점에 공간을 미리 확보하기 때문에 “레이아웃 점프” 현상을 줄여 사용자 경험을 개선할 수 있다는 것입니다. 특히 페이지 내 이미지가 많거나 이미지가 느리게 로드되는 환경에서 이 점이 큰 도움이 됩니다.\n\n추가로, 만약 정적으로 임포트된 이미지라면 빌드 시점에 이미지 크기 정보가 이미 포함되어 있어 직접 height를 명시하지 않아도 되고, fill 속성(부모 요소의 크기에 맞춰 이미지를 꽉 채우는 스타일)을 사용하는 경우에도 마찬가지로 height를 직접 지정할 필요가 없습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003e 알아두면 좋은 점:\nwidth와 height 속성은 이미지의 가로세로 비율(종횡비)을 결정하는 데 함께 사용돼요. 브라우저는 이 정보를 바탕으로 이미지가 로딩되기 전에 미리 공간을 확보하죠.  \n하지만 intrinsic size(내재적 크기)가 항상 브라우저에 렌더링되는 크기와 같지는 않아요. 부모 컨테이너 크기에 따라 이미지가 그 안에 맞게 조절되거든요. 예를 들어, 부모 컨테이너가 이미지 intrinsic size보다 작으면, 이미지는 자동으로 축소되어 컨테이너에 맞춰지는 거죠.  \n만약 width와 height가 애초에 알려지지 않았다면, `fill` 속성을 활용할 수도 있어요.\n\n### alt 속성\n\n이미지의 alt 속성은 화면 읽기 기기(screen reader)와 검색 엔진을 위한 설명 역할을 해요. 이미지가 비활성화되어 있거나 로딩 오류가 발생했을 때는 대체 텍스트로 나타나죠.\n\nalt 텍스트는 페이지의 의미를 바꾸지 않고 이미지를 대신할 수 있는 내용을 담아야 합니다.  \n즉, 이미지를 보완하는 용도가 아니라, 이미지 캡션이나 주변 텍스트에서 이미 설명한 내용을 반복하면 안 돼요.  \n\n요즘은 웹 접근성의 중요성이 부각되면서, 올바른 alt 속성 작성이 필수로 권장되고 있어요. 특히 시각장애인들이 사용하는 스크린 리더에서는 이미지가 제공하는 정보를 alt가 대신 전달하기 때문에, 간결하면서도 핵심을 담는 것이 좋답니다.\n\n| 속성              | 설명                                                         |\n|-------------------|--------------------------------------------------------------|\n| width, height     | 이미지의 가로세로 비율 결정, 브라우저가 공간 미리 확보       |\n| intrinsic size    | 실제 이미지 파일의 원본 크기, 부모 컨테이너에 따라 조정됨    |\n| fill              | width, height 미지정 시 공간에 꽉 채우기 위한 옵션           |\n| alt               | 이미지 설명, 스크린 리더와 검색 엔진에 활용되며 대체 텍스트 역할 |\n\n이미지 태그를 작성할 때는 위 내용을 참고해서, 디자인 뿐 아니라 접근성과 SEO까지 한 번에 챙겨보시면 좋아요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이미지가 단순히 장식용이거나\n사용자에게 중요한 정보 전달 목적이 아니라면,\nalt 속성은 빈 문자열로 설정하는 게 좋아요 (alt=\"\").\n\n더 알아보기\n\n## 선택적 속성(Optional Props)\n\n`Image /` 컴포넌트는 필수 속성 외에도 다양한 추가 속성을 지원해요.  \n이번 섹션에서는 가장 자주 쓰이는 속성들을 소개할게요.  \n좀 더 특별하거나 덜 자주 쓰이는 속성들은 '고급 속성(Advanced Props)' 섹션에서 확인할 수 있어요.\n\n---\n\n참고로, alt 속성은 이미지가 로드되지 않을 때 대체 텍스트로 보여주기도 하고, 시각장애인들이 스크린 리더를 사용할 때 이미지 내용을 설명해줘서 접근성 측면에서 매우 중요하답니다.  \n하지만 장식용인 경우에는 오히려 의미 없는 텍스트가 읽히면서 사용자에게 혼란을 줄 수 있으니, 빈 문자열로 두는 게 맞아요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### loader\n\n이미지 URL을 처리할 때 사용하는 커스텀 함수예요.\n\nloader 함수는 이미지에 필요한 URL을 직접 만들어내는데, 함수에 넘겨지는 주요 인자는 다음과 같아요:\n\n- `src`: 이미지 경로 또는 파일명\n- `width`: 이미지 너비 (픽셀 단위)\n- `quality`: 이미지 품질 (보통 압축률이나 화질 조절에 사용)\n\n이걸 기억하면, 원하는 대로 이미지 URL을 동적으로 생성할 수 있답니다! 예를 들어, CDN에서 이미지를 받아올 때 너비나 품질에 맞게 URL을 조합해서 요청할 수 있죠.\n\n추가로, 로더를 직접 만들면 기본 이미지 최적화 방식을 바꾸거나, 외부 이미지 서비스(예: Cloudinary, Imgix 등)를 쓸 때 유용해요. 그런 경우 URL 생성 규칙이 다르니까 loader 함수에서 그에 맞게 처리하면 되죠.\n\n---\n\n만약 간단한 예시가 궁금하다면 이렇게 써볼 수 있어요:\n\n```js\nfunction myLoader({ src, width, quality }) {\n  return `https://mycdn.com/${src}?w=${width}\u0026q=${quality || 75}`;\n}\n```\n\n위처럼 `src`, `width`, `quality`를 받아서 URL을 조합하고, 이 URL을 이미지 컴포넌트에 넘겨주면 돼요.  \n그럼 필요한 크기와 품질에 맞춰서 이미지를 호출하니 네트워크 비용도 아끼고 페이지 속도도 좋아져요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기 커스텀 로더(custom loader)를 사용하는 예제가 있어요:\n\n```js\n'use client'\n\nimport Image from 'next/image'\n\nconst imageLoader = ({ src, width, quality }) =\u003e {\n  return `https://example.com/${src}?w=${width}\u0026q=${quality || 75}`\n}\n\nexport default function Page() {\n  return (\n    \u003cImage\n      loader={imageLoader}\n      src=\"me.png\"\n      alt=\"Picture of the author\"\n      width={500}\n      height={500}\n    /\u003e\n  )\n}\n```\n\n### 핵심 포인트\n- `loader`라는 프로퍼티에 함수 형태로 로더를 넣을 때는 **클라이언트 컴포넌트(Client Components)** 안에서 사용해야 해요. 이유는 Next.js가 이 함수를 직렬화(serialization)해야 하기 때문입니다.\n- 즉, `'use client'` 지시어를 꼭 컴포넌트 상단에 추가해줘야 오류가 안 납니다.\n\n---\n\n### 참고!  \n만약 앱 전역에 걸쳐서 모든 `next/image` 컴포넌트에 대해 같은 커스텀 로더를 쓰고 싶다면, `next.config.js`의 `loaderFile` 옵션을 설정하는 방법도 있어요. 그러면 매번 개별 컴포넌트에서 `loader` prop을 넘겨주지 않아도 되죠. \n\n```js\n// next.config.js\nmodule.exports = {\n  experimental: {\n    images: {\n      loaderFile: './my-custom-loader.js',\n    },\n  },\n}\n```\n\n`my-custom-loader.js`에 로더 함수를 작성해두면 Next.js가 자동으로 이걸 참조합니다.\n\n---\n\n### 커스텀 로더 쓸 때 알아두면 좋은 점\n\n| 내용                        | 설명                                                           |\n|-----------------------------|----------------------------------------------------------------|\n| 로더에서 다루는 인자          | `src`, `width`, `quality` 등 이미지 최적화에 중요한 값들         |\n| 기본 품질 값                 | `quality`가 없으면 75로 기본 세팅되는 경우가 많음                  |\n| 'use client' 필요            | 로더 함수를 컴포넌트 안에서 직접 넘길 땐 클라이언트 컴포넌트여야 함  |\n| 전역 설정 가능               | `loaderFile` 옵션으로 앱 전체에 일괄 적용 가능                    |\n\n---\n\n커스텀 로더는 외부 CDN이나 이미지 서버에서 동적으로 크기 조절, 품질 조절이 가능할 때 특히 유용해요. 이렇게 하면 필요한 사이즈로 딱 맞는 이미지를 받아와서 페이지 로딩 속도를 개선할 수 있답니다. \n\n혹시 이미지 최적화 관련해서 더 궁금한 점 있으면 언제든 질문 주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### fill\n\n```js\nfill={true} // {true} | {false}\n```\n\n`fill`은 이미지가 부모 요소를 꽉 채우도록 하는 불리언 값이에요. 특히, 이미지의 너비와 높이를 미리 지정하기 어려울 때 유용하죠.\n\n단, 이 기능을 제대로 사용하려면 부모 요소에 `position: \"relative\"`, `position: \"fixed\"`, 또는 `position: \"absolute\"` 스타일을 꼭 지정해줘야 해요. 그래야 이미지가 부모 요소 안에서 정확하게 위치하고 크기가 맞춰지니까요.\n\n예를 들어 이렇게 쓸 수 있겠죠:\n\n```jsx\n\u003cdiv style={{ position: 'relative', width: '100%', height: '300px' }}\u003e\n  \u003cImage src=\"/example.jpg\" alt=\"Example\" fill={true} /\u003e\n\u003c/div\u003e\n```\n\n여기서 `div`에 `position: 'relative'`를 줌으로써 이미지가 그 영역을 꽉 채우게 만들 수 있어요.\n\n이 점 꼭 기억하고 활용하면, 반응형 이미지 배치 때 꽤 편리하답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기본적으로 img 태그에는 position: \"absolute\" 스타일이 자동으로 적용돼요.\n\n만약 이미지에 별도의 스타일이 지정되지 않았다면, 이미지는 컨테이너 크기에 맞춰 늘어나게 돼요. 그런데 이럴 때 이미지가 찌그러지거나 비율이 이상해질 수 있죠. 그래서 보통은 object-fit: \"contain\" 스타일을 주는 게 좋아요. 이걸 주면 이미지가 컨테이너 안에 딱 맞게 맞춰지고, 빈 공간이 있을 때는 레터박스(검은 여백)가 생기면서 원본 비율을 유지해 줍니다.\n\n반대로 object-fit: \"cover\"를 사용하면 이미지가 컨테이너를 꽉 채우도록 잘리면서 보여줘요. 원본 비율은 지키지만, 이미지 일부가 잘릴 수 있다는 점 명심하세요.\n\n이렇게 object-fit을 적절히 활용하면 웹에서 이미지가 깨지거나 비율이 이상해지는 걸 방지할 수 있어요. 특히 반응형 웹이나 다양한 크기의 컨테이너에 이미지를 넣을 때 꼭 알아두면 좋은 CSS 속성이죠.\n\n| 속성        | 설명                                         |\n|-------------|----------------------------------------------|\n| position    | 이미지 위치 지정, 기본값은 \"absolute\"        |\n| object-fit  | 이미지의 컨테이너 내 맞춤 방식 지정          |\n| contain     | 이미지 비율 유지하며 컨테이너 안에 모두 보여줌 |\n| cover       | 비율 유지하며 컨테이너를 완전히 덮되 일부 잘림 |\n\n더 자세한 내용은 CSS의 object-fit 관련 문서를 참고하면 도움이 될 거예요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n오늘은 웹 개발할 때 이미지 다룰 때 꼭 알아두면 좋은 CSS 속성 몇 가지와 함께, 특히 `sizes` 속성에 대해 이야기해볼게요. 이미지 로딩 성능과 반응형 디자인에 큰 영향을 주기 때문에 이해하면 꽤 유용하답니다.\n\n---\n\n### position, object-fit, object-position 간단 정리\n\n- **position**  \n  이미지나 요소의 위치를 설정할 때 쓰이는 CSS 속성이죠. 예를 들어, `relative`, `absolute` 같은 값을 줘요. 이미지가 컨테이너 내에서 어떻게 배치될지 결정할 때 많이 씁니다.\n\n- **object-fit**  \n  이미지를 컨테이너 크기에 맞게 어떻게 맞출지 정하는 속성이에요. 대표값으로는 `cover` (이미지 꽉 채우기, 잘릴 수 있음), `contain` (이미지 전체 보이도록 축소/확대), `fill` (비율 무시하고 꽉 채움), `none` (원본 크기 유지) 등이 있어요.\n\n- **object-position**  \n  `object-fit`이 `cover`나 `contain`일 때, 이미지가 컨테이너 안에서 어디에 위치할지 정하는 속성이에요. 기본값은 `center center`죠. 간단히 `top left`, `bottom right` 등으로 조절할 수 있어요.\n\n이 세 가지 조합하면, 이미지가 반응형일 때 원하는 방식으로 나타나게 할 수 있어요!\n\n---\n\n### sizes 속성 이해하기 (이미지 로딩 최적화에 핵심!)\n\n`\u003cimg\u003e` 태그에서 특히 `\u003csource\u003e`와 함께 쓰면서 '지금 이 화면 사이즈에서 이미지가 실제로 얼마나 크게 보여질지' 브라우저에 알려주는 역할을 해요. 사실, 브라우저가 이미지 크기를 미리 알고 있으면, 가장 적합한 크기의 이미지를 요청할 수 있어 성능이 팍 좋아집니다.\n\n#### sizes 정의 방식\n\n- 문자열 형태로 쓰고, CSS 미디어 쿼리랑 비슷해요.\n- 화면 너비 기준으로 '어떤 상황에 이미지가 몇 픽셀 너비만큼 보여질지'를 지정해줘요.\n- 여러 조건을 콤마(,)로 구분해 순서대로 해석합니다.\n\n예를 들어,\n\n```css\nsizes=\"(max-width: 600px) 480px, 800px\"\n```\n\n이렇게 하면, 화면 너비가 600px 이하일 땐 이미지가 480px 크기로 보여지고, 그 이상일 땐 800px 크기로 보여질 거란 걸 알려주는 거죠.\n\n#### sizes가 중요한 이유\n\n- `fill` 또는 반응형 크기를 가진 이미지를 사용할 때 특히 효과적입니다.\n- 화면 크기에 맞춘 적절한 이미지 해상도를 요청해 불필요한 데이터 낭비를 줄여줍니다.\n- 결국, 로딩 속도 개선과 데이터 절약으로 이어지니 모바일 환경에선 필수!\n\n---\n\n### 간단 요약 테이블\n\n| 속성           | 설명                                       | 대표값 및 의미                          |\n|----------------|------------------------------------------|---------------------------------------|\n| position       | 요소의 위치 설정                         | relative, absolute 등                 |\n| object-fit     | 이미지가 컨테이너 내에서 크기 조절 방법 | cover, contain, fill, none            |\n| object-position| 이미지 내부에서 위치 지정                | center center (기본), top left 등     |\n| sizes          | 여러 화면 크기에 맞춘 이미지 출력 크기 안내 | (media query) 크기, 최종 이미지 너비 |\n\n---\n\n### 마무리 팁\n\n- **`sizes`가 없으면?**  \n  브라우저는 디폴트로 전체 이미지 크기를 사용하거나 해상도에 맞춘 이미지를 선택 못해, 큰 이미지 불필요하게 다운받을 수 있어요.\n\n- **`srcset`과 함께 쓰기!**  \n  `sizes`는 주로 `srcset`과 같이 써서 여러 해상도 이미지를 상황에 맞게 불러오도록 해요.\n\n- **반응형 이미지 사용시 필수!**  \n  화면 크기별로 이미지를 다르게 하고 싶으면, `sizes`에 익숙해지는 게 좋습니다.\n\n---\n\n이미지를 효율적으로 다루는 건 작은 것 같지만 웹 페이지 속도와 사용자 경험에 큰 차이를 만듭니다. `position`, `object-fit`, `object-position`으로 디자인을 잡고, `sizes`로 똑똑하게 이미지 로딩 관리해보세요! 앞으로도 계속 실용적인 웹 테크닉 알려드릴게요. 궁금한 점 있으면 댓글 남겨주세요~ 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nnext/image의 sizes 속성, 제대로 이해하고 있나요?  \n이미지를 좀 더 똑똑하게 불러오고 싶다면 sizes 속성만큼 중요한 것도 없어요. 이번 글에서는 sizes가 왜 필요한지, 그리고 어떻게 활용하면 좋은지 쉽게 풀어볼게요.\n\n---\n\n### 1. sizes는 \"얼마나 크게 이미지를 보여줄 건지\" 알려주는 역할이에요.\n브라우저는 `\u003cImage\u003e` 컴포넌트에 자동으로 만들어지는 srcset(다양한 크기의 이미지 묶음)을 보고 어떤 이미지를 다운받을지 결정하는데요. 이때 sizes 속성 값이 중요한 역할을 해요.\n\n- sizes가 없다면?  \n  기본값인 `100vw`(화면 가로 너비 100%)로 인식해서, **화면 크기만큼 큰 이미지를 다운받아요**.  \n  즉, 모바일 화면이라도 큰 데스크톱용 이미지를 받을 수도 있다는 뜻이죠. 낭비 그 자체...!\n\n- sizes가 있으면?  \n  화면 크기나 레이아웃에 맞는 이미지를 미리 알려서, 그에 적합한 크기의 이미지를 똑똑하게 골라 다운받을 수 있어요.\n\n---\n\n### 2. sizes는 srcset을 어떻게 만들어내느냐에도 영향을 줘요.\n자동 생성되는 srcset이 크게 두 가지로 나뉘는데요.\n\n- sizes가 없을 때는, 고정 크기 이미지용으로 작은 srcset이 만들어져요 (예: 1x, 2x...)  \n- sizes가 있으면, 반응형 이미지를 위한 큰 srcset이 생성돼요(예: 640w, 750w 같은 픽셀 너비 단위)\n\n특히 sizes에 `50vw`처럼 뷰포트의 % 단위가 들어가면, 불필요하게 작은 이미지 옵션들이 걸러져서 srcset이 간결해지고, 진짜 필요한 이미지들만 주로 다운받게 되죠.\n\n---\n\n### 실제 사례로 살펴볼게요!\n\n```js\nimport Image from 'next/image'\n\nexport default function Page() {\n  return (\n    \u003cdiv className=\"grid-element\"\u003e\n      \u003cImage\n        fill\n        src=\"/example.png\"\n        sizes=\"(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw\"\n      /\u003e\n    \u003c/div\u003e\n  )\n}\n```\n\n- 화면이 최대 768px이면? 이미지가 화면 최대 너비(`100vw`)로 보여져요 - 주로 모바일용  \n- 768px 초과, 1200px 이하 화면이면? 이미지가 화면 너비의 절반(`50vw`)  \n- 1200px 초과면? 이미지가 화면 너비의 33%(`33vw`)만 차지한다는 의미\n\n---\n\n### sizes의 위력: 성능에 미치는 영향\n\n만약 `sizes`를 위 예시처럼 적절히 지정하지 않으면, 특히 데스크톱에서 **실제로 1/3 크기만 필요한 이미지를 3배 크기(가로 기준) 이미지로 다운받게 되겠죠**?  \n이미지 파일 크기는 가로 * 세로이기 때문에, 파일 크기는 대략 가로 크기의 제곱에 비례해요.  \n즉, 3배 큰 이미지를 받으면, 용량은 9배가 될 수 있다는 말입니다!\n\n---\n\n### 정리!\n\n| 포인트 | 설명 |\n|--------|-------|\n| sizes의 역할 | 이미지가 실제로 렌더링될 크기를 브라우저에 알려서 적합한 이미지 선택 유도 |\n| sizes 없을 때 | 기본 `100vw`로 간주, 무조건 화면 가로폭만큼 큰 이미지 다운 |\n| sizes가 있으면 | 반응형 srcset 선택 가능, 불필요한 큰 이미지 다운로드 억제 |\n| 권장 활용 | 뷰포트 크기별 예상 이미지 크기를 sizes에 정의해두기 |\n\n---\n\n### 추가 팁!\n\n- `fill` 속성을 사용할 때는 특히 sizes 설정 꼭 해주세요.  \n  그 이유는 fill일 때 이미지가 부모 요소에 맞춰 꽉 채워지는데, sizes가 없으면 무조건 화면 가로 크기로 판단하기 때문이에요.\n\n- 복잡한 레이아웃 환경이라면, media query 같은 복수 조건으로 sizes를 꼭 세분화해서 지정하는 습관을!\n\n---\n\n이처럼 sizes가 제한적으로 보이지만, 성능 최적화에 있어선 꽤나 강력한 역할을 해요.  \n앞으로 next/image 쓸 때는 **sizes 설정 잊지 말고 성능도 챙기는 스마트한 개발자**가 되어봅시다!  \n궁금한 점 있으면 댓글로 알려주세요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nsrcset과 sizes 속성에 대해 조금 더 재미있게 파헤쳐보도록 할게요!\n\n---\n\n## srcset과 sizes: 이미지 최적화를 위한 든든한 친구들\n\n웹에서 이미지가 너무 크거나 작게 나오면 사용자 경험이 떨어지잖아요? 그래서 요즘은 반응형 이미지를 쉽게 구현할 수 있도록 srcset과 sizes라는 속성을 많이 사용해요.\n\n### srcset이란?\n\n이미지를 다양한 크기로 준비해두고, 브라우저가 화면 크기나 해상도에 맞게 적절한 이미지를 골라서 보여주도록 해주는 역할이에요.\n\n예를 들어:\n\n```html\n\u003cimg \n  src=\"small.jpg\" \n  srcset=\"small.jpg 500w, medium.jpg 1000w, large.jpg 1500w\" \n  alt=\"예쁜 고양이\" \n/\u003e\n```\n\n위에서 500w, 1000w, 1500w는 각각 이미지의 가로 너비(pixel) 크기를 의미해요. 브라우저가 화면에 맞게 적절한 이미지를 골라서 내려받겠죠.\n\n### sizes란?\n\nsizes는 브라우저에게 \"내 이미지는 이렇게 크기로 보여질 거야\"라고 미리 알려주는 역할을 해요. 예를 들어, 내가 이미지가 보통 뷰포트의 50% 정도 차지한다면 그에 맞게 알려주면 크기를 더 정확하게 고를 수 있습니다.\n\n```html\n\u003cimg\n  src=\"small.jpg\"\n  srcset=\"small.jpg 500w, medium.jpg 1000w, large.jpg 1500w\"\n  sizes=\"(max-width: 600px) 100vw, 50vw\"\n  alt=\"예쁜 강아지\"\n/\u003e\n```\n\n- `(max-width: 600px) 100vw`: 뷰포트가 600px 이하일 때는 이미지가 화면 너비 전체(100vw)를 차지한다는 뜻이에요.\n- `50vw`: 그 외에는 화면 너비의 50%만 쓰인다는 뜻이에요.\n\n### quality 속성도 알아두자!\n\n위에서 언급된 quality는 이미지 처리 라이브러리(예: Next.js 이미지 컴포넌트)에서 이미지를 압축할 때 몇 퍼센트 품질로 줄일 건지를 나타내요. 1~100까지 숫자를 받는데, 너무 낮으면 이미지가 뭉개지고, 너무 높으면 용량도 커져서 로딩이 느려져요. 보통 70~80 수준에서 적절히 타협하는 편입니다.\n\n```js\nquality={75} // 적당한 화질과 용량의 밸런스를 잡을 수 있어요\n```\n\n---\n\n### 참고하면 좋은 사이트\n\n- [web.dev의 srcset 설명](https://web.dev/learn/design/responsive-images/)\n- [MDN 이미지 반응형 가이드](https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images)\n\n---\n\n이제부터 이미지 태그 예쁘게 짜서 웹사이트 속도도 챙기고 사용자 경험도 쏙쏙 높여보아요!  \n궁금한 점 있으면 언제든 댓글로 물어봐 주세요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이미지 최적화에서 quality(품질) 값은 1부터 100 사이의 정수로 설정할 수 있는데요, 100이 가장 높은 품질이자 가장 큰 파일 크기를 의미합니다. 기본값은 75로 설정되어 있어요.\n\n만약 next.config.js 파일에서 qualities 설정을 따로 정의해뒀다면, quality 속성 값은 그 중 하나와 꼭 일치해야 한다는 점 기억하세요.\n\n\u003e 참고할 내용: 원본 이미지가 이미 저품질이라면, quality 값을 너무 높게 설정할 경우 최적화된 이미지가 오히려 원본 파일보다 용량이 더 커질 수 있으니 주의가 필요합니다.\n\n---\n\n### priority (우선순위)\n\n여기서 priority는 Next.js에서 이미지 로딩 시, 어느 이미지를 더 빨리 불러올지 우선순위를 정하는 속성입니다. 예를 들어, 페이지 상단에 보이는 히어로 이미지 같은 경우 priority를 true로 설정하면, 브라우저가 페이지 렌더링 시 해당 이미지를 더 빨리 불러오게 됩니다.\n\n속성을 간단히 정리하면:\n\n| 속성명   | 설명                                    |\n|---------|----------------------------------------|\n| priority | true로 설정하면 해당 이미지에 우선순위를 줘 빠르게 로드 |\n\n적절하게 priority를 설정하면 사용자 경험이 한층 더 좋아질 수 있으니, 중요한 이미지는 꼭 체크해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\npriority={false} // {false} | {true}\n```\n\n이 옵션이 `true`일 때, Next.js는 해당 이미지를 미리(preload) 불러옵니다. 즉, 이미지가 더 빨리 로드되도록 하는 기능이죠. **중요한 점은, priority가 true일 경우 lazy loading(지연 로딩)이 자동으로 비활성화된다는 것**입니다. 만약 `loading` 속성을 사용하면서 `lazy`로 설정하면 `priority`와 함께 쓸 수 없어요. 그래서 priority가 필요한 이미지에서는 `loading` 속성을 제거하는 게 좋습니다.\n\n이 속성은 **Largest Contentful Paint(LCP)** 요소로 감지되는 이미지에 주로 사용해야 합니다. LCP란 페이지 로드 시 사용자에게 가장 크게 보이는 콘텐츠를 의미하는데, 이미지가 이 역할을 한다면 빠르게 불러오는 것이 UX 개선에 도움이 되거든요.\n\n뷰포트 크기에 따라 LCP 요소가 달라질 수 있어서, 여러 개의 이미지를 priority로 설정하는 것도 괜찮습니다. 다만, 이 속성은 화면 상단(above the fold)에 보이는 이미지에만 사용하는 게 효과적입니다. 기본값은 `false`로 설정돼 있어요.\n\n---\n\n### 추가 팁!\n\n- **priority 이미지가 너무 많으면 어떻게 될까요?**  \n  너무 많은 이미지를 미리 불러오면 네트워크에 부담이 갈 수 있으니, 정말 필요한 이미지만 우선순위를 주는 게 좋아요.\n\n- **Next.js의 `Image` 컴포넌트와 함께 사용**  \n  Next.js의 `\u003cImage /\u003e` 컴포넌트에서 이 옵션을 쓰면 자동으로 적절한 최적화도 같이 해줘서, 별도로 신경 쓰지 않아도 됩니다.\n\n- **LCP 개선은 SEO에도 좋아요!**  \n  페이지 로딩 속도와 사용자 경험 개선은 검색 엔진 최적화(SEO)에도 긍정적인 영향을 주니, 중요한 이미지에는 꼭 priority를 고려해보세요.\n\n---\n\n우리 웹 페이지가 빠르게 렌더링되고, 사용자들이 이미지 때문에 답답해하지 않게 하는 작은 팁 하나였어요! 다음 번에도 더 유용한 개발 꿀팁 가지고 올게요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### placeholder\n\n```js\nplaceholder = 'empty' // \"empty\" | \"blur\" | \"data:image/...\"\n```\n\n이미지가 로딩되는 동안 보여줄 자리 표시자(플레이스홀더)를 설정하는 속성입니다. 사용할 수 있는 값은 `'empty'`, `'blur'`, 또는 `'data:image/...'` 형태입니다. 기본값은 `'empty'`입니다.\n\n- `'empty'`: 아무 것도 표시하지 않고 그냥 빈 공간으로 둡니다.\n- `'blur'`: 이미지가 로딩되는 동안 블러 처리된 저해상도 이미지를 보여줍니다. 이때 `blurDataURL` 속성에 지정된 데이터 URL이 플레이스홀더로 사용돼요.\n- `'data:image/...'`: 직접 데이터 URL 형태의 이미지를 넣어서 커스텀 플레이스홀더를 설정할 수도 있습니다.\n\n특히, `blur` 옵션은 정적 임포트(static import)로 불러온 `.jpg`, `.png`, `.webp`, `.avif` 같은 이미지 포맷의 경우 자동으로 `blurDataURL`이 채워지는데, 만약 애니메이션 이미지라면 이 기능이 적용되지 않습니다.\n\n이 기능 덕분에 이미지가 화면에 깜빡이거나 완전히 로드될 때까지 기다리지 않고, 자연스러운 흐릿한 미리보기를 보여줘서 UX가 훨씬 부드러워진답니다. 요즘 웹사이트에서 흔히 볼 수 있는 '더 좋은 사용자 경험'을 위한 작은 팁이죠!\n\n추가로, **blurDataURL**은 보통 아주 작은 크기의 저해상도 이미지 정보를 base64로 인코딩한 문자열을 의미해요. 직접 생성하기 번거롭다면 자동 생성 도구나 라이브러리를 활용하는 것도 방법입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n동적 이미지(dynamic images)를 사용할 때는 반드시 `blurDataURL` 속성을 제공해줘야 해요. 이 속성은 이미지가 로딩되는 동안 보여줄 흐릿한(blurred) 이미지 데이터를 뜻하는데요, 이걸 넣어주면 사용자가 이미지가 완전히 로딩될 때까지 깜빡임 없이 부드러운 경험을 할 수 있답니다.\n\n그런데 이 `blurDataURL` 값을 직접 만들기 번거로울 수 있죠? 그래서 Plaiceholder 같은 솔루션이 인기를 끌고 있어요. Plaiceholder는 이미지를 자동으로 Base64 포맷으로 변환해서 흐릿한 이미지로 만들어주니까, 요긴하게 쓸 수 있어요.\n\n그리고 만약 이미지 URL이 `data:image/...` 형식이라면, 이 데이터 URL이 그대로 로딩 중인 플레이스홀더(placeholder)로 사용돼요. 반면에 `blurDataURL`을 비워두면 로딩 중에 아무 것도 보이지 않고 빈 공간만 남게 되니 주의해야 해요.\n\n쉽게 말해 이런 느낌이에요:\n\n| `blurDataURL` 상태           | 결과                          |\n|-----------------------------|-------------------------------|\n| 값이 세팅된 경우             | 로딩 중 흐릿한 이미지 표시    |\n| `data:image/...` 포맷       | 해당 데이터가 로딩 플레이스홀더로 사용됨 |\n| 비워둔 경우(빈값)           | 로딩 중 빈 공간               |\n\n직접 써보면서 확인해보세요. 이미지의 로딩 경험이 훨씬 부드러워질 거예요! 혹시 더 자세한 설정 방법이나 Plaiceholder 사용법이 궁금하면 알려주세요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 블러(blur) 플레이스홀더 데모  \n- 데이터 URL을 이용한 플레이스홀더 프로퍼티로 쉐이머(shimmer) 효과 데모  \n- blurDataURL 프로퍼티를 활용한 컬러 효과 데모  \n\n## 고급 속성 사용법\n\n때로는 더 복잡한 사용이 필요할 때가 있죠. `Image /` 컴포넌트는 선택적으로 아래와 같은 고급 속성들을 받을 수 있습니다.\n\n### style (스타일)\n\n여기서 스타일을 지정해서 이미지에 다양한 시각적 효과를 줄 수 있어요. 예를 들어, 이미지 모서리를 둥글게 하거나, 그림자를 넣는 등 CSS를 직접 적용할 수 있답니다.\n\n이런 고급 props들을 잘 활용하면 더 세련되고 사용자 친화적인 이미지 로딩 경험을 만들 수 있어요!  \n\n필요하면 다음에 `blurDataURL`이나 쉐이머 효과 만들 때 사용하는 데이터 URL 생성 방법도 같이 소개할게요.  \n편하게 알려드릴 테니 기대해 주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이미지에 CSS 스타일을 직접 전달할 수 있어요.\n\n```js\nconst imageStyle = {\n  borderRadius: '50%',\n  border: '1px solid #fff',\n}\n \nexport default function ProfileImage() {\n  return \u003cImage src=\"...\" style={imageStyle} /\u003e\n}\n```\n\n여기서 중요한 점! 이미지의 `width`와 `height` 속성은 스타일링에 영향을 줄 수 있어요. 만약 CSS 스타일로 이미지의 너비를 조절한다면, 높이는 `auto`로 설정해줘야 원래 비율을 유지할 수 있습니다. 안 그러면 이미지가 찌그러져 보일 수 있거든요.\n\n예를 들면 이렇게 하면 좋아요:\n\n```js\nconst imageStyle = {\n  width: '100px',\n  height: 'auto',\n  borderRadius: '50%',\n  border: '1px solid #fff',\n}\n```\n\n이렇게 하면 너비는 100px로 고정하고, 높이는 자동으로 조절되어 이미지 비율이 깨지지 않죠.\n\n---\n\n### onLoadingComplete\n\n`onLoadingComplete`는 이미지가 모두 로드된 후에 실행되는 콜백 함수입니다. 이미지 처리나 로딩 상태 관리를 할 때 유용해요.\n\n예를 들어, 이미지가 로드 완료되면 어떤 작업을 하고 싶을 때 이렇게 쓸 수 있어요:\n\n```js\nexport default function ProfileImage() {\n  const handleLoadingComplete = () =\u003e {\n    console.log('이미지가 성공적으로 로드되었습니다!');\n    // 여기서 로딩 스피너 숨기기 등 다른 작업을 할 수 있겠죠\n  }\n\n  return \u003cImage src=\"...\" onLoadingComplete={handleLoadingComplete} /\u003e\n}\n```\n\n이 콜백 함수를 활용해서 사용자 경험을 좀 더 부드럽게 만들 수 있어요. 예를 들어 이미지가 로드 중일 때 스피너를 표시하고, 완료되면 스피너를 숨기는 식으로요.\n\n이 부분도 꼭 기억해두세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요, 여러분! 오늘은 Next.js 14에서 Image 컴포넌트의 새로운 변화에 대해 짧게 이야기해보려고 해요.\n\n기존에 아래처럼 `onLoadingComplete`를 썼던 분들 많으시죠?\n\n```js\n'use client'\n\n\u003cImage onLoadingComplete={(img) =\u003e console.log(img.naturalWidth)} /\u003e\n```\n\n그런데 Next.js 14부터는 이 `onLoadingComplete`가 deprecated(더 이상 권장되지 않음) 되었어요. 대신 `onLoad`라는 새로운 콜백 함수가 도입됐답니다.\n\n### 그럼 뭐가 달라졌을까요?\n\n- **`onLoad`** 콜백은 이미지가 완전히 로드되고, 플레이스홀더(placeholder)가 제거된 후에 호출돼요.\n- 이 함수는 실제 `\u003cimg\u003e` 요소를 인자로 받아요. 그래서 이미지의 크기 정보나 기타 속성을 쉽게 가져올 수 있죠.\n\n### 바뀐 사용법은 이렇게!\n\n```js\n'use client'\n\nimport Image from 'next/image';\n\n\u003cImage\n  src=\"/example.jpg\"\n  width={500}\n  height={300}\n  onLoad={(img) =\u003e console.log('Image width:', img.naturalWidth)}\n/\u003e\n```\n\n### 참고!\n- `onLoad` 안에서 받는 인자는 실제 HTML의 `\u003cimg\u003e` 엘리먼트이므로, `naturalWidth`, `naturalHeight`, `currentSrc` 같은 DOM 속성에 접근 가능해요.\n- 이전과 달리 `onLoadingComplete`는 더 이상 공식 문서에서 지원하지 않으니, 꼭 `onLoad`로 바꾸시는 걸 추천드려요.\n\n---\n\n사실 이런 변화는 Next.js가 내부에서 이미지 로딩 과정을 더 효율적이고 통제하기 쉽게 만들기 위한 거라 생각하면 좋아요. 새로운 버전 나오면 공식 문서 체크와 함께 이렇게 바뀐 부분도 챙겨주면 프로젝트 유지보수가 훨씬 편하답니다.\n\n혹시 이미지 로딩과 관련해서 더 궁금한 점 있으면 댓글로 알려주세요! 그럼 즐거운 개발 되세요~ 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003e 참고할 점: onLoadingComplete 같은 함수 형태의 props를 사용할 때는, 전달한 함수를 직렬화하기 위해 클라이언트 컴포넌트를 사용해야 한다는 점을 기억하세요.\n\n### onLoad\n\n```js\n\u003cImage onLoad={(e) =\u003e console.log(e.target.naturalWidth)} /\u003e\n```\n\n이미지가 완전히 로드되고 플레이스홀더가 사라진 후에 실행되는 콜백 함수입니다.\n\n---\n\n여기에 덧붙여서, onLoad 이벤트는 이미지가 화면에 렌더링 되는 순간을 알 수 있어서, 예를 들어 이미지 크기에 따라 레이아웃을 조절하거나 로딩 상태를 업데이트 하는 데 쓸 수 있어요. 또한, 네트워크 상황이 느릴 때 사용자에게 로딩 완료 시점을 알려주는 용도로도 활용할 수 있답니다.\n\n하지만 Next.js의 Image 컴포넌트를 사용할 때는 내장된 최적화 특징 때문에, \"onLoadingComplete\"라는 비슷한 이벤트도 함께 제공되니 필요에 따라 적절히 선택해서 사용하세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n콜백 함수는 이벤트 객체 하나를 인자로 받게 되는데, 여기서 이벤트의 `target`은 실제로 렌더된 `img` 요소를 가리키게 돼요.\n\n\u003e 참고할 점: onLoad처럼 함수 형태의 prop을 사용할 때는, 이 함수를 직렬화하기 위해 클라이언트 컴포넌트(Client Components)를 사용해야 해요.\n\n### onError\n\n```jsx\n\u003cImage onError={(e) =\u003e console.error(e.target.id)} /\u003e\n```\n\n`onError`는 이미지 로드에 문제가 생겼을 때 호출되는 콜백 함수예요. 예를 들면, 이미지 URL이 잘못됐거나 서버에서 이미지를 불러올 수 없을 때 이 함수가 실행되죠. 위 코드에서는 에러가 발생한 이미지 엘리먼트의 id 값을 콘솔에 출력하고 있네요.\n\n참고로, 이런 이벤트 핸들러를 사용할 땐 해당 컴포넌트가 클라이언트에서 동작하도록 설정돼 있어야 한다는 점 기억하세요. 특히 Next.js 같은 프레임워크에서는 서버 컴포넌트와 클라이언트 컴포넌트가 구분되어 있어서, 함수가 전달되는 이벤트 핸들러는 클라이언트 컴포넌트에서만 제대로 동작합니다.  \n\n혹시 이미지 로드 실패 시 사용자에게 다른 이미지를 보여주거나, 오류 메시지를 띄우고 싶다면 `onError` 안에서 상태를 변경하거나 별도의 로직을 구현하면 돼요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이미지 로딩에 실패했을 때 호출되는 콜백 함수에 대해 이야기해볼게요.\n\n---\n\n### onError\n\n이미지 로딩 중 문제가 발생하면 실행되는 함수예요. 예를 들어, 이미지 URL이 잘못되었거나, 서버에 이미지가 없을 때 호출할 수 있죠.\n\n\u003e 참고로 알아두면 좋은 점!  \n\u003e `onError` 같은 콜백 함수를 프로퍼티로 넘기려면, 이 함수를 직렬화(serialization)할 수 있는 **클라이언트 컴포넌트(Client Components)** 안에서 사용해야 해요. 즉, 서버 컴포넌트에서 바로 함수 형태로 넘기면 동작하지 않을 수 있다는 뜻입니다.\n\n---\n\n### loading 속성\n\n```js\nloading = 'lazy' // 'lazy' 또는 'eager' 중 선택 가능\n```\n\n- `lazy` (지연 로딩): 이미지를 사용자가 실제로 볼 때까지 미뤄서 로딩해요. 페이지 초기 로딩 속도 향상에 도움을 줍니다.\n- `eager` (즉시 로딩): 페이지가 로드될 때 이미지를 바로 불러와요. 빠른 렌더링이 필요할 때 쓰면 좋아요.\n\n---\n\n요즘 웹에서는 지연 로딩이 기본 트렌드인데요, 특히 이미지를 많이 쓰는 페이지는 `loading='lazy'`를 적용하는 게 퍼포먼스 향상에 크게 이바지한답니다.\n\n간단한 예제도 같이 볼까요?\n\n```jsx\nimport { useState } from 'react';\n\nfunction ImageWithFallback({ src, alt }) {\n  const [error, setError] = useState(false);\n\n  return (\n    \u003c\u003e\n      {!error ? (\n        \u003cimg\n          src={src}\n          alt={alt}\n          loading=\"lazy\"\n          onError={() =\u003e setError(true)}\n        /\u003e\n      ) : (\n        \u003cdiv\u003e이미지를 불러올 수 없습니다.\u003c/div\u003e\n      )}\n    \u003c/\u003e\n  );\n}\n```\n\n이렇게 하면 이미지가 실패할 때 텍스트로 대체 표시도 할 수 있죠.\n\n---\n\n필요에 따라서 `onError`를 활용해 이미지 교체, 오류 기록, 사용자 알림 등 다양한 작업을 할 수 있으니 기억해두세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이미지 로딩 동작에 대해 이야기해볼게요. 기본값은 `lazy`인데요, 쉽게 말해 이미지는 화면에 보이기 직전에야 로드되도록 지연시켜서 페이지 로딩 속도를 높여주는 거예요.\n\n- `lazy`: 이미지가 화면에 가까워질 때까지 로딩을 미뤄요. 예를 들어, 사용자가 스크롤을 내려서 이미지가 보일 타이밍에 이미지를 불러오는 방식이죠. 데이터 소모도 줄이고 페이지가 훨씬 빨리 뜹니다.\n- `eager`: 이미지가 페이지가 로드될 때 바로 불러와요. 중요한 이미지나 빠르게 보여줘야 할 때 유용하답니다.\n\n이 `loading` 속성 덕분에 개발자들이 웹사이트 성능을 최적화하기가 한결 쉬워졌어요. 자세한 내용을 더 보고 싶다면 [loading attribute에 대해 알아보기](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#loading)에서 확인할 수 있어요.\n\n참고로, `lazy` 로딩은 모든 브라우저가 지원하는 건 아니라서 필요에 따라 자바스크립트로 폴리필을 적용하는 경우도 있어요. 또한, 이미지가 중요한 정보라면 `eager`를 선택하는 게 사용자 경험에 더 좋을 수 있으니 상황에 맞게 잘 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### blurDataURL\n\nblurDataURL은 이미지가 로드되기 전에 임시로 보여줄 작은 이미지를 Base64 형태로 지정할 때 사용해요. 쉽게 말해서, 실제 이미지가 로딩되기 전 잠깐 나타나는 ‘흐릿한 미리보기’ 같은 역할이죠. \n\n주의할 점은 이 값이 반영되려면 꼭 placeholder=\"blur\"와 함께 써야 한다는 거예요! \n\n또, blurDataURL에 넣는 이미지는 아주 작고 간단한 게 좋아요. 보통 10px 이하 크기의 이미지가 적당한데요, 그 이유는 이 이미지가 화면에 확대되고 흐려지면서 보여지기 때문이에요. 너무 큰 이미지를 넣으면 앱 성능에 안 좋을 수 있거든요.\n\n예를 들어 마크다운으로 표현하면 이렇게 써볼 수 있어요:\n\n| 속성명        | 설명                                                             |\n|---------------|----------------------------------------------------------------|\n| blurDataURL   | 로드 전에 쓰이는 미리보기 이미지의 Base64 인코딩 데이터            |\n| placeholder   | `'blur'`으로 설정해서 blurDataURL과 함께 사용해야 효과를 볼 수 있음 |\n\n이걸 활용하면 사용자 경험이 조금 더 매끄러워져서, 이미지가 늦게 뜰 때도 갑자기 빈 화면이 나오는 걸 방지할 수 있어요. 웹이나 앱에서 이미지가 무거워 딜레이가 있을 때 정말 유용하답니다.\n\n직접 써보는 것도 추천해요! 예를 들어, Next.js의 Image 컴포넌트에서 자주 쓰이는 기능이라, 관심 있으면 찾아보시면 도움이 많이 될 겁니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 기본 blurDataURL prop 사용법 데모  \n- blurDataURL prop를 이용한 색상 효과 데모\n\n이미지와 어울리는 단색 색상 Data URL도 생성할 수 있어요.\n\n### unoptimized 옵션\n\n```js\nunoptimized = {false} // false 또는 true 값 사용 가능\n```\n\n---\n\n조금 더 설명을 덧붙이자면, `blurDataURL`은 이미지가 로딩되기 전까지 잠깐 보여줄 작은 저해상도 이미지의 URL이에요. 흔히 ‘로딩 플레이스홀더’로 활용하죠. 특히 네트워크 속도가 느릴 때 사용자에게 부드러운 경험을 선사할 수 있어요.\n\n`unoptimized` 옵션은 Next.js에서 이미지 최적화를 끌지 말지를 결정하는 건데요. 기본값은 `false`로 최적화 기능을 켜둔 상태고, `true`로 설정하면 최적화를 끄고 원본 이미지를 그대로 사용하게 돼요. 개발 과정에서 최적화 문제를 피하거나 특정 상황에서 이미지를 그대로 사용하고 싶을 때 유용합니다.\n\n그리고 색상 효과를 내는 blurDataURL도 많이 활용되는데요, 실제 이미지와 비슷한 톤의 단색을 blurDataURL로 만들어 놓으면 로딩 시 배경색처럼 자연스럽게 보일 수 있어요. 이 방법은 이미지가 로딩되는 동안 사용자 시각 경험을 더 좋게 만들어주니까 개발할 때 한 번쯤 적용해 보는 걸 추천드려요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n원본 이미지를 `src`에서 그대로 내보내고 싶을 때, 즉 퀄리티나 크기, 포맷을 변경하지 않을 때는 `unoptimized` 속성을 `true`로 설정하면 됩니다. 기본값은 `false`입니다.\n\n이렇게 하는 게 특히 좋은 경우는 최적화를 해도 큰 이점이 없는 이미지들이에요. 예를 들어, 아주 작은 이미지(1KB 이하), 벡터 이미지(SVG), 또는 움직이는 이미지(GIF) 등이 그 예입니다.\n\n아래는 간단한 사용 예시입니다:\n\n```js\nimport Image from 'next/image'\n\nconst UnoptimizedImage = (props) =\u003e {\n  return \u003cImage {...props} unoptimized /\u003e\n}\n```\n\n그리고 Next.js 12.3.0부터는 모든 이미지에 대해 `unoptimized` 옵션을 기본으로 적용하려면 `next.config.js` 파일에 다음과 같은 설정을 추가하면 됩니다:\n\n```js\n// next.config.js\nmodule.exports = {\n  images: {\n    unoptimized: true,\n  },\n}\n```\n\n이렇게 설정하면 개별 이미지마다 `unoptimized` 속성을 일일이 지정하지 않아도 되니 관리가 훨씬 편해져요.\n\n추가로, 최적화를 비활성화하면 이미지가 CDN이나 외부 최적화 서비스 없이 그대로 제공되므로, 속도나 용량 활용 측면에서 체크가 필요합니다. 그래서 보통은 작은 이미지나 이미 최적화된 SVG, GIF에만 적용하는 것을 추천드려요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러분, Next.js에서 이미지 최적화 관련 설정해보셨나요? 오늘은 간단하게 `next.config.js`에서 이미지 최적화를 비활성화하는 법과, `Image` 컴포넌트에 `src`를 넘겨줄 때 어떤 일이 일어나는지 살펴보겠습니다.\n\n---\n\n### 이미지 최적화 끄기\n\nNext.js는 기본적으로 이미지 최적화를 자동으로 해주는데요, 가끔은 직접 최적화하지 않고 원본 이미지를 그대로 쓰고 싶을 때가 있죠. 그럴 때 `next.config.js` 파일에 이렇게 설정하면 됩니다:\n\n```js\nmodule.exports = {\n  images: {\n    unoptimized: true,\n  },\n}\n```\n\n이렇게 하면 Next.js가 이미지 최적화를 건너뛰고, 여러분이 지정한 이미지가 그대로 사용돼요.\n\n---\n\n### `Image` 컴포넌트의 `src` 프로퍼티\n\n그리고 `Image` 컴포넌트에 `src` 값을 넘기면, 내부적으로 `srcset` 과 `src` 속성이 자동으로 생성돼서 결국 HTML의 `\u003cimg\u003e` 태그로 변환됩니다.\n\n예를 들어:\n\n```js\n\u003cImage src=\"/me.jpg\" /\u003e\n```\n\n이렇게 쓰면 Next.js가 자동으로 화면 크기에 맞는 여러 해상도의 이미지 URL을 만들어서 `srcset`에 넣어주고, 동시에 기본 `src` 도 넣어줘서 브라우저가 가장 적합한 이미지를 골라서 보여주게 하는 거죠.\n\n이 부분이 왜 좋냐면, 반응형 이미지 처리가 훨씬 편하고, 성능도 좋아진다는 점입니다!\n\n---\n\n### 팁! 이미지 최적화 관련 기억할 점\n\n- `unoptimized: true`를 쓰면 캐싱이나 최적화가 없기 때문에, 프로덕션에서 할 때는 성능 저하가 있을 수 있으니 주의하세요.\n- `next/image` 컴포넌트를 쓸 때는 반드시 `width`와 `height`를 지정하는 게 좋습니다. 그래야 레이아웃이 안정적으로 잡히고 CLS(Cumulative Layout Shift)를 줄일 수 있어요.\n- 외부 도메인의 이미지를 쓸 때는 `next.config.js`에 도메인 허용 설정을 해줘야 합니다.\n\n\u003e 그리고 혹시 더 깊게 이미지 최적화를 알아보고 싶으면, `next/image` 공식 문서도 한번 들여다보시면 정말 많은 팁들이 숨어있답니다!\n\n오늘은 여기까지! 필요할 때마다 참고하시고, 이미지 최적화도 똑똑하게 활용해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! 오늘은 Next.js 이미지 컴포넌트(Image) 사용 시, `src` 속성 자동 생성 문제와 이를 우회하는 방법에 대해 알아볼게요.\n\n보통 `\u003cimg\u003e` 태그를 사용하면 이렇게 srcset과 src를 직접 지정하잖아요?\n\n```html\n\u003cimg\n  srcset=\"\n    /_next/image?url=%2Fme.jpg\u0026w=640\u0026q=75 1x,\n    /_next/image?url=%2Fme.jpg\u0026w=828\u0026q=75 2x\n  \"\n  src=\"/_next/image?url=%2Fme.jpg\u0026w=828\u0026q=75\"\n/\u003e\n```\n\n근데 Next.js의 `\u003cImage\u003e` 컴포넌트를 쓰면 내부적으로 `src`와 `srcset`을 자동으로 생성해줘요. 다 좋은데, 가끔은 이 자동 생성된 `src`를 우리가 직접 지정하고 싶을 때가 있죠. 예를 들어, 기존 웹사이트를 `img`에서 `Image` 컴포넌트로 바꿀 때, SEO 최적화를 위해 이미지 URL을 그대로 유지하고 싶을 수도 있어요. (검색엔진 최적화, 이미지 랭킹 유지 및 재크롤 방지 목적 등)\n\n그럴 때 사용하는 게 바로 `overrideSrc` prop 입니다.\n\n```jsx\n\u003cImage src=\"/me.jpg\" overrideSrc=\"/override.jpg\" /\u003e\n```\n\n이렇게 하면 내부적으로는 `/me.jpg`로 이미지 최적화 및 로딩 처리를 하면서도, 실제 `src` 속성은 `/override.jpg`로 지정할 수 있어요.\n\n🎯 핵심 정리!\n\n| 상황                                | 해결법                        |\n|---------------------------------|-----------------------------|\n| 기본적으로 자동 생성된 src 쓰기 원함       | 그냥 `\u003cImage src=\"...\" /\u003e` 사용      |\n| SEO 등 이미지 URL을 유지해야 할 때            | `\u003cImage src=\"...\" overrideSrc=\"...\" /\u003e` 사용 |\n\n---\n\n추가 팁!\n\n- 이미지 최적화는 Next.js가 자동으로 해주지만, SEO를 위해 실제 보여지는 HTML 속성 값을 직접 관리해야 할 때가 있어서 이렇게 `overrideSrc`가 유용해요.\n- 오버라이드 한 URL이 실제 이미지가 맞는지, 접근 가능 여부는 미리 확인하는 게 좋습니다.\n- `overrideSrc`는 Next.js 공식 문서에 나오는 기능은 아닌 경우가 많아서, 직접 구현하거나 커스텀 이미지 컴포넌트를 만들어 사용하는 방법도 있어요!\n\nNext.js 이미지 컴포넌트를 다룰 때 이런 작은 팁들이 개발 생산성도 올려주고, SEO 챙기는데도 크게 도움 된답니다. 다음에도 유용한 정보로 찾아올게요! 😄\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 코드는 `\u003cimg\u003e` 태그에서 `srcset`과 `src` 속성을 활용하는 예시입니다.\n\n```js\n\u003cimg\n  srcset=\"\n    /_next/image?url=%2Fme.jpg\u0026w=640\u0026q=75 1x,\n    /_next/image?url=%2Fme.jpg\u0026w=828\u0026q=75 2x\n  \"\n  src=\"/override.jpg\"\n/\u003e\n```\n\n### 간단 정리\n\n- `srcset`은 브라우저가 디바이스 해상도에 맞는 이미지를 선택해서 로드할 수 있도록 도와줘요.\n- 위 예시에서는 1배(640px)와 2배(828px) 해상도의 이미지를 준비해뒀죠.\n- `src`는 기본 이미지 URL로, `srcset`을 지원하지 않는 구형 브라우저에서 사용돼요.\n\n---\n\n### decoding 속성에 대해서\n\n브라우저에 이미지의 디코딩(화면에 보여주기 위해 이미지 데이터를 해석하는 과정)을 어떻게 처리할지 힌트를 주는 속성이에요. 기본값은 `async`로, 비동기적으로 디코딩해서 페이지 렌더링 속도에 도움을 줘요.\n\n| 속성값 | 설명                              |\n|--------|---------------------------------|\n| sync   | 이미지 디코딩이 끝날 때까지 렌더링을 중단해요. 주요 이미지에 적합. |\n| async  | 디코딩을 비동기 처리해요. 기본값이며, 렌더링에 지장 없어요. |\n| auto   | 브라우저가 최적의 전략으로 디코딩 방식을 결정해요. |\n\n### 왜 `decoding`을 신경 써야 할까?\n\n이미지가 많은 페이지에서 디코딩 방식을 잘 설정하면, 페이지 렌더링이 훨씬 부드러워지고 사용자 경험이 좋아집니다. 특히 중요한 이미지나 첫 화면에 노출되는 이미지가 있다면 `sync`로 설정해서 바로 보이게 하는 것도 방법이에요.\n\n---\n\n### 한 가지 팁!\n\n`loading=\"lazy\"` 속성과 함께 쓰면, 이미지가 화면 근처에 올 때만 로드하고, 디코딩도 적절히 조절할 수 있어서 성능 최적화에 더 도움이 됩니다.\n\n```html\n\u003cimg src=\"image.jpg\" decoding=\"async\" loading=\"lazy\" alt=\"example\" /\u003e\n```\n\n---\n\n이렇게 이미지 관련 속성들을 적절히 이해하고 사용하면, 웹 페이지의 성능과 사용자 경험을 크게 개선할 수 있어요. 다음에도 좋은 팁으로 또 만나요! 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- async: 이미지를 비동기적으로 디코딩해서, 이미지 로딩이 완료되기 전에도 다른 콘텐츠가 먼저 렌더링될 수 있게 해줘요.\n- sync: 이미지를 동기적으로 디코딩해서, 다른 콘텐츠와 함께 완전하게 한 번에 보여주고 싶을 때 사용해요.\n- auto: 디코딩 모드에 대한 특별한 선호 없이 브라우저가 가장 적절하다고 판단하는 방식을 선택하게 합니다.\n\n디코딩 속성(decoding attribute)에 대해 더 궁금하다면, 자세한 정보를 찾아보는 것도 좋아요. 이미지 로딩 방식에 따라 페이지 렌더링 속도나 사용자 경험이 달라질 수 있으니까요.\n\n### 다른 속성들 (Other Props)\n\n`Image` 컴포넌트에 넣는 다른 모든 속성들은, 특별히 제한된 몇 가지를 제외한 채로 실제 `\u003cimg\u003e` 태그에 그대로 전달됩니다.  \n즉, 일반적인 `alt`, `width`, `height` 같은 속성들은 걱정 없이 사용할 수 있죠.\n\n---\n\n추가로 알려드리자면, 이미지 디코딩 방식은 특히 페이지가 많이 복잡하거나 이미지가 많은 경우 성능에 꽤 큰 영향을 줄 수 있어요. 예를 들어, `async`로 둬서 텍스트 같은 중요한 콘텐츠가 먼저 보이게 하면 사용자 경험이 더 좋아질 수 있답니다. 반면, UI가 깔끔하게 한꺼번에 보여지는 게 중요한 경우엔 `sync`를 선택하는 게 좋고요.\n\n꼭 상황에 맞게 선택해 주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- srcSet 대신 Device Sizes를 사용하세요.\n\n## 설정 옵션\n\n다음은 props 외에 next.config.js 파일에서 Image 컴포넌트를 설정할 수 있는 옵션들입니다. 이 옵션들을 통해 이미지 최적화 동작을 세밀하게 조절할 수 있어요.\n\n### localPatterns\n\n(localPatterns 옵션에 대한 설명이 더 있으면 여기에 추가하면 좋겠지만, 지금은 제목만 주셨네요. 만약 이미지 경로나 패턴을 로컬 이미지 관리에 사용한다면, 이 옵션이 어떤 역할을 하는지 간단히 정리해볼게요.)\n\nlocalPatterns는 로컬 이미지 파일 경로나 패턴들을 지정하는 옵션입니다. 예를 들어, 특정 폴더 내 이미지 파일만 이미지 최적화 대상에 포함하거나 특정 형식의 파일만 처리하도록 할 때 유용하답니다. 이렇게 하면 불필요한 파일까지 빌드 과정에 포함되는 걸 막아 최적화를 더욱 깔끔하게 할 수 있어요.\n\n---\n\n추가로 srcSet과 Device Sizes에 대해 조금 더 알려드릴게요.\n\n### srcSet 대신 Device Sizes 사용하기\n\n예전에는 이미지 태그에 srcSet 속성을 직접 지정해서 여러 해상도 대응 이미지를 넘겨주곤 했는데요, Next.js Image 컴포넌트에서는 deviceSizes 배열을 통해 대응할 화면 너비별 이미지 사이즈를 미리 지정합니다. 그러면 Next.js가 자동으로 가장 적합한 이미지 크기를 골라 srcSet을 만들어서 넣어줘 개발자가 직접 일일이 srcSet을 관리할 필요가 사라지죠.\n\n```js\n// next.config.js 예시\nmodule.exports = {\n  images: {\n    deviceSizes: [320, 420, 768, 1024, 1200],\n  },\n};\n```\n\n이런 식으로 설정하면 각 기기별 스크린 크기에 맞는 이미지가 제공되어 더욱 빠르고 효율적인 이미지 로딩이 가능해져요.\n\n어려운 설정 같아 보여도, Next.js가 알아서 다 해주니까 걱정하지 마세요. 대신 나만의 이미지 정책에 맞게 deviceSizes 같은 옵션을 적절히 조정해주면 됩니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 이미지 최적화를 할 때, 특정 경로만 최적화 대상으로 지정하고 싶다면 `next.config.js` 파일에서 `localPatterns` 옵션을 활용할 수 있어요. 이 옵션을 사용하면 내가 원하는 경로만 이미지를 최적화하고, 그 외의 경로에 대해서는 요청을 차단할 수 있답니다.\n\n예를 들어, 아래처럼 설정하면 `/assets/images/`로 시작하는 로컬 이미지 경로만 최적화가 허용되고, 쿼리 스트링이 붙은 경로는 허용되지 않아요.\n\n```js\nmodule.exports = {\n  images: {\n    localPatterns: [\n      {\n        pathname: '/assets/images/**',\n        search: '',\n      },\n    ],\n  },\n}\n```\n\n\u003e 참고로, 위 설정을 적용하면 `next/image` 컴포넌트의 `src` 속성이 `/assets/images/`로 시작하지 않거나 쿼리 스트링이 포함된 경우, 요청이 400 Bad Request로 처리됩니다. 따라서 불필요한 경로나 잘못된 요청을 막는 데 유용해요.\n\n또한, `localPatterns` 외에도 `remotePatterns`라는 옵션도 있는데, 이것은 외부 도메인의 이미지를 최적화 대상으로 설정할 때 사용됩니다. 다음에 이어서 `remotePatterns`에 대해서도 알아볼게요. \n\n이렇게 경로를 명확하게 지정해주면 보안 측면에서도 도움이 되고, 최적화 대상이 한정되니 관리도 편해지니 꼭 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 외부 이미지를 사용할 때, 보안을 위해 외부 이미지에 대한 설정이 필요해요. 이렇게 해야 악의적인 사용자가 다른 도메인의 이미지를 마음대로 불러오는 걸 막을 수 있답니다. \n\nNext.js는 외부 이미지를 Next.js Image Optimization API를 통해 제공하는데, 이때 `remotePatterns` 설정을 통해 내 계정에서 사용할 수 있는 외부 이미지 URL 패턴을 지정할 수 있어요. 이렇게 지정하면 지정된 도메인과 경로에 해당하는 이미지들만 안전하게 불러올 수 있습니다.\n\n### Next.js 15.3.0 이상 버전\n\n아래처럼 `next.config.js` 파일에 `remotePatterns`에 `new URL` 객체로 패턴을 지정해주면 돼요.\n\n```js\nmodule.exports = {\n  images: {\n    remotePatterns: [new URL('https://example.com/account123/**')],\n  },\n}\n```\n\n### Next.js 15.3.0 미만 버전\n\n이전 버전에서는 `remotePatterns`를 객체 형태로 설정해줘야 하는데, 조금 더 자세하게 프로토콜, 호스트명, 포트, 경로 등을 나눠서 작성해줍니다.\n\n```js\nmodule.exports = {\n  images: {\n    remotePatterns: [\n      {\n        protocol: 'https',\n        hostname: 'example.com',\n        port: '',\n        pathname: '/account123/**',\n        search: '',\n      },\n    ],\n  },\n}\n```\n\n---\n\n### 추가 팁\n\n- `pathname`에서 `/**`는 와일드카드로, 해당 경로 이하의 모든 이미지 경로를 허용한다는 뜻이에요. 필요에 따라 경로를 더 구체적으로 설정해주세요.\n- 만약 여러 도메인에서 이미지를 불러와야 한다면, `remotePatterns` 안에 여러 패턴을 배열 형태로 추가하면 됩니다.\n- 보안을 위해 믿을 수 있는 도메인만 허용하는 게 가장 좋아요! 나중에 이미지 도메인이 바뀐다면 꼭 이 설정도 함께 업데이트해줘야 합니다.\n\n앱에서 이미지를 최적화하면서도 보안도 챙기려면 이런 설정, 꼭 잊지 말고 해주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nnext/image 컴포넌트를 사용할 때 외부 이미지 도메인을 어떻게 안전하게 설정할 수 있는지 아시나요? 이번에 알려드릴 내용은 Next.js의 `next.config.js` 파일에 `remotePatterns` 옵션을 활용하는 방법입니다.\n\n---\n\n먼저, 이렇게 설정하면 이미지 URL이 꼭 `https://example.com/account123/`로 시작해야 하고, 쿼리 스트링은 없어야 해요. 다른 프로토콜(예: http), 호스트 이름, 포트 번호, 혹은 경로가 일치하지 않으면 400 Bad Request 에러가 발생합니다.\n\n```js\nmodule.exports = {\n  images: {\n    remotePatterns: [\n      {\n        protocol: 'https',\n        hostname: 'example.com',\n        port: '',\n        pathname: '/account123/**',\n        search: '',\n      },\n    ],\n  },\n}\n```\n\n이렇게 해두면 고정된 경로 패턴을 안전하게 지정할 수 있어요. 근데 만약 여러 서브도메인이 있는 경우라면 어떻게 할까요?\n\n---\n\n그럴 때는 와일드카드 패턴을 활용할 수 있어요! 예를 들어, 아래 설정은 https 프로토콜에, `img1.example.com` 또는 `me.avatar.example.com` 같은 여러 서브도메인을 모두 허용합니다. 하지만 포트는 없고 쿼리 스트링도 없어야 하죠.\n\n```js\nmodule.exports = {\n  images: {\n    remotePatterns: [\n      {\n        protocol: 'https',\n        hostname: '**.example.com',\n        port: '',\n        search: '',\n      },\n    ],\n  },\n}\n```\n\n---\n\n| 속성      | 의미                                 | 예시 값                   |\n|-----------|------------------------------------|---------------------------|\n| protocol  | 허용할 프로토콜 (http, https 등)    | 'https'                   |\n| hostname  | 호스트 이름, 와일드카드 가능(**)      | '**.example.com'           |\n| port      | 포트 번호 (빈 문자열은 포트 없음)      | ''                        |\n| pathname  | 경로 (글로벌 와일드카드 /** 가능)  | '/account123/**'           |\n| search    | 쿼리 스트링 (빈 문자열은 쿼리 없음)    | ''                        |\n\n---\n\n\u003e 참고로, `remotePatterns` 안에 경로를 지정하려면 `pathname` 속성을 꼭 써야 해요. 위 첫번째 예제에서 `/account123/**`처럼 사용하구요!\n\n이 기능 덕분에 보안도 챙기면서 다양한 도메인에서 이미지를 마음껏 불러올 수 있답니다. 특히 외부 이미지가 많은 프로젝트에서는 꼭 살펴봐야 할 설정이에요.\n\n---\n\n요약하자면,\n\n- `remotePatterns`를 쓰면 이미지 허용 도메인을 세밀하게 설정할 수 있어요.\n- 와일드카드를 활용해 여러 서브도메인도 한방에 통제 가능합니다.\n- 프로토콜, 포트, 쿼리스트링까지 꼼꼼히 설정 가능해 오류를 줄이고 보안도 강화할 수 있죠.\n\n이렇게 하시면 Next.js 프로젝트에서 안전하게 외부 이미지를 관리할 수 있어서, 성능과 안정성을 함께 챙길 수 있답니다! 혹시 더 궁금한 점 있으면 언제든지 댓글로 물어봐 주세요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n와일드카드 패턴은 경로 이름(pathname)과 호스트 이름(hostname) 모두에 사용할 수 있는데, 다음과 같은 문법을 가지고 있어요:\n\n- `*` : 한 개의 경로 세그먼트(path segment) 또는 서브도메인(subdomain)에 대응해요.\n- `**` : 경로 세그먼트가 끝부분에 여러 개 있을 때, 또는 서브도메인이 시작 부분에 여러 개 있을 때 모두 매칭해요.\n\n단, `**` 문법은 패턴 중간에는 사용할 수 없다는 점 참고하세요!\n\n\u003e **알아두면 좋은 점**: 프로토콜, 포트, 경로(pathname), 검색(search) 정보를 생략하면 자동으로 와일드카드 `**`가 포함된 것으로 간주돼요. 하지만 이 방법은 권장하지 않아요. 왜냐하면 의도치 않은 URL까지 매칭되어 악의적인 사용자의 공격에 노출될 수 있기 때문이에요.\n\n---\n\n조금 더 부연하자면, 와일드카드를 사용할 때는 어떤 부분에 얼마만큼 유연함을 줄지 꼭 신중히 결정해야 해요. 특히, `**`는 매우 강력한 매칭이 되기 때문에 보안상 위험할 수 있으니, 가능한 최소한으로 사용하는 걸 추천합니다.\n\n예를 들어, 호스트네임에 `*.example.com`은 `abc.example.com`에는 매칭되지만, `xyz.abc.example.com`까지는 포함하지 않아요. 반면 `**.example.com`이라면 여러 개의 서브도메인을 복수로 포함하는 경우에 사용하죠.\n\n이런 와일드카드 패턴 활용법을 잘 이해하면, URL 필터링이나 라우팅 기능을 구현할 때 훨씬 편리하게 조건을 작성할 수 있어요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nnext.config.js에서 remotePatterns 속성에 search 옵션을 사용하는 예시를 보여드릴게요:\n\n```js\nmodule.exports = {\n  images: {\n    remotePatterns: [\n      {\n        protocol: 'https',\n        hostname: 'assets.example.com',\n        search: '?v=1727111025337',\n      },\n    ],\n  },\n}\n```\n\n\u003e 참고할 점: 위 예시는 next/image 컴포넌트의 src 값이 `https://assets.example.com`으로 시작해야 하고, 쿼리 스트링이 정확히 `?v=1727111025337` 로 일치해야만 이미지를 불러올 수 있다는 뜻이에요. 만약 프로토콜이나 쿼리 스트링이 다르면 400 Bad Request 오류가 발생할 수 있습니다.\n\n이렇게 remotePatterns에 search 값을 명시하면, URL 매칭 조건을 엄격하게 설정할 수 있어서 보안이나 캐시 관리를 조금 더 세밀하게 할 수 있어요.\n\n### domains와의 차이점\n\n`domains` 속성은 단순히 hostname 기반으로 이미지를 허용하는 반면, `remotePatterns`는 프로토콜, 호스트명, 경로, 포트, 검색(쿼리)까지 좀 더 자세히 지정할 수 있다는 점에서 훨씬 유연해요. 만약 특정 쿼리를 포함한 URL만 받고 싶다면 `remotePatterns`를 사용하세요.\n\n예를 들어, 다음은 domains와 remotePatterns의 비교입니다:\n\n| 속성명        | 설명                                  | 유연성                |\n|-------------|-------------------------------------|--------------------|\n| domains     | 도메인 이름만 지정, 간단히 허용 목록 작성 가능    | 낮음                  |\n| remotePatterns | 프로토콜, 호스트, 경로, 검색 등 세부적으로 지정 가능 | 매우 높음             |\n\n개발할 때 이렇게 쿼리 스트링까지 조건에 넣으면, 이미지 요청에서 인증 토큰이나 버전 관리 같은 정보를 활용할 때도 편리해요.\n\n필요에 따라 여러분 프로젝트에 맞는 방식을 선택해서 사용해 보면 좋겠네요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js 14부터는 remotePatterns라는 엄격한 설정 방식을 권장하면서, 기존의 domains 설정이 점점 Deprecated(사용 중단)되고 있다는 경고가 나오는 경우가 많아요. \n\n왜 그러냐면, domains 설정은 외부 이미지 도메인을 허용하는 데는 편리하지만, 와일드카드 패턴 매칭이 안 되고, 프로토콜(https, http), 포트, 경로나 쿼리 스트링 같은 세밀한 조건을 제한할 수가 없거든요. 즉, 보안 측면에서 좀 허술할 수 있어요. 특히 도메인의 모든 콘텐츠를 소유하지 않은 경우에는 위험할 수도 있어요.\n\n대신 remotePatterns는 이런 부분을 세밀하게 지정할 수 있어서, 악성 사용자가 이미지 요청을 조작해 공격하는 걸 막아줄 수 있답니다.\n\n---\n\n### domains 설정 예시 (next.config.js)\n\n```js\nmodule.exports = {\n  images: {\n    domains: ['example.com', 'cdn.example.com'],\n  },\n};\n```\n\n위처럼 도메인을 배열로 넣어주면, 해당 도메인에 있는 외부 이미지들을 Next.js 이미지 최적화 기능과 함께 쓸 수 있어요. 하지만 프로토콜이나 경로는 제한하지 못하고, 와일드카드(*)도 안 돼서 살짝 아쉽죠.\n\n---\n\n### 추가로, remotePatterns 설정법은?\n\n만약 `remotePatterns`를 써보고 싶다면, 이렇게 쓸 수 있어요:\n\n```js\nmodule.exports = {\n  images: {\n    remotePatterns: [\n      {\n        protocol: 'https',\n        hostname: 'example.com',\n        port: '',\n        pathname: '/images/**',\n      },\n    ],\n  },\n};\n```\n\n이렇게 하면 `https://example.com/images/` 하위 경로만 허용하는 식으로 훨씬 정밀한 제어가 가능해요. 물론, Next.js 14 이상이어야 지원됩니다.\n\n---\n\n### 정리하자면\n\n- domains는 간단하지만 제한적이고 보안 취약점이 있을 수 있으니 조심!\n- remotePatterns는 더 엄격하고 안전한 설정 방법\n- 여러분이 도메인 소유주가 아니면 remotePatterns 추천!\n\n개발하면서 이미지 도메인 설정할 때 참고하시고, 가능하면 최신 방식인 remotePatterns로 업데이트해보세요! 안전한 앱 만드는 데 큰 도움이 될 거예요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러분, Next.js에서 이미지 최적화를 할 때 기본 API 대신 클라우드 제공업체를 이용하고 싶을 때가 있죠? 그럴 땐 next.config.js 파일에서 loaderFile 옵션을 활용해서 커스텀 로더를 설정할 수 있어요.\n\n먼저 기본적으로 도메인을 설정해주는 예제를 볼게요:\n\n```js\nmodule.exports = {\n  images: {\n    domains: ['assets.acme.com'], // 여기서 외부 이미지 도메인을 지정해줘요.\n  },\n}\n```\n\n이렇게 하면 Next.js가 `assets.acme.com`에서 가져오는 이미지를 허용하고 최적화할 수 있게 됩니다.\n\n그런데 만약 클라우드 제공업체(예: Cloudinary, Imgix 등)를 직접 써서 이미지 최적화를 맡기고 싶으면 어떻게 할까요? 이때는 `loaderFile` 옵션을 사용해서 커스텀 이미지 로더를 지정하면 돼요. 예시는 아래와 같습니다:\n\n```js\nmodule.exports = {\n  images: {\n    loader: 'custom',               // 커스텀 로더 사용 선언\n    loaderFile: './my/image/loader.js', // 직접 만든 로더 파일 경로\n  },\n}\n```\n\n### 여기서 중요한 점\n- `loader`는 `'default'`, `'imgix'`, `'cloudinary'`, `'akamai'` 등 미리 준비된 옵션도 있지만, `custom`을 쓰면 직접 로더 코드를 만들어 제어할 수 있습니다.\n- `loaderFile`에 적힌 파일에서는 함수가 export되어 있어야 하며, 이미지 URL과 원하는 크기 등을 인자로 받아 최종 이미지 URL을 반환해야 해요.\n\n예를 들어, `./my/image/loader.js` 파일은 대략 이런 모양일 수 있어요:\n\n```js\nmodule.exports = ({ src, width, quality }) =\u003e {\n  return `https://your-cloud-provider.com/${src}?w=${width}\u0026q=${quality || 75}`\n}\n```\n\n이렇게 하면 Next.js가 이미지 최적화를 요청할 때 이 커스텀 로더를 거쳐 이미지 URL을 생성하고, 클라우드에서 최적화된 이미지를 받아 올 수 있습니다.\n\n---\n\n요약하자면, Next.js의 이미지 컴포넌트는 기본 제공 API로도 훌륭하지만, 자신만의 클라우드 서비스나 특별한 최적화 방식을 쓰고 싶을 땐 `loader`를 `'custom'`으로 설정하고, `loaderFile`에서 직접 URL 생성 방식을 관리하면 완전 내 맘대로 컨트롤할 수 있어 편리하답니다! \n\n더 궁금하면 언제든 질문 주세요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 이미지 로더를 설정할 때, `loader` 파일은 반드시 Next.js 애플리케이션 루트 기준으로 상대 경로를 가리켜야 합니다. 이 파일에서는 기본(default)로 문자열을 반환하는 함수 하나를 export해야 하는데요, 예를 들어 아래처럼 작성할 수 있습니다:\n\n```js\n'use client'\n\nexport default function myImageLoader({ src, width, quality }) {\n  return `https://example.com/${src}?w=${width}\u0026q=${quality || 75}`\n}\n```\n\n여기서 `src`는 이미지 경로, `width`는 요청할 이미지의 너비, `quality`는 이미지 품질(기본 75)인데요, 함수가 최종적으로 반환하는 문자열은 이미지 URL이 됩니다. 이 방식을 쓰면 이미지 요청을 커스터마이징할 수 있어서 CDN이나 외부 이미지 서버와 연동할 때 아주 유용하답니다.\n\n---\n\n그리고 꼭 파일 하나에 넣어야 한다고 생각하지 마세요! Next.js `next/image` 컴포넌트의 `loader` 프롭에도 직접 함수를 넘겨줄 수 있어요. 이렇게 하면 각 이미지마다 다른 로더를 쓸 수도 있어서 더욱 유연한 관리가 가능합니다.\n\n아래는 두 가지 예시입니다:\n\n| 구분 | 설명 | 코드 |\n|-------|-------------|-------------|\n| 1. loader 파일 사용 | 루트에 파일 만들어서 재사용 | js 'use client' export default function myImageLoader({ src, width, quality }) { return `https://example.com/${src}?w=${width}\u0026q=${quality || 75}` }  |\n| 2. loader prop 사용 | 이미지 컴포넌트마다 다르게 설정 | jsx import Image from 'next/image'; const myImageLoader = ({ src, width, quality }) =\u003e { return `https://example.com/${src}?w=${width}\u0026q=${quality || 75}`; } \u003cImage loader={myImageLoader} src=\"me.png\" width={500} height={500} alt=\"me\" /\u003e  |\n\n---\n\nTip!  \n- `loader` 함수가 반환하는 URL은 클라이언트가 실제로 접근 가능한 주소여야 해요. 내부 경로나 상대 경로를 그대로 쓰면 안 됩니다.  \n- 품질(`quality`) 옵션을 넣는 이유는 이미지 크기와 품질간 밸런스를 맞추기 위해서인데, 기본값은 75이지만 필요에 따라 조절하세요.  \n- 공식 Next.js 문서(https://nextjs.org/docs/api-reference/next/image#loader)에서도 다양한 예제를 참고할 수 있어요.\n\n이미지 요청 경로 다루는 게 어렵게 느껴질 수 있는데, 이런 사용자 정의 로더를 잘 활용하면 서버 부담도 줄이고, 이미지 로딩 속도도 개선할 수 있답니다! 궁금하면 꼭 한 번 시도해 보세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 커스텀 이미지 로더 설정\n\n\u003e 참고할 점: 이미지 로더 파일을 커스터마이징할 때 함수(function)를 넘겨줘야 하는데, 이 함수는 Client Components에서 직렬화(serialization) 과정을 거쳐야 제대로 작동해요.\n\n## 고급 설정\n\n아래 설정들은 주로 고급 사용자들을 위한 내용이에요. 보통은 건드릴 필요가 없고, 만약 이 설정들을 직접 바꾸면 향후 Next.js 업데이트 시 기본 설정이 변경돼도 자동 반영되지 않으니 주의가 필요해요.\n\n---\n\n사실 이미지 로더를 직접 커스터마이징하는 경우는 주로 이미지 처리 방식을 세밀하게 조정하고 싶을 때입니다. 예를 들면, 이미지 CDN을 직접 지정하거나, 특정 포맷 변환, 압축 옵션을 다루고 싶을 때 쓰이죠. 하지만 대부분 프로젝트에서는 Next.js가 제공하는 기본 이미지 로더로 충분한 성능과 편리함을 느낄 수 있으니, 특별한 이유가 없다면 기본 설정을 유지하는 게 안정적입니다.\n\n필요하다면 Client Component에서 커스텀 함수를 어떻게 직렬화하는지 추가 예제도 나중에 소개할게요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### deviceSizes\n\n만약 여러분이 타겟하려는 사용자들이 주로 사용하는 디바이스의 화면 너비를 알고 있다면, `next.config.js` 파일에서 `deviceSizes`라는 속성에 해당 너비들을 지정할 수 있어요. 이렇게 지정해주면, `next/image` 컴포넌트가 `sizes` 속성을 사용할 때 사용자의 디바이스에 가장 적합한 이미지 크기를 골라서 제공할 수 있게 됩니다.\n\n만약 별도로 설정하지 않으면, Next.js는 기본값으로 아래와 같은 디바이스 크기들을 사용해요.\n\n```js\nmodule.exports = {\n  images: {\n    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],\n  },\n}\n```\n\n| 기본 deviceSizes 값 |\n| ------------------- |\n| 640                 |\n| 750                 |\n| 828                 |\n| 1080                |\n| 1200                |\n| 1920                |\n| 2048                |\n| 3840                |\n\n---\n\n이걸 설정하는 가장 큰 장점은 이미지 최적화에서 효율성! 예를 들어, 모바일 사용자에게 굳이 큰 해상도의 이미지를 내려주면 데이터 낭비가 심하잖아요. 그런데 이걸 활용하면 크고 작은 여러 버전의 이미지가 준비되어서, 각각의 디바이스에 최적화된 이미지를 업로드 없이 자동으로 빠르게 제공해주니까요.\n\n추가로, `deviceSizes`와 비슷하게 `imageSizes`라는 옵션도 있는데요, 이건 고정된 이미지 크기(아이콘 같은 작은 이미지)들을 지정할 때 유용해요. 보통 `deviceSizes`는 반응형 이미지에, `imageSizes`는 고정 사이즈 이미지에 활용한다고 이해하시면 좋아요. \n\n실제로 프로젝트에 맞춰 이 값들을 잘 조절하면 성능이 확연히 개선되는 걸 체감할 수 있으니 한 번 프로젝트에 적용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### imageSizes란?\n\nNext.js에서 `next.config.js` 파일 안에 `images.imageSizes`라는 속성을 통해 **이미지 너비 리스트를 직접 지정**할 수 있어요. 이 리스트는 `deviceSizes`라는 또 다른 배열과 합쳐져서, 이미지의 `srcset`을 생성할 때 사용되는 전체 크기 배열을 만든답니다.\n\n그런데 왜 두 개의 리스트가 따로 있냐고요? 그 이유는, `imageSizes`는 **이미지에 `sizes` 속성이 제공될 때만 사용**돼요. 즉, `sizes` prop이 있으면 이 이미지는 화면 전체 너비를 쓰는 게 아니라, 화면보다 작은 크기로 보여준다는 의미거든요. 그래서 `imageSizes`에 들어가는 값들은 항상 `deviceSizes`의 가장 작은 크기보다 작아야 해요. 이것은 이미지가 너무 커서 불필요한 리소스를 쓰는 걸 방지해줍니다.\n\n만약 여러분이 따로 설정을 안 해주면 Next.js가 기본값을 사용하게 돼요.\n\n---\n\n#### 추가로 알아두면 좋은 점!\n\n- `deviceSizes`는 주로 일반적인 기기 화면 크기를 기준으로 하며, Next.js가 자동으로 기본값을 제공하지만, 상황에 맞게 조정할 수도 있어요.\n- 예를 들어, 모바일 최적화가 매우 중요하거나, 특정 컴포넌트가 작은 이미지 크기를 주로 쓴다면, `imageSizes`를 알맞게 지정해주면 네트워크 대역폭 절약과 빠른 로딩에 도움이 됩니다.\n- 또한, Image 컴포넌트에서 `sizes` prop을 사용하면, 당신이 지정한 `imageSizes` 배열에 맞게 다양한 이미지를 브라우저가 선택하게 됩니다.\n\n---\n\n아래는 각 속성별 기본값이 어떻게 설정되어 있는지 참고해보세요.\n\n| 속성 이름       | 기본값                                 | 설명                                            |\n|----------------|---------------------------------------|-------------------------------------------------|\n| deviceSizes    | [640, 750, 828, 1080, 1200, 1920, 2048, 3840] | 대표적인 기기 너비 배열                             |\n| imageSizes     | [16, 32, 48, 64, 96]                  | `sizes` prop이 있는 이미지에 사용되는 작고 세밀한 너비 배열 |\n\n요렇게 이해하면 Next.js 이미지 최적화가 좀 더 명확해지실 거예요! 혹시 이미지 로딩 최적화 팁에 관심 있으면 또 알려드릴게요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n오늘은 Next.js에서 이미지 최적화 설정하는 방법에 대해 쉽고 간단하게 알아볼게요. 이미지 크기와 퀄리티(quality)를 직접 설정해서 웹사이트 로딩 속도와 사용자 경험을 개선할 수 있답니다.\n\n---\n\n### 이미지 크기 (`imageSizes`) 설정하기\n\nNext.js의 기본 이미지 최적화 API는 여러 크기의 이미지를 자동으로 만드는데요. 만약 이 크기를 내가 원하는 크기로 지정하고 싶다면 `next.config.js` 파일에 `imageSizes`를 설정하면 돼요.\n\n```js\nmodule.exports = {\n  images: {\n    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],\n  },\n}\n```\n\n위 코드에서 이미지 사이즈 배열에 들어간 숫자들은 픽셀 단위의 너비를 의미해요. 예를 들어 16은 16px 너비의 이미지를 생성한단 뜻이죠. 이 설정을 참고해서 사이트에 필요한 크기만 지정하면 불필요한 이미지 생성과 트래픽을 줄일 수 있어요.\n\n---\n\n### 이미지 퀄리티 (`qualities`) 제한하기\n\n기본적으로 Next.js는 이미지 퀄리티를 1부터 100까지 모두 허용해요. 근데 세부적으로 퀄리티를 제한하고 싶을 때는 이렇게 해볼 수 있습니다.\n\n```js\nmodule.exports = {\n  images: {\n    qualities: [25, 50, 75],\n  },\n}\n```\n\n이렇게 하면 오직 25%, 50%, 75% 퀄리티만 이미지 최적화 API에서 허용하게 돼요. 덕분에 최대한 이미지 품질과 용량을 조절할 수 있죠. 예를 들어, 퀄리티를 너무 낮게 하면 화질이 떨어져 사용자 경험이 나빠질 수 있으니, 적당한 균형을 찾는 게 중요해요!\n\n---\n\n### 참고로 더 알아두면 좋은 팁\n\n- `imageSizes`는 기본적으로 `[16, 32, 48, 64, 96, 128, 256, 384]` 크기들이 포함돼 있지만, 커스텀 사이즈 추가 가능해요.\n- `imageSizes`는 사이즈 지정에 사용하고, 실제 사용할 수 있는 이미지 최대 크기는 `deviceSizes`에서 설정할 수 있어요.\n- 퀄리티 제한을 할 때는 일반적으로 75~80 정도가 적당히 고화질과 적당한 용량의 밸런스로 추천됩니다.\n- 더 나아가 `formats` 설정을 이용해서 WebP, AVIF 등 최신 이미지 포맷으로 변환하는 것도 가능하니까 같이 고려해보세요!\n\n---\n\n### 마무리\n\nNext.js 이미지 최적화 세팅은 웹 속도를 개선하고 사용자 경험을 올리는 데 적절한 이미지 크기와 퀄리티를 직접 정할 수 있어 정말 편리해요. 사이트 규모와 용도에 맞춰서 적절하게 설정해 보시길 추천드려요!\n\n앞으로도 이런 실용적인 팁들 많이 공유할게요. 언제든 질문 주세요~!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 예시에서는 허용되는 품질 값이 25, 50, 75 세 가지로 정해져 있어요. quality prop에 이 배열에 없는 값이 들어가면, 이미지 요청이 실패하면서 400 Bad Request 에러가 발생합니다. 그러니까 품질 설정할 때는 꼭 허용된 값 중에서 선택해야 한다는 점 꼭 기억하세요!\n\n### formats\n\n기본적으로 Image Optimization API는 요청에 포함된 브라우저의 Accept 헤더를 통해 어떤 이미지 포맷을 지원하는지 자동으로 감지합니다. 이 정보를 바탕으로 가장 최적화된 출력 포맷을 선택해주는 거죠.\n\n여기서 중요한 점은 만약 Accept 헤더에 여러 개의 지원 포맷이 포함되어 있다면, 미리 설정된 formats 배열에서 가장 먼저 일치하는 포맷을 사용한다는 것입니다. 즉, 배열의 순서가 정말 중요해요! 만약 일치하는 포맷이 없거나, 원본 이미지가 애니메이션 GIF 같은 특수한 경우라면, API는 원본 이미지 포맷을 그대로 반환합니다.\n\n이 부분을 이해하면, 이미지 최적화를 하면서도 호환성을 최대한 보장할 수 있고, 불필요한 에러도 막을 수 있으니 꼭 참고하세요!\n\n아래는 요점 정리한 표예요:\n\n| 키워드       | 설명                                                                |\n|--------------|-------------------------------------------------------------------|\n| quality      | 허용값은 25, 50, 75. 배열 외 값 입력 시 400 Bad Request 발생           |\n| Accept 헤더  | 브라우저가 지원하는 이미지 포맷 정보를 포함하는 HTTP 헤더               |\n| formats 배열 | Accept 헤더와 비교해 출력 포맷을 결정. 배열 내 순서가 최종 포맷 선택에 중요 |\n| Fallback     | 일치하는 포맷 없거나 애니메이션 이미지일 경우 원본 포맷 사용             |\n\n이렇게 정리해두면 이미지 최적화 설정할 때 훨씬 이해가 쉬워질 거예요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n설정을 따로 해주지 않으면 기본값으로 아래와 같은 설정이 적용돼요.\n\n```js\nmodule.exports = {\n  images: {\n    formats: ['image/webp'],\n  },\n}\n```\n\n여기서 `formats`는 이미지 최적화를 위해 어떤 포맷을 사용할지 지정하는 옵션인데요, 기본값은 `webp` 포맷이에요. `webp`는 구글에서 만든 이미지 포맷으로, JPG나 PNG보다 용량을 줄이면서도 화질 손실이 적어 많이 쓰이죠.\n\n그리고 만약 AVIF 포맷을 사용해보고 싶다면, 이렇게 바꿔주면 돼요.\n\n```js\nmodule.exports = {\n  images: {\n    formats: ['image/avif'],\n  },\n}\n```\n\nAVIF는 최근에 각광받는 이미지 포맷으로, `webp`보다 압축률이 더 좋고 화질도 뛰어나지만 아직 모든 브라우저에서 완벽하게 지원하는 건 아니에요. 그래서 위 설정처럼 넣으면, 브라우저가 AVIF를 지원하지 않을 땐 원본 이미지 포맷을 대신 보여줘서 큰 문제가 없답니다.\n\n참고로, `formats` 배열에 여러 포맷을 넣어서 동시에 지원하게 할 수도 있어요. 예를 들어 내비게이션이 상황에 맞게 최적화된 포맷을 골라주도록 하려면 이렇게 할 수 있죠.\n\n```js\nmodule.exports = {\n  images: {\n    formats: ['image/avif', 'image/webp'],\n  },\n}\n```\n\n이렇게 하면 AVIF를 우선 시도하고, 지원하지 않으면 webp, 또 그마저 지원하지 않으면 원본 이미지로 자동으로 fallback 해준답니다.\n\n요즘은 이미지 최적화를 하는 게 페이지 로딩 속도 개선에 큰 도움이 되니까, 이런 포맷 지정은 꼭 활용해보길 추천해요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003e 참고할 점:\n대부분의 경우에는 여전히 WebP 형식을 사용하는 것을 추천해요.\nAVIF는 인코딩하는 데 WebP보다 약 50% 더 시간이 걸리지만, 압축률은 약 20% 더 좋아서 파일 크기가 더 작아진답니다. 그래서 이미지를 처음 요청할 때는 속도가 조금 느릴 수 있지만, 캐시된 이후에는 훨씬 빠르게 로드돼요.\n만약 Next.js 앞에 Proxy나 CDN을 직접 운영한다면, 반드시 Proxy가 `Accept` 헤더를 전달하도록 설정해줘야 해요. 이 부분을 놓치면 최적화된 이미지가 제대로 제공되지 않을 수 있거든요.\n\n## 캐싱 동작 방식\n\n기본 이미지 로더의 캐싱 알고리즘은 다음과 같아요. 다른 로더를 사용한다면 클라우드 제공업체의 문서를 참고하는 게 좋아요.\n\n이미지는 요청 시 동적으로 최적화되고, 프로젝트의 `distDir/cache/images` 디렉터리에 저장돼요. 이렇게 최적화된 이미지는 만료 시간이 도달할 때까지 이후 요청에 동일하게 제공됩니다. 만약 요청한 이미지가 캐시돼있지만 만료되었다면, 서버는 만료된(오래된) 이미지를 바로 보여주고, 백그라운드에서는 이미지를 다시 최적화(재검증)해서 새 캐시와 만료 시간으로 업데이트합니다.\n\n---\n\n이렇게 하면 처음 사용자에게도 최소한의 지연만 주면서 최신 이미지를 유지하는 효율적인 캐싱 전략이 구현되는 거죠. 실제로 운영할 때는 압축률과 인코딩 속도, 그리고 캐시 만료 정책을 적절히 조절하는 게 중요해요. CDN이나 프록시를 쓴다면, `Accept` 헤더가 제대로 전달되는지 꼭 확인해서 원하는 포맷으로 이미지를 제공받도록 하는 것도 핵심입니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이미지 캐시 상태를 확인할 때는 `x-nextjs-cache`라는 응답 헤더 값을 보면 됩니다. 이 헤더가 가리키는 값은 보통 다음 세 가지 중 하나예요:\n\n| 캐시 상태 | 설명 |\n|------------|---------|\n| MISS | 경로가 캐시에 없다는 뜻이에요. 보통 이건 처음 한번, 첫 방문할 때 발생해요. |\n| STALE | 경로가 캐시에 있긴 한데, 재검증(revalidate) 시간이 초과돼서 백그라운드에서 업데이트가 진행 중인 경우입니다. |\n| HIT | 경로가 캐시에 있고, 재검증 시간이 지나지 않았을 때를 의미해요. |\n\n캐시 만료 시간(정확히 말하면 Max Age)은 `minimumCacheTTL` 설정값과 업스트림 이미지의 `Cache-Control` 헤더 중 더 큰 값으로 정해집니다. 여기서 `Cache-Control` 헤더의 `max-age` 값을 기준으로 하는데, 만약 `s-maxage`와 `max-age` 둘 다 있으면 `s-maxage`가 우선입니다. 그리고 이 `max-age` 값은 CDN이나 브라우저 같은 하위 클라이언트에게도 그대로 전달돼요.\n\n그리고 몇 가지 팁을 드리면:\n\n- `minimumCacheTTL`을 설정하면, 업스트림 이미지에서 Cache-Control 헤더가 없거나 너무 낮을 때 캐시 지속 시간을 인위적으로 늘릴 수 있어요.\n- `deviceSizes`와 `imageSizes`를 잘 설정해서 생성되는 이미지 종류(사이즈)를 줄이면 서버의 부하도 줄이고 캐시 효율도 높일 수 있어요.\n- `formats` 설정으로 여러 이미지 포맷 생성을 끄고, 한 가지 포맷만 사용하도록 할 수도 있어요. 이건 클라이언트의 호환성이나 트래픽 관리에 도움됩니다.\n\n이렇게 캐시 설정을 적절히 조절하면, 이미지 로딩 속도 향상과 서버 비용 절감 두 마리 토끼를 잡을 수 있으니, 꼭 한 번 살펴보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### minimumCacheTTL\n\n이미지 최적화 캐시의 TTL(Time to Live), 즉 이미지가 캐시에서 살아있는 시간을 초 단위로 설정할 수 있어요. \n\n사실 대부분의 경우에는 **Static Image Import** 방식을 쓰는 게 더 좋아요. 이 방법은 파일 내용을 자동으로 해시(hash)해서 캐시를 사실상 영구적으로 유지하는 효과가 있고, `Cache-Control` 헤더에 `immutable`이 설정돼서 브라우저가 굳이 자주 새로 다운로드하지 않게 해주거든요.\n\n만약 따로 설정하지 않으면 기본값으로 아래 설정이 사용됩니다.\n\n```js\nmodule.exports = {\n  images: {\n    minimumCacheTTL: 60, // 1분 간 캐시 유지\n  },\n}\n```\n\n### 추가 팁!\n\n- TTL을 너무 짧게 하면 캐시를 자주 새로 받아서 서버 부하가 늘어나고, 반대로 너무 길게 설정하면 오래된 이미지가 사용될 수도 있어요.\n- 그래서 가능하면 정적 이미지(import 방식)를 활용하는 게 좋고, 동적으로 변경될 가능성이 있는 이미지만 TTL을 적절히 조절하는 방식을 추천드립니다.\n- 만약 이미지가 자주 변경되는 편이라면 TTL을 짧게, 그렇지 않으면 길게 잡는 게 무난해요.\n\n이렇게 적절한 캐시 설정으로 웹사이트 속도와 사용자 경험을 더 좋게 만들어 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이미지 최적화할 때 TTL(Time To Live)을 늘려서 재검증(revalidation) 횟수를 줄이고, 그 결과 비용 절감 효과를 기대할 수 있어요. 예를 들어, Next.js 내 설정 파일에서 이렇게 써주면 돼요:\n\n```js\nmodule.exports = {\n  images: {\n    minimumCacheTTL: 2678400, // 31일 (초 단위)\n  },\n};\n```\n\n여기서 `minimumCacheTTL`은 이미지가 캐시에 머무르는 최소 시간을 의미해요. 최적화된 이미지의 만료 시간(또는 Max Age)은 이 값과 원본 이미지 서버가 보내는 `Cache-Control` 헤더 중 더 긴 쪽을 따르게 됩니다.\n\n만약 이미지마다 캐싱 정책을 다르게 하고 싶다면, 최적화 요청이 가는 `/_next/image` 경로가 아니라 원본 이미지 경로(예: `/some-asset.jpg`)에 직접 `Cache-Control` 헤더를 설정해야 합니다. 그렇지 않으면 모든 이미지가 같은 캐시 정책을 따르게 돼요.\n\n참고로, TTL을 너무 길게 잡으면 업데이트된 이미지가 바로 반영되지 않을 수 있으니, 상황에 맞게 적절한 기간을 선택하는 게 좋아요. 개발 중에는 짧게, 배포 환경에선 길게 설정하는 방식도 괜찮겠죠? 그리고 이미지 캐싱 전략은 비용뿐만 아니라 사용자 경험에도 큰 영향을 주니 신중하게 고민해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금은 캐시를 무효화할 수 있는 별도의 방법이 없기 때문에, minimumCacheTTL 값을 낮게 설정하는 게 좋아요. 그렇지 않으면 src 속성을 직접 변경하거나, `distDir`/cache/images 폴더를 수동으로 삭제해야 할 수도 있어요.\n\n### disableStaticImages\n\n기본 설정으로는 `import icon from './icon.png'`처럼 정적 파일을 임포트해서 src 속성에 바로 전달할 수 있어요.\n\n하지만 어떤 경우에는, 다른 플러그인과 충돌이 일어나서 임포트가 다르게 동작해야 할 때가 있어요. 그럴 때 이 기능을 끄는 옵션이 바로 `disableStaticImages`입니다.\n\n---\n\n한 가지 팁을 더 드리자면, 이미지 캐시를 적절히 관리하지 않으면 개발 중에 변경 사항이 바로 반영되지 않아 꽤 답답할 수 있어요. 그래서 개발 모드에서는 캐시 TTL을 낮게 설정하거나, 필요할 땐 수동으로 캐시를 삭제하는 습관을 들이면 좋습니다. 또한, 플러그인 간 충돌을 미리 파악해서 `disableStaticImages` 옵션을 활용하면 예상치 못한 문제도 피할 수 있답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 static 이미지 임포트를 비활성화하고 싶다면, `next.config.js` 파일에 아래와 같이 설정할 수 있어요:\n\n```js\nmodule.exports = {\n  images: {\n    disableStaticImages: true,\n  },\n}\n```\n\n이 설정을 하면 정적 이미지 임포트를 끄게 되어, 이미지 파일들을 직접 import 하는 방식 대신 다른 방법으로 이미지를 다루게 돼요. 예를 들어, public 폴더에 이미지를 두고 경로로만 접근하는 방식이죠.\n\n---\n\n### dangerouslyAllowSVG 옵션에 대해\n\nNext.js 기본 이미지 로더는 SVG 최적화를 지원하지 않는데, 그 이유는 두 가지가 있어요.\n\n1. **SVG는 벡터 이미지라서 크기를 조절해도 화질 손실이 없어요.** 그렇기 때문에 변형 과정이 딱히 필요 없죠.\n2. **SVG 파일은 HTML/CSS와 비슷한 특성을 갖고 있어서, 제대로 된 Content Security Policy(CSP) 헤더 없이는 보안 취약점이 생길 수 있어요.**\n\n그래서 `dangerouslyAllowSVG` 옵션이 있긴 하지만, 이걸 사용할 땐 보안에 특히 신경 써야 해요. SVG를 사용하면서 보안 문제가 걱정된다면, SVG를 컴포넌트 형태로 다루거나 외부에서 안전하게 처리한 뒤 사용하는 걸 추천합니다.\n\n---\n\n### 추가 팁!\n\n- 만약 SVG를 React 컴포넌트처럼 사용하고 싶다면, `@svgr/webpack`을 쓰는 방법도 있어요. 이걸 쓰면 SVG를 import 해서 SVG 컴포넌트로 만들 수 있죠.\n- 그리고 이미지 최적화는 Next.js 이미지 컴포넌트의 핵심 기능 중 하나니까, 가능하면 static 이미지 임포트 기능을 끄기보다는 제대로 활용하는 걸 추천해요.\n\n이런 설정 하나하나 이해하고 적용하다 보면 Next.js에서 이미지 다루는 법에 자신감이 생길 거예요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그래서 src 속성이 SVG임이 확실할 때는 unoptimized 속성을 사용하는 걸 추천해요. 실제로 src가 \".svg\"로 끝날 때는 이 부분이 자동으로 적용됩니다.\n\n하지만 만약 기본 이미지 최적화 API를 사용해서 SVG 이미지를 제공해야 한다면, next.config.js 파일 안에 dangerouslyAllowSVG 옵션을 설정할 수 있어요:\n\n```js\nmodule.exports = {\n  images: {\n    dangerouslyAllowSVG: true,\n    contentDispositionType: 'attachment',\n    contentSecurityPolicy: \"default-src 'self'; script-src 'none'; sandbox;\",\n  },\n}\n```\n\n여기서 주의할 점은, SVG 이미지가 종종 악성 스크립트를 포함할 수 있어서 보안 면에서 취약할 수 있다는 거예요. 그래서 contentDispositionType을 'attachment'로 설정해서 브라우저가 이미지를 그냥 보여주는 게 아니라 다운로드하도록 강제하는 걸 추천하고, contentSecurityPolicy를 지정해서 이미지 안에 숨어있는 스크립트가 실행되지 못하도록 막는 것이 매우 중요하답니다.\n\n참고로, SVG는 벡터 이미지라서 해상도에 상관없이 선명한 장점이 있지만, 안전하지 않은 SVG를 그대로 사용하면 XSS 공격에 노출될 수 있으니, 가능하면 신뢰할 수 있는 SVG만 쓰거나 이런 보안 설정을 꼭 해주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### contentDispositionType\n\n기본적으로 이미지 로더(loader)는 `Content-Disposition` 헤더를 `attachment`로 설정합니다. 이 설정이 중요한 이유는 API가 원격 이미지를 임의로 불러올 수 있기 때문에 보안을 강화하기 위해서예요.\n\n| 설정값     | 설명                                      |\n|------------|-------------------------------------------|\n| attachment | 브라우저가 이미지를 직접 방문하면 다운로드하도록 강제함 (기본값) |\n| inline     | 브라우저가 이미지를 직접 방문했을 때 바로 렌더링해서 보여줌     |\n\n특히, `dangerouslyAllowSVG` 옵션이 켜져 있을 경우 `attachment`로 설정하는 것이 더 안전합니다. SVG 파일은 악성코드로 악용될 수 있기 때문에, 무조건 다운받게 만들어서 브라우저가 바로 실행하지 못하게 하는 거죠.\n\n하지만 경우에 따라서는 직접 이미지를 방문했을 때 다운로드 받는 게 아니라 바로 화면에 표시되길 원할 수도 있어요. 이런 때는 `contentDispositionType`을 `inline`으로 설정하면 됩니다. 그러면 URL을 브라우저에 직접 입력했을 때도 이미지가 바로 보이게 되죠.\n\n---\n\n### 추가 팁!\n\n- 만약 내 서비스에서 외부에서 임의로 이미지를 불러오는걸 허용한다면, 보안에 신경 써서 꼭 `attachment`로 두세요.\n- SVG는 특히 조심해야 하니, 내장 SVG가 아닌 외부 SVG를 불러올 때는 `inline`보다는 `attachment`를 추천해요.\n- 하지만 사용자 경험(UX)을 고려해 이미지 바로 보기가 자주 필요한 서비스라면 `inline` 설정을 고려해볼 수 있습니다. 이럴 땐 SVG 보안 이슈도 신경 써주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자, 이번에는 Next.js에서 이미지 최적화와 애니메이션 이미지 다루는 방법에 대해 살펴볼게요.\n\n```js\nmodule.exports = {\n  images: {\n    contentDispositionType: 'inline',\n  },\n}\n```\n\n위 설정 코드는 이미지 응답 시 `Content-Disposition` 헤더를 'inline'으로 설정해주는 거예요. 이렇게 하면 브라우저가 이미지를 다운로드하지 않고, 바로 화면에 표시하도록 하는 역할을 해요. 이미지를 웹페이지 내에서 자연스럽게 보여주고 싶을 때 유용하죠.\n\n---\n\n## 애니메이션 이미지 처리\n\nNext.js의 기본 이미지 로더는 애니메이션이 들어간 이미지(예: GIF, APNG, WebP)가 들어오면 자동으로 이미지 최적화를 건너뛰고 원본 그대로 이미지를 서빙해줍니다. 왜냐면 애니메이션 이미지 최적화는 조금 까다롭고, 최적화 과정에서 애니메이션이 깨질 위험이 있거든요.\n\n자동으로 애니메이션인지 판단하는 기능은 완벽하진 않지만, 대부분의 경우 GIF, APNG, WebP 파일 포맷을 기준으로 잘 감지해 줍니다.\n\n만약 특정 애니메이션 이미지에 대해서 확실하게 최적화를 건너뛰고 싶다면, Next.js의 `Image` 컴포넌트에 `unoptimized` 속성을 추가해주면 돼요.\n\n```jsx\nimport Image from 'next/image'\n\nexport default function MyComponent() {\n  return (\n    \u003cImage\n      src=\"/animated-image.gif\"\n      alt=\"애니메이션 이미지\"\n      width={500}\n      height={300}\n      unoptimized // 이 속성 덕분에 해당 이미지는 최적화 없이 바로 서빙됩니다.\n    /\u003e\n  )\n}\n```\n\n### 추가 팁!\n\n- GIF 대신 WebP 포맷으로 애니메이션 이미지를 사용하는 것도 좋은 방법이에요. WebP는 파일 크기는 훨씬 작으면서도 화질을 잘 유지하거든요.\n- Next.js에서 자동 최적화를 사용하면 성능이 좋아지지만, 애니메이션 이미지 때문에 어쩔 수 없이 건너뛰는 경우가 있으니, 애니메이션 이미지가 많다면 CDN 또는 별도의 외부 이미지 서버를 사용하는 것도 고려해보세요.\n\n---\n\n요약하면, Next.js는 애니메이션 이미지에 대해 친절한 자동 최적화를 제공하지만, 100% 완벽하진 않아서 직접 `unoptimized` 플래그를 활용하는 게 좋고, `contentDispositionType: 'inline'` 설정으로 이미지를 웹 내에서 부드럽게 다룰 수 있다는 이야기였습니다!\n\n필요하면 언제든지 더 구체적인 사용법도 알려드릴게요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 반응형 이미지 만들기\n\n웹 개발하다 보면 다양한 기기별 해상도를 지원하기 위해 이미지도 그에 맞게 잘 보여줘야 할 때가 많죠. 기본적으로 srcset 속성에는 1x, 2x 해상도 이미지가 들어가서 화면의 픽셀 밀도에 맞춰 이미지를 바꿔주는데요. 하지만, 뷰포트 크기에 따라 이미지 크기도 유동적으로 바꾸고 싶다면, srcset 뿐만 아니라 sizes 속성도 함께 설정해줘야 합니다. 그리고 스타일이나 className으로 이미지 크기를 조정하는 것도 중요하죠.\n\n아래는 반응형 이미지를 만드는 몇 가지 방법 중 하나인 '정적 import 사용하기' 예시입니다.\n\n---\n\n### 정적 임포트로 반응형 이미지 만들기\n\nReact나 Next.js 같은 환경에서 자주 쓰이는 방식인데요, 이미지를 프로젝트 안에서 import 해서 쓸 때 유용합니다.\n\n```jsx\nimport responsiveImg from '../public/images/responsive-image.jpg';\n\nexport default function MyComponent() {\n  return (\n    \u003cimg\n      src={responsiveImg.src}\n      srcSet={`${responsiveImg.src} 1x, ${responsiveImg.src.replace('.jpg', '@2x.jpg')} 2x`}\n      sizes=\"(max-width: 600px) 100vw, 50vw\"\n      style={{ width: '100%', height: 'auto' }}\n      alt=\"Responsive example\"\n    /\u003e\n  );\n}\n```\n\n---\n\n여기서 sizes 속성은 뷰포트 너비가 600px 이하일 때 이미지가 화면 너비(100vw)의 100%를 차지하고, 그 이상일 땐 50%를 차지하도록 지정하는 거예요. 이렇게 하면 작은 화면에선 이미지가 꽉 차 보이고, 큰 화면에선 절반 크기로 나란히 배치하기 좋아요.\n\n그리고 style이나 className으로 `width: 100%`를 주면 이미지가 부모 컨테이너의 크기에 맞게 늘어나거나 줄어듭니다. height는 auto로 하면 비율이 유지돼서 이미지가 찌그러지지 않죠.\n\n---\n\n**팁!**  \n- 이미지를 더 다양하게 반응형으로 다루고 싶으면 picture 태그와 함께 여러 해상도, 형식(webp, jpeg 등)을 srcSet에 넣어주는 것도 좋은 방법이에요.  \n- Next.js를 쓰는 분들이라면 내장된 Image 컴포넌트를 활용하면 알아서 최적화 해주니 더 쉽게 반응형 이미지를 만들 수 있습니다.\n\n이제 images 태그만 써도 다양한 기기에서 딱 예쁘게 보여줄 수 있으니 꼭 sizes값과 css 조합도 함께 고려해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 이미지가 정적(변하지 않는) 소스라면, 이렇게 statically import해서 반응형 이미지(Responsive Image)를 쉽게 만들 수 있어요:\n\n```js\nimport Image from 'next/image'\nimport me from '../photos/me.jpg'\n\nexport default function Author() {\n  return (\n    \u003cImage\n      src={me}\n      alt=\"Picture of the author\"\n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }}\n    /\u003e\n  )\n}\n```\n\n이 코드에서 중요한 점은 `sizes=\"100vw\"`예요. 이 설정 덕분에 이미지가 뷰포트(Viewport) 너비 100%에 맞춰서 크기가 조절돼요. 그리고 `style`로 `width: '100%'` 그리고 `height: 'auto'`를 줘서 이미지 비율을 유지하며 폭에 맞게 크기가 변하게 됩니다.\n\n---\n\n### 왜 이렇게 하는 걸까?\n\n- **정적 import**는 번들링할 때 이미지 정보를 미리 알아서, 최적화된 사이즈를 자동으로 만들어줘서 페이지 로딩 속도가 빨라져요.\n- `next/image` 컴포넌트 자체가 여러 크기의 이미지를 제공해주고, 뷰포트에 따라 적절한 사이즈의 이미지를 불러오기 때문에 데이터 사용량도 줄일 수 있답니다.\n- `sizes` 속성은 반응형 이미지에서 어떤 폭에서 이미지를 얼마나 크게 보여줄 지 브라우저에 알려주는 역할을 해요. \n\n---\n\n### 한번 해보세요!\n\n위 코드를 페이지에 넣고 브라우저 창 크기를 조절해서 이미지가 폭에 맞춰 잘 변하는지 확인해 보면 정말 반응형 이미지임을 체감할 수 있을 거예요.\n\n---\n\n만약 이미지를 동적으로 불러야 한다면, 다음 시간에 그 방법도 알려드릴게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 반응형 이미지에 비율 맞추기\n\n웹에서 이미지를 쓸 때 특히 원본 이미지가 동적이거나 외부 URL일 경우, 반응형으로 잘 보여주려면 이미지의 가로(width)와 세로(height)를 꼭 지정해줘야 해요. 그래야 이미지가 비율을 유지하면서 화면 크기에 맞게 조절되거든요.\n\nNext.js의 `next/image` 컴포넌트를 예로 들어볼게요.\n\n```js\nimport Image from 'next/image'\n\nexport default function Page({ photoUrl }) {\n  return (\n    \u003cImage\n      src={photoUrl}            // 동적 혹은 외부 주소로 이미지 호출\n      alt=\"Picture of the author\"\n      sizes=\"100vw\"             // 화면 전체 폭에 맞춰서 크기를 조절\n      style={{\n        width: '100%',          // 가로는 부모 컨테이너에 딱 맞게\n        height: 'auto',         // 세로는 비율에 맞게 자동 조절\n      }}\n      width={500}               // 이미지의 원본 가로 크기\n      height={300}              // 이미지의 원본 세로 크기\n    /\u003e\n  )\n}\n```\n\n여기서 `width={500}`과 `height={300}`은 원본 이미지의 가로, 세로 크기를 나타내고, `style`에서 `width: 100%`로 설정해주면 화면 크기에 딱 맞춰서 이미지 크기가 바뀌면서도 가로세로 비율이 깨지지 않아요.\n\n\u003e 실제로 `next/image`는 `width`, `height` 정보가 있어야 이미지 사이즈 계산과 레이아웃 잡는 데 도움을 줘서 CLS(Cumulative Layout Shift) 같은 레이아웃 깨짐 문제도 예방할 수 있답니다.\n\n---\n\n추가로, 반응형 이미지를 만들 때 기억하면 좋은 점!\n\n| 팁 | 설명 |\n| --- | --- |\n| `sizes` 속성 | 뷰포트(viewport) 크기에 따라 어떤 크기의 이미지를 로딩할지 브라우저에 알려줍니다. `100vw`는 화면 전체 너비를 뜻해요. |\n| `style` | CSS로 가로 세로 비율을 조절하지만 원본 비율과 다르면 이미지가 찌그러질 수 있어 비율 맞추는 게 중요해요. |\n| 원본 크기 지정 | `width`와 `height`를 지정해야 브라우저가 최적의 이미지를 불러오고 레이아웃이 안정적이에요! |\n\n필요하다면, CSS로 부모 요소에 `max-width`를 정해서 너무 커지지 않도록 제한하는 것도 좋아요.\n\n오늘은 이렇게 동적 이미지로 반응형 이미지를 깔끔하게 다루는 방법을 알아봤어요. 실무에서 꽤 자주 쓰이니 한번 써보시면서 감 잡아보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 뷰포트에 반응하는 이미지 데모\n\n#### 이미지의 가로세로 비율(aspect ratio)을 모를 때 - `fill` 속성 활용법\n\n이미지를 반응형으로 만들고 싶은데, 이미지의 정확한 가로세로 비율을 모를 경우가 있죠? 그럴 땐 부모 요소에 `position: relative`를 주고, Next.js의 `Image` 컴포넌트에 `fill` 속성을 사용하면 꽉 차게 이미지가 들어가요. 이때 `object-fit` 스타일로 이미지가 어떻게 맞춰질지 정할 수 있는데, `'contain'`으로 하면 이미지가 찌그러지거나 잘리지 않고 꽉 차도록 조절해 줍니다.\n\n아래 예시 코드를 보시면 이해가 빠르실 거에요:\n\n```jsx\nimport Image from 'next/image'\n\nexport default function Page({ photoUrl }) {\n  return (\n    \u003cdiv style={{ position: 'relative', width: '300px', height: '500px' }}\u003e\n      \u003cImage\n        src={photoUrl}\n        alt=\"Picture of the author\"\n        sizes=\"300px\"\n        fill\n        style={{\n          objectFit: 'contain',\n        }}\n      /\u003e\n    \u003c/div\u003e\n  )\n}\n```\n\n- `div`에 `position: relative`를 줘야 `fill`로 설정된 이미지가 부모 영역을 기준으로 꽉 채울 수 있어요.\n- `width`와 `height`를 고정 또는 반응형 단위로 지정해주면 이미지 크기가 결정되고, 그 안에서 `fill`이 동작하는 거죠.\n- `objectFit`을 `'contain'`으로 하면 이미지가 영역 내에 꽉 차면서 비율이 유지되고, `'cover'`로 설정하면 영역을 가득 채우되 일부 잘릴 수도 있습니다.\n\n\u003e 추가 팁!  \n\u003e 만약 이미지가 부모 크기에 맞춰 유연하게 크기가 변하길 원한다면, 부모 요소를 미디어 쿼리나 CSS 그리드/플렉스를 활용해 동적으로 크기를 조절하는 방법도 있어요. 그러면 `fill`과 함께 더 자연스러운 반응형 이미지를 구현할 수 있습니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한번 해볼까요?\n\n- fill prop을 활용하는 데모\n\n## 테마 감지 CSS\n\n웹사이트를 만들 때, 라이트 모드와 다크 모드에 따라 다른 이미지를 보여주고 싶을 때가 있죠? 이럴 때는 두 개의 `Image` 컴포넌트를 감싸는 새로운 컴포넌트를 만들어서 CSS 미디어 쿼리를 활용해 적절한 이미지만 보여주도록 할 수 있어요.\n\n예를 들어, CSS의 `prefers-color-scheme` 미디어 쿼리를 사용하면 사용자가 설정한 테마(라이트 or 다크)에 따라 다른 스타일이나 이미지를 적용할 수 있답니다. 이를 이용하면 자바스크립트로 복잡한 조건문을 작성하지 않아도, 아주 깔끔하게 테마별 이미지를 처리할 수 있어요.\n\n아래는 이 개념을 활용한 간단한 예시입니다.\n\n```jsx\nimport Image from 'next/image';\n\nconst ThemeImage = () =\u003e {\n  return (\n    \u003c\u003e\n      \u003cImage\n        src=\"/images/light-mode.png\"\n        alt=\"라이트 모드 이미지\"\n        className=\"light-image\"\n        width={200}\n        height={200}\n      /\u003e\n      \u003cImage\n        src=\"/images/dark-mode.png\"\n        alt=\"다크 모드 이미지\"\n        className=\"dark-image\"\n        width={200}\n        height={200}\n      /\u003e\n      \u003cstyle jsx\u003e{`\n        .light-image {\n          display: block;\n        }\n        .dark-image {\n          display: none;\n        }\n        @media (prefers-color-scheme: dark) {\n          .light-image {\n            display: none;\n          }\n          .dark-image {\n            display: block;\n          }\n        }\n      `}\u003c/style\u003e\n    \u003c/\u003e\n  );\n};\n\nexport default ThemeImage;\n```\n\n위 코드에서는 기본적으로 라이트 모드 이미지를 보여주고, 다크 모드가 감지되면 다크 모드 이미지만 보이도록 CSS로 조절해줍니다.\n\n----\n\n추가로 팁 하나!\n\n만약 이미지가 너무 많아서 이렇게 일일이 컴포넌트를 만들기 번거롭다면, [picture 태그](https://developer.mozilla.org/ko/docs/Web/HTML/Element/picture)와 `source` 태그를 활용하는 방법도 있어요. `source`의 `media` 속성에 `prefers-color-scheme` 조건을 넣으면 브라우저가 자동으로 맞는 이미지를 골라줍니다.\n\n```jsx\n\u003cpicture\u003e\n  \u003csource srcSet=\"/images/dark-mode.png\" media=\"(prefers-color-scheme: dark)\" /\u003e\n  \u003cimg src=\"/images/light-mode.png\" alt=\"테마별 이미지\" width={200} height={200} /\u003e\n\u003c/picture\u003e\n```\n\n이렇게 하면 자바스크립트나 추가 CSS 없이도 손쉽게 테마별 이미지를 관리할 수 있어서 더 깔끔하니 참고해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번 시간에는 다크모드 지원을 할 때 이미지도 알아서 라이트모드용, 다크모드용 이미지를 잘 보여주게 하는 간단한 방법을 소개해 드릴게요. CSS와 Next.js를 함께 활용한 스타일링과 컴포넌트 설계법을 보면서, 실제로 어떻게 이미지 로딩이 최적화되는지도 짚어보려 합니다.\n\n---\n\n### 1. CSS로 다크모드에 따라 보이기/숨기기 설정하기\n\n```css\n.imgDark {\n  display: none;\n}\n\n@media (prefers-color-scheme: dark) {\n  .imgLight {\n    display: none;\n  }\n  .imgDark {\n    display: unset;\n  }\n}\n```\n\n- `.imgDark` 이미지는 기본적으로 숨겨져 있어요.\n- 사용자의 OS나 브라우저가 다크모드를 감지하면(`prefers-color-scheme: dark`), `.imgLight` 이미지는 숨기고 `.imgDark` 이미지는 보여주게 됩니다.\n\n이렇게만 해줘도 다크모드 감지 시 자동으로 이미지를 바꿔서 보여줄 수 있죠.\n\n---\n\n### 2. Next.js 컴포넌트로 깔끔하게 관리하기\n\n```tsx\nimport styles from './theme-image.module.css'\nimport Image, { ImageProps } from 'next/image'\n\ntype Props = Omit\u003cImageProps, 'src' | 'priority' | 'loading'\u003e \u0026 {\n  srcLight: string\n  srcDark: string\n}\n\nconst ThemeImage = (props: Props) =\u003e {\n  const { srcLight, srcDark, ...rest } = props\n\n  return (\n    \u003c\u003e\n      \u003cImage {...rest} src={srcLight} className={styles.imgLight} /\u003e\n      \u003cImage {...rest} src={srcDark} className={styles.imgDark} /\u003e\n    \u003c/\u003e\n  )\n}\n```\n\n- Next.js의 `Image` 컴포넌트를 한 번에 두 개 넣고, CSS로 어느 이미지를 보여줄지 제어하는 방식입니다.\n- `Priority`나 `loading=\"eager\"`를 쓰면 이미지가 모두 로드되어 버려서 비효율적이므로 **기본 `loading=\"lazy\"` 속성을 이용**하거나 **`fetchPriority=\"high\"`**를 활용하세요.\n\n---\n\n### 3. 핵심 포인트: 이미지 로딩 최적화\n\n| 고려사항                 | 설명                                                         |\n|------------------------|------------------------------------------------------------|\n| 기본 로딩 방식            | `loading=\"lazy\"`는 스크롤 등 사용자 행동에 맞게 이미지를 불러옵니다. 이 덕분에 안 보이는 이미지는 바로 로드되지 않아요.  |\n| `priority` 속성 사용 제한 | 라이트/다크용 이미지가 동시에 로드되기 때문에 `priority`를 쓰면 번거로워질 수 있습니다.                     |\n| `fetchPriority` 활용      | Next.js 13부터 새로 도입된 `fetchPriority=\"high\"`를 이용하면 우선순위 지정이 가능하지만, 옮겨서 써야 하는 상황이라는 점 참고! |\n\n---\n\n### 간단 요약\n\n- CSS 미디어 쿼리로 라이트/다크 이미지를 제어하자.\n- `next/image`를 두 개 겹쳐서 쓰되, 실제 보여줄 이미지만 노출되도록 CSS로 관리하자.\n- 불필요한 이미지 로딩을 막기 위해 기본 `loading=\"lazy\"`를 사용하자. 필요할 땐 `fetchPriority=\"high\"`도 써보자.\n\n---\n\n### 덧붙여서 알려드리는 팁!\n\n- 만약 이미지가 너무 많거나 용량이 크다면, 라이트/다크 모드 전환 시 자바스크립트로 이미지를 동적으로 교체하는 방법도 고려할 수 있습니다.\n- 또 CSS `image-set` 같은 기능도 사용해볼 수 있지만, 브라우저 지원이 조금씩 다르니 꼭 테스트하세요!\n\n---\n\n다크모드 시대에 잘 맞춰 사용자 경험을 선물해주는 테마별 이미지 처리, 어렵지 않지요? 직접 코드를 돌려보면서 이미지 교체가 매끄럽게 되는 걸 느껴보시면 이해가 훨씬 쉬워집니다.\n\n그럼 즐거운 개발 하세요! 🚀\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 데모: 라이트/다크 모드 테마 감지\n\n## getImageProps 함수\n\n조금 더 고급 활용법을 원할 때는 getImageProps() 함수를 호출해서, 실제 `img` 태그에 들어갈 props들을 받아올 수 있어요. 그리고 이 props들을 다른 컴포넌트나 스타일, 혹은 캔버스 등에 넘겨서 자유롭게 사용할 수 있죠.\n\n이 방법의 좋은 점은 React의 useState()를 사용하지 않기 때문에 퍼포먼스가 좀 더 좋아질 수 있다는 거예요. (useState를 쓰면 상태 변경으로 리렌더링이 발생할 수 있거든요.) 하지만 여기서 주의할 점은 placeholder prop과 함께 사용할 수 없다는 겁니다! 왜냐하면 placeholder가 한 번 설정되면 절대 사라지지 않거든요.\n\n즉, 이미지 로딩 상태를 직접 관리하거나, 커스텀한 방식으로 이미지를 표시하고 싶을 때 이 함수를 쓰면 꽤 유용하겠죠? 다만, 나중에 placeholder 효과를 구현하고 싶다면 다른 방법을 고민해야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 테마 감지용 이미지 바꾸기\n\n웹사이트를 만들 때, 라이트 모드와 다크 모드에 따라 다른 이미지를 보여주고 싶을 때가 있죠? 이럴 때 유용한 방법이 바로 `picture` 태그를 활용하는 거예요. 사용자 브라우저가 선호하는 색상 모드(라이트/다크)를 감지해서 그에 맞는 이미지를 자동으로 보여줄 수 있답니다.\n\n아래는 Next.js에서 `next/image`의 `getImageProps`를 활용해, 라이트/다크 모드별로 서로 다른 이미지를 설정하는 예시 코드입니다.\n\n```jsx\nimport { getImageProps } from 'next/image'\n\nexport default function Page() {\n  const common = { alt: 'Theme Example', width: 800, height: 400 }\n\n  const {\n    props: { srcSet: dark },\n  } = getImageProps({ ...common, src: '/dark.png' })\n\n  const {\n    props: { srcSet: light, ...rest },\n  } = getImageProps({ ...common, src: '/light.png' })\n\n  return (\n    \u003cpicture\u003e\n      \u003csource media=\"(prefers-color-scheme: dark)\" srcSet={dark} /\u003e\n      \u003csource media=\"(prefers-color-scheme: light)\" srcSet={light} /\u003e\n      \u003cimg {...rest} /\u003e\n    \u003c/picture\u003e\n  )\n}\n```\n\n---\n\n### 여기서 알아두면 좋은 점!\n\n- **`picture` 태그**: 여러 이미지를 상황에 맞게 골라 보여주기 위해 쓰여요. `\u003csource\u003e`에 조건(미디어쿼리)을 걸고, 마지막 `\u003cimg\u003e` 태그가 기본 이미지 역할을 해주죠.\n- **`prefers-color-scheme` 미디어 쿼리**: 사용자 기기의 모드 설정을 감지해 `dark`나 `light` 여부를 판단해요.\n- **Next.js의 `getImageProps`**: 이미지를 최적화하고 메타 정보를 제공해서, 별도의 수동 작업 없이도 쉽게 이미지 관련 속성을 얻을 수 있어요.\n\n---\n\n### 추가 팁!\n\n1. 이미지 파일을 많이 만드는 게 번거롭다면, CSS 필터(예: `filter: invert(1)`)를 활용해 이미지 색상을 조절하는 방법도 있어요. 단, 복잡한 이미지엔 적용하기 어려울 수 있답니다.\n\n2. 다크 모드 이미지를 SVG로 만들면 색상 변경도 더 자유롭고, 용량도 줄일 수 있으니 참고하세요.\n\n3. `picture` 태그가 구형 브라우저에서는 지원되지 않을 수 있으니, 꼭 호환성 체크도 해보시면서 사용하시길 추천드립니다.\n\n---\n\n다음에는 ‘아트 디렉션’(Art Direction)을 위해서 어떻게 이미지 크기나 구성을 바꾸는지에 대해 다뤄볼게요! 디자인 변화에 따라 이미지를 컨트롤하는 재미난 방법들이 많이 있답니다. 기대해주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데스크탑과 모바일에서 각각 다른 이미지를 보여주고 싶을 때, 흔히 'Art Direction(아트 디렉션)'이라고 불러요.  \n이럴 때는 `getImageProps()` 함수에 각 기기별로 다른 `src`, `width`, `height`, `quality` 값을 넘겨줘서 손쉽게 처리할 수 있답니다.\n\n아래 예제를 보면 조금 더 이해하기 쉬울 거예요:\n\n```jsx\nimport { getImageProps } from 'next/image'\n\nexport default function Home() {\n  const common = { alt: 'Art Direction Example', sizes: '100vw' }\n\n  // 데스크탑용 이미지 속성 가져오기\n  const {\n    props: { srcSet: desktop },\n  } = getImageProps({\n    ...common,\n    width: 1440,\n    height: 875,\n    quality: 80,\n    src: '/desktop.jpg',\n  })\n\n  // 모바일용 이미지 속성 가져오기\n  const {\n    props: { srcSet: mobile, ...rest },\n  } = getImageProps({\n    ...common,\n    width: 750,\n    height: 1334,\n    quality: 70,\n    src: '/mobile.jpg',\n  })\n\n  return (\n    \u003cpicture\u003e\n      \u003csource media=\"(min-width: 1000px)\" srcSet={desktop} /\u003e\n      \u003csource media=\"(min-width: 500px)\" srcSet={mobile} /\u003e\n      \u003cimg {...rest} style={{ width: '100%', height: 'auto' }} /\u003e\n    \u003c/picture\u003e\n  )\n}\n```\n\n`\u003cpicture\u003e` 태그와 `\u003csource\u003e`를 사용해서 화면 크기에 맞는 이미지를 선택하도록 해주는데요, 브라우저가 조건에 맞는 첫 번째 `\u003csource\u003e`를 찾아 이미지를 보여주고, 맞는 게 없으면 `\u003cimg\u003e` 태그에 있는 이미지가 기본으로 나옵니다.\n\n그리고 여기서 `getImageProps()`로 반환받은 `srcSet`은 여러 해상도 이미지를 브라우저가 자동으로 선택하게 도와줘서, 고해상도 기기에서도 선명한 이미지를 볼 수 있습니다.\n\n---\n\n### CSS 배경 이미지에 활용하기\n\n사실 이미지를 태그로만 쓰는 게 아니라, CSS `background-image`로도 활용할 수 있어요.  \n이때 `srcSet` 문자열을 CSS의 `image-set()` 함수로 변환해서 반응형 배경 이미지를 만들 수 있답니다.\n\n예를 들어, 이렇게 쓸 수 있어요:\n\n```css\nbackground-image: image-set(\n  url('/image-1x.png') 1x,\n  url('/image-2x.png') 2x\n);\n```\n\n`image-set()` 함수는 해상도에 따라 다른 이미지를 로드하도록 도와주는데, 그렇게 하면 모바일과 데스크탑의 배경 이미지를 각각 최적화할 수 있어요.\n\n---\n\n### 이렇게 활용해보세요!\n\n- 이미지 용량과 해상도를 따로 조절해서 모바일에서는 가볍고, 데스크탑에서는 선명한 이미지를 제공할 수 있어요.\n- `\u003cpicture\u003e` 태그를 활용하면 SEO와 접근성에도 좋아요. `\u003cimg\u003e`의 `alt` 속성을 꼭 챙기는 것도 잊지 말고요!\n- CSS `image-set()`으로 배경 이미지에 반응형을 적용해보면 디자인 퀄리티가 더 좋아질 수 있답니다.\n\n이미지 아트 디렉션, 처음에는 조금 복잡해 보여도 차근차근 손에 익으면서 효과를 톡톡히 볼 수 있을 거예요.  \n필요하면 제가 배경 이미지용 `image-set()` 변환법도 예제로 한번 더 알려드릴게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nJS와 Next.js의 next/image 컴포넌트를 활용해서 배경 이미지를 다루는 예제와, 관련한 브라우저 호환 이슈를 알아볼게요.\n\n---\n\n## 배경 이미지로 next/image srcSet 활용하기\n\n```js\nimport { getImageProps } from 'next/image';\n \nfunction getBackgroundImage(srcSet = '') {\n  const imageSet = srcSet\n    .split(', ')\n    .map((str) =\u003e {\n      const [url, dpi] = str.split(' ');\n      return `url(\"${url}\") ${dpi}`;\n    })\n    .join(', ');\n  return `image-set(${imageSet})`;\n}\n \nexport default function Home() {\n  const {\n    props: { srcSet },\n  } = getImageProps({ alt: '', width: 128, height: 128, src: '/img.png' });\n  \n  const backgroundImage = getBackgroundImage(srcSet);\n  \n  const style = { height: '100vh', width: '100vw', backgroundImage };\n \n  return (\n    \u003cmain style={style}\u003e\n      \u003ch1\u003eHello World\u003c/h1\u003e\n    \u003c/main\u003e\n  );\n}\n```\n\n### 설명을 덧붙이자면\n\n- `getImageProps`는 next/image가 이미지 로딩에 최적화된 속성들(`srcSet`, `src`, `sizes` 등)을 생성해주는 함수입니다.\n- 여기서는 `srcSet` 문자열을 받아서 CSS `image-set()` 구문에 맞게 변환해줍니다.\n- `image-set`은 여러 해상도에 맞는 이미지들을 선언해서 브라우저가 상황에 맞게 선택적으로 로딩할 수 있게 합니다.\n- 이걸 스타일 객체에 바로 `backgroundImage`로 넣어서 배경으로 활용하는 거죠.\n\n### 작은 팁!\n\n- CSS `image-set()` 지원은 아직 일부 브라우저에서 제한적이라 실제로 쓸 땐 호환성 체크 꼭 하세요.\n- 여기선 inline style로 썼지만, css-in-js나 external css로 작성하면 유지보수가 더 좋을 수 있어요.\n- next/image 기본 컴포넌트는 `\u003cimg\u003e` 태그에 최적화되어 있기 때문에 배경 이미지로 쓰긴 다소 변칙적이라, 상황에 따라 직접 이미지 태그를 쓰는 것도 고민해보세요.\n\n---\n\n## 알려진 브라우저 버그 및 주의점\n\n| 브라우저             | 이슈 내용                                               | 해결법 / 참고                                |\n|----------------------|--------------------------------------------------------|---------------------------------------------|\n| Safari 15 ~ 16.3     | 이미지 로딩 시 회색 테두리 표시                        | - CSS @supports로 특정 스타일 적용\u003cbr\u003e- `priority` 속성으로 위쪽 영역 이미지 우선 로딩 |\n| Safari \u003c 15.4         | native lazy loading 미지원 (eager fallback)            | 최신 버전으로 업데이트 권장                 |\n| Safari \u003c 12           | blur-up placeholder 빈 상태 fallback                   | blur-up 효과 대신 다른 placeholder 사용 고려|\n| Safari \u003c 15           | width/height auto 스타일 사용 시 레이아웃 시프트 발생 가능 | 고정 크기 사용 추천                          |\n| Firefox 67+           | 로딩 중 흰색 배경 표시                                  | - AVIF 포맷 활성화\u003cbr\u003e- placeholder 사용   |\n\n### 알아두면 좋은 점\n\n- Next.js의 next/image는 기본적으로 lazy loading을 지원하지만, 브라우저마다 native 지원 범위가 다릅니다.\n- 특히 구형 브라우저에서는 eager로 강제 변경되거나 placeholder가 제대로 보이지 않는 등 UX가 달라질 수 있어요.\n- blur-up placeholder 효과가 안되는 구형 사파리는 사용자 눈에 빈 화면이 되는 단점이 있습니다.\n- Firefox에서 흰색 배경 문제는 AVIF 사용 및 placeholder 설정으로 완화할 수 있으니 가능하면 이미지를 AVIF 포맷으로 변환하는 게 좋아요.\n- Layout Shift (레이아웃 변화)를 막으려면 기본적으로 이미지 영역의 크기를 미리 지정해주는 게 중요합니다.\n\n---\n\n### 마무리\n\nnext/image는 편리한 이미지 최적화 도구지만, 브라우저 별로 미묘한 차이가 있어서 꼼꼼한 테스트가 필요해요.  \n특히 배경 이미지로 변형하거나 레거시 브라우저를 지원한다면, 위 이슈들을 참고해서 적절히 대응하세요!\n\n더 궁금한 점 있으면 언제든 질문해 주세요~  \n개발할 때 자주 쓰는 팁도 하나씩 알려 드릴게요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 버전 히스토리\n\n| 버전        | 변경사항                                                                                                                         |\n|-------------|----------------------------------------------------------------------------------------------------------------------------------|\n| `v15.3.0`   | `remotePatterns`에서 `URL` 객체 배열을 지원하도록 추가됨.                                                                       |\n| `v15.0.0`   | `contentDispositionType` 설정 기본값이 `attachment`으로 변경됨.                                                                  |\n| `v14.2.23`  | `qualities` 설정이 추가됨.                                                                                                      |\n| `v14.2.15`  | `decoding` prop과 `localPatterns` 설정이 추가됨.                                                                                |\n| `v14.2.14`  | `remotePatterns.search` prop이 추가됨.                                                                                         |\n| `v14.2.0`   | `overrideSrc` prop이 추가됨.                                                                                                   |\n| `v14.1.0`   | `getImageProps()`가 안정화됨.                                                                                                  |\n| `v14.0.0`   | `onLoadingComplete` prop과 `domains` 설정이 deprecated됨.                                                                       |\n| `v13.4.14`  | `placeholder` prop이 `data:/image...` URI를 지원하도록 추가됨.                                                                    |\n| `v13.2.0`   | `contentDispositionType` 설정이 추가됨.                                                                                         |\n| `v13.0.6`   | `ref` prop이 추가됨.                                                                                                            |\n| `v13.0.0`   | - `next/image` 임포트가 `next/legacy/image`로 이름 변경됨.\u003cbr\u003e- `next/future/image` 임포트가 `next/image`로 이름 변경됨.\u003cbr\u003e- \u003ca href=\"/docs/app/guides/upgrading/codemods#next-image-to-legacy-image\"\u003e안전하고 자동으로 임포트를 변경해주는 codemod 제공\u003c/a\u003e.\u003cbr\u003e- `\u003cspan\u003e` 래퍼 제거.\u003cbr\u003e- `layout`, `objectFit`, `objectPosition`, `lazyBoundary`, `lazyRoot` prop 삭제.\u003cbr\u003e- `alt` prop 필수화.\u003cbr\u003e- `onLoadingComplete`이 `img` 엘리먼트 레퍼런스를 받음.\u003cbr\u003e- 기본 내장 로더 설정 제거됨. |\n| `v12.3.0`   | `remotePatterns` 및 `unoptimized` 설정이 안정화됨.                                                                              |\n| `v12.2.0`   | 실험적 `remotePatterns`와 `unoptimized` 설정 추가.\u003cbr\u003e`layout=\"raw\"` 삭제됨.                                                   |\n| `v12.1.1`   | `style` prop 추가.\u003cbr\u003e실험적 `layout=\"raw\"` 지원 추가.                                                                           |\n| `v12.1.0`   | `dangerouslyAllowSVG`와 `contentSecurityPolicy` 설정 추가됨.                                                                     |\n| `v12.0.9`   | `lazyRoot` prop 추가됨.                                                                                                         |\n| `v12.0.0`   | - `formats` 설정 추가.\u003cbr\u003e- AVIF 이미지 포맷 지원 추가.\u003cbr\u003e- 래퍼 엘리먼트가 `\u003cdiv\u003e`에서 `\u003cspan\u003e`으로 변경됨.                  |\n| `v11.1.0`   | `onLoadingComplete`과 `lazyBoundary` prop 추가됨.                                                                               |\n| `v11.0.0`   | - `src` prop이 정적 임포트를 지원.\u003cbr\u003e- `placeholder` prop 추가.\u003cbr\u003e- `blurDataURL` prop 추가.                                  |\n| `v10.0.5`   | `loader` prop 추가됨.                                                                                                           |\n| `v10.0.1`   | `layout` prop 추가됨.                                                                                                           |\n| `v10.0.0`   | `next/image` 컴포넌트 도입됨.                                                                                                  |\n\n---\n\n이렇게 버전별로 주요 업데이트가 정리되어 있으니, 특히 `v13`에서 큰 변화가 있었던 점 잊지 마세요! `alt`가 필수로 변경된 점이라든지 `next/image`의 경로가 달라진 부분은 프로젝트 마이그레이션 시 꼭 체크하세요. 그리고 최신 버전에서는 AVIF 포맷 지원 등 이미지 최적화 기능도 점점 좋아지고 있어서, 가능하면 최신 버전을 쓰는 게 좋습니다.\n\n필요하면 각 버전에 있는 새로운 prop이나 설정을 활용해 성능과 사용자 경험을 개선해보시길 추천합니다!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":99},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003eImage 컴포넌트 사용법\u003c/h1\u003e\n\u003cp\u003e이번에는 Next.js에서 제공하는 \u003ccode\u003eImage\u003c/code\u003e 컴포넌트에 대해서 알아볼게요. 이미지 최적화에 신경 써야 할 때 직접 \u003ccode\u003e\u0026#x3C;img\u003e\u003c/code\u003e 태그를 쓰기보다는 이 컴포넌트를 활용하면 자동으로 다양한 최적화가 진행되어 성능 향상에 도움이 된답니다.\u003c/p\u003e\n\u003cp\u003e아래는 \u003ccode\u003eImage\u003c/code\u003e 컴포넌트를 사용하는 기본적인 예시입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/image'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eImage\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"/profile.png\"\u003c/span\u003e       // \u003cspan class=\"hljs-attr\"\u003e이미지\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e경로\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{500}\u003c/span\u003e              // \u003cspan class=\"hljs-attr\"\u003e이미지\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e너비\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003epx\u003c/span\u003e)\n      \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{500}\u003c/span\u003e             // \u003cspan class=\"hljs-attr\"\u003e이미지\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e높이\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003epx\u003c/span\u003e)\n      \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"Picture of the author\"\u003c/span\u003e // \u003cspan class=\"hljs-attr\"\u003e대체\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e텍스트\u003c/span\u003e (\u003cspan class=\"hljs-attr\"\u003e접근성에\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e필수\u003c/span\u003e!)\n    /\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eImage\u003c/code\u003e 컴포넌트의 기본적인 사용법은 이렇게 \u003ccode\u003esrc\u003c/code\u003e, \u003ccode\u003ewidth\u003c/code\u003e, \u003ccode\u003eheight\u003c/code\u003e, \u003ccode\u003ealt\u003c/code\u003e 속성을 넘겨주는 거에요. 이 외에도 여러 유용한 props들이 있는데, 이어서 자세히 살펴볼게요.\u003c/p\u003e\n\u003ch2\u003eImage 컴포넌트 주요 Props\u003c/h2\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eProp\u003c/th\u003e\u003cth\u003e타입\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003esrc\u003c/td\u003e\u003ctd\u003estring\u003c/td\u003e\u003ctd\u003e불러올 이미지 경로 또는 URL\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003ewidth\u003c/td\u003e\u003ctd\u003enumber/string\u003c/td\u003e\u003ctd\u003e이미지 너비\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eheight\u003c/td\u003e\u003ctd\u003enumber/string\u003c/td\u003e\u003ctd\u003e이미지 높이\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003ealt\u003c/td\u003e\u003ctd\u003estring\u003c/td\u003e\u003ctd\u003e이미지 설명 텍스트 (웹 접근성 측면에서 매우 중요)\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003elayout\u003c/td\u003e\u003ctd\u003estring\u003c/td\u003e\u003ctd\u003e이미지 레이아웃 (\u003ccode\u003efixed\u003c/code\u003e, \u003ccode\u003eintrinsic\u003c/code\u003e, \u003ccode\u003eresponsive\u003c/code\u003e, \u003ccode\u003efill\u003c/code\u003e) 설정\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003epriority\u003c/td\u003e\u003ctd\u003eboolean\u003c/td\u003e\u003ctd\u003etrue일 경우 우선 로딩, 주로 초기 페이지에 사용\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eplaceholder\u003c/td\u003e\u003ctd\u003estring\u003c/td\u003e\u003ctd\u003e이미지 로딩 전 보여줄 플레이스홀더 (\u003ccode\u003eblur\u003c/code\u003e 가능)\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003equality\u003c/td\u003e\u003ctd\u003enumber\u003c/td\u003e\u003ctd\u003e이미지 품질 설정 (1~100)\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eloader\u003c/td\u003e\u003ctd\u003efunction\u003c/td\u003e\u003ctd\u003e커스텀 이미지 로더 함수 설정\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003elayout 옵션 간단 설명\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003efixed\u003c/code\u003e: 지정한 크기에서 고정\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eintrinsic\u003c/code\u003e: 원본 비율 유지하며 최대 크기까지 늘어남\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eresponsive\u003c/code\u003e: 부모 컨테이너의 크기에 맞게 반응형 조절\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efill\u003c/code\u003e: 부모 컨테이너를 가득 채움 (position: absolute 필요)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eTip\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003epriority\u003c/code\u003e 속성을 설정하면 페이지 로딩 시 해당 이미지가 우선적으로 로드되어 사용자 경험이 개선됩니다. 예를 들어, 프로필 사진이나 메인 배너 이미지에 사용하는 게 좋아요.\u003c/p\u003e\n\u003cp\u003e또한 \u003ccode\u003eplaceholder=\"blur\"\u003c/code\u003e와 함께 \u003ccode\u003eblurDataURL\u003c/code\u003e 속성을 사용하면 이미지를 불러오는 동안 흐릿한 미리보기 이미지를 보여줄 수 있어 깔끔한 로딩 효과를 줄 수 있답니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e추가로 궁금한 점이나 더 자세한 사용법이 필요하면 언제든지 알려주세요! Next.js는 이미지 핸들링을 꽤 잘 처리해주니까 꼭 활용해보시길 추천해요.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eImage 컴포넌트에 사용할 수 있는 주요 props를 정리해봤어요. 이 내용을 참고하면 이미지 컴포넌트를 사용할 때 어떤 옵션들을 넣을 수 있는지 한눈에 확인할 수 있을 거예요.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eProp\u003c/th\u003e\u003cth\u003eExample\u003c/th\u003e\u003cth\u003eType\u003c/th\u003e\u003cth\u003eStatus\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003esrc\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003esrc=\"/profile.png\"\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eString\u003c/td\u003e\u003ctd\u003eRequired\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ewidth\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003ewidth={500}\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eInteger (px)\u003c/td\u003e\u003ctd\u003eRequired\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eheight\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eheight={500}\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eInteger (px)\u003c/td\u003e\u003ctd\u003eRequired\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ealt\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003ealt=\"Picture of the author\"\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eString\u003c/td\u003e\u003ctd\u003eRequired\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eloader\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eloader={imageLoader}\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eFunction\u003c/td\u003e\u003ctd\u003e-\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003efill\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003efill={true}\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eBoolean\u003c/td\u003e\u003ctd\u003e-\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003esizes\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003esizes=\"(max-width: 768px) 100vw, 33vw\"\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eString\u003c/td\u003e\u003ctd\u003e-\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003equality\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003equality={80}\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eInteger (1-100)\u003c/td\u003e\u003ctd\u003e-\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003epriority\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003epriority={true}\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eBoolean\u003c/td\u003e\u003ctd\u003e-\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eplaceholder\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eplaceholder=\"blur\"\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eString\u003c/td\u003e\u003ctd\u003e-\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003estyle\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003estyle={{objectFit: \"contain\"}}\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eObject\u003c/td\u003e\u003ctd\u003e-\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eonLoadingComplete\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eonLoadingComplete={img =\u003e done()}\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eFunction\u003c/td\u003e\u003ctd\u003eDeprecated\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eonLoad\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eonLoad={event =\u003e done()}\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eFunction\u003c/td\u003e\u003ctd\u003e-\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eonError\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eonError={event =\u003e fail()}\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eFunction\u003c/td\u003e\u003ctd\u003e-\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eloading\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eloading=\"lazy\"\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eString\u003c/td\u003e\u003ctd\u003e-\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eblurDataURL\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eblurDataURL=\"data:image/jpeg...\"\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eString\u003c/td\u003e\u003ctd\u003e-\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eoverrideSrc\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eoverrideSrc=\"/seo.png\"\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eString\u003c/td\u003e\u003ctd\u003e-\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003ch3\u003e필수로 꼭 들어가야 하는 props\u003c/h3\u003e\n\u003cp\u003eImage 컴포넌트를 쓸 때는 최소한 다음 네 가지는 꼭 지정해줘야 해요.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003esrc\u003c/code\u003e: 이미지 경로 (예: \u003ccode\u003e/profile.png\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ealt\u003c/code\u003e: 이미지가 로드되지 않을 때 대체 텍스트 역할을 하는 설명\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ewidth\u003c/code\u003e: 이미지 너비 (픽셀 단위)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eheight\u003c/code\u003e: 이미지 높이 (픽셀 단위)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003ewidth\u003c/code\u003e와 \u003ccode\u003eheight\u003c/code\u003e 대신에 \u003ccode\u003efill={true}\u003c/code\u003e 옵션을 사용하는 방법도 있는데, 이 경우 이미지가 부모 요소의 크기에 맞춰서 자동으로 채워지게 돼요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e그 외에 알아두면 좋은 점들\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eloader\u003c/code\u003e: 커스텀 이미지 로더를 만들 때 유용해요. 기본 로더 대신 내가 원하는 로딩 방식을 정의할 수 있어요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epriority\u003c/code\u003e: 중요한 이미지는 이 옵션을 true로 설정해서 퍼포먼스를 개선할 수 있어요. React 내장 lazy loading과 다르게 우선 로드되게 할 수 있답니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eplaceholder\u003c/code\u003e와 \u003ccode\u003eblurDataURL\u003c/code\u003e: 이미지를 불러오기 전에 흐릿한 이미지(blur 효과)를 보여 주는 용도로 자주 쓰여요. 사용자 경험을 한층 부드럽게 만들어주죠.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esizes\u003c/code\u003e: 반응형 이미지에서 매우 유용해요. 화면 크기에 따라 적절한 이미지 크기를 제공할 수 있게 도와줍니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eonLoad\u003c/code\u003e와 \u003ccode\u003eonError\u003c/code\u003e: 이미지가 로드되었을 때나 에러가 났을 때 적절한 콜백 처리를 하고 싶으면 이 props들을 활용하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003eonLoadingComplete\u003c/code\u003e는 요즘은 사용을 권장하지 않는 Deprecated 상태니까, 가능하면 \u003ccode\u003eonLoad\u003c/code\u003e를 사용하시는 걸 추천해요.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e실제 프로젝트에서 이미지를 최적화하고 싶을 때 이 컴포넌트의 다양한 옵션들을 잘 활용하면 훨씬 효율적이고 깔끔한 구현이 가능해집니다. 저는 개인적으로 \u003ccode\u003epriority\u003c/code\u003e, \u003ccode\u003eplaceholder\u003c/code\u003e, 그리고 \u003ccode\u003esizes\u003c/code\u003e 옵션을 자주 사용해서 사용자 경험이 좋아지는 걸 체감했어요.\u003c/p\u003e\n\u003cp\u003e필요한 부분만 잘 골라서 쓰면 되니 너무 걱정 말고 하나씩 시도해보면서 익혀보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e안녕하세요! 오늘은 Next.js에서 \u003ccode\u003eImage\u003c/code\u003e 컴포넌트를 사용할 때 \u003ccode\u003esrc\u003c/code\u003e 속성에 대해 알아볼게요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/image'\u003c/span\u003e\n \n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eImage\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"/profile.png\"\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{500}\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{500}\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"Picture of the author\"\u003c/span\u003e\n      /\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 예제에서 \u003ccode\u003esrc\u003c/code\u003e는 이미지 경로를 나타내는데요, Next.js에서는 \u003ccode\u003esrc\u003c/code\u003e에 사용할 수 있는 값이 제한되어 있습니다. 그 조건을 한번 살펴볼게요.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003esrc 값 유형\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e정적으로 import된 이미지 파일\u003c/td\u003e\u003ctd\u003e예를 들어, \u003ccode\u003eimport profilePic from '../public/profile.png'\u003c/code\u003e 처럼 미리 불러온 이미지 파일을 사용할 수 있어요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e경로 문자열\u003c/td\u003e\u003ctd\u003eURL 형태의 문자열로, 다음 두 경우로 나뉘어요: \u003cbr\u003e - 외부 URL: \u003ccode\u003ehttps://example.com/image.png\u003c/code\u003e \u003cbr\u003e - 내부 경로: \u003ccode\u003e/profile.png\u003c/code\u003e 等\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e여기서 중요한 점! 내부 경로를 쓸 때는 \u003ccode\u003eloader\u003c/code\u003e 속성에 따라서 다음과 같이 처리되는데요,\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e기본 \u003ccode\u003eloader\u003c/code\u003e를 사용할 때는 \u003ccode\u003e/public\u003c/code\u003e 폴더 내의 자원을 지정할 때는 경로가 \u003ccode\u003e/\u003c/code\u003e 로 시작해야 해요.즉, \u003ccode\u003e/profile.png\u003c/code\u003e는 \u003ccode\u003epublic/profile.png\u003c/code\u003e에 위치한 파일을 가리킵니다.\u003c/li\u003e\n\u003cli\u003e외부 이미지 URL을 쓸 땐 반드시 도메인을 \u003ccode\u003enext.config.js\u003c/code\u003e의 \u003ccode\u003eimages.domains\u003c/code\u003e 배열에 추가해줘야 정상적으로 최적화가 이루어져요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e또한, Next.js의 \u003ccode\u003eImage\u003c/code\u003e 컴포넌트는 이미지 최적화나 lazy loading 등 다양한 이점을 주는데요, 그래서 \u003ccode\u003ewidth\u003c/code\u003e와 \u003ccode\u003eheight\u003c/code\u003e를 꼭 명시해주는 게 좋아요. 그래야 이미지가 로드되기 전에도 레이아웃이 안정적으로 잡히고, 화면이 덜 흔들리게 되거든요.\u003c/p\u003e\n\u003cp\u003e추가 팁으로, 만약 이미지를 자바스크립트에서 직접 import 한다면 이렇게 쓸 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e profilePic \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'../public/profile.png'\u003c/span\u003e\n\n\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e\n  src={profilePic}\n  alt=\u003cspan class=\"hljs-string\"\u003e\"Profile\"\u003c/span\u003e\n  width={\u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e}\n  height={\u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e}\n/\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 Next.js가 빌드 타임에 이미지 사이즈를 정확히 파악해서 최적화에 도움을 줄 거예요.\u003c/p\u003e\n\u003cp\u003e요약하면, \u003ccode\u003esrc\u003c/code\u003e에 들어가는 값은 크게 두 가지! \u003cstrong\u003e정적 import한 이미지\u003c/strong\u003e 또는 \u003cstrong\u003e경로 문자열\u003c/strong\u003e이에요. 외부 이미지를 쓸 때는 꼭 \u003ccode\u003enext.config.js\u003c/code\u003e에 도메인 등록 잊지 마시고, 내부 경로는 \u003ccode\u003epublic\u003c/code\u003e 폴더를 기준으로 적절하게 작성하면 된답니다.\u003c/p\u003e\n\u003cp\u003eNext.js에서 이미지 다루기를 조금 더 편하고 효율적으로 하려면 이 부분을 잘 이해하시면 큰 도움이 될 거예요! 😊\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e기본 로더(default loader)를 사용할 때는 다음 사항도 꼭 참고하세요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003esrc가 외부 URL일 경우에는 \u003ccode\u003eremotePatterns\u003c/code\u003e 설정도 함께 해줘야 합니다.\u003c/li\u003e\n\u003cli\u003esrc가 애니메이션 이미지거나 JPEG, PNG, WebP, AVIF, GIF, TIFF 같은 알려진 포맷이 아닐 때는, 이미지는 있는 그대로(served as-is) 서빙됩니다.\u003c/li\u003e\n\u003cli\u003esrc가 SVG 형식이면 기본적으로 차단됩니다. SVG를 사용하려면 \u003ccode\u003eunoptimized\u003c/code\u003e 또는 \u003ccode\u003edangerouslyAllowSVG\u003c/code\u003e 옵션을 활성화해야 해요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003ewidth 속성\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003ewidth\u003c/code\u003e 속성은 이미지의 실제 픽셀 너비를 나타내는 값이에요. 이 값은 이미지가 로드될 때 레이아웃이 흔들리는 걸 막기 위해 적절한 종횡비(aspect ratio)를 계산하는 데 쓰입니다. 하지만 이게 곧 화면에 표시되는 크기를 결정하는 건 아니에요! 화면에 보이는 크기는 CSS로 조절하게 돼요. 쉽게 말해, HTML의 \u003ccode\u003eimg\u003c/code\u003e 태그에서 \u003ccode\u003ewidth\u003c/code\u003e 속성과 비슷한 역할을 한다고 생각하시면 됩니다.\u003c/p\u003e\n\u003cp\u003e요즘 반응형 이미지 대응이나 레이아웃 안정성을 위해 width, height 같은 실제 이미지 크기 정보를 명확히 지정해주는 게 권장되고 있으니 꼭 기억해 주세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e필수 항목입니다. 단, 정적으로 임포트된 이미지나 fill 속성이 적용된 이미지의 경우는 예외입니다.\u003c/p\u003e\n\u003ch3\u003eheight (높이)\u003c/h3\u003e\n\u003cp\u003eheight 속성은 이미지의 본래 높이를 픽셀 단위로 나타냅니다. 이 값은 이미지의 올바른 가로세로 비율을 추론하는 데 사용되며, 로딩 중에 레이아웃이 흔들리는 현상(layout shift)을 방지하는 효과가 있어요. 다만, 실제 화면에 렌더링되는 이미지 크기를 결정하는 속성은 아니에요. 렌더링 크기는 CSS에서 제어하며, HTML \u003ccode\u003eimg\u003c/code\u003e 태그의 height 속성과 비슷한 역할을 한다고 생각하시면 됩니다.\u003c/p\u003e\n\u003cp\u003e이 부분에서 중요한 점은, height 속성을 명시해두면 브라우저가 이미지 로딩 시점에 공간을 미리 확보하기 때문에 “레이아웃 점프” 현상을 줄여 사용자 경험을 개선할 수 있다는 것입니다. 특히 페이지 내 이미지가 많거나 이미지가 느리게 로드되는 환경에서 이 점이 큰 도움이 됩니다.\u003c/p\u003e\n\u003cp\u003e추가로, 만약 정적으로 임포트된 이미지라면 빌드 시점에 이미지 크기 정보가 이미 포함되어 있어 직접 height를 명시하지 않아도 되고, fill 속성(부모 요소의 크기에 맞춰 이미지를 꽉 채우는 스타일)을 사용하는 경우에도 마찬가지로 height를 직접 지정할 필요가 없습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cblockquote\u003e\n\u003cp\u003e알아두면 좋은 점:\nwidth와 height 속성은 이미지의 가로세로 비율(종횡비)을 결정하는 데 함께 사용돼요. 브라우저는 이 정보를 바탕으로 이미지가 로딩되기 전에 미리 공간을 확보하죠.\u003cbr\u003e\n하지만 intrinsic size(내재적 크기)가 항상 브라우저에 렌더링되는 크기와 같지는 않아요. 부모 컨테이너 크기에 따라 이미지가 그 안에 맞게 조절되거든요. 예를 들어, 부모 컨테이너가 이미지 intrinsic size보다 작으면, 이미지는 자동으로 축소되어 컨테이너에 맞춰지는 거죠.\u003cbr\u003e\n만약 width와 height가 애초에 알려지지 않았다면, \u003ccode\u003efill\u003c/code\u003e 속성을 활용할 수도 있어요.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3\u003ealt 속성\u003c/h3\u003e\n\u003cp\u003e이미지의 alt 속성은 화면 읽기 기기(screen reader)와 검색 엔진을 위한 설명 역할을 해요. 이미지가 비활성화되어 있거나 로딩 오류가 발생했을 때는 대체 텍스트로 나타나죠.\u003c/p\u003e\n\u003cp\u003ealt 텍스트는 페이지의 의미를 바꾸지 않고 이미지를 대신할 수 있는 내용을 담아야 합니다.\u003cbr\u003e\n즉, 이미지를 보완하는 용도가 아니라, 이미지 캡션이나 주변 텍스트에서 이미 설명한 내용을 반복하면 안 돼요.\u003c/p\u003e\n\u003cp\u003e요즘은 웹 접근성의 중요성이 부각되면서, 올바른 alt 속성 작성이 필수로 권장되고 있어요. 특히 시각장애인들이 사용하는 스크린 리더에서는 이미지가 제공하는 정보를 alt가 대신 전달하기 때문에, 간결하면서도 핵심을 담는 것이 좋답니다.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e속성\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003ewidth, height\u003c/td\u003e\u003ctd\u003e이미지의 가로세로 비율 결정, 브라우저가 공간 미리 확보\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eintrinsic size\u003c/td\u003e\u003ctd\u003e실제 이미지 파일의 원본 크기, 부모 컨테이너에 따라 조정됨\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003efill\u003c/td\u003e\u003ctd\u003ewidth, height 미지정 시 공간에 꽉 채우기 위한 옵션\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003ealt\u003c/td\u003e\u003ctd\u003e이미지 설명, 스크린 리더와 검색 엔진에 활용되며 대체 텍스트 역할\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e이미지 태그를 작성할 때는 위 내용을 참고해서, 디자인 뿐 아니라 접근성과 SEO까지 한 번에 챙겨보시면 좋아요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이미지가 단순히 장식용이거나\n사용자에게 중요한 정보 전달 목적이 아니라면,\nalt 속성은 빈 문자열로 설정하는 게 좋아요 (alt=\"\").\u003c/p\u003e\n\u003cp\u003e더 알아보기\u003c/p\u003e\n\u003ch2\u003e선택적 속성(Optional Props)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eImage /\u003c/code\u003e 컴포넌트는 필수 속성 외에도 다양한 추가 속성을 지원해요.\u003cbr\u003e\n이번 섹션에서는 가장 자주 쓰이는 속성들을 소개할게요.\u003cbr\u003e\n좀 더 특별하거나 덜 자주 쓰이는 속성들은 '고급 속성(Advanced Props)' 섹션에서 확인할 수 있어요.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e참고로, alt 속성은 이미지가 로드되지 않을 때 대체 텍스트로 보여주기도 하고, 시각장애인들이 스크린 리더를 사용할 때 이미지 내용을 설명해줘서 접근성 측면에서 매우 중요하답니다.\u003cbr\u003e\n하지만 장식용인 경우에는 오히려 의미 없는 텍스트가 읽히면서 사용자에게 혼란을 줄 수 있으니, 빈 문자열로 두는 게 맞아요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003eloader\u003c/h3\u003e\n\u003cp\u003e이미지 URL을 처리할 때 사용하는 커스텀 함수예요.\u003c/p\u003e\n\u003cp\u003eloader 함수는 이미지에 필요한 URL을 직접 만들어내는데, 함수에 넘겨지는 주요 인자는 다음과 같아요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003esrc\u003c/code\u003e: 이미지 경로 또는 파일명\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ewidth\u003c/code\u003e: 이미지 너비 (픽셀 단위)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003equality\u003c/code\u003e: 이미지 품질 (보통 압축률이나 화질 조절에 사용)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이걸 기억하면, 원하는 대로 이미지 URL을 동적으로 생성할 수 있답니다! 예를 들어, CDN에서 이미지를 받아올 때 너비나 품질에 맞게 URL을 조합해서 요청할 수 있죠.\u003c/p\u003e\n\u003cp\u003e추가로, 로더를 직접 만들면 기본 이미지 최적화 방식을 바꾸거나, 외부 이미지 서비스(예: Cloudinary, Imgix 등)를 쓸 때 유용해요. 그런 경우 URL 생성 규칙이 다르니까 loader 함수에서 그에 맞게 처리하면 되죠.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e만약 간단한 예시가 궁금하다면 이렇게 써볼 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emyLoader\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ src, width, quality }\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e`https://mycdn.com/\u003cspan class=\"hljs-subst\"\u003e${src}\u003c/span\u003e?w=\u003cspan class=\"hljs-subst\"\u003e${width}\u003c/span\u003e\u0026#x26;q=\u003cspan class=\"hljs-subst\"\u003e${quality || \u003cspan class=\"hljs-number\"\u003e75\u003c/span\u003e}\u003c/span\u003e`\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위처럼 \u003ccode\u003esrc\u003c/code\u003e, \u003ccode\u003ewidth\u003c/code\u003e, \u003ccode\u003equality\u003c/code\u003e를 받아서 URL을 조합하고, 이 URL을 이미지 컴포넌트에 넘겨주면 돼요.\u003cbr\u003e\n그럼 필요한 크기와 품질에 맞춰서 이미지를 호출하니 네트워크 비용도 아끼고 페이지 속도도 좋아져요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e여기 커스텀 로더(custom loader)를 사용하는 예제가 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e'use client'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/image'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eimageLoader\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e{ src, width, quality }\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e`https://example.com/\u003cspan class=\"hljs-subst\"\u003e${src}\u003c/span\u003e?w=\u003cspan class=\"hljs-subst\"\u003e${width}\u003c/span\u003e\u0026#x26;q=\u003cspan class=\"hljs-subst\"\u003e${quality || \u003cspan class=\"hljs-number\"\u003e75\u003c/span\u003e}\u003c/span\u003e`\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eImage\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eloader\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{imageLoader}\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"me.png\"\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"Picture of the author\"\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{500}\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{500}\u003c/span\u003e\n    /\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e핵심 포인트\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eloader\u003c/code\u003e라는 프로퍼티에 함수 형태로 로더를 넣을 때는 \u003cstrong\u003e클라이언트 컴포넌트(Client Components)\u003c/strong\u003e 안에서 사용해야 해요. 이유는 Next.js가 이 함수를 직렬화(serialization)해야 하기 때문입니다.\u003c/li\u003e\n\u003cli\u003e즉, \u003ccode\u003e'use client'\u003c/code\u003e 지시어를 꼭 컴포넌트 상단에 추가해줘야 오류가 안 납니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003e참고!\u003c/h3\u003e\n\u003cp\u003e만약 앱 전역에 걸쳐서 모든 \u003ccode\u003enext/image\u003c/code\u003e 컴포넌트에 대해 같은 커스텀 로더를 쓰고 싶다면, \u003ccode\u003enext.config.js\u003c/code\u003e의 \u003ccode\u003eloaderFile\u003c/code\u003e 옵션을 설정하는 방법도 있어요. 그러면 매번 개별 컴포넌트에서 \u003ccode\u003eloader\u003c/code\u003e prop을 넘겨주지 않아도 되죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// next.config.js\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eexperimental\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003eimages\u003c/span\u003e: {\n      \u003cspan class=\"hljs-attr\"\u003eloaderFile\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'./my-custom-loader.js'\u003c/span\u003e,\n    },\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003emy-custom-loader.js\u003c/code\u003e에 로더 함수를 작성해두면 Next.js가 자동으로 이걸 참조합니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e커스텀 로더 쓸 때 알아두면 좋은 점\u003c/h3\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e내용\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e로더에서 다루는 인자\u003c/td\u003e\u003ctd\u003e\u003ccode\u003esrc\u003c/code\u003e, \u003ccode\u003ewidth\u003c/code\u003e, \u003ccode\u003equality\u003c/code\u003e 등 이미지 최적화에 중요한 값들\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e기본 품질 값\u003c/td\u003e\u003ctd\u003e\u003ccode\u003equality\u003c/code\u003e가 없으면 75로 기본 세팅되는 경우가 많음\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e'use client' 필요\u003c/td\u003e\u003ctd\u003e로더 함수를 컴포넌트 안에서 직접 넘길 땐 클라이언트 컴포넌트여야 함\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e전역 설정 가능\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eloaderFile\u003c/code\u003e 옵션으로 앱 전체에 일괄 적용 가능\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003cp\u003e커스텀 로더는 외부 CDN이나 이미지 서버에서 동적으로 크기 조절, 품질 조절이 가능할 때 특히 유용해요. 이렇게 하면 필요한 사이즈로 딱 맞는 이미지를 받아와서 페이지 로딩 속도를 개선할 수 있답니다.\u003c/p\u003e\n\u003cp\u003e혹시 이미지 최적화 관련해서 더 궁금한 점 있으면 언제든 질문 주세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003efill\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efill={\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e} \u003cspan class=\"hljs-comment\"\u003e// {true} | {false}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003efill\u003c/code\u003e은 이미지가 부모 요소를 꽉 채우도록 하는 불리언 값이에요. 특히, 이미지의 너비와 높이를 미리 지정하기 어려울 때 유용하죠.\u003c/p\u003e\n\u003cp\u003e단, 이 기능을 제대로 사용하려면 부모 요소에 \u003ccode\u003eposition: \"relative\"\u003c/code\u003e, \u003ccode\u003eposition: \"fixed\"\u003c/code\u003e, 또는 \u003ccode\u003eposition: \"absolute\"\u003c/code\u003e 스타일을 꼭 지정해줘야 해요. 그래야 이미지가 부모 요소 안에서 정확하게 위치하고 크기가 맞춰지니까요.\u003c/p\u003e\n\u003cp\u003e예를 들어 이렇게 쓸 수 있겠죠:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u0026#x3C;div style={{ \u003cspan class=\"hljs-attr\"\u003eposition\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'relative'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'100%'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'300px'\u003c/span\u003e }}\u003e\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eImage\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"/example.jpg\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"Example\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003efill\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{true}\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e\n\u0026#x3C;/div\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 \u003ccode\u003ediv\u003c/code\u003e에 \u003ccode\u003eposition: 'relative'\u003c/code\u003e를 줌으로써 이미지가 그 영역을 꽉 채우게 만들 수 있어요.\u003c/p\u003e\n\u003cp\u003e이 점 꼭 기억하고 활용하면, 반응형 이미지 배치 때 꽤 편리하답니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e기본적으로 img 태그에는 position: \"absolute\" 스타일이 자동으로 적용돼요.\u003c/p\u003e\n\u003cp\u003e만약 이미지에 별도의 스타일이 지정되지 않았다면, 이미지는 컨테이너 크기에 맞춰 늘어나게 돼요. 그런데 이럴 때 이미지가 찌그러지거나 비율이 이상해질 수 있죠. 그래서 보통은 object-fit: \"contain\" 스타일을 주는 게 좋아요. 이걸 주면 이미지가 컨테이너 안에 딱 맞게 맞춰지고, 빈 공간이 있을 때는 레터박스(검은 여백)가 생기면서 원본 비율을 유지해 줍니다.\u003c/p\u003e\n\u003cp\u003e반대로 object-fit: \"cover\"를 사용하면 이미지가 컨테이너를 꽉 채우도록 잘리면서 보여줘요. 원본 비율은 지키지만, 이미지 일부가 잘릴 수 있다는 점 명심하세요.\u003c/p\u003e\n\u003cp\u003e이렇게 object-fit을 적절히 활용하면 웹에서 이미지가 깨지거나 비율이 이상해지는 걸 방지할 수 있어요. 특히 반응형 웹이나 다양한 크기의 컨테이너에 이미지를 넣을 때 꼭 알아두면 좋은 CSS 속성이죠.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e속성\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eposition\u003c/td\u003e\u003ctd\u003e이미지 위치 지정, 기본값은 \"absolute\"\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eobject-fit\u003c/td\u003e\u003ctd\u003e이미지의 컨테이너 내 맞춤 방식 지정\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003econtain\u003c/td\u003e\u003ctd\u003e이미지 비율 유지하며 컨테이너 안에 모두 보여줌\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003ecover\u003c/td\u003e\u003ctd\u003e비율 유지하며 컨테이너를 완전히 덮되 일부 잘림\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e더 자세한 내용은 CSS의 object-fit 관련 문서를 참고하면 도움이 될 거예요.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e오늘은 웹 개발할 때 이미지 다룰 때 꼭 알아두면 좋은 CSS 속성 몇 가지와 함께, 특히 \u003ccode\u003esizes\u003c/code\u003e 속성에 대해 이야기해볼게요. 이미지 로딩 성능과 반응형 디자인에 큰 영향을 주기 때문에 이해하면 꽤 유용하답니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003eposition, object-fit, object-position 간단 정리\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eposition\u003c/strong\u003e\u003cbr\u003e\n이미지나 요소의 위치를 설정할 때 쓰이는 CSS 속성이죠. 예를 들어, \u003ccode\u003erelative\u003c/code\u003e, \u003ccode\u003eabsolute\u003c/code\u003e 같은 값을 줘요. 이미지가 컨테이너 내에서 어떻게 배치될지 결정할 때 많이 씁니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eobject-fit\u003c/strong\u003e\u003cbr\u003e\n이미지를 컨테이너 크기에 맞게 어떻게 맞출지 정하는 속성이에요. 대표값으로는 \u003ccode\u003ecover\u003c/code\u003e (이미지 꽉 채우기, 잘릴 수 있음), \u003ccode\u003econtain\u003c/code\u003e (이미지 전체 보이도록 축소/확대), \u003ccode\u003efill\u003c/code\u003e (비율 무시하고 꽉 채움), \u003ccode\u003enone\u003c/code\u003e (원본 크기 유지) 등이 있어요.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eobject-position\u003c/strong\u003e\u003cbr\u003e\n\u003ccode\u003eobject-fit\u003c/code\u003e이 \u003ccode\u003ecover\u003c/code\u003e나 \u003ccode\u003econtain\u003c/code\u003e일 때, 이미지가 컨테이너 안에서 어디에 위치할지 정하는 속성이에요. 기본값은 \u003ccode\u003ecenter center\u003c/code\u003e죠. 간단히 \u003ccode\u003etop left\u003c/code\u003e, \u003ccode\u003ebottom right\u003c/code\u003e 등으로 조절할 수 있어요.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 세 가지 조합하면, 이미지가 반응형일 때 원하는 방식으로 나타나게 할 수 있어요!\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003esizes 속성 이해하기 (이미지 로딩 최적화에 핵심!)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e\u0026#x3C;img\u003e\u003c/code\u003e 태그에서 특히 \u003ccode\u003e\u0026#x3C;source\u003e\u003c/code\u003e와 함께 쓰면서 '지금 이 화면 사이즈에서 이미지가 실제로 얼마나 크게 보여질지' 브라우저에 알려주는 역할을 해요. 사실, 브라우저가 이미지 크기를 미리 알고 있으면, 가장 적합한 크기의 이미지를 요청할 수 있어 성능이 팍 좋아집니다.\u003c/p\u003e\n\u003ch4\u003esizes 정의 방식\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e문자열 형태로 쓰고, CSS 미디어 쿼리랑 비슷해요.\u003c/li\u003e\n\u003cli\u003e화면 너비 기준으로 '어떤 상황에 이미지가 몇 픽셀 너비만큼 보여질지'를 지정해줘요.\u003c/li\u003e\n\u003cli\u003e여러 조건을 콤마(,)로 구분해 순서대로 해석합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예를 들어,\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-css\"\u003esizes=\"(\u003cspan class=\"hljs-attribute\"\u003emax-width\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e600px\u003c/span\u003e) \u003cspan class=\"hljs-number\"\u003e480px\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e800px\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면, 화면 너비가 600px 이하일 땐 이미지가 480px 크기로 보여지고, 그 이상일 땐 800px 크기로 보여질 거란 걸 알려주는 거죠.\u003c/p\u003e\n\u003ch4\u003esizes가 중요한 이유\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003efill\u003c/code\u003e 또는 반응형 크기를 가진 이미지를 사용할 때 특히 효과적입니다.\u003c/li\u003e\n\u003cli\u003e화면 크기에 맞춘 적절한 이미지 해상도를 요청해 불필요한 데이터 낭비를 줄여줍니다.\u003c/li\u003e\n\u003cli\u003e결국, 로딩 속도 개선과 데이터 절약으로 이어지니 모바일 환경에선 필수!\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003e간단 요약 테이블\u003c/h3\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e속성\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003cth\u003e대표값 및 의미\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eposition\u003c/td\u003e\u003ctd\u003e요소의 위치 설정\u003c/td\u003e\u003ctd\u003erelative, absolute 등\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eobject-fit\u003c/td\u003e\u003ctd\u003e이미지가 컨테이너 내에서 크기 조절 방법\u003c/td\u003e\u003ctd\u003ecover, contain, fill, none\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eobject-position\u003c/td\u003e\u003ctd\u003e이미지 내부에서 위치 지정\u003c/td\u003e\u003ctd\u003ecenter center (기본), top left 등\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003esizes\u003c/td\u003e\u003ctd\u003e여러 화면 크기에 맞춘 이미지 출력 크기 안내\u003c/td\u003e\u003ctd\u003e(media query) 크기, 최종 이미지 너비\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003ch3\u003e마무리 팁\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003esizes\u003c/code\u003e가 없으면?\u003c/strong\u003e\u003cbr\u003e\n브라우저는 디폴트로 전체 이미지 크기를 사용하거나 해상도에 맞춘 이미지를 선택 못해, 큰 이미지 불필요하게 다운받을 수 있어요.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003esrcset\u003c/code\u003e과 함께 쓰기!\u003c/strong\u003e\u003cbr\u003e\n\u003ccode\u003esizes\u003c/code\u003e는 주로 \u003ccode\u003esrcset\u003c/code\u003e과 같이 써서 여러 해상도 이미지를 상황에 맞게 불러오도록 해요.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e반응형 이미지 사용시 필수!\u003c/strong\u003e\u003cbr\u003e\n화면 크기별로 이미지를 다르게 하고 싶으면, \u003ccode\u003esizes\u003c/code\u003e에 익숙해지는 게 좋습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e이미지를 효율적으로 다루는 건 작은 것 같지만 웹 페이지 속도와 사용자 경험에 큰 차이를 만듭니다. \u003ccode\u003eposition\u003c/code\u003e, \u003ccode\u003eobject-fit\u003c/code\u003e, \u003ccode\u003eobject-position\u003c/code\u003e으로 디자인을 잡고, \u003ccode\u003esizes\u003c/code\u003e로 똑똑하게 이미지 로딩 관리해보세요! 앞으로도 계속 실용적인 웹 테크닉 알려드릴게요. 궁금한 점 있으면 댓글 남겨주세요~ 😊\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003enext/image의 sizes 속성, 제대로 이해하고 있나요?\u003cbr\u003e\n이미지를 좀 더 똑똑하게 불러오고 싶다면 sizes 속성만큼 중요한 것도 없어요. 이번 글에서는 sizes가 왜 필요한지, 그리고 어떻게 활용하면 좋은지 쉽게 풀어볼게요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e1. sizes는 \"얼마나 크게 이미지를 보여줄 건지\" 알려주는 역할이에요.\u003c/h3\u003e\n\u003cp\u003e브라우저는 \u003ccode\u003e\u0026#x3C;Image\u003e\u003c/code\u003e 컴포넌트에 자동으로 만들어지는 srcset(다양한 크기의 이미지 묶음)을 보고 어떤 이미지를 다운받을지 결정하는데요. 이때 sizes 속성 값이 중요한 역할을 해요.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003esizes가 없다면?\u003cbr\u003e\n기본값인 \u003ccode\u003e100vw\u003c/code\u003e(화면 가로 너비 100%)로 인식해서, \u003cstrong\u003e화면 크기만큼 큰 이미지를 다운받아요\u003c/strong\u003e.\u003cbr\u003e\n즉, 모바일 화면이라도 큰 데스크톱용 이미지를 받을 수도 있다는 뜻이죠. 낭비 그 자체...!\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003esizes가 있으면?\u003cbr\u003e\n화면 크기나 레이아웃에 맞는 이미지를 미리 알려서, 그에 적합한 크기의 이미지를 똑똑하게 골라 다운받을 수 있어요.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003e2. sizes는 srcset을 어떻게 만들어내느냐에도 영향을 줘요.\u003c/h3\u003e\n\u003cp\u003e자동 생성되는 srcset이 크게 두 가지로 나뉘는데요.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003esizes가 없을 때는, 고정 크기 이미지용으로 작은 srcset이 만들어져요 (예: 1x, 2x...)\u003c/li\u003e\n\u003cli\u003esizes가 있으면, 반응형 이미지를 위한 큰 srcset이 생성돼요(예: 640w, 750w 같은 픽셀 너비 단위)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e특히 sizes에 \u003ccode\u003e50vw\u003c/code\u003e처럼 뷰포트의 % 단위가 들어가면, 불필요하게 작은 이미지 옵션들이 걸러져서 srcset이 간결해지고, 진짜 필요한 이미지들만 주로 다운받게 되죠.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e실제 사례로 살펴볼게요!\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/image'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"grid-element\"\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eImage\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003efill\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"/example.png\"\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003esizes\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw\"\u003c/span\u003e\n      /\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e화면이 최대 768px이면? 이미지가 화면 최대 너비(\u003ccode\u003e100vw\u003c/code\u003e)로 보여져요 - 주로 모바일용\u003c/li\u003e\n\u003cli\u003e768px 초과, 1200px 이하 화면이면? 이미지가 화면 너비의 절반(\u003ccode\u003e50vw\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e1200px 초과면? 이미지가 화면 너비의 33%(\u003ccode\u003e33vw\u003c/code\u003e)만 차지한다는 의미\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003esizes의 위력: 성능에 미치는 영향\u003c/h3\u003e\n\u003cp\u003e만약 \u003ccode\u003esizes\u003c/code\u003e를 위 예시처럼 적절히 지정하지 않으면, 특히 데스크톱에서 \u003cstrong\u003e실제로 1/3 크기만 필요한 이미지를 3배 크기(가로 기준) 이미지로 다운받게 되겠죠\u003c/strong\u003e?\u003cbr\u003e\n이미지 파일 크기는 가로 * 세로이기 때문에, 파일 크기는 대략 가로 크기의 제곱에 비례해요.\u003cbr\u003e\n즉, 3배 큰 이미지를 받으면, 용량은 9배가 될 수 있다는 말입니다!\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e정리!\u003c/h3\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e포인트\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003esizes의 역할\u003c/td\u003e\u003ctd\u003e이미지가 실제로 렌더링될 크기를 브라우저에 알려서 적합한 이미지 선택 유도\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003esizes 없을 때\u003c/td\u003e\u003ctd\u003e기본 \u003ccode\u003e100vw\u003c/code\u003e로 간주, 무조건 화면 가로폭만큼 큰 이미지 다운\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003esizes가 있으면\u003c/td\u003e\u003ctd\u003e반응형 srcset 선택 가능, 불필요한 큰 이미지 다운로드 억제\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e권장 활용\u003c/td\u003e\u003ctd\u003e뷰포트 크기별 예상 이미지 크기를 sizes에 정의해두기\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003ch3\u003e추가 팁!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003efill\u003c/code\u003e 속성을 사용할 때는 특히 sizes 설정 꼭 해주세요.\u003cbr\u003e\n그 이유는 fill일 때 이미지가 부모 요소에 맞춰 꽉 채워지는데, sizes가 없으면 무조건 화면 가로 크기로 판단하기 때문이에요.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e복잡한 레이아웃 환경이라면, media query 같은 복수 조건으로 sizes를 꼭 세분화해서 지정하는 습관을!\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e이처럼 sizes가 제한적으로 보이지만, 성능 최적화에 있어선 꽤나 강력한 역할을 해요.\u003cbr\u003e\n앞으로 next/image 쓸 때는 \u003cstrong\u003esizes 설정 잊지 말고 성능도 챙기는 스마트한 개발자\u003c/strong\u003e가 되어봅시다!\u003cbr\u003e\n궁금한 점 있으면 댓글로 알려주세요~\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003esrcset과 sizes 속성에 대해 조금 더 재미있게 파헤쳐보도록 할게요!\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003esrcset과 sizes: 이미지 최적화를 위한 든든한 친구들\u003c/h2\u003e\n\u003cp\u003e웹에서 이미지가 너무 크거나 작게 나오면 사용자 경험이 떨어지잖아요? 그래서 요즘은 반응형 이미지를 쉽게 구현할 수 있도록 srcset과 sizes라는 속성을 많이 사용해요.\u003c/p\u003e\n\u003ch3\u003esrcset이란?\u003c/h3\u003e\n\u003cp\u003e이미지를 다양한 크기로 준비해두고, 브라우저가 화면 크기나 해상도에 맞게 적절한 이미지를 골라서 보여주도록 해주는 역할이에요.\u003c/p\u003e\n\u003cp\u003e예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-html\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \n  \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"small.jpg\"\u003c/span\u003e \n  \u003cspan class=\"hljs-attr\"\u003esrcset\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"small.jpg 500w, medium.jpg 1000w, large.jpg 1500w\"\u003c/span\u003e \n  \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"예쁜 고양이\"\u003c/span\u003e \n/\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위에서 500w, 1000w, 1500w는 각각 이미지의 가로 너비(pixel) 크기를 의미해요. 브라우저가 화면에 맞게 적절한 이미지를 골라서 내려받겠죠.\u003c/p\u003e\n\u003ch3\u003esizes란?\u003c/h3\u003e\n\u003cp\u003esizes는 브라우저에게 \"내 이미지는 이렇게 크기로 보여질 거야\"라고 미리 알려주는 역할을 해요. 예를 들어, 내가 이미지가 보통 뷰포트의 50% 정도 차지한다면 그에 맞게 알려주면 크기를 더 정확하게 고를 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-html\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"small.jpg\"\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003esrcset\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"small.jpg 500w, medium.jpg 1000w, large.jpg 1500w\"\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003esizes\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"(max-width: 600px) 100vw, 50vw\"\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"예쁜 강아지\"\u003c/span\u003e\n/\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e(max-width: 600px) 100vw\u003c/code\u003e: 뷰포트가 600px 이하일 때는 이미지가 화면 너비 전체(100vw)를 차지한다는 뜻이에요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e50vw\u003c/code\u003e: 그 외에는 화면 너비의 50%만 쓰인다는 뜻이에요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003equality 속성도 알아두자!\u003c/h3\u003e\n\u003cp\u003e위에서 언급된 quality는 이미지 처리 라이브러리(예: Next.js 이미지 컴포넌트)에서 이미지를 압축할 때 몇 퍼센트 품질로 줄일 건지를 나타내요. 1\u003cdel\u003e100까지 숫자를 받는데, 너무 낮으면 이미지가 뭉개지고, 너무 높으면 용량도 커져서 로딩이 느려져요. 보통 70\u003c/del\u003e80 수준에서 적절히 타협하는 편입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003equality={\u003cspan class=\"hljs-number\"\u003e75\u003c/span\u003e} \u003cspan class=\"hljs-comment\"\u003e// 적당한 화질과 용량의 밸런스를 잡을 수 있어요\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003e참고하면 좋은 사이트\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://web.dev/learn/design/responsive-images/\" rel=\"nofollow\" target=\"_blank\"\u003eweb.dev의 srcset 설명\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images\" rel=\"nofollow\" target=\"_blank\"\u003eMDN 이미지 반응형 가이드\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e이제부터 이미지 태그 예쁘게 짜서 웹사이트 속도도 챙기고 사용자 경험도 쏙쏙 높여보아요!\u003cbr\u003e\n궁금한 점 있으면 언제든 댓글로 물어봐 주세요~\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이미지 최적화에서 quality(품질) 값은 1부터 100 사이의 정수로 설정할 수 있는데요, 100이 가장 높은 품질이자 가장 큰 파일 크기를 의미합니다. 기본값은 75로 설정되어 있어요.\u003c/p\u003e\n\u003cp\u003e만약 next.config.js 파일에서 qualities 설정을 따로 정의해뒀다면, quality 속성 값은 그 중 하나와 꼭 일치해야 한다는 점 기억하세요.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e참고할 내용: 원본 이미지가 이미 저품질이라면, quality 값을 너무 높게 설정할 경우 최적화된 이미지가 오히려 원본 파일보다 용량이 더 커질 수 있으니 주의가 필요합니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch3\u003epriority (우선순위)\u003c/h3\u003e\n\u003cp\u003e여기서 priority는 Next.js에서 이미지 로딩 시, 어느 이미지를 더 빨리 불러올지 우선순위를 정하는 속성입니다. 예를 들어, 페이지 상단에 보이는 히어로 이미지 같은 경우 priority를 true로 설정하면, 브라우저가 페이지 렌더링 시 해당 이미지를 더 빨리 불러오게 됩니다.\u003c/p\u003e\n\u003cp\u003e속성을 간단히 정리하면:\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e속성명\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003epriority\u003c/td\u003e\u003ctd\u003etrue로 설정하면 해당 이미지에 우선순위를 줘 빠르게 로드\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e적절하게 priority를 설정하면 사용자 경험이 한층 더 좋아질 수 있으니, 중요한 이미지는 꼭 체크해보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epriority={\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e} \u003cspan class=\"hljs-comment\"\u003e// {false} | {true}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 옵션이 \u003ccode\u003etrue\u003c/code\u003e일 때, Next.js는 해당 이미지를 미리(preload) 불러옵니다. 즉, 이미지가 더 빨리 로드되도록 하는 기능이죠. \u003cstrong\u003e중요한 점은, priority가 true일 경우 lazy loading(지연 로딩)이 자동으로 비활성화된다는 것\u003c/strong\u003e입니다. 만약 \u003ccode\u003eloading\u003c/code\u003e 속성을 사용하면서 \u003ccode\u003elazy\u003c/code\u003e로 설정하면 \u003ccode\u003epriority\u003c/code\u003e와 함께 쓸 수 없어요. 그래서 priority가 필요한 이미지에서는 \u003ccode\u003eloading\u003c/code\u003e 속성을 제거하는 게 좋습니다.\u003c/p\u003e\n\u003cp\u003e이 속성은 \u003cstrong\u003eLargest Contentful Paint(LCP)\u003c/strong\u003e 요소로 감지되는 이미지에 주로 사용해야 합니다. LCP란 페이지 로드 시 사용자에게 가장 크게 보이는 콘텐츠를 의미하는데, 이미지가 이 역할을 한다면 빠르게 불러오는 것이 UX 개선에 도움이 되거든요.\u003c/p\u003e\n\u003cp\u003e뷰포트 크기에 따라 LCP 요소가 달라질 수 있어서, 여러 개의 이미지를 priority로 설정하는 것도 괜찮습니다. 다만, 이 속성은 화면 상단(above the fold)에 보이는 이미지에만 사용하는 게 효과적입니다. 기본값은 \u003ccode\u003efalse\u003c/code\u003e로 설정돼 있어요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e추가 팁!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003epriority 이미지가 너무 많으면 어떻게 될까요?\u003c/strong\u003e\u003cbr\u003e\n너무 많은 이미지를 미리 불러오면 네트워크에 부담이 갈 수 있으니, 정말 필요한 이미지만 우선순위를 주는 게 좋아요.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eNext.js의 \u003ccode\u003eImage\u003c/code\u003e 컴포넌트와 함께 사용\u003c/strong\u003e\u003cbr\u003e\nNext.js의 \u003ccode\u003e\u0026#x3C;Image /\u003e\u003c/code\u003e 컴포넌트에서 이 옵션을 쓰면 자동으로 적절한 최적화도 같이 해줘서, 별도로 신경 쓰지 않아도 됩니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eLCP 개선은 SEO에도 좋아요!\u003c/strong\u003e\u003cbr\u003e\n페이지 로딩 속도와 사용자 경험 개선은 검색 엔진 최적화(SEO)에도 긍정적인 영향을 주니, 중요한 이미지에는 꼭 priority를 고려해보세요.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e우리 웹 페이지가 빠르게 렌더링되고, 사용자들이 이미지 때문에 답답해하지 않게 하는 작은 팁 하나였어요! 다음 번에도 더 유용한 개발 꿀팁 가지고 올게요 :)\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003eplaceholder\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eplaceholder = \u003cspan class=\"hljs-string\"\u003e'empty'\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// \"empty\" | \"blur\" | \"data:image/...\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이미지가 로딩되는 동안 보여줄 자리 표시자(플레이스홀더)를 설정하는 속성입니다. 사용할 수 있는 값은 \u003ccode\u003e'empty'\u003c/code\u003e, \u003ccode\u003e'blur'\u003c/code\u003e, 또는 \u003ccode\u003e'data:image/...'\u003c/code\u003e 형태입니다. 기본값은 \u003ccode\u003e'empty'\u003c/code\u003e입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e'empty'\u003c/code\u003e: 아무 것도 표시하지 않고 그냥 빈 공간으로 둡니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e'blur'\u003c/code\u003e: 이미지가 로딩되는 동안 블러 처리된 저해상도 이미지를 보여줍니다. 이때 \u003ccode\u003eblurDataURL\u003c/code\u003e 속성에 지정된 데이터 URL이 플레이스홀더로 사용돼요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e'data:image/...'\u003c/code\u003e: 직접 데이터 URL 형태의 이미지를 넣어서 커스텀 플레이스홀더를 설정할 수도 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e특히, \u003ccode\u003eblur\u003c/code\u003e 옵션은 정적 임포트(static import)로 불러온 \u003ccode\u003e.jpg\u003c/code\u003e, \u003ccode\u003e.png\u003c/code\u003e, \u003ccode\u003e.webp\u003c/code\u003e, \u003ccode\u003e.avif\u003c/code\u003e 같은 이미지 포맷의 경우 자동으로 \u003ccode\u003eblurDataURL\u003c/code\u003e이 채워지는데, 만약 애니메이션 이미지라면 이 기능이 적용되지 않습니다.\u003c/p\u003e\n\u003cp\u003e이 기능 덕분에 이미지가 화면에 깜빡이거나 완전히 로드될 때까지 기다리지 않고, 자연스러운 흐릿한 미리보기를 보여줘서 UX가 훨씬 부드러워진답니다. 요즘 웹사이트에서 흔히 볼 수 있는 '더 좋은 사용자 경험'을 위한 작은 팁이죠!\u003c/p\u003e\n\u003cp\u003e추가로, \u003cstrong\u003eblurDataURL\u003c/strong\u003e은 보통 아주 작은 크기의 저해상도 이미지 정보를 base64로 인코딩한 문자열을 의미해요. 직접 생성하기 번거롭다면 자동 생성 도구나 라이브러리를 활용하는 것도 방법입니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e동적 이미지(dynamic images)를 사용할 때는 반드시 \u003ccode\u003eblurDataURL\u003c/code\u003e 속성을 제공해줘야 해요. 이 속성은 이미지가 로딩되는 동안 보여줄 흐릿한(blurred) 이미지 데이터를 뜻하는데요, 이걸 넣어주면 사용자가 이미지가 완전히 로딩될 때까지 깜빡임 없이 부드러운 경험을 할 수 있답니다.\u003c/p\u003e\n\u003cp\u003e그런데 이 \u003ccode\u003eblurDataURL\u003c/code\u003e 값을 직접 만들기 번거로울 수 있죠? 그래서 Plaiceholder 같은 솔루션이 인기를 끌고 있어요. Plaiceholder는 이미지를 자동으로 Base64 포맷으로 변환해서 흐릿한 이미지로 만들어주니까, 요긴하게 쓸 수 있어요.\u003c/p\u003e\n\u003cp\u003e그리고 만약 이미지 URL이 \u003ccode\u003edata:image/...\u003c/code\u003e 형식이라면, 이 데이터 URL이 그대로 로딩 중인 플레이스홀더(placeholder)로 사용돼요. 반면에 \u003ccode\u003eblurDataURL\u003c/code\u003e을 비워두면 로딩 중에 아무 것도 보이지 않고 빈 공간만 남게 되니 주의해야 해요.\u003c/p\u003e\n\u003cp\u003e쉽게 말해 이런 느낌이에요:\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e\u003ccode\u003eblurDataURL\u003c/code\u003e 상태\u003c/th\u003e\u003cth\u003e결과\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e값이 세팅된 경우\u003c/td\u003e\u003ctd\u003e로딩 중 흐릿한 이미지 표시\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003edata:image/...\u003c/code\u003e 포맷\u003c/td\u003e\u003ctd\u003e해당 데이터가 로딩 플레이스홀더로 사용됨\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e비워둔 경우(빈값)\u003c/td\u003e\u003ctd\u003e로딩 중 빈 공간\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e직접 써보면서 확인해보세요. 이미지의 로딩 경험이 훨씬 부드러워질 거예요! 혹시 더 자세한 설정 방법이나 Plaiceholder 사용법이 궁금하면 알려주세요~\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e블러(blur) 플레이스홀더 데모\u003c/li\u003e\n\u003cli\u003e데이터 URL을 이용한 플레이스홀더 프로퍼티로 쉐이머(shimmer) 효과 데모\u003c/li\u003e\n\u003cli\u003eblurDataURL 프로퍼티를 활용한 컬러 효과 데모\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e고급 속성 사용법\u003c/h2\u003e\n\u003cp\u003e때로는 더 복잡한 사용이 필요할 때가 있죠. \u003ccode\u003eImage /\u003c/code\u003e 컴포넌트는 선택적으로 아래와 같은 고급 속성들을 받을 수 있습니다.\u003c/p\u003e\n\u003ch3\u003estyle (스타일)\u003c/h3\u003e\n\u003cp\u003e여기서 스타일을 지정해서 이미지에 다양한 시각적 효과를 줄 수 있어요. 예를 들어, 이미지 모서리를 둥글게 하거나, 그림자를 넣는 등 CSS를 직접 적용할 수 있답니다.\u003c/p\u003e\n\u003cp\u003e이런 고급 props들을 잘 활용하면 더 세련되고 사용자 친화적인 이미지 로딩 경험을 만들 수 있어요!\u003c/p\u003e\n\u003cp\u003e필요하면 다음에 \u003ccode\u003eblurDataURL\u003c/code\u003e이나 쉐이머 효과 만들 때 사용하는 데이터 URL 생성 방법도 같이 소개할게요.\u003cbr\u003e\n편하게 알려드릴 테니 기대해 주세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이미지에 CSS 스타일을 직접 전달할 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e imageStyle = {\n  \u003cspan class=\"hljs-attr\"\u003eborderRadius\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'50%'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eborder\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'1px solid #fff'\u003c/span\u003e,\n}\n \n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eProfileImage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eImage\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{imageStyle}\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 중요한 점! 이미지의 \u003ccode\u003ewidth\u003c/code\u003e와 \u003ccode\u003eheight\u003c/code\u003e 속성은 스타일링에 영향을 줄 수 있어요. 만약 CSS 스타일로 이미지의 너비를 조절한다면, 높이는 \u003ccode\u003eauto\u003c/code\u003e로 설정해줘야 원래 비율을 유지할 수 있습니다. 안 그러면 이미지가 찌그러져 보일 수 있거든요.\u003c/p\u003e\n\u003cp\u003e예를 들면 이렇게 하면 좋아요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e imageStyle = {\n  \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'100px'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'auto'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eborderRadius\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'50%'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eborder\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'1px solid #fff'\u003c/span\u003e,\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 너비는 100px로 고정하고, 높이는 자동으로 조절되어 이미지 비율이 깨지지 않죠.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003eonLoadingComplete\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eonLoadingComplete\u003c/code\u003e는 이미지가 모두 로드된 후에 실행되는 콜백 함수입니다. 이미지 처리나 로딩 상태 관리를 할 때 유용해요.\u003c/p\u003e\n\u003cp\u003e예를 들어, 이미지가 로드 완료되면 어떤 작업을 하고 싶을 때 이렇게 쓸 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eProfileImage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandleLoadingComplete\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'이미지가 성공적으로 로드되었습니다!'\u003c/span\u003e);\n    \u003cspan class=\"hljs-comment\"\u003e// 여기서 로딩 스피너 숨기기 등 다른 작업을 할 수 있겠죠\u003c/span\u003e\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eImage\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonLoadingComplete\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{handleLoadingComplete}\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 콜백 함수를 활용해서 사용자 경험을 좀 더 부드럽게 만들 수 있어요. 예를 들어 이미지가 로드 중일 때 스피너를 표시하고, 완료되면 스피너를 숨기는 식으로요.\u003c/p\u003e\n\u003cp\u003e이 부분도 꼭 기억해두세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e안녕하세요, 여러분! 오늘은 Next.js 14에서 Image 컴포넌트의 새로운 변화에 대해 짧게 이야기해보려고 해요.\u003c/p\u003e\n\u003cp\u003e기존에 아래처럼 \u003ccode\u003eonLoadingComplete\u003c/code\u003e를 썼던 분들 많으시죠?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e'use client'\u003c/span\u003e\n\n\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e onLoadingComplete={\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eimg\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(img.\u003cspan class=\"hljs-property\"\u003enaturalWidth\u003c/span\u003e)} /\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런데 Next.js 14부터는 이 \u003ccode\u003eonLoadingComplete\u003c/code\u003e가 deprecated(더 이상 권장되지 않음) 되었어요. 대신 \u003ccode\u003eonLoad\u003c/code\u003e라는 새로운 콜백 함수가 도입됐답니다.\u003c/p\u003e\n\u003ch3\u003e그럼 뭐가 달라졌을까요?\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eonLoad\u003c/code\u003e\u003c/strong\u003e 콜백은 이미지가 완전히 로드되고, 플레이스홀더(placeholder)가 제거된 후에 호출돼요.\u003c/li\u003e\n\u003cli\u003e이 함수는 실제 \u003ccode\u003e\u0026#x3C;img\u003e\u003c/code\u003e 요소를 인자로 받아요. 그래서 이미지의 크기 정보나 기타 속성을 쉽게 가져올 수 있죠.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e바뀐 사용법은 이렇게!\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e'use client'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/image'\u003c/span\u003e;\n\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eImage\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"/example.jpg\"\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{500}\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{300}\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eonLoad\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{(img)\u003c/span\u003e =\u003e\u003c/span\u003e console.log('Image width:', img.naturalWidth)}\n/\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e참고!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eonLoad\u003c/code\u003e 안에서 받는 인자는 실제 HTML의 \u003ccode\u003e\u0026#x3C;img\u003e\u003c/code\u003e 엘리먼트이므로, \u003ccode\u003enaturalWidth\u003c/code\u003e, \u003ccode\u003enaturalHeight\u003c/code\u003e, \u003ccode\u003ecurrentSrc\u003c/code\u003e 같은 DOM 속성에 접근 가능해요.\u003c/li\u003e\n\u003cli\u003e이전과 달리 \u003ccode\u003eonLoadingComplete\u003c/code\u003e는 더 이상 공식 문서에서 지원하지 않으니, 꼭 \u003ccode\u003eonLoad\u003c/code\u003e로 바꾸시는 걸 추천드려요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e사실 이런 변화는 Next.js가 내부에서 이미지 로딩 과정을 더 효율적이고 통제하기 쉽게 만들기 위한 거라 생각하면 좋아요. 새로운 버전 나오면 공식 문서 체크와 함께 이렇게 바뀐 부분도 챙겨주면 프로젝트 유지보수가 훨씬 편하답니다.\u003c/p\u003e\n\u003cp\u003e혹시 이미지 로딩과 관련해서 더 궁금한 점 있으면 댓글로 알려주세요! 그럼 즐거운 개발 되세요~ 😊\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cblockquote\u003e\n\u003cp\u003e참고할 점: onLoadingComplete 같은 함수 형태의 props를 사용할 때는, 전달한 함수를 직렬화하기 위해 클라이언트 컴포넌트를 사용해야 한다는 점을 기억하세요.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3\u003eonLoad\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e onLoad={\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ee\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(e.\u003cspan class=\"hljs-property\"\u003etarget\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003enaturalWidth\u003c/span\u003e)} /\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이미지가 완전히 로드되고 플레이스홀더가 사라진 후에 실행되는 콜백 함수입니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e여기에 덧붙여서, onLoad 이벤트는 이미지가 화면에 렌더링 되는 순간을 알 수 있어서, 예를 들어 이미지 크기에 따라 레이아웃을 조절하거나 로딩 상태를 업데이트 하는 데 쓸 수 있어요. 또한, 네트워크 상황이 느릴 때 사용자에게 로딩 완료 시점을 알려주는 용도로도 활용할 수 있답니다.\u003c/p\u003e\n\u003cp\u003e하지만 Next.js의 Image 컴포넌트를 사용할 때는 내장된 최적화 특징 때문에, \"onLoadingComplete\"라는 비슷한 이벤트도 함께 제공되니 필요에 따라 적절히 선택해서 사용하세요.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e콜백 함수는 이벤트 객체 하나를 인자로 받게 되는데, 여기서 이벤트의 \u003ccode\u003etarget\u003c/code\u003e은 실제로 렌더된 \u003ccode\u003eimg\u003c/code\u003e 요소를 가리키게 돼요.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e참고할 점: onLoad처럼 함수 형태의 prop을 사용할 때는, 이 함수를 직렬화하기 위해 클라이언트 컴포넌트(Client Components)를 사용해야 해요.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3\u003eonError\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e onError={\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ee\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(e.\u003cspan class=\"hljs-property\"\u003etarget\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e)} /\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eonError\u003c/code\u003e는 이미지 로드에 문제가 생겼을 때 호출되는 콜백 함수예요. 예를 들면, 이미지 URL이 잘못됐거나 서버에서 이미지를 불러올 수 없을 때 이 함수가 실행되죠. 위 코드에서는 에러가 발생한 이미지 엘리먼트의 id 값을 콘솔에 출력하고 있네요.\u003c/p\u003e\n\u003cp\u003e참고로, 이런 이벤트 핸들러를 사용할 땐 해당 컴포넌트가 클라이언트에서 동작하도록 설정돼 있어야 한다는 점 기억하세요. 특히 Next.js 같은 프레임워크에서는 서버 컴포넌트와 클라이언트 컴포넌트가 구분되어 있어서, 함수가 전달되는 이벤트 핸들러는 클라이언트 컴포넌트에서만 제대로 동작합니다.\u003c/p\u003e\n\u003cp\u003e혹시 이미지 로드 실패 시 사용자에게 다른 이미지를 보여주거나, 오류 메시지를 띄우고 싶다면 \u003ccode\u003eonError\u003c/code\u003e 안에서 상태를 변경하거나 별도의 로직을 구현하면 돼요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이미지 로딩에 실패했을 때 호출되는 콜백 함수에 대해 이야기해볼게요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003eonError\u003c/h3\u003e\n\u003cp\u003e이미지 로딩 중 문제가 발생하면 실행되는 함수예요. 예를 들어, 이미지 URL이 잘못되었거나, 서버에 이미지가 없을 때 호출할 수 있죠.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e참고로 알아두면 좋은 점!\u003cbr\u003e\n\u003ccode\u003eonError\u003c/code\u003e 같은 콜백 함수를 프로퍼티로 넘기려면, 이 함수를 직렬화(serialization)할 수 있는 \u003cstrong\u003e클라이언트 컴포넌트(Client Components)\u003c/strong\u003e 안에서 사용해야 해요. 즉, 서버 컴포넌트에서 바로 함수 형태로 넘기면 동작하지 않을 수 있다는 뜻입니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch3\u003eloading 속성\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eloading = \u003cspan class=\"hljs-string\"\u003e'lazy'\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// 'lazy' 또는 'eager' 중 선택 가능\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elazy\u003c/code\u003e (지연 로딩): 이미지를 사용자가 실제로 볼 때까지 미뤄서 로딩해요. 페이지 초기 로딩 속도 향상에 도움을 줍니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eeager\u003c/code\u003e (즉시 로딩): 페이지가 로드될 때 이미지를 바로 불러와요. 빠른 렌더링이 필요할 때 쓰면 좋아요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e요즘 웹에서는 지연 로딩이 기본 트렌드인데요, 특히 이미지를 많이 쓰는 페이지는 \u003ccode\u003eloading='lazy'\u003c/code\u003e를 적용하는 게 퍼포먼스 향상에 크게 이바지한답니다.\u003c/p\u003e\n\u003cp\u003e간단한 예제도 같이 볼까요?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useState } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eImageWithFallback\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ src, alt }\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [error, setError] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003e\u003c/span\u003e\n      {!error ? (\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{src}\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{alt}\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eloading\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"lazy\"\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eonError\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{()\u003c/span\u003e =\u003e\u003c/span\u003e setError(true)}\n        /\u003e\n      ) : (\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e이미지를 불러올 수 없습니다.\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      )}\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 이미지가 실패할 때 텍스트로 대체 표시도 할 수 있죠.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e필요에 따라서 \u003ccode\u003eonError\u003c/code\u003e를 활용해 이미지 교체, 오류 기록, 사용자 알림 등 다양한 작업을 할 수 있으니 기억해두세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이미지 로딩 동작에 대해 이야기해볼게요. 기본값은 \u003ccode\u003elazy\u003c/code\u003e인데요, 쉽게 말해 이미지는 화면에 보이기 직전에야 로드되도록 지연시켜서 페이지 로딩 속도를 높여주는 거예요.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elazy\u003c/code\u003e: 이미지가 화면에 가까워질 때까지 로딩을 미뤄요. 예를 들어, 사용자가 스크롤을 내려서 이미지가 보일 타이밍에 이미지를 불러오는 방식이죠. 데이터 소모도 줄이고 페이지가 훨씬 빨리 뜹니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eeager\u003c/code\u003e: 이미지가 페이지가 로드될 때 바로 불러와요. 중요한 이미지나 빠르게 보여줘야 할 때 유용하답니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 \u003ccode\u003eloading\u003c/code\u003e 속성 덕분에 개발자들이 웹사이트 성능을 최적화하기가 한결 쉬워졌어요. 자세한 내용을 더 보고 싶다면 \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#loading\" rel=\"nofollow\" target=\"_blank\"\u003eloading attribute에 대해 알아보기\u003c/a\u003e에서 확인할 수 있어요.\u003c/p\u003e\n\u003cp\u003e참고로, \u003ccode\u003elazy\u003c/code\u003e 로딩은 모든 브라우저가 지원하는 건 아니라서 필요에 따라 자바스크립트로 폴리필을 적용하는 경우도 있어요. 또한, 이미지가 중요한 정보라면 \u003ccode\u003eeager\u003c/code\u003e를 선택하는 게 사용자 경험에 더 좋을 수 있으니 상황에 맞게 잘 활용해보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003eblurDataURL\u003c/h3\u003e\n\u003cp\u003eblurDataURL은 이미지가 로드되기 전에 임시로 보여줄 작은 이미지를 Base64 형태로 지정할 때 사용해요. 쉽게 말해서, 실제 이미지가 로딩되기 전 잠깐 나타나는 ‘흐릿한 미리보기’ 같은 역할이죠.\u003c/p\u003e\n\u003cp\u003e주의할 점은 이 값이 반영되려면 꼭 placeholder=\"blur\"와 함께 써야 한다는 거예요!\u003c/p\u003e\n\u003cp\u003e또, blurDataURL에 넣는 이미지는 아주 작고 간단한 게 좋아요. 보통 10px 이하 크기의 이미지가 적당한데요, 그 이유는 이 이미지가 화면에 확대되고 흐려지면서 보여지기 때문이에요. 너무 큰 이미지를 넣으면 앱 성능에 안 좋을 수 있거든요.\u003c/p\u003e\n\u003cp\u003e예를 들어 마크다운으로 표현하면 이렇게 써볼 수 있어요:\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e속성명\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eblurDataURL\u003c/td\u003e\u003ctd\u003e로드 전에 쓰이는 미리보기 이미지의 Base64 인코딩 데이터\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eplaceholder\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e'blur'\u003c/code\u003e으로 설정해서 blurDataURL과 함께 사용해야 효과를 볼 수 있음\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e이걸 활용하면 사용자 경험이 조금 더 매끄러워져서, 이미지가 늦게 뜰 때도 갑자기 빈 화면이 나오는 걸 방지할 수 있어요. 웹이나 앱에서 이미지가 무거워 딜레이가 있을 때 정말 유용하답니다.\u003c/p\u003e\n\u003cp\u003e직접 써보는 것도 추천해요! 예를 들어, Next.js의 Image 컴포넌트에서 자주 쓰이는 기능이라, 관심 있으면 찾아보시면 도움이 많이 될 겁니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e기본 blurDataURL prop 사용법 데모\u003c/li\u003e\n\u003cli\u003eblurDataURL prop를 이용한 색상 효과 데모\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이미지와 어울리는 단색 색상 Data URL도 생성할 수 있어요.\u003c/p\u003e\n\u003ch3\u003eunoptimized 옵션\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eunoptimized = {\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e} \u003cspan class=\"hljs-comment\"\u003e// false 또는 true 값 사용 가능\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003cp\u003e조금 더 설명을 덧붙이자면, \u003ccode\u003eblurDataURL\u003c/code\u003e은 이미지가 로딩되기 전까지 잠깐 보여줄 작은 저해상도 이미지의 URL이에요. 흔히 ‘로딩 플레이스홀더’로 활용하죠. 특히 네트워크 속도가 느릴 때 사용자에게 부드러운 경험을 선사할 수 있어요.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eunoptimized\u003c/code\u003e 옵션은 Next.js에서 이미지 최적화를 끌지 말지를 결정하는 건데요. 기본값은 \u003ccode\u003efalse\u003c/code\u003e로 최적화 기능을 켜둔 상태고, \u003ccode\u003etrue\u003c/code\u003e로 설정하면 최적화를 끄고 원본 이미지를 그대로 사용하게 돼요. 개발 과정에서 최적화 문제를 피하거나 특정 상황에서 이미지를 그대로 사용하고 싶을 때 유용합니다.\u003c/p\u003e\n\u003cp\u003e그리고 색상 효과를 내는 blurDataURL도 많이 활용되는데요, 실제 이미지와 비슷한 톤의 단색을 blurDataURL로 만들어 놓으면 로딩 시 배경색처럼 자연스럽게 보일 수 있어요. 이 방법은 이미지가 로딩되는 동안 사용자 시각 경험을 더 좋게 만들어주니까 개발할 때 한 번쯤 적용해 보는 걸 추천드려요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e원본 이미지를 \u003ccode\u003esrc\u003c/code\u003e에서 그대로 내보내고 싶을 때, 즉 퀄리티나 크기, 포맷을 변경하지 않을 때는 \u003ccode\u003eunoptimized\u003c/code\u003e 속성을 \u003ccode\u003etrue\u003c/code\u003e로 설정하면 됩니다. 기본값은 \u003ccode\u003efalse\u003c/code\u003e입니다.\u003c/p\u003e\n\u003cp\u003e이렇게 하는 게 특히 좋은 경우는 최적화를 해도 큰 이점이 없는 이미지들이에요. 예를 들어, 아주 작은 이미지(1KB 이하), 벡터 이미지(SVG), 또는 움직이는 이미지(GIF) 등이 그 예입니다.\u003c/p\u003e\n\u003cp\u003e아래는 간단한 사용 예시입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/image'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eUnoptimizedImage\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003eprops\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eImage\u003c/span\u003e {\u003cspan class=\"hljs-attr\"\u003e...props\u003c/span\u003e} \u003cspan class=\"hljs-attr\"\u003eunoptimized\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 Next.js 12.3.0부터는 모든 이미지에 대해 \u003ccode\u003eunoptimized\u003c/code\u003e 옵션을 기본으로 적용하려면 \u003ccode\u003enext.config.js\u003c/code\u003e 파일에 다음과 같은 설정을 추가하면 됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// next.config.js\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eimages\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003eunoptimized\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 설정하면 개별 이미지마다 \u003ccode\u003eunoptimized\u003c/code\u003e 속성을 일일이 지정하지 않아도 되니 관리가 훨씬 편해져요.\u003c/p\u003e\n\u003cp\u003e추가로, 최적화를 비활성화하면 이미지가 CDN이나 외부 최적화 서비스 없이 그대로 제공되므로, 속도나 용량 활용 측면에서 체크가 필요합니다. 그래서 보통은 작은 이미지나 이미 최적화된 SVG, GIF에만 적용하는 것을 추천드려요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e여러분, Next.js에서 이미지 최적화 관련 설정해보셨나요? 오늘은 간단하게 \u003ccode\u003enext.config.js\u003c/code\u003e에서 이미지 최적화를 비활성화하는 법과, \u003ccode\u003eImage\u003c/code\u003e 컴포넌트에 \u003ccode\u003esrc\u003c/code\u003e를 넘겨줄 때 어떤 일이 일어나는지 살펴보겠습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e이미지 최적화 끄기\u003c/h3\u003e\n\u003cp\u003eNext.js는 기본적으로 이미지 최적화를 자동으로 해주는데요, 가끔은 직접 최적화하지 않고 원본 이미지를 그대로 쓰고 싶을 때가 있죠. 그럴 때 \u003ccode\u003enext.config.js\u003c/code\u003e 파일에 이렇게 설정하면 됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eimages\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003eunoptimized\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 Next.js가 이미지 최적화를 건너뛰고, 여러분이 지정한 이미지가 그대로 사용돼요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003ccode\u003eImage\u003c/code\u003e 컴포넌트의 \u003ccode\u003esrc\u003c/code\u003e 프로퍼티\u003c/h3\u003e\n\u003cp\u003e그리고 \u003ccode\u003eImage\u003c/code\u003e 컴포넌트에 \u003ccode\u003esrc\u003c/code\u003e 값을 넘기면, 내부적으로 \u003ccode\u003esrcset\u003c/code\u003e 과 \u003ccode\u003esrc\u003c/code\u003e 속성이 자동으로 생성돼서 결국 HTML의 \u003ccode\u003e\u0026#x3C;img\u003e\u003c/code\u003e 태그로 변환됩니다.\u003c/p\u003e\n\u003cp\u003e예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e src=\u003cspan class=\"hljs-string\"\u003e\"/me.jpg\"\u003c/span\u003e /\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 쓰면 Next.js가 자동으로 화면 크기에 맞는 여러 해상도의 이미지 URL을 만들어서 \u003ccode\u003esrcset\u003c/code\u003e에 넣어주고, 동시에 기본 \u003ccode\u003esrc\u003c/code\u003e 도 넣어줘서 브라우저가 가장 적합한 이미지를 골라서 보여주게 하는 거죠.\u003c/p\u003e\n\u003cp\u003e이 부분이 왜 좋냐면, 반응형 이미지 처리가 훨씬 편하고, 성능도 좋아진다는 점입니다!\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e팁! 이미지 최적화 관련 기억할 점\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eunoptimized: true\u003c/code\u003e를 쓰면 캐싱이나 최적화가 없기 때문에, 프로덕션에서 할 때는 성능 저하가 있을 수 있으니 주의하세요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enext/image\u003c/code\u003e 컴포넌트를 쓸 때는 반드시 \u003ccode\u003ewidth\u003c/code\u003e와 \u003ccode\u003eheight\u003c/code\u003e를 지정하는 게 좋습니다. 그래야 레이아웃이 안정적으로 잡히고 CLS(Cumulative Layout Shift)를 줄일 수 있어요.\u003c/li\u003e\n\u003cli\u003e외부 도메인의 이미지를 쓸 때는 \u003ccode\u003enext.config.js\u003c/code\u003e에 도메인 허용 설정을 해줘야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e그리고 혹시 더 깊게 이미지 최적화를 알아보고 싶으면, \u003ccode\u003enext/image\u003c/code\u003e 공식 문서도 한번 들여다보시면 정말 많은 팁들이 숨어있답니다!\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e오늘은 여기까지! 필요할 때마다 참고하시고, 이미지 최적화도 똑똑하게 활용해 보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e안녕하세요! 오늘은 Next.js 이미지 컴포넌트(Image) 사용 시, \u003ccode\u003esrc\u003c/code\u003e 속성 자동 생성 문제와 이를 우회하는 방법에 대해 알아볼게요.\u003c/p\u003e\n\u003cp\u003e보통 \u003ccode\u003e\u0026#x3C;img\u003e\u003c/code\u003e 태그를 사용하면 이렇게 srcset과 src를 직접 지정하잖아요?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-html\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003esrcset\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"\n    /_next/image?url=%2Fme.jpg\u0026#x26;w=640\u0026#x26;q=75 1x,\n    /_next/image?url=%2Fme.jpg\u0026#x26;w=828\u0026#x26;q=75 2x\n  \"\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"/_next/image?url=%2Fme.jpg\u0026#x26;w=828\u0026#x26;q=75\"\u003c/span\u003e\n/\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e근데 Next.js의 \u003ccode\u003e\u0026#x3C;Image\u003e\u003c/code\u003e 컴포넌트를 쓰면 내부적으로 \u003ccode\u003esrc\u003c/code\u003e와 \u003ccode\u003esrcset\u003c/code\u003e을 자동으로 생성해줘요. 다 좋은데, 가끔은 이 자동 생성된 \u003ccode\u003esrc\u003c/code\u003e를 우리가 직접 지정하고 싶을 때가 있죠. 예를 들어, 기존 웹사이트를 \u003ccode\u003eimg\u003c/code\u003e에서 \u003ccode\u003eImage\u003c/code\u003e 컴포넌트로 바꿀 때, SEO 최적화를 위해 이미지 URL을 그대로 유지하고 싶을 수도 있어요. (검색엔진 최적화, 이미지 랭킹 유지 및 재크롤 방지 목적 등)\u003c/p\u003e\n\u003cp\u003e그럴 때 사용하는 게 바로 \u003ccode\u003eoverrideSrc\u003c/code\u003e prop 입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e src=\u003cspan class=\"hljs-string\"\u003e\"/me.jpg\"\u003c/span\u003e overrideSrc=\u003cspan class=\"hljs-string\"\u003e\"/override.jpg\"\u003c/span\u003e /\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 내부적으로는 \u003ccode\u003e/me.jpg\u003c/code\u003e로 이미지 최적화 및 로딩 처리를 하면서도, 실제 \u003ccode\u003esrc\u003c/code\u003e 속성은 \u003ccode\u003e/override.jpg\u003c/code\u003e로 지정할 수 있어요.\u003c/p\u003e\n\u003cp\u003e🎯 핵심 정리!\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e상황\u003c/th\u003e\u003cth\u003e해결법\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e기본적으로 자동 생성된 src 쓰기 원함\u003c/td\u003e\u003ctd\u003e그냥 \u003ccode\u003e\u0026#x3C;Image src=\"...\" /\u003e\u003c/code\u003e 사용\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSEO 등 이미지 URL을 유지해야 할 때\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e\u0026#x3C;Image src=\"...\" overrideSrc=\"...\" /\u003e\u003c/code\u003e 사용\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003cp\u003e추가 팁!\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이미지 최적화는 Next.js가 자동으로 해주지만, SEO를 위해 실제 보여지는 HTML 속성 값을 직접 관리해야 할 때가 있어서 이렇게 \u003ccode\u003eoverrideSrc\u003c/code\u003e가 유용해요.\u003c/li\u003e\n\u003cli\u003e오버라이드 한 URL이 실제 이미지가 맞는지, 접근 가능 여부는 미리 확인하는 게 좋습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eoverrideSrc\u003c/code\u003e는 Next.js 공식 문서에 나오는 기능은 아닌 경우가 많아서, 직접 구현하거나 커스텀 이미지 컴포넌트를 만들어 사용하는 방법도 있어요!\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNext.js 이미지 컴포넌트를 다룰 때 이런 작은 팁들이 개발 생산성도 올려주고, SEO 챙기는데도 크게 도움 된답니다. 다음에도 유용한 정보로 찾아올게요! 😄\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e아래 코드는 \u003ccode\u003e\u0026#x3C;img\u003e\u003c/code\u003e 태그에서 \u003ccode\u003esrcset\u003c/code\u003e과 \u003ccode\u003esrc\u003c/code\u003e 속성을 활용하는 예시입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;img\n  srcset=\u003cspan class=\"hljs-string\"\u003e\"\n    /_next/image?url=%2Fme.jpg\u0026#x26;w=640\u0026#x26;q=75 1x,\n    /_next/image?url=%2Fme.jpg\u0026#x26;w=828\u0026#x26;q=75 2x\n  \"\u003c/span\u003e\n  src=\u003cspan class=\"hljs-string\"\u003e\"/override.jpg\"\u003c/span\u003e\n/\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e간단 정리\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003esrcset\u003c/code\u003e은 브라우저가 디바이스 해상도에 맞는 이미지를 선택해서 로드할 수 있도록 도와줘요.\u003c/li\u003e\n\u003cli\u003e위 예시에서는 1배(640px)와 2배(828px) 해상도의 이미지를 준비해뒀죠.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esrc\u003c/code\u003e는 기본 이미지 URL로, \u003ccode\u003esrcset\u003c/code\u003e을 지원하지 않는 구형 브라우저에서 사용돼요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003edecoding 속성에 대해서\u003c/h3\u003e\n\u003cp\u003e브라우저에 이미지의 디코딩(화면에 보여주기 위해 이미지 데이터를 해석하는 과정)을 어떻게 처리할지 힌트를 주는 속성이에요. 기본값은 \u003ccode\u003easync\u003c/code\u003e로, 비동기적으로 디코딩해서 페이지 렌더링 속도에 도움을 줘요.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e속성값\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003esync\u003c/td\u003e\u003ctd\u003e이미지 디코딩이 끝날 때까지 렌더링을 중단해요. 주요 이미지에 적합.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003easync\u003c/td\u003e\u003ctd\u003e디코딩을 비동기 처리해요. 기본값이며, 렌더링에 지장 없어요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eauto\u003c/td\u003e\u003ctd\u003e브라우저가 최적의 전략으로 디코딩 방식을 결정해요.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e왜 \u003ccode\u003edecoding\u003c/code\u003e을 신경 써야 할까?\u003c/h3\u003e\n\u003cp\u003e이미지가 많은 페이지에서 디코딩 방식을 잘 설정하면, 페이지 렌더링이 훨씬 부드러워지고 사용자 경험이 좋아집니다. 특히 중요한 이미지나 첫 화면에 노출되는 이미지가 있다면 \u003ccode\u003esync\u003c/code\u003e로 설정해서 바로 보이게 하는 것도 방법이에요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e한 가지 팁!\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eloading=\"lazy\"\u003c/code\u003e 속성과 함께 쓰면, 이미지가 화면 근처에 올 때만 로드하고, 디코딩도 적절히 조절할 수 있어서 성능 최적화에 더 도움이 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-html\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"image.jpg\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edecoding\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"async\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eloading\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"lazy\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"example\"\u003c/span\u003e /\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003cp\u003e이렇게 이미지 관련 속성들을 적절히 이해하고 사용하면, 웹 페이지의 성능과 사용자 경험을 크게 개선할 수 있어요. 다음에도 좋은 팁으로 또 만나요! 😊\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003easync: 이미지를 비동기적으로 디코딩해서, 이미지 로딩이 완료되기 전에도 다른 콘텐츠가 먼저 렌더링될 수 있게 해줘요.\u003c/li\u003e\n\u003cli\u003esync: 이미지를 동기적으로 디코딩해서, 다른 콘텐츠와 함께 완전하게 한 번에 보여주고 싶을 때 사용해요.\u003c/li\u003e\n\u003cli\u003eauto: 디코딩 모드에 대한 특별한 선호 없이 브라우저가 가장 적절하다고 판단하는 방식을 선택하게 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e디코딩 속성(decoding attribute)에 대해 더 궁금하다면, 자세한 정보를 찾아보는 것도 좋아요. 이미지 로딩 방식에 따라 페이지 렌더링 속도나 사용자 경험이 달라질 수 있으니까요.\u003c/p\u003e\n\u003ch3\u003e다른 속성들 (Other Props)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eImage\u003c/code\u003e 컴포넌트에 넣는 다른 모든 속성들은, 특별히 제한된 몇 가지를 제외한 채로 실제 \u003ccode\u003e\u0026#x3C;img\u003e\u003c/code\u003e 태그에 그대로 전달됩니다.\u003cbr\u003e\n즉, 일반적인 \u003ccode\u003ealt\u003c/code\u003e, \u003ccode\u003ewidth\u003c/code\u003e, \u003ccode\u003eheight\u003c/code\u003e 같은 속성들은 걱정 없이 사용할 수 있죠.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e추가로 알려드리자면, 이미지 디코딩 방식은 특히 페이지가 많이 복잡하거나 이미지가 많은 경우 성능에 꽤 큰 영향을 줄 수 있어요. 예를 들어, \u003ccode\u003easync\u003c/code\u003e로 둬서 텍스트 같은 중요한 콘텐츠가 먼저 보이게 하면 사용자 경험이 더 좋아질 수 있답니다. 반면, UI가 깔끔하게 한꺼번에 보여지는 게 중요한 경우엔 \u003ccode\u003esync\u003c/code\u003e를 선택하는 게 좋고요.\u003c/p\u003e\n\u003cp\u003e꼭 상황에 맞게 선택해 주세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003esrcSet 대신 Device Sizes를 사용하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e설정 옵션\u003c/h2\u003e\n\u003cp\u003e다음은 props 외에 next.config.js 파일에서 Image 컴포넌트를 설정할 수 있는 옵션들입니다. 이 옵션들을 통해 이미지 최적화 동작을 세밀하게 조절할 수 있어요.\u003c/p\u003e\n\u003ch3\u003elocalPatterns\u003c/h3\u003e\n\u003cp\u003e(localPatterns 옵션에 대한 설명이 더 있으면 여기에 추가하면 좋겠지만, 지금은 제목만 주셨네요. 만약 이미지 경로나 패턴을 로컬 이미지 관리에 사용한다면, 이 옵션이 어떤 역할을 하는지 간단히 정리해볼게요.)\u003c/p\u003e\n\u003cp\u003elocalPatterns는 로컬 이미지 파일 경로나 패턴들을 지정하는 옵션입니다. 예를 들어, 특정 폴더 내 이미지 파일만 이미지 최적화 대상에 포함하거나 특정 형식의 파일만 처리하도록 할 때 유용하답니다. 이렇게 하면 불필요한 파일까지 빌드 과정에 포함되는 걸 막아 최적화를 더욱 깔끔하게 할 수 있어요.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e추가로 srcSet과 Device Sizes에 대해 조금 더 알려드릴게요.\u003c/p\u003e\n\u003ch3\u003esrcSet 대신 Device Sizes 사용하기\u003c/h3\u003e\n\u003cp\u003e예전에는 이미지 태그에 srcSet 속성을 직접 지정해서 여러 해상도 대응 이미지를 넘겨주곤 했는데요, Next.js Image 컴포넌트에서는 deviceSizes 배열을 통해 대응할 화면 너비별 이미지 사이즈를 미리 지정합니다. 그러면 Next.js가 자동으로 가장 적합한 이미지 크기를 골라 srcSet을 만들어서 넣어줘 개발자가 직접 일일이 srcSet을 관리할 필요가 사라지죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// next.config.js 예시\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eimages\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003edeviceSizes\u003c/span\u003e: [\u003cspan class=\"hljs-number\"\u003e320\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e420\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e768\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1024\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1200\u003c/span\u003e],\n  },\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이런 식으로 설정하면 각 기기별 스크린 크기에 맞는 이미지가 제공되어 더욱 빠르고 효율적인 이미지 로딩이 가능해져요.\u003c/p\u003e\n\u003cp\u003e어려운 설정 같아 보여도, Next.js가 알아서 다 해주니까 걱정하지 마세요. 대신 나만의 이미지 정책에 맞게 deviceSizes 같은 옵션을 적절히 조정해주면 됩니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eNext.js에서 이미지 최적화를 할 때, 특정 경로만 최적화 대상으로 지정하고 싶다면 \u003ccode\u003enext.config.js\u003c/code\u003e 파일에서 \u003ccode\u003elocalPatterns\u003c/code\u003e 옵션을 활용할 수 있어요. 이 옵션을 사용하면 내가 원하는 경로만 이미지를 최적화하고, 그 외의 경로에 대해서는 요청을 차단할 수 있답니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 아래처럼 설정하면 \u003ccode\u003e/assets/images/\u003c/code\u003e로 시작하는 로컬 이미지 경로만 최적화가 허용되고, 쿼리 스트링이 붙은 경로는 허용되지 않아요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eimages\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003elocalPatterns\u003c/span\u003e: [\n      {\n        \u003cspan class=\"hljs-attr\"\u003epathname\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/assets/images/**'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003esearch\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e,\n      },\n    ],\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e참고로, 위 설정을 적용하면 \u003ccode\u003enext/image\u003c/code\u003e 컴포넌트의 \u003ccode\u003esrc\u003c/code\u003e 속성이 \u003ccode\u003e/assets/images/\u003c/code\u003e로 시작하지 않거나 쿼리 스트링이 포함된 경우, 요청이 400 Bad Request로 처리됩니다. 따라서 불필요한 경로나 잘못된 요청을 막는 데 유용해요.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e또한, \u003ccode\u003elocalPatterns\u003c/code\u003e 외에도 \u003ccode\u003eremotePatterns\u003c/code\u003e라는 옵션도 있는데, 이것은 외부 도메인의 이미지를 최적화 대상으로 설정할 때 사용됩니다. 다음에 이어서 \u003ccode\u003eremotePatterns\u003c/code\u003e에 대해서도 알아볼게요.\u003c/p\u003e\n\u003cp\u003e이렇게 경로를 명확하게 지정해주면 보안 측면에서도 도움이 되고, 최적화 대상이 한정되니 관리도 편해지니 꼭 활용해보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eNext.js에서 외부 이미지를 사용할 때, 보안을 위해 외부 이미지에 대한 설정이 필요해요. 이렇게 해야 악의적인 사용자가 다른 도메인의 이미지를 마음대로 불러오는 걸 막을 수 있답니다.\u003c/p\u003e\n\u003cp\u003eNext.js는 외부 이미지를 Next.js Image Optimization API를 통해 제공하는데, 이때 \u003ccode\u003eremotePatterns\u003c/code\u003e 설정을 통해 내 계정에서 사용할 수 있는 외부 이미지 URL 패턴을 지정할 수 있어요. 이렇게 지정하면 지정된 도메인과 경로에 해당하는 이미지들만 안전하게 불러올 수 있습니다.\u003c/p\u003e\n\u003ch3\u003eNext.js 15.3.0 이상 버전\u003c/h3\u003e\n\u003cp\u003e아래처럼 \u003ccode\u003enext.config.js\u003c/code\u003e 파일에 \u003ccode\u003eremotePatterns\u003c/code\u003e에 \u003ccode\u003enew URL\u003c/code\u003e 객체로 패턴을 지정해주면 돼요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eimages\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003eremotePatterns\u003c/span\u003e: [\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eURL\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'https://example.com/account123/**'\u003c/span\u003e)],\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eNext.js 15.3.0 미만 버전\u003c/h3\u003e\n\u003cp\u003e이전 버전에서는 \u003ccode\u003eremotePatterns\u003c/code\u003e를 객체 형태로 설정해줘야 하는데, 조금 더 자세하게 프로토콜, 호스트명, 포트, 경로 등을 나눠서 작성해줍니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eimages\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003eremotePatterns\u003c/span\u003e: [\n      {\n        \u003cspan class=\"hljs-attr\"\u003eprotocol\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'https'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003ehostname\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'example.com'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003eport\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003epathname\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/account123/**'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003esearch\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e,\n      },\n    ],\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003e추가 팁\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epathname\u003c/code\u003e에서 \u003ccode\u003e/**\u003c/code\u003e는 와일드카드로, 해당 경로 이하의 모든 이미지 경로를 허용한다는 뜻이에요. 필요에 따라 경로를 더 구체적으로 설정해주세요.\u003c/li\u003e\n\u003cli\u003e만약 여러 도메인에서 이미지를 불러와야 한다면, \u003ccode\u003eremotePatterns\u003c/code\u003e 안에 여러 패턴을 배열 형태로 추가하면 됩니다.\u003c/li\u003e\n\u003cli\u003e보안을 위해 믿을 수 있는 도메인만 허용하는 게 가장 좋아요! 나중에 이미지 도메인이 바뀐다면 꼭 이 설정도 함께 업데이트해줘야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e앱에서 이미지를 최적화하면서도 보안도 챙기려면 이런 설정, 꼭 잊지 말고 해주세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003enext/image 컴포넌트를 사용할 때 외부 이미지 도메인을 어떻게 안전하게 설정할 수 있는지 아시나요? 이번에 알려드릴 내용은 Next.js의 \u003ccode\u003enext.config.js\u003c/code\u003e 파일에 \u003ccode\u003eremotePatterns\u003c/code\u003e 옵션을 활용하는 방법입니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e먼저, 이렇게 설정하면 이미지 URL이 꼭 \u003ccode\u003ehttps://example.com/account123/\u003c/code\u003e로 시작해야 하고, 쿼리 스트링은 없어야 해요. 다른 프로토콜(예: http), 호스트 이름, 포트 번호, 혹은 경로가 일치하지 않으면 400 Bad Request 에러가 발생합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eimages\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003eremotePatterns\u003c/span\u003e: [\n      {\n        \u003cspan class=\"hljs-attr\"\u003eprotocol\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'https'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003ehostname\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'example.com'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003eport\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003epathname\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/account123/**'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003esearch\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e,\n      },\n    ],\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 해두면 고정된 경로 패턴을 안전하게 지정할 수 있어요. 근데 만약 여러 서브도메인이 있는 경우라면 어떻게 할까요?\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e그럴 때는 와일드카드 패턴을 활용할 수 있어요! 예를 들어, 아래 설정은 https 프로토콜에, \u003ccode\u003eimg1.example.com\u003c/code\u003e 또는 \u003ccode\u003eme.avatar.example.com\u003c/code\u003e 같은 여러 서브도메인을 모두 허용합니다. 하지만 포트는 없고 쿼리 스트링도 없어야 하죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eimages\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003eremotePatterns\u003c/span\u003e: [\n      {\n        \u003cspan class=\"hljs-attr\"\u003eprotocol\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'https'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003ehostname\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'**.example.com'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003eport\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003esearch\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e,\n      },\n    ],\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e속성\u003c/th\u003e\u003cth\u003e의미\u003c/th\u003e\u003cth\u003e예시 값\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eprotocol\u003c/td\u003e\u003ctd\u003e허용할 프로토콜 (http, https 등)\u003c/td\u003e\u003ctd\u003e'https'\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003ehostname\u003c/td\u003e\u003ctd\u003e호스트 이름, 와일드카드 가능(**)\u003c/td\u003e\u003ctd\u003e'**.example.com'\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eport\u003c/td\u003e\u003ctd\u003e포트 번호 (빈 문자열은 포트 없음)\u003c/td\u003e\u003ctd\u003e''\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003epathname\u003c/td\u003e\u003ctd\u003e경로 (글로벌 와일드카드 /** 가능)\u003c/td\u003e\u003ctd\u003e'/account123/**'\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003esearch\u003c/td\u003e\u003ctd\u003e쿼리 스트링 (빈 문자열은 쿼리 없음)\u003c/td\u003e\u003ctd\u003e''\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003e참고로, \u003ccode\u003eremotePatterns\u003c/code\u003e 안에 경로를 지정하려면 \u003ccode\u003epathname\u003c/code\u003e 속성을 꼭 써야 해요. 위 첫번째 예제에서 \u003ccode\u003e/account123/**\u003c/code\u003e처럼 사용하구요!\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e이 기능 덕분에 보안도 챙기면서 다양한 도메인에서 이미지를 마음껏 불러올 수 있답니다. 특히 외부 이미지가 많은 프로젝트에서는 꼭 살펴봐야 할 설정이에요.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e요약하자면,\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eremotePatterns\u003c/code\u003e를 쓰면 이미지 허용 도메인을 세밀하게 설정할 수 있어요.\u003c/li\u003e\n\u003cli\u003e와일드카드를 활용해 여러 서브도메인도 한방에 통제 가능합니다.\u003c/li\u003e\n\u003cli\u003e프로토콜, 포트, 쿼리스트링까지 꼼꼼히 설정 가능해 오류를 줄이고 보안도 강화할 수 있죠.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이렇게 하시면 Next.js 프로젝트에서 안전하게 외부 이미지를 관리할 수 있어서, 성능과 안정성을 함께 챙길 수 있답니다! 혹시 더 궁금한 점 있으면 언제든지 댓글로 물어봐 주세요~\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e와일드카드 패턴은 경로 이름(pathname)과 호스트 이름(hostname) 모두에 사용할 수 있는데, 다음과 같은 문법을 가지고 있어요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e*\u003c/code\u003e : 한 개의 경로 세그먼트(path segment) 또는 서브도메인(subdomain)에 대응해요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e**\u003c/code\u003e : 경로 세그먼트가 끝부분에 여러 개 있을 때, 또는 서브도메인이 시작 부분에 여러 개 있을 때 모두 매칭해요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e단, \u003ccode\u003e**\u003c/code\u003e 문법은 패턴 중간에는 사용할 수 없다는 점 참고하세요!\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e알아두면 좋은 점\u003c/strong\u003e: 프로토콜, 포트, 경로(pathname), 검색(search) 정보를 생략하면 자동으로 와일드카드 \u003ccode\u003e**\u003c/code\u003e가 포함된 것으로 간주돼요. 하지만 이 방법은 권장하지 않아요. 왜냐하면 의도치 않은 URL까지 매칭되어 악의적인 사용자의 공격에 노출될 수 있기 때문이에요.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003cp\u003e조금 더 부연하자면, 와일드카드를 사용할 때는 어떤 부분에 얼마만큼 유연함을 줄지 꼭 신중히 결정해야 해요. 특히, \u003ccode\u003e**\u003c/code\u003e는 매우 강력한 매칭이 되기 때문에 보안상 위험할 수 있으니, 가능한 최소한으로 사용하는 걸 추천합니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 호스트네임에 \u003ccode\u003e*.example.com\u003c/code\u003e은 \u003ccode\u003eabc.example.com\u003c/code\u003e에는 매칭되지만, \u003ccode\u003exyz.abc.example.com\u003c/code\u003e까지는 포함하지 않아요. 반면 \u003ccode\u003e**.example.com\u003c/code\u003e이라면 여러 개의 서브도메인을 복수로 포함하는 경우에 사용하죠.\u003c/p\u003e\n\u003cp\u003e이런 와일드카드 패턴 활용법을 잘 이해하면, URL 필터링이나 라우팅 기능을 구현할 때 훨씬 편리하게 조건을 작성할 수 있어요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003enext.config.js에서 remotePatterns 속성에 search 옵션을 사용하는 예시를 보여드릴게요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eimages\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003eremotePatterns\u003c/span\u003e: [\n      {\n        \u003cspan class=\"hljs-attr\"\u003eprotocol\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'https'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003ehostname\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'assets.example.com'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003esearch\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'?v=1727111025337'\u003c/span\u003e,\n      },\n    ],\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e참고할 점: 위 예시는 next/image 컴포넌트의 src 값이 \u003ccode\u003ehttps://assets.example.com\u003c/code\u003e으로 시작해야 하고, 쿼리 스트링이 정확히 \u003ccode\u003e?v=1727111025337\u003c/code\u003e 로 일치해야만 이미지를 불러올 수 있다는 뜻이에요. 만약 프로토콜이나 쿼리 스트링이 다르면 400 Bad Request 오류가 발생할 수 있습니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e이렇게 remotePatterns에 search 값을 명시하면, URL 매칭 조건을 엄격하게 설정할 수 있어서 보안이나 캐시 관리를 조금 더 세밀하게 할 수 있어요.\u003c/p\u003e\n\u003ch3\u003edomains와의 차이점\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003edomains\u003c/code\u003e 속성은 단순히 hostname 기반으로 이미지를 허용하는 반면, \u003ccode\u003eremotePatterns\u003c/code\u003e는 프로토콜, 호스트명, 경로, 포트, 검색(쿼리)까지 좀 더 자세히 지정할 수 있다는 점에서 훨씬 유연해요. 만약 특정 쿼리를 포함한 URL만 받고 싶다면 \u003ccode\u003eremotePatterns\u003c/code\u003e를 사용하세요.\u003c/p\u003e\n\u003cp\u003e예를 들어, 다음은 domains와 remotePatterns의 비교입니다:\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e속성명\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003cth\u003e유연성\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003edomains\u003c/td\u003e\u003ctd\u003e도메인 이름만 지정, 간단히 허용 목록 작성 가능\u003c/td\u003e\u003ctd\u003e낮음\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eremotePatterns\u003c/td\u003e\u003ctd\u003e프로토콜, 호스트, 경로, 검색 등 세부적으로 지정 가능\u003c/td\u003e\u003ctd\u003e매우 높음\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e개발할 때 이렇게 쿼리 스트링까지 조건에 넣으면, 이미지 요청에서 인증 토큰이나 버전 관리 같은 정보를 활용할 때도 편리해요.\u003c/p\u003e\n\u003cp\u003e필요에 따라 여러분 프로젝트에 맞는 방식을 선택해서 사용해 보면 좋겠네요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eNext.js 14부터는 remotePatterns라는 엄격한 설정 방식을 권장하면서, 기존의 domains 설정이 점점 Deprecated(사용 중단)되고 있다는 경고가 나오는 경우가 많아요.\u003c/p\u003e\n\u003cp\u003e왜 그러냐면, domains 설정은 외부 이미지 도메인을 허용하는 데는 편리하지만, 와일드카드 패턴 매칭이 안 되고, 프로토콜(https, http), 포트, 경로나 쿼리 스트링 같은 세밀한 조건을 제한할 수가 없거든요. 즉, 보안 측면에서 좀 허술할 수 있어요. 특히 도메인의 모든 콘텐츠를 소유하지 않은 경우에는 위험할 수도 있어요.\u003c/p\u003e\n\u003cp\u003e대신 remotePatterns는 이런 부분을 세밀하게 지정할 수 있어서, 악성 사용자가 이미지 요청을 조작해 공격하는 걸 막아줄 수 있답니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003edomains 설정 예시 (next.config.js)\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eimages\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003edomains\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e'example.com'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'cdn.example.com'\u003c/span\u003e],\n  },\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위처럼 도메인을 배열로 넣어주면, 해당 도메인에 있는 외부 이미지들을 Next.js 이미지 최적화 기능과 함께 쓸 수 있어요. 하지만 프로토콜이나 경로는 제한하지 못하고, 와일드카드(*)도 안 돼서 살짝 아쉽죠.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e추가로, remotePatterns 설정법은?\u003c/h3\u003e\n\u003cp\u003e만약 \u003ccode\u003eremotePatterns\u003c/code\u003e를 써보고 싶다면, 이렇게 쓸 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eimages\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003eremotePatterns\u003c/span\u003e: [\n      {\n        \u003cspan class=\"hljs-attr\"\u003eprotocol\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'https'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003ehostname\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'example.com'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003eport\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003epathname\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/images/**'\u003c/span\u003e,\n      },\n    ],\n  },\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 \u003ccode\u003ehttps://example.com/images/\u003c/code\u003e 하위 경로만 허용하는 식으로 훨씬 정밀한 제어가 가능해요. 물론, Next.js 14 이상이어야 지원됩니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e정리하자면\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003edomains는 간단하지만 제한적이고 보안 취약점이 있을 수 있으니 조심!\u003c/li\u003e\n\u003cli\u003eremotePatterns는 더 엄격하고 안전한 설정 방법\u003c/li\u003e\n\u003cli\u003e여러분이 도메인 소유주가 아니면 remotePatterns 추천!\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e개발하면서 이미지 도메인 설정할 때 참고하시고, 가능하면 최신 방식인 remotePatterns로 업데이트해보세요! 안전한 앱 만드는 데 큰 도움이 될 거예요.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e여러분, Next.js에서 이미지 최적화를 할 때 기본 API 대신 클라우드 제공업체를 이용하고 싶을 때가 있죠? 그럴 땐 next.config.js 파일에서 loaderFile 옵션을 활용해서 커스텀 로더를 설정할 수 있어요.\u003c/p\u003e\n\u003cp\u003e먼저 기본적으로 도메인을 설정해주는 예제를 볼게요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eimages\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003edomains\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e'assets.acme.com'\u003c/span\u003e], \u003cspan class=\"hljs-comment\"\u003e// 여기서 외부 이미지 도메인을 지정해줘요.\u003c/span\u003e\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 Next.js가 \u003ccode\u003eassets.acme.com\u003c/code\u003e에서 가져오는 이미지를 허용하고 최적화할 수 있게 됩니다.\u003c/p\u003e\n\u003cp\u003e그런데 만약 클라우드 제공업체(예: Cloudinary, Imgix 등)를 직접 써서 이미지 최적화를 맡기고 싶으면 어떻게 할까요? 이때는 \u003ccode\u003eloaderFile\u003c/code\u003e 옵션을 사용해서 커스텀 이미지 로더를 지정하면 돼요. 예시는 아래와 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eimages\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003eloader\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'custom'\u003c/span\u003e,               \u003cspan class=\"hljs-comment\"\u003e// 커스텀 로더 사용 선언\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eloaderFile\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'./my/image/loader.js'\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 직접 만든 로더 파일 경로\u003c/span\u003e\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e여기서 중요한 점\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eloader\u003c/code\u003e는 \u003ccode\u003e'default'\u003c/code\u003e, \u003ccode\u003e'imgix'\u003c/code\u003e, \u003ccode\u003e'cloudinary'\u003c/code\u003e, \u003ccode\u003e'akamai'\u003c/code\u003e 등 미리 준비된 옵션도 있지만, \u003ccode\u003ecustom\u003c/code\u003e을 쓰면 직접 로더 코드를 만들어 제어할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eloaderFile\u003c/code\u003e에 적힌 파일에서는 함수가 export되어 있어야 하며, 이미지 URL과 원하는 크기 등을 인자로 받아 최종 이미지 URL을 반환해야 해요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예를 들어, \u003ccode\u003e./my/image/loader.js\u003c/code\u003e 파일은 대략 이런 모양일 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e{ src, width, quality }\u003c/span\u003e) =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e`https://your-cloud-provider.com/\u003cspan class=\"hljs-subst\"\u003e${src}\u003c/span\u003e?w=\u003cspan class=\"hljs-subst\"\u003e${width}\u003c/span\u003e\u0026#x26;q=\u003cspan class=\"hljs-subst\"\u003e${quality || \u003cspan class=\"hljs-number\"\u003e75\u003c/span\u003e}\u003c/span\u003e`\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 Next.js가 이미지 최적화를 요청할 때 이 커스텀 로더를 거쳐 이미지 URL을 생성하고, 클라우드에서 최적화된 이미지를 받아 올 수 있습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e요약하자면, Next.js의 이미지 컴포넌트는 기본 제공 API로도 훌륭하지만, 자신만의 클라우드 서비스나 특별한 최적화 방식을 쓰고 싶을 땐 \u003ccode\u003eloader\u003c/code\u003e를 \u003ccode\u003e'custom'\u003c/code\u003e으로 설정하고, \u003ccode\u003eloaderFile\u003c/code\u003e에서 직접 URL 생성 방식을 관리하면 완전 내 맘대로 컨트롤할 수 있어 편리하답니다!\u003c/p\u003e\n\u003cp\u003e더 궁금하면 언제든 질문 주세요~\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eNext.js에서 이미지 로더를 설정할 때, \u003ccode\u003eloader\u003c/code\u003e 파일은 반드시 Next.js 애플리케이션 루트 기준으로 상대 경로를 가리켜야 합니다. 이 파일에서는 기본(default)로 문자열을 반환하는 함수 하나를 export해야 하는데요, 예를 들어 아래처럼 작성할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e'use client'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emyImageLoader\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ src, width, quality }\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e`https://example.com/\u003cspan class=\"hljs-subst\"\u003e${src}\u003c/span\u003e?w=\u003cspan class=\"hljs-subst\"\u003e${width}\u003c/span\u003e\u0026#x26;q=\u003cspan class=\"hljs-subst\"\u003e${quality || \u003cspan class=\"hljs-number\"\u003e75\u003c/span\u003e}\u003c/span\u003e`\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 \u003ccode\u003esrc\u003c/code\u003e는 이미지 경로, \u003ccode\u003ewidth\u003c/code\u003e는 요청할 이미지의 너비, \u003ccode\u003equality\u003c/code\u003e는 이미지 품질(기본 75)인데요, 함수가 최종적으로 반환하는 문자열은 이미지 URL이 됩니다. 이 방식을 쓰면 이미지 요청을 커스터마이징할 수 있어서 CDN이나 외부 이미지 서버와 연동할 때 아주 유용하답니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e그리고 꼭 파일 하나에 넣어야 한다고 생각하지 마세요! Next.js \u003ccode\u003enext/image\u003c/code\u003e 컴포넌트의 \u003ccode\u003eloader\u003c/code\u003e 프롭에도 직접 함수를 넘겨줄 수 있어요. 이렇게 하면 각 이미지마다 다른 로더를 쓸 수도 있어서 더욱 유연한 관리가 가능합니다.\u003c/p\u003e\n\u003cp\u003e아래는 두 가지 예시입니다:\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e구분\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003cth\u003e코드\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e1. loader 파일 사용\u003c/td\u003e\u003ctd\u003e루트에 파일 만들어서 재사용\u003c/td\u003e\u003ctd\u003ejs 'use client' export default function myImageLoader({ src, width, quality }) { return `\u003ca href=\"https://example.com/$%7Bsrc%7D?w=$%7Bwidth%7D\u0026#x26;q=$%7Bquality\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://example.com/${src}?w=${width}\u0026#x26;q=${quality\u003c/a\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e2. loader prop 사용\u003c/td\u003e\u003ctd\u003e이미지 컴포넌트마다 다르게 설정\u003c/td\u003e\u003ctd\u003ejsx import Image from 'next/image'; const myImageLoader = ({ src, width, quality }) =\u003e { return `\u003ca href=\"https://example.com/$%7Bsrc%7D?w=$%7Bwidth%7D\u0026#x26;q=$%7Bquality\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://example.com/${src}?w=${width}\u0026#x26;q=${quality\u003c/a\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003cp\u003eTip!\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eloader\u003c/code\u003e 함수가 반환하는 URL은 클라이언트가 실제로 접근 가능한 주소여야 해요. 내부 경로나 상대 경로를 그대로 쓰면 안 됩니다.\u003c/li\u003e\n\u003cli\u003e품질(\u003ccode\u003equality\u003c/code\u003e) 옵션을 넣는 이유는 이미지 크기와 품질간 밸런스를 맞추기 위해서인데, 기본값은 75이지만 필요에 따라 조절하세요.\u003c/li\u003e\n\u003cli\u003e공식 Next.js 문서(\u003ca href=\"https://nextjs.org/docs/api-reference/next/image#loader)%EC%97%90%EC%84%9C%EB%8F%84\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://nextjs.org/docs/api-reference/next/image#loader)에서도\u003c/a\u003e 다양한 예제를 참고할 수 있어요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이미지 요청 경로 다루는 게 어렵게 느껴질 수 있는데, 이런 사용자 정의 로더를 잘 활용하면 서버 부담도 줄이고, 이미지 로딩 속도도 개선할 수 있답니다! 궁금하면 꼭 한 번 시도해 보세요.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e커스텀 이미지 로더 설정\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e참고할 점: 이미지 로더 파일을 커스터마이징할 때 함수(function)를 넘겨줘야 하는데, 이 함수는 Client Components에서 직렬화(serialization) 과정을 거쳐야 제대로 작동해요.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e고급 설정\u003c/h2\u003e\n\u003cp\u003e아래 설정들은 주로 고급 사용자들을 위한 내용이에요. 보통은 건드릴 필요가 없고, 만약 이 설정들을 직접 바꾸면 향후 Next.js 업데이트 시 기본 설정이 변경돼도 자동 반영되지 않으니 주의가 필요해요.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e사실 이미지 로더를 직접 커스터마이징하는 경우는 주로 이미지 처리 방식을 세밀하게 조정하고 싶을 때입니다. 예를 들면, 이미지 CDN을 직접 지정하거나, 특정 포맷 변환, 압축 옵션을 다루고 싶을 때 쓰이죠. 하지만 대부분 프로젝트에서는 Next.js가 제공하는 기본 이미지 로더로 충분한 성능과 편리함을 느낄 수 있으니, 특별한 이유가 없다면 기본 설정을 유지하는 게 안정적입니다.\u003c/p\u003e\n\u003cp\u003e필요하다면 Client Component에서 커스텀 함수를 어떻게 직렬화하는지 추가 예제도 나중에 소개할게요.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003edeviceSizes\u003c/h3\u003e\n\u003cp\u003e만약 여러분이 타겟하려는 사용자들이 주로 사용하는 디바이스의 화면 너비를 알고 있다면, \u003ccode\u003enext.config.js\u003c/code\u003e 파일에서 \u003ccode\u003edeviceSizes\u003c/code\u003e라는 속성에 해당 너비들을 지정할 수 있어요. 이렇게 지정해주면, \u003ccode\u003enext/image\u003c/code\u003e 컴포넌트가 \u003ccode\u003esizes\u003c/code\u003e 속성을 사용할 때 사용자의 디바이스에 가장 적합한 이미지 크기를 골라서 제공할 수 있게 됩니다.\u003c/p\u003e\n\u003cp\u003e만약 별도로 설정하지 않으면, Next.js는 기본값으로 아래와 같은 디바이스 크기들을 사용해요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eimages\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003edeviceSizes\u003c/span\u003e: [\u003cspan class=\"hljs-number\"\u003e640\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e750\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e828\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1080\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1200\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1920\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2048\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3840\u003c/span\u003e],\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e기본 deviceSizes 값\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e640\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e750\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e828\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e1080\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e1200\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e1920\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e2048\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e3840\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003cp\u003e이걸 설정하는 가장 큰 장점은 이미지 최적화에서 효율성! 예를 들어, 모바일 사용자에게 굳이 큰 해상도의 이미지를 내려주면 데이터 낭비가 심하잖아요. 그런데 이걸 활용하면 크고 작은 여러 버전의 이미지가 준비되어서, 각각의 디바이스에 최적화된 이미지를 업로드 없이 자동으로 빠르게 제공해주니까요.\u003c/p\u003e\n\u003cp\u003e추가로, \u003ccode\u003edeviceSizes\u003c/code\u003e와 비슷하게 \u003ccode\u003eimageSizes\u003c/code\u003e라는 옵션도 있는데요, 이건 고정된 이미지 크기(아이콘 같은 작은 이미지)들을 지정할 때 유용해요. 보통 \u003ccode\u003edeviceSizes\u003c/code\u003e는 반응형 이미지에, \u003ccode\u003eimageSizes\u003c/code\u003e는 고정 사이즈 이미지에 활용한다고 이해하시면 좋아요.\u003c/p\u003e\n\u003cp\u003e실제로 프로젝트에 맞춰 이 값들을 잘 조절하면 성능이 확연히 개선되는 걸 체감할 수 있으니 한 번 프로젝트에 적용해보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003eimageSizes란?\u003c/h3\u003e\n\u003cp\u003eNext.js에서 \u003ccode\u003enext.config.js\u003c/code\u003e 파일 안에 \u003ccode\u003eimages.imageSizes\u003c/code\u003e라는 속성을 통해 \u003cstrong\u003e이미지 너비 리스트를 직접 지정\u003c/strong\u003e할 수 있어요. 이 리스트는 \u003ccode\u003edeviceSizes\u003c/code\u003e라는 또 다른 배열과 합쳐져서, 이미지의 \u003ccode\u003esrcset\u003c/code\u003e을 생성할 때 사용되는 전체 크기 배열을 만든답니다.\u003c/p\u003e\n\u003cp\u003e그런데 왜 두 개의 리스트가 따로 있냐고요? 그 이유는, \u003ccode\u003eimageSizes\u003c/code\u003e는 \u003cstrong\u003e이미지에 \u003ccode\u003esizes\u003c/code\u003e 속성이 제공될 때만 사용\u003c/strong\u003e돼요. 즉, \u003ccode\u003esizes\u003c/code\u003e prop이 있으면 이 이미지는 화면 전체 너비를 쓰는 게 아니라, 화면보다 작은 크기로 보여준다는 의미거든요. 그래서 \u003ccode\u003eimageSizes\u003c/code\u003e에 들어가는 값들은 항상 \u003ccode\u003edeviceSizes\u003c/code\u003e의 가장 작은 크기보다 작아야 해요. 이것은 이미지가 너무 커서 불필요한 리소스를 쓰는 걸 방지해줍니다.\u003c/p\u003e\n\u003cp\u003e만약 여러분이 따로 설정을 안 해주면 Next.js가 기본값을 사용하게 돼요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch4\u003e추가로 알아두면 좋은 점!\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003edeviceSizes\u003c/code\u003e는 주로 일반적인 기기 화면 크기를 기준으로 하며, Next.js가 자동으로 기본값을 제공하지만, 상황에 맞게 조정할 수도 있어요.\u003c/li\u003e\n\u003cli\u003e예를 들어, 모바일 최적화가 매우 중요하거나, 특정 컴포넌트가 작은 이미지 크기를 주로 쓴다면, \u003ccode\u003eimageSizes\u003c/code\u003e를 알맞게 지정해주면 네트워크 대역폭 절약과 빠른 로딩에 도움이 됩니다.\u003c/li\u003e\n\u003cli\u003e또한, Image 컴포넌트에서 \u003ccode\u003esizes\u003c/code\u003e prop을 사용하면, 당신이 지정한 \u003ccode\u003eimageSizes\u003c/code\u003e 배열에 맞게 다양한 이미지를 브라우저가 선택하게 됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e아래는 각 속성별 기본값이 어떻게 설정되어 있는지 참고해보세요.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e속성 이름\u003c/th\u003e\u003cth\u003e기본값\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003edeviceSizes\u003c/td\u003e\u003ctd\u003e[640, 750, 828, 1080, 1200, 1920, 2048, 3840]\u003c/td\u003e\u003ctd\u003e대표적인 기기 너비 배열\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eimageSizes\u003c/td\u003e\u003ctd\u003e[16, 32, 48, 64, 96]\u003c/td\u003e\u003ctd\u003e\u003ccode\u003esizes\u003c/code\u003e prop이 있는 이미지에 사용되는 작고 세밀한 너비 배열\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e요렇게 이해하면 Next.js 이미지 최적화가 좀 더 명확해지실 거예요! 혹시 이미지 로딩 최적화 팁에 관심 있으면 또 알려드릴게요~\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e오늘은 Next.js에서 이미지 최적화 설정하는 방법에 대해 쉽고 간단하게 알아볼게요. 이미지 크기와 퀄리티(quality)를 직접 설정해서 웹사이트 로딩 속도와 사용자 경험을 개선할 수 있답니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e이미지 크기 (\u003ccode\u003eimageSizes\u003c/code\u003e) 설정하기\u003c/h3\u003e\n\u003cp\u003eNext.js의 기본 이미지 최적화 API는 여러 크기의 이미지를 자동으로 만드는데요. 만약 이 크기를 내가 원하는 크기로 지정하고 싶다면 \u003ccode\u003enext.config.js\u003c/code\u003e 파일에 \u003ccode\u003eimageSizes\u003c/code\u003e를 설정하면 돼요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eimages\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003eimageSizes\u003c/span\u003e: [\u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e32\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e48\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e64\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e96\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e128\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e256\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e384\u003c/span\u003e],\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드에서 이미지 사이즈 배열에 들어간 숫자들은 픽셀 단위의 너비를 의미해요. 예를 들어 16은 16px 너비의 이미지를 생성한단 뜻이죠. 이 설정을 참고해서 사이트에 필요한 크기만 지정하면 불필요한 이미지 생성과 트래픽을 줄일 수 있어요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e이미지 퀄리티 (\u003ccode\u003equalities\u003c/code\u003e) 제한하기\u003c/h3\u003e\n\u003cp\u003e기본적으로 Next.js는 이미지 퀄리티를 1부터 100까지 모두 허용해요. 근데 세부적으로 퀄리티를 제한하고 싶을 때는 이렇게 해볼 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eimages\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003equalities\u003c/span\u003e: [\u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e75\u003c/span\u003e],\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 오직 25%, 50%, 75% 퀄리티만 이미지 최적화 API에서 허용하게 돼요. 덕분에 최대한 이미지 품질과 용량을 조절할 수 있죠. 예를 들어, 퀄리티를 너무 낮게 하면 화질이 떨어져 사용자 경험이 나빠질 수 있으니, 적당한 균형을 찾는 게 중요해요!\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e참고로 더 알아두면 좋은 팁\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eimageSizes\u003c/code\u003e는 기본적으로 \u003ccode\u003e[16, 32, 48, 64, 96, 128, 256, 384]\u003c/code\u003e 크기들이 포함돼 있지만, 커스텀 사이즈 추가 가능해요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eimageSizes\u003c/code\u003e는 사이즈 지정에 사용하고, 실제 사용할 수 있는 이미지 최대 크기는 \u003ccode\u003edeviceSizes\u003c/code\u003e에서 설정할 수 있어요.\u003c/li\u003e\n\u003cli\u003e퀄리티 제한을 할 때는 일반적으로 75~80 정도가 적당히 고화질과 적당한 용량의 밸런스로 추천됩니다.\u003c/li\u003e\n\u003cli\u003e더 나아가 \u003ccode\u003eformats\u003c/code\u003e 설정을 이용해서 WebP, AVIF 등 최신 이미지 포맷으로 변환하는 것도 가능하니까 같이 고려해보세요!\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003e마무리\u003c/h3\u003e\n\u003cp\u003eNext.js 이미지 최적화 세팅은 웹 속도를 개선하고 사용자 경험을 올리는 데 적절한 이미지 크기와 퀄리티를 직접 정할 수 있어 정말 편리해요. 사이트 규모와 용도에 맞춰서 적절하게 설정해 보시길 추천드려요!\u003c/p\u003e\n\u003cp\u003e앞으로도 이런 실용적인 팁들 많이 공유할게요. 언제든 질문 주세요~!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e위 예시에서는 허용되는 품질 값이 25, 50, 75 세 가지로 정해져 있어요. quality prop에 이 배열에 없는 값이 들어가면, 이미지 요청이 실패하면서 400 Bad Request 에러가 발생합니다. 그러니까 품질 설정할 때는 꼭 허용된 값 중에서 선택해야 한다는 점 꼭 기억하세요!\u003c/p\u003e\n\u003ch3\u003eformats\u003c/h3\u003e\n\u003cp\u003e기본적으로 Image Optimization API는 요청에 포함된 브라우저의 Accept 헤더를 통해 어떤 이미지 포맷을 지원하는지 자동으로 감지합니다. 이 정보를 바탕으로 가장 최적화된 출력 포맷을 선택해주는 거죠.\u003c/p\u003e\n\u003cp\u003e여기서 중요한 점은 만약 Accept 헤더에 여러 개의 지원 포맷이 포함되어 있다면, 미리 설정된 formats 배열에서 가장 먼저 일치하는 포맷을 사용한다는 것입니다. 즉, 배열의 순서가 정말 중요해요! 만약 일치하는 포맷이 없거나, 원본 이미지가 애니메이션 GIF 같은 특수한 경우라면, API는 원본 이미지 포맷을 그대로 반환합니다.\u003c/p\u003e\n\u003cp\u003e이 부분을 이해하면, 이미지 최적화를 하면서도 호환성을 최대한 보장할 수 있고, 불필요한 에러도 막을 수 있으니 꼭 참고하세요!\u003c/p\u003e\n\u003cp\u003e아래는 요점 정리한 표예요:\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e키워드\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003equality\u003c/td\u003e\u003ctd\u003e허용값은 25, 50, 75. 배열 외 값 입력 시 400 Bad Request 발생\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eAccept 헤더\u003c/td\u003e\u003ctd\u003e브라우저가 지원하는 이미지 포맷 정보를 포함하는 HTTP 헤더\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eformats 배열\u003c/td\u003e\u003ctd\u003eAccept 헤더와 비교해 출력 포맷을 결정. 배열 내 순서가 최종 포맷 선택에 중요\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eFallback\u003c/td\u003e\u003ctd\u003e일치하는 포맷 없거나 애니메이션 이미지일 경우 원본 포맷 사용\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e이렇게 정리해두면 이미지 최적화 설정할 때 훨씬 이해가 쉬워질 거예요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e설정을 따로 해주지 않으면 기본값으로 아래와 같은 설정이 적용돼요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eimages\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003eformats\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e'image/webp'\u003c/span\u003e],\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 \u003ccode\u003eformats\u003c/code\u003e는 이미지 최적화를 위해 어떤 포맷을 사용할지 지정하는 옵션인데요, 기본값은 \u003ccode\u003ewebp\u003c/code\u003e 포맷이에요. \u003ccode\u003ewebp\u003c/code\u003e는 구글에서 만든 이미지 포맷으로, JPG나 PNG보다 용량을 줄이면서도 화질 손실이 적어 많이 쓰이죠.\u003c/p\u003e\n\u003cp\u003e그리고 만약 AVIF 포맷을 사용해보고 싶다면, 이렇게 바꿔주면 돼요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eimages\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003eformats\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e'image/avif'\u003c/span\u003e],\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAVIF는 최근에 각광받는 이미지 포맷으로, \u003ccode\u003ewebp\u003c/code\u003e보다 압축률이 더 좋고 화질도 뛰어나지만 아직 모든 브라우저에서 완벽하게 지원하는 건 아니에요. 그래서 위 설정처럼 넣으면, 브라우저가 AVIF를 지원하지 않을 땐 원본 이미지 포맷을 대신 보여줘서 큰 문제가 없답니다.\u003c/p\u003e\n\u003cp\u003e참고로, \u003ccode\u003eformats\u003c/code\u003e 배열에 여러 포맷을 넣어서 동시에 지원하게 할 수도 있어요. 예를 들어 내비게이션이 상황에 맞게 최적화된 포맷을 골라주도록 하려면 이렇게 할 수 있죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eimages\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003eformats\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e'image/avif'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'image/webp'\u003c/span\u003e],\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 AVIF를 우선 시도하고, 지원하지 않으면 webp, 또 그마저 지원하지 않으면 원본 이미지로 자동으로 fallback 해준답니다.\u003c/p\u003e\n\u003cp\u003e요즘은 이미지 최적화를 하는 게 페이지 로딩 속도 개선에 큰 도움이 되니까, 이런 포맷 지정은 꼭 활용해보길 추천해요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cblockquote\u003e\n\u003cp\u003e참고할 점:\n대부분의 경우에는 여전히 WebP 형식을 사용하는 것을 추천해요.\nAVIF는 인코딩하는 데 WebP보다 약 50% 더 시간이 걸리지만, 압축률은 약 20% 더 좋아서 파일 크기가 더 작아진답니다. 그래서 이미지를 처음 요청할 때는 속도가 조금 느릴 수 있지만, 캐시된 이후에는 훨씬 빠르게 로드돼요.\n만약 Next.js 앞에 Proxy나 CDN을 직접 운영한다면, 반드시 Proxy가 \u003ccode\u003eAccept\u003c/code\u003e 헤더를 전달하도록 설정해줘야 해요. 이 부분을 놓치면 최적화된 이미지가 제대로 제공되지 않을 수 있거든요.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e캐싱 동작 방식\u003c/h2\u003e\n\u003cp\u003e기본 이미지 로더의 캐싱 알고리즘은 다음과 같아요. 다른 로더를 사용한다면 클라우드 제공업체의 문서를 참고하는 게 좋아요.\u003c/p\u003e\n\u003cp\u003e이미지는 요청 시 동적으로 최적화되고, 프로젝트의 \u003ccode\u003edistDir/cache/images\u003c/code\u003e 디렉터리에 저장돼요. 이렇게 최적화된 이미지는 만료 시간이 도달할 때까지 이후 요청에 동일하게 제공됩니다. 만약 요청한 이미지가 캐시돼있지만 만료되었다면, 서버는 만료된(오래된) 이미지를 바로 보여주고, 백그라운드에서는 이미지를 다시 최적화(재검증)해서 새 캐시와 만료 시간으로 업데이트합니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e이렇게 하면 처음 사용자에게도 최소한의 지연만 주면서 최신 이미지를 유지하는 효율적인 캐싱 전략이 구현되는 거죠. 실제로 운영할 때는 압축률과 인코딩 속도, 그리고 캐시 만료 정책을 적절히 조절하는 게 중요해요. CDN이나 프록시를 쓴다면, \u003ccode\u003eAccept\u003c/code\u003e 헤더가 제대로 전달되는지 꼭 확인해서 원하는 포맷으로 이미지를 제공받도록 하는 것도 핵심입니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이미지 캐시 상태를 확인할 때는 \u003ccode\u003ex-nextjs-cache\u003c/code\u003e라는 응답 헤더 값을 보면 됩니다. 이 헤더가 가리키는 값은 보통 다음 세 가지 중 하나예요:\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e캐시 상태\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eMISS\u003c/td\u003e\u003ctd\u003e경로가 캐시에 없다는 뜻이에요. 보통 이건 처음 한번, 첫 방문할 때 발생해요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSTALE\u003c/td\u003e\u003ctd\u003e경로가 캐시에 있긴 한데, 재검증(revalidate) 시간이 초과돼서 백그라운드에서 업데이트가 진행 중인 경우입니다.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eHIT\u003c/td\u003e\u003ctd\u003e경로가 캐시에 있고, 재검증 시간이 지나지 않았을 때를 의미해요.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e캐시 만료 시간(정확히 말하면 Max Age)은 \u003ccode\u003eminimumCacheTTL\u003c/code\u003e 설정값과 업스트림 이미지의 \u003ccode\u003eCache-Control\u003c/code\u003e 헤더 중 더 큰 값으로 정해집니다. 여기서 \u003ccode\u003eCache-Control\u003c/code\u003e 헤더의 \u003ccode\u003emax-age\u003c/code\u003e 값을 기준으로 하는데, 만약 \u003ccode\u003es-maxage\u003c/code\u003e와 \u003ccode\u003emax-age\u003c/code\u003e 둘 다 있으면 \u003ccode\u003es-maxage\u003c/code\u003e가 우선입니다. 그리고 이 \u003ccode\u003emax-age\u003c/code\u003e 값은 CDN이나 브라우저 같은 하위 클라이언트에게도 그대로 전달돼요.\u003c/p\u003e\n\u003cp\u003e그리고 몇 가지 팁을 드리면:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eminimumCacheTTL\u003c/code\u003e을 설정하면, 업스트림 이미지에서 Cache-Control 헤더가 없거나 너무 낮을 때 캐시 지속 시간을 인위적으로 늘릴 수 있어요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edeviceSizes\u003c/code\u003e와 \u003ccode\u003eimageSizes\u003c/code\u003e를 잘 설정해서 생성되는 이미지 종류(사이즈)를 줄이면 서버의 부하도 줄이고 캐시 효율도 높일 수 있어요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eformats\u003c/code\u003e 설정으로 여러 이미지 포맷 생성을 끄고, 한 가지 포맷만 사용하도록 할 수도 있어요. 이건 클라이언트의 호환성이나 트래픽 관리에 도움됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이렇게 캐시 설정을 적절히 조절하면, 이미지 로딩 속도 향상과 서버 비용 절감 두 마리 토끼를 잡을 수 있으니, 꼭 한 번 살펴보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003eminimumCacheTTL\u003c/h3\u003e\n\u003cp\u003e이미지 최적화 캐시의 TTL(Time to Live), 즉 이미지가 캐시에서 살아있는 시간을 초 단위로 설정할 수 있어요.\u003c/p\u003e\n\u003cp\u003e사실 대부분의 경우에는 \u003cstrong\u003eStatic Image Import\u003c/strong\u003e 방식을 쓰는 게 더 좋아요. 이 방법은 파일 내용을 자동으로 해시(hash)해서 캐시를 사실상 영구적으로 유지하는 효과가 있고, \u003ccode\u003eCache-Control\u003c/code\u003e 헤더에 \u003ccode\u003eimmutable\u003c/code\u003e이 설정돼서 브라우저가 굳이 자주 새로 다운로드하지 않게 해주거든요.\u003c/p\u003e\n\u003cp\u003e만약 따로 설정하지 않으면 기본값으로 아래 설정이 사용됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eimages\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003eminimumCacheTTL\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 1분 간 캐시 유지\u003c/span\u003e\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e추가 팁!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eTTL을 너무 짧게 하면 캐시를 자주 새로 받아서 서버 부하가 늘어나고, 반대로 너무 길게 설정하면 오래된 이미지가 사용될 수도 있어요.\u003c/li\u003e\n\u003cli\u003e그래서 가능하면 정적 이미지(import 방식)를 활용하는 게 좋고, 동적으로 변경될 가능성이 있는 이미지만 TTL을 적절히 조절하는 방식을 추천드립니다.\u003c/li\u003e\n\u003cli\u003e만약 이미지가 자주 변경되는 편이라면 TTL을 짧게, 그렇지 않으면 길게 잡는 게 무난해요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이렇게 적절한 캐시 설정으로 웹사이트 속도와 사용자 경험을 더 좋게 만들어 보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이미지 최적화할 때 TTL(Time To Live)을 늘려서 재검증(revalidation) 횟수를 줄이고, 그 결과 비용 절감 효과를 기대할 수 있어요. 예를 들어, Next.js 내 설정 파일에서 이렇게 써주면 돼요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eimages\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003eminimumCacheTTL\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2678400\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 31일 (초 단위)\u003c/span\u003e\n  },\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 \u003ccode\u003eminimumCacheTTL\u003c/code\u003e은 이미지가 캐시에 머무르는 최소 시간을 의미해요. 최적화된 이미지의 만료 시간(또는 Max Age)은 이 값과 원본 이미지 서버가 보내는 \u003ccode\u003eCache-Control\u003c/code\u003e 헤더 중 더 긴 쪽을 따르게 됩니다.\u003c/p\u003e\n\u003cp\u003e만약 이미지마다 캐싱 정책을 다르게 하고 싶다면, 최적화 요청이 가는 \u003ccode\u003e/_next/image\u003c/code\u003e 경로가 아니라 원본 이미지 경로(예: \u003ccode\u003e/some-asset.jpg\u003c/code\u003e)에 직접 \u003ccode\u003eCache-Control\u003c/code\u003e 헤더를 설정해야 합니다. 그렇지 않으면 모든 이미지가 같은 캐시 정책을 따르게 돼요.\u003c/p\u003e\n\u003cp\u003e참고로, TTL을 너무 길게 잡으면 업데이트된 이미지가 바로 반영되지 않을 수 있으니, 상황에 맞게 적절한 기간을 선택하는 게 좋아요. 개발 중에는 짧게, 배포 환경에선 길게 설정하는 방식도 괜찮겠죠? 그리고 이미지 캐싱 전략은 비용뿐만 아니라 사용자 경험에도 큰 영향을 주니 신중하게 고민해보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e지금은 캐시를 무효화할 수 있는 별도의 방법이 없기 때문에, minimumCacheTTL 값을 낮게 설정하는 게 좋아요. 그렇지 않으면 src 속성을 직접 변경하거나, \u003ccode\u003edistDir\u003c/code\u003e/cache/images 폴더를 수동으로 삭제해야 할 수도 있어요.\u003c/p\u003e\n\u003ch3\u003edisableStaticImages\u003c/h3\u003e\n\u003cp\u003e기본 설정으로는 \u003ccode\u003eimport icon from './icon.png'\u003c/code\u003e처럼 정적 파일을 임포트해서 src 속성에 바로 전달할 수 있어요.\u003c/p\u003e\n\u003cp\u003e하지만 어떤 경우에는, 다른 플러그인과 충돌이 일어나서 임포트가 다르게 동작해야 할 때가 있어요. 그럴 때 이 기능을 끄는 옵션이 바로 \u003ccode\u003edisableStaticImages\u003c/code\u003e입니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e한 가지 팁을 더 드리자면, 이미지 캐시를 적절히 관리하지 않으면 개발 중에 변경 사항이 바로 반영되지 않아 꽤 답답할 수 있어요. 그래서 개발 모드에서는 캐시 TTL을 낮게 설정하거나, 필요할 땐 수동으로 캐시를 삭제하는 습관을 들이면 좋습니다. 또한, 플러그인 간 충돌을 미리 파악해서 \u003ccode\u003edisableStaticImages\u003c/code\u003e 옵션을 활용하면 예상치 못한 문제도 피할 수 있답니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eNext.js에서 static 이미지 임포트를 비활성화하고 싶다면, \u003ccode\u003enext.config.js\u003c/code\u003e 파일에 아래와 같이 설정할 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eimages\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003edisableStaticImages\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 설정을 하면 정적 이미지 임포트를 끄게 되어, 이미지 파일들을 직접 import 하는 방식 대신 다른 방법으로 이미지를 다루게 돼요. 예를 들어, public 폴더에 이미지를 두고 경로로만 접근하는 방식이죠.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003edangerouslyAllowSVG 옵션에 대해\u003c/h3\u003e\n\u003cp\u003eNext.js 기본 이미지 로더는 SVG 최적화를 지원하지 않는데, 그 이유는 두 가지가 있어요.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eSVG는 벡터 이미지라서 크기를 조절해도 화질 손실이 없어요.\u003c/strong\u003e 그렇기 때문에 변형 과정이 딱히 필요 없죠.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSVG 파일은 HTML/CSS와 비슷한 특성을 갖고 있어서, 제대로 된 Content Security Policy(CSP) 헤더 없이는 보안 취약점이 생길 수 있어요.\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e그래서 \u003ccode\u003edangerouslyAllowSVG\u003c/code\u003e 옵션이 있긴 하지만, 이걸 사용할 땐 보안에 특히 신경 써야 해요. SVG를 사용하면서 보안 문제가 걱정된다면, SVG를 컴포넌트 형태로 다루거나 외부에서 안전하게 처리한 뒤 사용하는 걸 추천합니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e추가 팁!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e만약 SVG를 React 컴포넌트처럼 사용하고 싶다면, \u003ccode\u003e@svgr/webpack\u003c/code\u003e을 쓰는 방법도 있어요. 이걸 쓰면 SVG를 import 해서 SVG 컴포넌트로 만들 수 있죠.\u003c/li\u003e\n\u003cli\u003e그리고 이미지 최적화는 Next.js 이미지 컴포넌트의 핵심 기능 중 하나니까, 가능하면 static 이미지 임포트 기능을 끄기보다는 제대로 활용하는 걸 추천해요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이런 설정 하나하나 이해하고 적용하다 보면 Next.js에서 이미지 다루는 법에 자신감이 생길 거예요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그래서 src 속성이 SVG임이 확실할 때는 unoptimized 속성을 사용하는 걸 추천해요. 실제로 src가 \".svg\"로 끝날 때는 이 부분이 자동으로 적용됩니다.\u003c/p\u003e\n\u003cp\u003e하지만 만약 기본 이미지 최적화 API를 사용해서 SVG 이미지를 제공해야 한다면, next.config.js 파일 안에 dangerouslyAllowSVG 옵션을 설정할 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eimages\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003edangerouslyAllowSVG\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003econtentDispositionType\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'attachment'\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003econtentSecurityPolicy\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"default-src 'self'; script-src 'none'; sandbox;\"\u003c/span\u003e,\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 주의할 점은, SVG 이미지가 종종 악성 스크립트를 포함할 수 있어서 보안 면에서 취약할 수 있다는 거예요. 그래서 contentDispositionType을 'attachment'로 설정해서 브라우저가 이미지를 그냥 보여주는 게 아니라 다운로드하도록 강제하는 걸 추천하고, contentSecurityPolicy를 지정해서 이미지 안에 숨어있는 스크립트가 실행되지 못하도록 막는 것이 매우 중요하답니다.\u003c/p\u003e\n\u003cp\u003e참고로, SVG는 벡터 이미지라서 해상도에 상관없이 선명한 장점이 있지만, 안전하지 않은 SVG를 그대로 사용하면 XSS 공격에 노출될 수 있으니, 가능하면 신뢰할 수 있는 SVG만 쓰거나 이런 보안 설정을 꼭 해주세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003econtentDispositionType\u003c/h3\u003e\n\u003cp\u003e기본적으로 이미지 로더(loader)는 \u003ccode\u003eContent-Disposition\u003c/code\u003e 헤더를 \u003ccode\u003eattachment\u003c/code\u003e로 설정합니다. 이 설정이 중요한 이유는 API가 원격 이미지를 임의로 불러올 수 있기 때문에 보안을 강화하기 위해서예요.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e설정값\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eattachment\u003c/td\u003e\u003ctd\u003e브라우저가 이미지를 직접 방문하면 다운로드하도록 강제함 (기본값)\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003einline\u003c/td\u003e\u003ctd\u003e브라우저가 이미지를 직접 방문했을 때 바로 렌더링해서 보여줌\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e특히, \u003ccode\u003edangerouslyAllowSVG\u003c/code\u003e 옵션이 켜져 있을 경우 \u003ccode\u003eattachment\u003c/code\u003e로 설정하는 것이 더 안전합니다. SVG 파일은 악성코드로 악용될 수 있기 때문에, 무조건 다운받게 만들어서 브라우저가 바로 실행하지 못하게 하는 거죠.\u003c/p\u003e\n\u003cp\u003e하지만 경우에 따라서는 직접 이미지를 방문했을 때 다운로드 받는 게 아니라 바로 화면에 표시되길 원할 수도 있어요. 이런 때는 \u003ccode\u003econtentDispositionType\u003c/code\u003e을 \u003ccode\u003einline\u003c/code\u003e으로 설정하면 됩니다. 그러면 URL을 브라우저에 직접 입력했을 때도 이미지가 바로 보이게 되죠.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e추가 팁!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e만약 내 서비스에서 외부에서 임의로 이미지를 불러오는걸 허용한다면, 보안에 신경 써서 꼭 \u003ccode\u003eattachment\u003c/code\u003e로 두세요.\u003c/li\u003e\n\u003cli\u003eSVG는 특히 조심해야 하니, 내장 SVG가 아닌 외부 SVG를 불러올 때는 \u003ccode\u003einline\u003c/code\u003e보다는 \u003ccode\u003eattachment\u003c/code\u003e를 추천해요.\u003c/li\u003e\n\u003cli\u003e하지만 사용자 경험(UX)을 고려해 이미지 바로 보기가 자주 필요한 서비스라면 \u003ccode\u003einline\u003c/code\u003e 설정을 고려해볼 수 있습니다. 이럴 땐 SVG 보안 이슈도 신경 써주세요!\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e자, 이번에는 Next.js에서 이미지 최적화와 애니메이션 이미지 다루는 방법에 대해 살펴볼게요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eimages\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003econtentDispositionType\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'inline'\u003c/span\u003e,\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 설정 코드는 이미지 응답 시 \u003ccode\u003eContent-Disposition\u003c/code\u003e 헤더를 'inline'으로 설정해주는 거예요. 이렇게 하면 브라우저가 이미지를 다운로드하지 않고, 바로 화면에 표시하도록 하는 역할을 해요. 이미지를 웹페이지 내에서 자연스럽게 보여주고 싶을 때 유용하죠.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e애니메이션 이미지 처리\u003c/h2\u003e\n\u003cp\u003eNext.js의 기본 이미지 로더는 애니메이션이 들어간 이미지(예: GIF, APNG, WebP)가 들어오면 자동으로 이미지 최적화를 건너뛰고 원본 그대로 이미지를 서빙해줍니다. 왜냐면 애니메이션 이미지 최적화는 조금 까다롭고, 최적화 과정에서 애니메이션이 깨질 위험이 있거든요.\u003c/p\u003e\n\u003cp\u003e자동으로 애니메이션인지 판단하는 기능은 완벽하진 않지만, 대부분의 경우 GIF, APNG, WebP 파일 포맷을 기준으로 잘 감지해 줍니다.\u003c/p\u003e\n\u003cp\u003e만약 특정 애니메이션 이미지에 대해서 확실하게 최적화를 건너뛰고 싶다면, Next.js의 \u003ccode\u003eImage\u003c/code\u003e 컴포넌트에 \u003ccode\u003eunoptimized\u003c/code\u003e 속성을 추가해주면 돼요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/image'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eMyComponent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eImage\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"/animated-image.gif\"\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"애니메이션 이미지\"\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{500}\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{300}\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eunoptimized\u003c/span\u003e // \u003cspan class=\"hljs-attr\"\u003e이\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e속성\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e덕분에\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e해당\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e이미지는\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e최적화\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e없이\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e바로\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e서빙됩니다.\u003c/span\u003e\n    /\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e추가 팁!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eGIF 대신 WebP 포맷으로 애니메이션 이미지를 사용하는 것도 좋은 방법이에요. WebP는 파일 크기는 훨씬 작으면서도 화질을 잘 유지하거든요.\u003c/li\u003e\n\u003cli\u003eNext.js에서 자동 최적화를 사용하면 성능이 좋아지지만, 애니메이션 이미지 때문에 어쩔 수 없이 건너뛰는 경우가 있으니, 애니메이션 이미지가 많다면 CDN 또는 별도의 외부 이미지 서버를 사용하는 것도 고려해보세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e요약하면, Next.js는 애니메이션 이미지에 대해 친절한 자동 최적화를 제공하지만, 100% 완벽하진 않아서 직접 \u003ccode\u003eunoptimized\u003c/code\u003e 플래그를 활용하는 게 좋고, \u003ccode\u003econtentDispositionType: 'inline'\u003c/code\u003e 설정으로 이미지를 웹 내에서 부드럽게 다룰 수 있다는 이야기였습니다!\u003c/p\u003e\n\u003cp\u003e필요하면 언제든지 더 구체적인 사용법도 알려드릴게요 :)\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e반응형 이미지 만들기\u003c/h2\u003e\n\u003cp\u003e웹 개발하다 보면 다양한 기기별 해상도를 지원하기 위해 이미지도 그에 맞게 잘 보여줘야 할 때가 많죠. 기본적으로 srcset 속성에는 1x, 2x 해상도 이미지가 들어가서 화면의 픽셀 밀도에 맞춰 이미지를 바꿔주는데요. 하지만, 뷰포트 크기에 따라 이미지 크기도 유동적으로 바꾸고 싶다면, srcset 뿐만 아니라 sizes 속성도 함께 설정해줘야 합니다. 그리고 스타일이나 className으로 이미지 크기를 조정하는 것도 중요하죠.\u003c/p\u003e\n\u003cp\u003e아래는 반응형 이미지를 만드는 몇 가지 방법 중 하나인 '정적 import 사용하기' 예시입니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e정적 임포트로 반응형 이미지 만들기\u003c/h3\u003e\n\u003cp\u003eReact나 Next.js 같은 환경에서 자주 쓰이는 방식인데요, 이미지를 프로젝트 안에서 import 해서 쓸 때 유용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e responsiveImg \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'../public/images/responsive-image.jpg'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eMyComponent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{responsiveImg.src}\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003esrcSet\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e`${\u003cspan class=\"hljs-attr\"\u003eresponsiveImg.src\u003c/span\u003e} \u003cspan class=\"hljs-attr\"\u003e1x\u003c/span\u003e, ${\u003cspan class=\"hljs-attr\"\u003eresponsiveImg.src.replace\u003c/span\u003e('\u003cspan class=\"hljs-attr\"\u003e.jpg\u003c/span\u003e', '@\u003cspan class=\"hljs-attr\"\u003e2x.jpg\u003c/span\u003e')} \u003cspan class=\"hljs-attr\"\u003e2x\u003c/span\u003e`}\n      \u003cspan class=\"hljs-attr\"\u003esizes\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"(max-width: 600px) 100vw, 50vw\"\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{{\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ewidth:\u003c/span\u003e '\u003cspan class=\"hljs-attr\"\u003e100\u003c/span\u003e%', \u003cspan class=\"hljs-attr\"\u003eheight:\u003c/span\u003e '\u003cspan class=\"hljs-attr\"\u003eauto\u003c/span\u003e' }}\n      \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"Responsive example\"\u003c/span\u003e\n    /\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003cp\u003e여기서 sizes 속성은 뷰포트 너비가 600px 이하일 때 이미지가 화면 너비(100vw)의 100%를 차지하고, 그 이상일 땐 50%를 차지하도록 지정하는 거예요. 이렇게 하면 작은 화면에선 이미지가 꽉 차 보이고, 큰 화면에선 절반 크기로 나란히 배치하기 좋아요.\u003c/p\u003e\n\u003cp\u003e그리고 style이나 className으로 \u003ccode\u003ewidth: 100%\u003c/code\u003e를 주면 이미지가 부모 컨테이너의 크기에 맞게 늘어나거나 줄어듭니다. height는 auto로 하면 비율이 유지돼서 이미지가 찌그러지지 않죠.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e팁!\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이미지를 더 다양하게 반응형으로 다루고 싶으면 picture 태그와 함께 여러 해상도, 형식(webp, jpeg 등)을 srcSet에 넣어주는 것도 좋은 방법이에요.\u003c/li\u003e\n\u003cli\u003eNext.js를 쓰는 분들이라면 내장된 Image 컴포넌트를 활용하면 알아서 최적화 해주니 더 쉽게 반응형 이미지를 만들 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이제 images 태그만 써도 다양한 기기에서 딱 예쁘게 보여줄 수 있으니 꼭 sizes값과 css 조합도 함께 고려해보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e만약 이미지가 정적(변하지 않는) 소스라면, 이렇게 statically import해서 반응형 이미지(Responsive Image)를 쉽게 만들 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/image'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e me \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'../photos/me.jpg'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eAuthor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eImage\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{me}\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"Picture of the author\"\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003esizes\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"100vw\"\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{{\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003ewidth:\u003c/span\u003e '\u003cspan class=\"hljs-attr\"\u003e100\u003c/span\u003e%',\n        \u003cspan class=\"hljs-attr\"\u003eheight:\u003c/span\u003e '\u003cspan class=\"hljs-attr\"\u003eauto\u003c/span\u003e',\n      }}\n    /\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 코드에서 중요한 점은 \u003ccode\u003esizes=\"100vw\"\u003c/code\u003e예요. 이 설정 덕분에 이미지가 뷰포트(Viewport) 너비 100%에 맞춰서 크기가 조절돼요. 그리고 \u003ccode\u003estyle\u003c/code\u003e로 \u003ccode\u003ewidth: '100%'\u003c/code\u003e 그리고 \u003ccode\u003eheight: 'auto'\u003c/code\u003e를 줘서 이미지 비율을 유지하며 폭에 맞게 크기가 변하게 됩니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e왜 이렇게 하는 걸까?\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e정적 import\u003c/strong\u003e는 번들링할 때 이미지 정보를 미리 알아서, 최적화된 사이즈를 자동으로 만들어줘서 페이지 로딩 속도가 빨라져요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enext/image\u003c/code\u003e 컴포넌트 자체가 여러 크기의 이미지를 제공해주고, 뷰포트에 따라 적절한 사이즈의 이미지를 불러오기 때문에 데이터 사용량도 줄일 수 있답니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esizes\u003c/code\u003e 속성은 반응형 이미지에서 어떤 폭에서 이미지를 얼마나 크게 보여줄 지 브라우저에 알려주는 역할을 해요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003e한번 해보세요!\u003c/h3\u003e\n\u003cp\u003e위 코드를 페이지에 넣고 브라우저 창 크기를 조절해서 이미지가 폭에 맞춰 잘 변하는지 확인해 보면 정말 반응형 이미지임을 체감할 수 있을 거예요.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e만약 이미지를 동적으로 불러야 한다면, 다음 시간에 그 방법도 알려드릴게요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003e반응형 이미지에 비율 맞추기\u003c/h3\u003e\n\u003cp\u003e웹에서 이미지를 쓸 때 특히 원본 이미지가 동적이거나 외부 URL일 경우, 반응형으로 잘 보여주려면 이미지의 가로(width)와 세로(height)를 꼭 지정해줘야 해요. 그래야 이미지가 비율을 유지하면서 화면 크기에 맞게 조절되거든요.\u003c/p\u003e\n\u003cp\u003eNext.js의 \u003ccode\u003enext/image\u003c/code\u003e 컴포넌트를 예로 들어볼게요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/image'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ photoUrl }\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eImage\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{photoUrl}\u003c/span\u003e            // \u003cspan class=\"hljs-attr\"\u003e동적\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e혹은\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e외부\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e주소로\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e이미지\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e호출\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"Picture of the author\"\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003esizes\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"100vw\"\u003c/span\u003e             // \u003cspan class=\"hljs-attr\"\u003e화면\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e전체\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e폭에\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e맞춰서\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e크기를\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e조절\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{{\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003ewidth:\u003c/span\u003e '\u003cspan class=\"hljs-attr\"\u003e100\u003c/span\u003e%',          // \u003cspan class=\"hljs-attr\"\u003e가로는\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e부모\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e컨테이너에\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e딱\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e맞게\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eheight:\u003c/span\u003e '\u003cspan class=\"hljs-attr\"\u003eauto\u003c/span\u003e',         // \u003cspan class=\"hljs-attr\"\u003e세로는\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e비율에\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e맞게\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e자동\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e조절\u003c/span\u003e\n      }}\n      \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{500}\u003c/span\u003e               // \u003cspan class=\"hljs-attr\"\u003e이미지의\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e원본\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e가로\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e크기\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{300}\u003c/span\u003e              // \u003cspan class=\"hljs-attr\"\u003e이미지의\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e원본\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e세로\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e크기\u003c/span\u003e\n    /\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 \u003ccode\u003ewidth={500}\u003c/code\u003e과 \u003ccode\u003eheight={300}\u003c/code\u003e은 원본 이미지의 가로, 세로 크기를 나타내고, \u003ccode\u003estyle\u003c/code\u003e에서 \u003ccode\u003ewidth: 100%\u003c/code\u003e로 설정해주면 화면 크기에 딱 맞춰서 이미지 크기가 바뀌면서도 가로세로 비율이 깨지지 않아요.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e실제로 \u003ccode\u003enext/image\u003c/code\u003e는 \u003ccode\u003ewidth\u003c/code\u003e, \u003ccode\u003eheight\u003c/code\u003e 정보가 있어야 이미지 사이즈 계산과 레이아웃 잡는 데 도움을 줘서 CLS(Cumulative Layout Shift) 같은 레이아웃 깨짐 문제도 예방할 수 있답니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003cp\u003e추가로, 반응형 이미지를 만들 때 기억하면 좋은 점!\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e팁\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003esizes\u003c/code\u003e 속성\u003c/td\u003e\u003ctd\u003e뷰포트(viewport) 크기에 따라 어떤 크기의 이미지를 로딩할지 브라우저에 알려줍니다. \u003ccode\u003e100vw\u003c/code\u003e는 화면 전체 너비를 뜻해요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003estyle\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eCSS로 가로 세로 비율을 조절하지만 원본 비율과 다르면 이미지가 찌그러질 수 있어 비율 맞추는 게 중요해요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e원본 크기 지정\u003c/td\u003e\u003ctd\u003e\u003ccode\u003ewidth\u003c/code\u003e와 \u003ccode\u003eheight\u003c/code\u003e를 지정해야 브라우저가 최적의 이미지를 불러오고 레이아웃이 안정적이에요!\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e필요하다면, CSS로 부모 요소에 \u003ccode\u003emax-width\u003c/code\u003e를 정해서 너무 커지지 않도록 제한하는 것도 좋아요.\u003c/p\u003e\n\u003cp\u003e오늘은 이렇게 동적 이미지로 반응형 이미지를 깔끔하게 다루는 방법을 알아봤어요. 실무에서 꽤 자주 쓰이니 한번 써보시면서 감 잡아보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003e뷰포트에 반응하는 이미지 데모\u003c/h3\u003e\n\u003ch4\u003e이미지의 가로세로 비율(aspect ratio)을 모를 때 - \u003ccode\u003efill\u003c/code\u003e 속성 활용법\u003c/h4\u003e\n\u003cp\u003e이미지를 반응형으로 만들고 싶은데, 이미지의 정확한 가로세로 비율을 모를 경우가 있죠? 그럴 땐 부모 요소에 \u003ccode\u003eposition: relative\u003c/code\u003e를 주고, Next.js의 \u003ccode\u003eImage\u003c/code\u003e 컴포넌트에 \u003ccode\u003efill\u003c/code\u003e 속성을 사용하면 꽉 차게 이미지가 들어가요. 이때 \u003ccode\u003eobject-fit\u003c/code\u003e 스타일로 이미지가 어떻게 맞춰질지 정할 수 있는데, \u003ccode\u003e'contain'\u003c/code\u003e으로 하면 이미지가 찌그러지거나 잘리지 않고 꽉 차도록 조절해 줍니다.\u003c/p\u003e\n\u003cp\u003e아래 예시 코드를 보시면 이해가 빠르실 거에요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/image'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ photoUrl }\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{{\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eposition:\u003c/span\u003e '\u003cspan class=\"hljs-attr\"\u003erelative\u003c/span\u003e', \u003cspan class=\"hljs-attr\"\u003ewidth:\u003c/span\u003e '\u003cspan class=\"hljs-attr\"\u003e300px\u003c/span\u003e', \u003cspan class=\"hljs-attr\"\u003eheight:\u003c/span\u003e '\u003cspan class=\"hljs-attr\"\u003e500px\u003c/span\u003e' }}\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eImage\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{photoUrl}\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"Picture of the author\"\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003esizes\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"300px\"\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003efill\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{{\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eobjectFit:\u003c/span\u003e '\u003cspan class=\"hljs-attr\"\u003econtain\u003c/span\u003e',\n        }}\n      /\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ediv\u003c/code\u003e에 \u003ccode\u003eposition: relative\u003c/code\u003e를 줘야 \u003ccode\u003efill\u003c/code\u003e로 설정된 이미지가 부모 영역을 기준으로 꽉 채울 수 있어요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ewidth\u003c/code\u003e와 \u003ccode\u003eheight\u003c/code\u003e를 고정 또는 반응형 단위로 지정해주면 이미지 크기가 결정되고, 그 안에서 \u003ccode\u003efill\u003c/code\u003e이 동작하는 거죠.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eobjectFit\u003c/code\u003e을 \u003ccode\u003e'contain'\u003c/code\u003e으로 하면 이미지가 영역 내에 꽉 차면서 비율이 유지되고, \u003ccode\u003e'cover'\u003c/code\u003e로 설정하면 영역을 가득 채우되 일부 잘릴 수도 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e추가 팁!\u003cbr\u003e\n만약 이미지가 부모 크기에 맞춰 유연하게 크기가 변하길 원한다면, 부모 요소를 미디어 쿼리나 CSS 그리드/플렉스를 활용해 동적으로 크기를 조절하는 방법도 있어요. 그러면 \u003ccode\u003efill\u003c/code\u003e과 함께 더 자연스러운 반응형 이미지를 구현할 수 있습니다!\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e한번 해볼까요?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003efill prop을 활용하는 데모\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e테마 감지 CSS\u003c/h2\u003e\n\u003cp\u003e웹사이트를 만들 때, 라이트 모드와 다크 모드에 따라 다른 이미지를 보여주고 싶을 때가 있죠? 이럴 때는 두 개의 \u003ccode\u003eImage\u003c/code\u003e 컴포넌트를 감싸는 새로운 컴포넌트를 만들어서 CSS 미디어 쿼리를 활용해 적절한 이미지만 보여주도록 할 수 있어요.\u003c/p\u003e\n\u003cp\u003e예를 들어, CSS의 \u003ccode\u003eprefers-color-scheme\u003c/code\u003e 미디어 쿼리를 사용하면 사용자가 설정한 테마(라이트 or 다크)에 따라 다른 스타일이나 이미지를 적용할 수 있답니다. 이를 이용하면 자바스크립트로 복잡한 조건문을 작성하지 않아도, 아주 깔끔하게 테마별 이미지를 처리할 수 있어요.\u003c/p\u003e\n\u003cp\u003e아래는 이 개념을 활용한 간단한 예시입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/image'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eThemeImage\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eImage\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"/images/light-mode.png\"\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"라이트 모드 이미지\"\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"light-image\"\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{200}\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{200}\u003c/span\u003e\n      /\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eImage\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"/images/dark-mode.png\"\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"다크 모드 이미지\"\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"dark-image\"\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{200}\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{200}\u003c/span\u003e\n      /\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003estyle\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ejsx\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"css\"\u003e{`\n        \u003cspan class=\"hljs-selector-class\"\u003e.light-image\u003c/span\u003e {\n          \u003cspan class=\"hljs-attribute\"\u003edisplay\u003c/span\u003e: block;\n        }\n        \u003cspan class=\"hljs-selector-class\"\u003e.dark-image\u003c/span\u003e {\n          \u003cspan class=\"hljs-attribute\"\u003edisplay\u003c/span\u003e: none;\n        }\n        \u003cspan class=\"hljs-keyword\"\u003e@media\u003c/span\u003e (\u003cspan class=\"hljs-attribute\"\u003eprefers-color-scheme\u003c/span\u003e: dark) {\n          \u003cspan class=\"hljs-selector-class\"\u003e.light-image\u003c/span\u003e {\n            \u003cspan class=\"hljs-attribute\"\u003edisplay\u003c/span\u003e: none;\n          }\n          \u003cspan class=\"hljs-selector-class\"\u003e.dark-image\u003c/span\u003e {\n            \u003cspan class=\"hljs-attribute\"\u003edisplay\u003c/span\u003e: block;\n          }\n        }\n      `}\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003estyle\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n};\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eThemeImage\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드에서는 기본적으로 라이트 모드 이미지를 보여주고, 다크 모드가 감지되면 다크 모드 이미지만 보이도록 CSS로 조절해줍니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e추가로 팁 하나!\u003c/p\u003e\n\u003cp\u003e만약 이미지가 너무 많아서 이렇게 일일이 컴포넌트를 만들기 번거롭다면, \u003ca href=\"https://developer.mozilla.org/ko/docs/Web/HTML/Element/picture\" rel=\"nofollow\" target=\"_blank\"\u003epicture 태그\u003c/a\u003e와 \u003ccode\u003esource\u003c/code\u003e 태그를 활용하는 방법도 있어요. \u003ccode\u003esource\u003c/code\u003e의 \u003ccode\u003emedia\u003c/code\u003e 속성에 \u003ccode\u003eprefers-color-scheme\u003c/code\u003e 조건을 넣으면 브라우저가 자동으로 맞는 이미지를 골라줍니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u0026#x3C;picture\u003e\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003esource\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrcSet\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"/images/dark-mode.png\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003emedia\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"(prefers-color-scheme: dark)\"\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"/images/light-mode.png\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"테마별 이미지\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{200}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{200}\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e\n\u0026#x3C;/picture\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 자바스크립트나 추가 CSS 없이도 손쉽게 테마별 이미지를 관리할 수 있어서 더 깔끔하니 참고해보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이번 시간에는 다크모드 지원을 할 때 이미지도 알아서 라이트모드용, 다크모드용 이미지를 잘 보여주게 하는 간단한 방법을 소개해 드릴게요. CSS와 Next.js를 함께 활용한 스타일링과 컴포넌트 설계법을 보면서, 실제로 어떻게 이미지 로딩이 최적화되는지도 짚어보려 합니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e1. CSS로 다크모드에 따라 보이기/숨기기 설정하기\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-css\"\u003e\u003cspan class=\"hljs-selector-class\"\u003e.imgDark\u003c/span\u003e {\n  \u003cspan class=\"hljs-attribute\"\u003edisplay\u003c/span\u003e: none;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003e@media\u003c/span\u003e (\u003cspan class=\"hljs-attribute\"\u003eprefers-color-scheme\u003c/span\u003e: dark) {\n  \u003cspan class=\"hljs-selector-class\"\u003e.imgLight\u003c/span\u003e {\n    \u003cspan class=\"hljs-attribute\"\u003edisplay\u003c/span\u003e: none;\n  }\n  \u003cspan class=\"hljs-selector-class\"\u003e.imgDark\u003c/span\u003e {\n    \u003cspan class=\"hljs-attribute\"\u003edisplay\u003c/span\u003e: unset;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e.imgDark\u003c/code\u003e 이미지는 기본적으로 숨겨져 있어요.\u003c/li\u003e\n\u003cli\u003e사용자의 OS나 브라우저가 다크모드를 감지하면(\u003ccode\u003eprefers-color-scheme: dark\u003c/code\u003e), \u003ccode\u003e.imgLight\u003c/code\u003e 이미지는 숨기고 \u003ccode\u003e.imgDark\u003c/code\u003e 이미지는 보여주게 됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이렇게만 해줘도 다크모드 감지 시 자동으로 이미지를 바꿔서 보여줄 수 있죠.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e2. Next.js 컴포넌트로 깔끔하게 관리하기\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-tsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e styles \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./theme-image.module.css'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e, { \u003cspan class=\"hljs-title class_\"\u003eImageProps\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/image'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eProps\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eOmit\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eImageProps\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'src'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'priority'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'loading'\u003c/span\u003e\u003e \u0026#x26; {\n  \u003cspan class=\"hljs-attr\"\u003esrcLight\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003esrcDark\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eThemeImage\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003eprops: Props\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { srcLight, srcDark, ...rest } = props\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eImage\u003c/span\u003e {\u003cspan class=\"hljs-attr\"\u003e...rest\u003c/span\u003e} \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{srcLight}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.imgLight}\u003c/span\u003e /\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eImage\u003c/span\u003e {\u003cspan class=\"hljs-attr\"\u003e...rest\u003c/span\u003e} \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{srcDark}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.imgDark}\u003c/span\u003e /\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eNext.js의 \u003ccode\u003eImage\u003c/code\u003e 컴포넌트를 한 번에 두 개 넣고, CSS로 어느 이미지를 보여줄지 제어하는 방식입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePriority\u003c/code\u003e나 \u003ccode\u003eloading=\"eager\"\u003c/code\u003e를 쓰면 이미지가 모두 로드되어 버려서 비효율적이므로 \u003cstrong\u003e기본 \u003ccode\u003eloading=\"lazy\"\u003c/code\u003e 속성을 이용\u003c/strong\u003e하거나 **\u003ccode\u003efetchPriority=\"high\"\u003c/code\u003e**를 활용하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003e3. 핵심 포인트: 이미지 로딩 최적화\u003c/h3\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e고려사항\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e기본 로딩 방식\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eloading=\"lazy\"\u003c/code\u003e는 스크롤 등 사용자 행동에 맞게 이미지를 불러옵니다. 이 덕분에 안 보이는 이미지는 바로 로드되지 않아요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003epriority\u003c/code\u003e 속성 사용 제한\u003c/td\u003e\u003ctd\u003e라이트/다크용 이미지가 동시에 로드되기 때문에 \u003ccode\u003epriority\u003c/code\u003e를 쓰면 번거로워질 수 있습니다.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003efetchPriority\u003c/code\u003e 활용\u003c/td\u003e\u003ctd\u003eNext.js 13부터 새로 도입된 \u003ccode\u003efetchPriority=\"high\"\u003c/code\u003e를 이용하면 우선순위 지정이 가능하지만, 옮겨서 써야 하는 상황이라는 점 참고!\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003ch3\u003e간단 요약\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eCSS 미디어 쿼리로 라이트/다크 이미지를 제어하자.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enext/image\u003c/code\u003e를 두 개 겹쳐서 쓰되, 실제 보여줄 이미지만 노출되도록 CSS로 관리하자.\u003c/li\u003e\n\u003cli\u003e불필요한 이미지 로딩을 막기 위해 기본 \u003ccode\u003eloading=\"lazy\"\u003c/code\u003e를 사용하자. 필요할 땐 \u003ccode\u003efetchPriority=\"high\"\u003c/code\u003e도 써보자.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003e덧붙여서 알려드리는 팁!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e만약 이미지가 너무 많거나 용량이 크다면, 라이트/다크 모드 전환 시 자바스크립트로 이미지를 동적으로 교체하는 방법도 고려할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e또 CSS \u003ccode\u003eimage-set\u003c/code\u003e 같은 기능도 사용해볼 수 있지만, 브라우저 지원이 조금씩 다르니 꼭 테스트하세요!\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e다크모드 시대에 잘 맞춰 사용자 경험을 선물해주는 테마별 이미지 처리, 어렵지 않지요? 직접 코드를 돌려보면서 이미지 교체가 매끄럽게 되는 걸 느껴보시면 이해가 훨씬 쉬워집니다.\u003c/p\u003e\n\u003cp\u003e그럼 즐거운 개발 하세요! 🚀\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e데모: 라이트/다크 모드 테마 감지\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003egetImageProps 함수\u003c/h2\u003e\n\u003cp\u003e조금 더 고급 활용법을 원할 때는 getImageProps() 함수를 호출해서, 실제 \u003ccode\u003eimg\u003c/code\u003e 태그에 들어갈 props들을 받아올 수 있어요. 그리고 이 props들을 다른 컴포넌트나 스타일, 혹은 캔버스 등에 넘겨서 자유롭게 사용할 수 있죠.\u003c/p\u003e\n\u003cp\u003e이 방법의 좋은 점은 React의 useState()를 사용하지 않기 때문에 퍼포먼스가 좀 더 좋아질 수 있다는 거예요. (useState를 쓰면 상태 변경으로 리렌더링이 발생할 수 있거든요.) 하지만 여기서 주의할 점은 placeholder prop과 함께 사용할 수 없다는 겁니다! 왜냐하면 placeholder가 한 번 설정되면 절대 사라지지 않거든요.\u003c/p\u003e\n\u003cp\u003e즉, 이미지 로딩 상태를 직접 관리하거나, 커스텀한 방식으로 이미지를 표시하고 싶을 때 이 함수를 쓰면 꽤 유용하겠죠? 다만, 나중에 placeholder 효과를 구현하고 싶다면 다른 방법을 고민해야 합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003e테마 감지용 이미지 바꾸기\u003c/h3\u003e\n\u003cp\u003e웹사이트를 만들 때, 라이트 모드와 다크 모드에 따라 다른 이미지를 보여주고 싶을 때가 있죠? 이럴 때 유용한 방법이 바로 \u003ccode\u003epicture\u003c/code\u003e 태그를 활용하는 거예요. 사용자 브라우저가 선호하는 색상 모드(라이트/다크)를 감지해서 그에 맞는 이미지를 자동으로 보여줄 수 있답니다.\u003c/p\u003e\n\u003cp\u003e아래는 Next.js에서 \u003ccode\u003enext/image\u003c/code\u003e의 \u003ccode\u003egetImageProps\u003c/code\u003e를 활용해, 라이트/다크 모드별로 서로 다른 이미지를 설정하는 예시 코드입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { getImageProps } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/image'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e common = { \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Theme Example'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e800\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e400\u003c/span\u003e }\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003eprops\u003c/span\u003e: { \u003cspan class=\"hljs-attr\"\u003esrcSet\u003c/span\u003e: dark },\n  } = \u003cspan class=\"hljs-title function_\"\u003egetImageProps\u003c/span\u003e({ ...common, \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/dark.png'\u003c/span\u003e })\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003eprops\u003c/span\u003e: { \u003cspan class=\"hljs-attr\"\u003esrcSet\u003c/span\u003e: light, ...rest },\n  } = \u003cspan class=\"hljs-title function_\"\u003egetImageProps\u003c/span\u003e({ ...common, \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/light.png'\u003c/span\u003e })\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003epicture\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003esource\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003emedia\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"(prefers-color-scheme: dark)\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrcSet\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{dark}\u003c/span\u003e /\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003esource\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003emedia\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"(prefers-color-scheme: light)\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrcSet\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{light}\u003c/span\u003e /\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e {\u003cspan class=\"hljs-attr\"\u003e...rest\u003c/span\u003e} /\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003epicture\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003e여기서 알아두면 좋은 점!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003epicture\u003c/code\u003e 태그\u003c/strong\u003e: 여러 이미지를 상황에 맞게 골라 보여주기 위해 쓰여요. \u003ccode\u003e\u0026#x3C;source\u003e\u003c/code\u003e에 조건(미디어쿼리)을 걸고, 마지막 \u003ccode\u003e\u0026#x3C;img\u003e\u003c/code\u003e 태그가 기본 이미지 역할을 해주죠.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eprefers-color-scheme\u003c/code\u003e 미디어 쿼리\u003c/strong\u003e: 사용자 기기의 모드 설정을 감지해 \u003ccode\u003edark\u003c/code\u003e나 \u003ccode\u003elight\u003c/code\u003e 여부를 판단해요.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eNext.js의 \u003ccode\u003egetImageProps\u003c/code\u003e\u003c/strong\u003e: 이미지를 최적화하고 메타 정보를 제공해서, 별도의 수동 작업 없이도 쉽게 이미지 관련 속성을 얻을 수 있어요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003e추가 팁!\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e이미지 파일을 많이 만드는 게 번거롭다면, CSS 필터(예: \u003ccode\u003efilter: invert(1)\u003c/code\u003e)를 활용해 이미지 색상을 조절하는 방법도 있어요. 단, 복잡한 이미지엔 적용하기 어려울 수 있답니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e다크 모드 이미지를 SVG로 만들면 색상 변경도 더 자유롭고, 용량도 줄일 수 있으니 참고하세요.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003epicture\u003c/code\u003e 태그가 구형 브라우저에서는 지원되지 않을 수 있으니, 꼭 호환성 체크도 해보시면서 사용하시길 추천드립니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003cp\u003e다음에는 ‘아트 디렉션’(Art Direction)을 위해서 어떻게 이미지 크기나 구성을 바꾸는지에 대해 다뤄볼게요! 디자인 변화에 따라 이미지를 컨트롤하는 재미난 방법들이 많이 있답니다. 기대해주세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e데스크탑과 모바일에서 각각 다른 이미지를 보여주고 싶을 때, 흔히 'Art Direction(아트 디렉션)'이라고 불러요.\u003cbr\u003e\n이럴 때는 \u003ccode\u003egetImageProps()\u003c/code\u003e 함수에 각 기기별로 다른 \u003ccode\u003esrc\u003c/code\u003e, \u003ccode\u003ewidth\u003c/code\u003e, \u003ccode\u003eheight\u003c/code\u003e, \u003ccode\u003equality\u003c/code\u003e 값을 넘겨줘서 손쉽게 처리할 수 있답니다.\u003c/p\u003e\n\u003cp\u003e아래 예제를 보면 조금 더 이해하기 쉬울 거예요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { getImageProps } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/image'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eHome\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e common = { \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Art Direction Example'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003esizes\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'100vw'\u003c/span\u003e }\n\n  \u003cspan class=\"hljs-comment\"\u003e// 데스크탑용 이미지 속성 가져오기\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003eprops\u003c/span\u003e: { \u003cspan class=\"hljs-attr\"\u003esrcSet\u003c/span\u003e: desktop },\n  } = \u003cspan class=\"hljs-title function_\"\u003egetImageProps\u003c/span\u003e({\n    ...common,\n    \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1440\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e875\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003equality\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e80\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/desktop.jpg'\u003c/span\u003e,\n  })\n\n  \u003cspan class=\"hljs-comment\"\u003e// 모바일용 이미지 속성 가져오기\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003eprops\u003c/span\u003e: { \u003cspan class=\"hljs-attr\"\u003esrcSet\u003c/span\u003e: mobile, ...rest },\n  } = \u003cspan class=\"hljs-title function_\"\u003egetImageProps\u003c/span\u003e({\n    ...common,\n    \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e750\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1334\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003equality\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e70\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/mobile.jpg'\u003c/span\u003e,\n  })\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003epicture\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003esource\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003emedia\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"(min-width: 1000px)\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrcSet\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{desktop}\u003c/span\u003e /\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003esource\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003emedia\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"(min-width: 500px)\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrcSet\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{mobile}\u003c/span\u003e /\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e {\u003cspan class=\"hljs-attr\"\u003e...rest\u003c/span\u003e} \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{{\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ewidth:\u003c/span\u003e '\u003cspan class=\"hljs-attr\"\u003e100\u003c/span\u003e%', \u003cspan class=\"hljs-attr\"\u003eheight:\u003c/span\u003e '\u003cspan class=\"hljs-attr\"\u003eauto\u003c/span\u003e' }} /\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003epicture\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e\u0026#x3C;picture\u003e\u003c/code\u003e 태그와 \u003ccode\u003e\u0026#x3C;source\u003e\u003c/code\u003e를 사용해서 화면 크기에 맞는 이미지를 선택하도록 해주는데요, 브라우저가 조건에 맞는 첫 번째 \u003ccode\u003e\u0026#x3C;source\u003e\u003c/code\u003e를 찾아 이미지를 보여주고, 맞는 게 없으면 \u003ccode\u003e\u0026#x3C;img\u003e\u003c/code\u003e 태그에 있는 이미지가 기본으로 나옵니다.\u003c/p\u003e\n\u003cp\u003e그리고 여기서 \u003ccode\u003egetImageProps()\u003c/code\u003e로 반환받은 \u003ccode\u003esrcSet\u003c/code\u003e은 여러 해상도 이미지를 브라우저가 자동으로 선택하게 도와줘서, 고해상도 기기에서도 선명한 이미지를 볼 수 있습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003eCSS 배경 이미지에 활용하기\u003c/h3\u003e\n\u003cp\u003e사실 이미지를 태그로만 쓰는 게 아니라, CSS \u003ccode\u003ebackground-image\u003c/code\u003e로도 활용할 수 있어요.\u003cbr\u003e\n이때 \u003ccode\u003esrcSet\u003c/code\u003e 문자열을 CSS의 \u003ccode\u003eimage-set()\u003c/code\u003e 함수로 변환해서 반응형 배경 이미지를 만들 수 있답니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 이렇게 쓸 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-css\"\u003e\u003cspan class=\"hljs-attribute\"\u003ebackground-image\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003eimage-set\u003c/span\u003e(\n  \u003cspan class=\"hljs-built_in\"\u003eurl\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/image-1x.png'\u003c/span\u003e) \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003ex,\n  \u003cspan class=\"hljs-built_in\"\u003eurl\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/image-2x.png'\u003c/span\u003e) \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003ex\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eimage-set()\u003c/code\u003e 함수는 해상도에 따라 다른 이미지를 로드하도록 도와주는데, 그렇게 하면 모바일과 데스크탑의 배경 이미지를 각각 최적화할 수 있어요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e이렇게 활용해보세요!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e이미지 용량과 해상도를 따로 조절해서 모바일에서는 가볍고, 데스크탑에서는 선명한 이미지를 제공할 수 있어요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026#x3C;picture\u003e\u003c/code\u003e 태그를 활용하면 SEO와 접근성에도 좋아요. \u003ccode\u003e\u0026#x3C;img\u003e\u003c/code\u003e의 \u003ccode\u003ealt\u003c/code\u003e 속성을 꼭 챙기는 것도 잊지 말고요!\u003c/li\u003e\n\u003cli\u003eCSS \u003ccode\u003eimage-set()\u003c/code\u003e으로 배경 이미지에 반응형을 적용해보면 디자인 퀄리티가 더 좋아질 수 있답니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이미지 아트 디렉션, 처음에는 조금 복잡해 보여도 차근차근 손에 익으면서 효과를 톡톡히 볼 수 있을 거예요.\u003cbr\u003e\n필요하면 제가 배경 이미지용 \u003ccode\u003eimage-set()\u003c/code\u003e 변환법도 예제로 한번 더 알려드릴게요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eJS와 Next.js의 next/image 컴포넌트를 활용해서 배경 이미지를 다루는 예제와, 관련한 브라우저 호환 이슈를 알아볼게요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e배경 이미지로 next/image srcSet 활용하기\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { getImageProps } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/image'\u003c/span\u003e;\n \n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetBackgroundImage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003esrcSet = \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e imageSet = srcSet\n    .\u003cspan class=\"hljs-title function_\"\u003esplit\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e', '\u003c/span\u003e)\n    .\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003estr\u003c/span\u003e) =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [url, dpi] = str.\u003cspan class=\"hljs-title function_\"\u003esplit\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e' '\u003c/span\u003e);\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e`url(\"\u003cspan class=\"hljs-subst\"\u003e${url}\u003c/span\u003e\") \u003cspan class=\"hljs-subst\"\u003e${dpi}\u003c/span\u003e`\u003c/span\u003e;\n    })\n    .\u003cspan class=\"hljs-title function_\"\u003ejoin\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e', '\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e`image-set(\u003cspan class=\"hljs-subst\"\u003e${imageSet}\u003c/span\u003e)`\u003c/span\u003e;\n}\n \n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eHome\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003eprops\u003c/span\u003e: { srcSet },\n  } = \u003cspan class=\"hljs-title function_\"\u003egetImageProps\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e128\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e128\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/img.png'\u003c/span\u003e });\n  \n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e backgroundImage = \u003cspan class=\"hljs-title function_\"\u003egetBackgroundImage\u003c/span\u003e(srcSet);\n  \n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e style = { \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'100vh'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'100vw'\u003c/span\u003e, backgroundImage };\n \n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003emain\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{style}\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003eHello World\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003emain\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e설명을 덧붙이자면\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003egetImageProps\u003c/code\u003e는 next/image가 이미지 로딩에 최적화된 속성들(\u003ccode\u003esrcSet\u003c/code\u003e, \u003ccode\u003esrc\u003c/code\u003e, \u003ccode\u003esizes\u003c/code\u003e 등)을 생성해주는 함수입니다.\u003c/li\u003e\n\u003cli\u003e여기서는 \u003ccode\u003esrcSet\u003c/code\u003e 문자열을 받아서 CSS \u003ccode\u003eimage-set()\u003c/code\u003e 구문에 맞게 변환해줍니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eimage-set\u003c/code\u003e은 여러 해상도에 맞는 이미지들을 선언해서 브라우저가 상황에 맞게 선택적으로 로딩할 수 있게 합니다.\u003c/li\u003e\n\u003cli\u003e이걸 스타일 객체에 바로 \u003ccode\u003ebackgroundImage\u003c/code\u003e로 넣어서 배경으로 활용하는 거죠.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e작은 팁!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eCSS \u003ccode\u003eimage-set()\u003c/code\u003e 지원은 아직 일부 브라우저에서 제한적이라 실제로 쓸 땐 호환성 체크 꼭 하세요.\u003c/li\u003e\n\u003cli\u003e여기선 inline style로 썼지만, css-in-js나 external css로 작성하면 유지보수가 더 좋을 수 있어요.\u003c/li\u003e\n\u003cli\u003enext/image 기본 컴포넌트는 \u003ccode\u003e\u0026#x3C;img\u003e\u003c/code\u003e 태그에 최적화되어 있기 때문에 배경 이미지로 쓰긴 다소 변칙적이라, 상황에 따라 직접 이미지 태그를 쓰는 것도 고민해보세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003e알려진 브라우저 버그 및 주의점\u003c/h2\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e브라우저\u003c/th\u003e\u003cth\u003e이슈 내용\u003c/th\u003e\u003cth\u003e해결법 / 참고\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eSafari 15 ~ 16.3\u003c/td\u003e\u003ctd\u003e이미지 로딩 시 회색 테두리 표시\u003c/td\u003e\u003ctd\u003e- CSS @supports로 특정 스타일 적용\u003cbr\u003e- \u003ccode\u003epriority\u003c/code\u003e 속성으로 위쪽 영역 이미지 우선 로딩\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSafari \u0026#x3C; 15.4\u003c/td\u003e\u003ctd\u003enative lazy loading 미지원 (eager fallback)\u003c/td\u003e\u003ctd\u003e최신 버전으로 업데이트 권장\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSafari \u0026#x3C; 12\u003c/td\u003e\u003ctd\u003eblur-up placeholder 빈 상태 fallback\u003c/td\u003e\u003ctd\u003eblur-up 효과 대신 다른 placeholder 사용 고려\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSafari \u0026#x3C; 15\u003c/td\u003e\u003ctd\u003ewidth/height auto 스타일 사용 시 레이아웃 시프트 발생 가능\u003c/td\u003e\u003ctd\u003e고정 크기 사용 추천\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eFirefox 67+\u003c/td\u003e\u003ctd\u003e로딩 중 흰색 배경 표시\u003c/td\u003e\u003ctd\u003e- AVIF 포맷 활성화\u003cbr\u003e- placeholder 사용\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e알아두면 좋은 점\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eNext.js의 next/image는 기본적으로 lazy loading을 지원하지만, 브라우저마다 native 지원 범위가 다릅니다.\u003c/li\u003e\n\u003cli\u003e특히 구형 브라우저에서는 eager로 강제 변경되거나 placeholder가 제대로 보이지 않는 등 UX가 달라질 수 있어요.\u003c/li\u003e\n\u003cli\u003eblur-up placeholder 효과가 안되는 구형 사파리는 사용자 눈에 빈 화면이 되는 단점이 있습니다.\u003c/li\u003e\n\u003cli\u003eFirefox에서 흰색 배경 문제는 AVIF 사용 및 placeholder 설정으로 완화할 수 있으니 가능하면 이미지를 AVIF 포맷으로 변환하는 게 좋아요.\u003c/li\u003e\n\u003cli\u003eLayout Shift (레이아웃 변화)를 막으려면 기본적으로 이미지 영역의 크기를 미리 지정해주는 게 중요합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003e마무리\u003c/h3\u003e\n\u003cp\u003enext/image는 편리한 이미지 최적화 도구지만, 브라우저 별로 미묘한 차이가 있어서 꼼꼼한 테스트가 필요해요.\u003cbr\u003e\n특히 배경 이미지로 변형하거나 레거시 브라우저를 지원한다면, 위 이슈들을 참고해서 적절히 대응하세요!\u003c/p\u003e\n\u003cp\u003e더 궁금한 점 있으면 언제든 질문해 주세요~\u003cbr\u003e\n개발할 때 자주 쓰는 팁도 하나씩 알려 드릴게요 :)\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e버전 히스토리\u003c/h2\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e버전\u003c/th\u003e\u003cth\u003e변경사항\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev15.3.0\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eremotePatterns\u003c/code\u003e에서 \u003ccode\u003eURL\u003c/code\u003e 객체 배열을 지원하도록 추가됨.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev15.0.0\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003econtentDispositionType\u003c/code\u003e 설정 기본값이 \u003ccode\u003eattachment\u003c/code\u003e으로 변경됨.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev14.2.23\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003equalities\u003c/code\u003e 설정이 추가됨.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev14.2.15\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003edecoding\u003c/code\u003e prop과 \u003ccode\u003elocalPatterns\u003c/code\u003e 설정이 추가됨.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev14.2.14\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eremotePatterns.search\u003c/code\u003e prop이 추가됨.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev14.2.0\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eoverrideSrc\u003c/code\u003e prop이 추가됨.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev14.1.0\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003egetImageProps()\u003c/code\u003e가 안정화됨.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev14.0.0\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eonLoadingComplete\u003c/code\u003e prop과 \u003ccode\u003edomains\u003c/code\u003e 설정이 deprecated됨.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev13.4.14\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eplaceholder\u003c/code\u003e prop이 \u003ccode\u003edata:/image...\u003c/code\u003e URI를 지원하도록 추가됨.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev13.2.0\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003econtentDispositionType\u003c/code\u003e 설정이 추가됨.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev13.0.6\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eref\u003c/code\u003e prop이 추가됨.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev13.0.0\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e- \u003ccode\u003enext/image\u003c/code\u003e 임포트가 \u003ccode\u003enext/legacy/image\u003c/code\u003e로 이름 변경됨.\u003cbr\u003e- \u003ccode\u003enext/future/image\u003c/code\u003e 임포트가 \u003ccode\u003enext/image\u003c/code\u003e로 이름 변경됨.\u003cbr\u003e- \u003ca href=\"/docs/app/guides/upgrading/codemods#next-image-to-legacy-image\"\u003e안전하고 자동으로 임포트를 변경해주는 codemod 제공\u003c/a\u003e.\u003cbr\u003e- \u003ccode\u003e\u0026#x3C;span\u003e\u003c/code\u003e 래퍼 제거.\u003cbr\u003e- \u003ccode\u003elayout\u003c/code\u003e, \u003ccode\u003eobjectFit\u003c/code\u003e, \u003ccode\u003eobjectPosition\u003c/code\u003e, \u003ccode\u003elazyBoundary\u003c/code\u003e, \u003ccode\u003elazyRoot\u003c/code\u003e prop 삭제.\u003cbr\u003e- \u003ccode\u003ealt\u003c/code\u003e prop 필수화.\u003cbr\u003e- \u003ccode\u003eonLoadingComplete\u003c/code\u003e이 \u003ccode\u003eimg\u003c/code\u003e 엘리먼트 레퍼런스를 받음.\u003cbr\u003e- 기본 내장 로더 설정 제거됨.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev12.3.0\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eremotePatterns\u003c/code\u003e 및 \u003ccode\u003eunoptimized\u003c/code\u003e 설정이 안정화됨.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev12.2.0\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e실험적 \u003ccode\u003eremotePatterns\u003c/code\u003e와 \u003ccode\u003eunoptimized\u003c/code\u003e 설정 추가.\u003cbr\u003e\u003ccode\u003elayout=\"raw\"\u003c/code\u003e 삭제됨.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev12.1.1\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003estyle\u003c/code\u003e prop 추가.\u003cbr\u003e실험적 \u003ccode\u003elayout=\"raw\"\u003c/code\u003e 지원 추가.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev12.1.0\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003edangerouslyAllowSVG\u003c/code\u003e와 \u003ccode\u003econtentSecurityPolicy\u003c/code\u003e 설정 추가됨.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev12.0.9\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003elazyRoot\u003c/code\u003e prop 추가됨.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev12.0.0\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e- \u003ccode\u003eformats\u003c/code\u003e 설정 추가.\u003cbr\u003e- AVIF 이미지 포맷 지원 추가.\u003cbr\u003e- 래퍼 엘리먼트가 \u003ccode\u003e\u0026#x3C;div\u003e\u003c/code\u003e에서 \u003ccode\u003e\u0026#x3C;span\u003e\u003c/code\u003e으로 변경됨.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev11.1.0\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eonLoadingComplete\u003c/code\u003e과 \u003ccode\u003elazyBoundary\u003c/code\u003e prop 추가됨.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev11.0.0\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e- \u003ccode\u003esrc\u003c/code\u003e prop이 정적 임포트를 지원.\u003cbr\u003e- \u003ccode\u003eplaceholder\u003c/code\u003e prop 추가.\u003cbr\u003e- \u003ccode\u003eblurDataURL\u003c/code\u003e prop 추가.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev10.0.5\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eloader\u003c/code\u003e prop 추가됨.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev10.0.1\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003elayout\u003c/code\u003e prop 추가됨.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev10.0.0\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003enext/image\u003c/code\u003e 컴포넌트 도입됨.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003cp\u003e이렇게 버전별로 주요 업데이트가 정리되어 있으니, 특히 \u003ccode\u003ev13\u003c/code\u003e에서 큰 변화가 있었던 점 잊지 마세요! \u003ccode\u003ealt\u003c/code\u003e가 필수로 변경된 점이라든지 \u003ccode\u003enext/image\u003c/code\u003e의 경로가 달라진 부분은 프로젝트 마이그레이션 시 꼭 체크하세요. 그리고 최신 버전에서는 AVIF 포맷 지원 등 이미지 최적화 기능도 점점 좋아지고 있어서, 가능하면 최신 버전을 쓰는 게 좋습니다.\u003c/p\u003e\n\u003cp\u003e필요하면 각 버전에 있는 새로운 prop이나 설정을 활용해 성능과 사용자 경험을 개선해보시길 추천합니다!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2025-04-22-Image"},"buildId":"KUC9M_yIlA1Ugo01xmkHL","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>