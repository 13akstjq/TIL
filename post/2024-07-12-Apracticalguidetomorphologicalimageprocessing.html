<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>형태학적 이미지 처리 실용 가이드 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2024-07-12-Apracticalguidetomorphologicalimageprocessing" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="형태학적 이미지 처리 실용 가이드 | TIL" data-gatsby-head="true"/><meta property="og:title" content="형태학적 이미지 처리 실용 가이드 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2024-07-12-Apracticalguidetomorphologicalimageprocessing" data-gatsby-head="true"/><meta name="twitter:title" content="형태학적 이미지 처리 실용 가이드 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-12 20:50" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-8ded8b979ba73586.js" defer=""></script><script src="/TIL/_next/static/N1mNhRlQaHCliEGDvPEpG/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/N1mNhRlQaHCliEGDvPEpG/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">형태학적 이미지 처리 실용 가이드</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="형태학적 이미지 처리 실용 가이드" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 12, 2024</span><span class="posts_reading_time__f7YPP">15<!-- --> min read</span></span></div></div></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>| 인공지능 | 컴퓨터 비전 | 전처리 |</h2>
<img src="/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_0.png">
<p>Python에서 모폴로지 연산을 어떻게 구현하는지 및 왜 디지털 이미지 처리에서 중요한지에 대해 설명하는 가이드입니다.</p>
<p>이전 시리즈의 기사는 다음과 같습니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>형태학 소개</h1>
<p><img src="/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_1.png" alt="이미지"></p>
<p>형태학(가끔 수학적 형태학으로도 불립니다)은 이웃 처리의 한 분야로 여겨질 수 있습니다. 1964년 Georges Matheron과 Jean Serra에 의해 개발되었으며, 광물 단면의 특성을 정량화하기 위해 고안되었지만 다른 다양한 응용 분야에서도 가치가 있다는 것이 입증되었습니다. 일반적으로 형태학은 이미지에 일관된 노출이 없는 경우에 발생하는 노이즈를 제거하는 데 사용할 수 있습니다. 실제로 형태학은 역처리로 얻은 바이너리 이미지와 매우 잘 작동하지만(하지만 그레이스케일 이미지에서도 사용할 수 있습니다).</p>
<p>예를 들어, 임계 처리 후 몇 가지 상황이 발생할 수 있고, 이를 형태학으로 해결할 수 있습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_2.png" alt="A practical guide to morphological image processing"></p>
<p>여기서 나는 히트 또는 핏 연산, 팽창, 침식을 적용했는데, 이에 대해 자세히 알아볼 것이다.</p>
<p>형태학은 다양한 흥미로운 응용 프로그램을 갖고 있습니다. 예를 들어 광학 문자 인식(OCR)의 전처리 단계로 사용되며, 바코드 및 자동차 번호판은 감지하는 데 사용됩니다. 형태학 연산은 간단하고 계산 비용이 적고 결합하여 효율적으로 사용할 수 있어 시간과 계산 자원을 절약할 수 있습니다. 실제로 여러 가지 작업을 수행하기 위해 복잡한 알고리즘이 필요하지 않을 때가 많으며, 적은 고급 기술도 우아하고 효율적인 솔루션으로 이어질 수 있습니다. 또한, 이러한 연산은 다양한 컴퓨터 비전 알고리즘에서 매우 유용하며 실제로 학습할 가치가 있습니다.</p>
<h1>형태학</h1>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_3.png" alt="image"></p>
<p>임계처리는 전역 작업으로 (이미지의 모든 픽셀에 대해) 지역 위치를 고려하지 않고 수행되며, 결과적으로 과소 세분화 또는 과대 세분화된 영역을 유발할 수 있습니다.</p>
<p>대신, 형태학은 이웃 처리와 비슷하게 적용됩니다. 이 경우에는 값이 아닌 모양이 중요합니다 (상자 모양 커널은 날카로운 모서리를 보존하고 둥근/디스크 모양 커널은 모서리를 둥글게 만듭니다).</p>
<p><img src="/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_4.png" alt="image"></p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 커널은 이미지에있는 객체 (또는 요소)에만 적용됩니다. 따라서 커널이 클수록 이미지에 미치는 영향도 커집니다. 이러한 절차는 일반적으로 1이 전경을 나타내고 0이 배경을 나타내는 바이너리 이미지에서 수행됩니다.</p>
<h2>맞추기와 맞추기</h2>
<p>이 알고리즘에서는 위에서 본 것과 같은 모양의 커널을 특정 위치에 놓은 다음 커널에 의해 커버되는 픽셀의 값을 고려합니다. 아이디어는 커널을 고려할 때, 특정 위치에있는 픽셀이 커널에도 1이면 1로 설정하려는 것입니다 (이를 '맞춤'이라고 함). 일치하는 경우 출력 이미지의 픽셀이 1로 설정됩니다. 맞춤 (또는 맞춤)에서 이미지 전체를 스캔하는 것이 아니라 특정 위치와 커널을 선택하고 커널 및 해당 위치의 픽셀의 일치 여부를 확인합니다.</p>
<p>맞춤의 경우에는 커널에있는 것처럼 동일한 위치의 모든 픽셀이 1인지 확인합니다 (참이면 이미지가 맞는 것입니다). 모든 픽셀에 대해 일치하는 경우, 모든 픽셀을 출력 이미지에서 1로 설정하고, 그렇지 않은 경우 모두 0으로 설정합니다. 아래 두 위치에 맞춤 또는 맞춤을 적용합니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_5.png" alt="풍부한 이진화와 침식"></p>
<h2>팽창과 침식</h2>
<p>전체 이미지에 히트를 적용하는 것을 '팽창'이라고 합니다. 왜냐하면 그 이미지의 요소들이 변환 후에 크기가 증가하기 때문입니다. 또한, 작은 구멍이 닫히고 일부 객체가 병합됩니다. 증가량은 커널 요소의 크기에 따라 달라지거나, 대안으로 작은 커널을 반복적으로 적용할 수 있습니다. 문제는 잡음이 있는 객체도 확대될 수 있다는 것입니다. 커널 k를 사용한 방정식은 다음과 같습니다:</p>
<p><img src="/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_6.png" alt="팽창과 침식"></p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>⊕은 벡터 하위 공간의 합을 나타냅니다.</p>
<p>말했듯이, 커널 크기는 영향을 미치며 작은 커널을 반복적으로 적용할 때 영향이 유사합니다 (예: 6x6 커널은 3x3 커널을 2배 적용한 것과 유사한 효과를 줍니다). 이미지에 다른 커널의 효과를 시도해 보겠습니다. 우선 이전 튜토리얼에서 언급했던대로 이미지에 Otsu의 임계값 처리를 적용한 이미지로 시작하겠습니다 (이는 일정 임계값 이상인 픽셀이 255 또는 흰색이 되고 나머지는 0인 바이너리 이미지를 반환합니다).</p>
<p><img src="/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_7.png" alt="image"></p>
<p>그런 다음 이 바이너리 이미지에 다양한 커널 크기와 팽창을 적용합니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-python"><span class="hljs-comment"># 확장</span>
<span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> ndimage
<span class="hljs-keyword">from</span> skimage.filters <span class="hljs-keyword">import</span> threshold_otsu
<span class="hljs-keyword">from</span> skimage.morphology <span class="hljs-keyword">import</span> disk
<span class="hljs-keyword">from</span> skimage.morphology <span class="hljs-keyword">import</span> erosion

fig, axes = plt.subplots(ncols=<span class="hljs-number">4</span>, nrows=<span class="hljs-number">1</span>, sharex=<span class="hljs-literal">True</span>, sharey=<span class="hljs-literal">True</span>, figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">5</span>))

image = im
thresh = threshold_otsu(image)
binary = image > thresh

dilated = ndimage.binary_dilation(binary, structure=np.ones((<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)))
dilated1 = ndimage.binary_dilation(binary, structure=np.ones((<span class="hljs-number">5</span>,<span class="hljs-number">5</span>)))
dilated2 = ndimage.binary_dilation(binary, structure=np.ones((<span class="hljs-number">9</span>,<span class="hljs-number">9</span>)))
</code></pre>
<p><img src="/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_8.png" alt="image"></p>
<p>물체가 커지고 이미지의 구멍이 메꿔지며 일부 잡음 요소가 확대되는 것을 알 수 있습니다.</p>
<p>침식은 확장과 정반대입니다. 이 경우에는 모든 이미지에 대해 맞추고 있습니다. 효과는 객체 크기의 일반적인 축소와 작은 객체의 제거로 이어집니다. 더불어 종종 더 큰 객체가 더 작은 객체로 분할됩니다. 우리는 잡음을 제거하지만 관심 대상 객체는 파손됩니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>여기 방정식입니다:</p>
<p><img src="/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_9.png" alt="equation"></p>
<p>여기에 Python 구현이 있습니다:</p>
<pre><code class="hljs language-python"><span class="hljs-comment">#침식</span>

fig, axes = plt.subplots(ncols=<span class="hljs-number">4</span>, nrows=<span class="hljs-number">1</span>, sharex=<span class="hljs-literal">True</span>, sharey=<span class="hljs-literal">True</span>, figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">5</span>))

image = im
thresh = threshold_otsu(image)
binary = image > thresh

eroded = ndimage.binary_erosion(binary, structure=np.ones((<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)))
eroded1 = ndimage.binary_erosion(binary, structure=np.ones((<span class="hljs-number">5</span>,<span class="hljs-number">5</span>)))
eroded2 = ndimage.binary_erosion(binary, structure=np.ones((<span class="hljs-number">9</span>,<span class="hljs-number">9</span>)))
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>아래의 표를 마크다운 형식으로 바꿔보세요.</p>
<img src="/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_10.png">
<p>주의할 점은 작은 물체가 사라지는 것과, 관심 대상물체에 구멍이 형성되는 것입니다.</p>
<p>침식과 팽창의 조합으로 우리는 개방, 폐쇄, 경계 감지와 같은 복합 연산을 유도합니다.</p>
<h2>폐쇄와 개방</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>보통 클로징은 구멍을 메우는 연산입니다. 팽창에 이어 침식이 이루어지면 얻을 수 있습니다. 이미지 내부의 구멍은 보통 이 작업 이후에 닫힙니다. 팽창을 사용하여 객체의 크기 (그리고 잡음의 크기)를 키우고 출력 객체는 입력 크기와 같습니다. 따라서 클로징이 이 문제를 해결합니다. 다음 작업을 위한 커널의 크기도 동일합니다. 클로징 연산은 항등성을 갖고 있어 한 번만 사용할 수 있습니다. 그렇지 않으면 이미지 전체를 축소시키는 것만 일어나서 뚜렷한 효과가 없습니다 (경계 문제). 아래 방정식을 볼 수 있습니다:</p>
<p><img src="/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_11.png" alt=""></p>
<p>여기서 커널의 크기를 다르게 사용하는 경우 무슨 일이 일어나는지 주목해 보세요:</p>
<pre><code class="hljs language-js">closed = ndimage.<span class="hljs-title function_">binary_closing</span>(binary, structure=np.<span class="hljs-title function_">ones</span>((<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)))
closed1 = ndimage.<span class="hljs-title function_">binary_closing</span>(binary, structure=np.<span class="hljs-title function_">ones</span>((<span class="hljs-number">5</span>,<span class="hljs-number">5</span>)))
closed2 = ndimage.<span class="hljs-title function_">binary_closing</span>(binary, structure=np.<span class="hljs-title function_">ones</span>((<span class="hljs-number">9</span>,<span class="hljs-number">9</span>)))
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_12.png" alt="Opening operation"></p>
<p>Opening is generally used to avoid fractioning bigger objects when removing the noise. In this case, we use first erosion and then dilation. The output image presents an object with the original size but the noise is removed. Another idempotent transformation and the equation is:</p>
<p><img src="/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_13.png" alt="Idempotent transformation"></p>
<p>Let’s also test the opening operation to see what is happening:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-python">opened = ndimage.binary_opening(binary, structure=np.ones((<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)))
opened1 = ndimage.binary_opening(binary, structure=np.ones((<span class="hljs-number">5</span>,<span class="hljs-number">5</span>)))
opened2 = ndimage.binary_opening(binary, structure=np.ones((<span class="hljs-number">9</span>,<span class="hljs-number">9</span>)))
</code></pre>
<p><img src="/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_14.png" alt="Image"></p>
<p>두 가지 과정을 결합할 수도 있지만, 커널은 서로 달라야 합니다 (opening에 사용되는 것과 closing에 사용되는 것이 서로 다른 커널이어야 함)</p>
<p>5x5 커널을 사용하여 모든 연산을 함께 확인해보겠습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_15.png" alt="image"></p>
<p>Boundary detection is an edge detection technique on binary images, where you subtract the eroded image, obtaining the boundary. The idea is that with eroding we are obtaining a smaller version of the object and if we subtract the image only the boundary will remain. In formula:</p>
<p><img src="/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_16.png" alt="formula"></p>
<pre><code class="hljs language-js">eroded = ndimage.<span class="hljs-title function_">binary_erosion</span>(binary, structure=np.<span class="hljs-title function_">ones</span>((<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)))
boundary =binary ^ eroded
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<img src="/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_17.png">
<p>뺄셈이 아니라 두 개의 논리 마스크 (참/거짓)를 사용하기 때문에 논리 연산자 AND를 사용하는 것에 유의하세요. 그렇지 않으면 Numpy가 오류를 반환합니다. (하지만 원리는 같습니다)</p>
<h2>약간의 실제 예시</h2>
<p>마이크로스코프 이미지에서 핵 윤곽선을 선택하여 분석을 수행하려면 몇 가지 조작만으로 가능합니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"># 핵을 선택하려고 합니다.
# 따라서, 파란색 부분만 선택합니다.
im = a[:,:,<span class="hljs-number">2</span>]
image = im
thresh = <span class="hljs-title function_">threshold_otsu</span>(image)
binary = image > thresh
eroded = ndimage.<span class="hljs-title function_">binary_erosion</span>(binary, structure=np.<span class="hljs-title function_">ones</span>((<span class="hljs-number">7</span>,<span class="hljs-number">7</span>)))
opening = ndimage.<span class="hljs-title function_">binary_opening</span>(eroded, structure=np.<span class="hljs-title function_">ones</span>((<span class="hljs-number">11</span>,<span class="hljs-number">11</span>)))
boundary = binary ^ opening
</code></pre>
<p><img src="/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_18.png" alt="image"></p>
<p>보너스 예제: 자동차 이미지의 번호판을 읽고 싶다면, 복잡한 딥 러닝 모델 대신 간단한 전처리 단계로 시작할 수 있습니다. 하얀색과 검은색 모자(흰색은 회색 이미지에서 개방 이미지를 뺀 것이고 검은색은 회색 입력 이미지에서 닫힘을 뺀 것)와 같은 몇 가지 간단한 연산을 사용할 수 있습니다. 여기서 우리는 번호판이 가로보다 세로가 길기 때문에 사각형 커널을 사용했습니다. 그리고 임의의 크기의 커널을 사용할 수 있습니다. 몇 가지 간단한 작업만으로도 결과가 꽤 좋아집니다.</p>
<pre><code class="hljs language-js">image = im
thresh = <span class="hljs-title function_">threshold_otsu</span>(image)
binary = image > thresh
opening = ndimage.<span class="hljs-title function_">binary_opening</span>(binary, structure=np.<span class="hljs-title function_">ones</span>((<span class="hljs-number">13</span>,<span class="hljs-number">5</span>)))
closing = ndimage.<span class="hljs-title function_">binary_closing</span>(binary, structure=np.<span class="hljs-title function_">ones</span>((<span class="hljs-number">13</span>,<span class="hljs-number">5</span>)))
black_hat =  im - closing
white_hat = im - opening
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<img src="/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_19.png">
<h1>마무리</h1>
<img src="/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_20.png">
<p>우리는 간단한 연산으로 다양한 결과를 얻을 수 있는 형태학적 연산이 얼마나 강력한지 보았습니다. 각 연산에는 그만의 반대가 있다는 것을 주목할 가치가 있으며, 이들을 결합하여 더 정교한 작업을 수행할 수 있습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>합성에서는 침식 기법을 사용하여 물체를 연결하는 작은 링크를 제거하거나 작은 잡음 물체를 제거하고 바이너리 이미지에서 경계를 감지할 수 있습니다. 반면 팽창은 이미지의 부분을 연결하는 데 유용합니다. 열림은 물체를 파괴하지 않고 작은 물체를 제거할 수 있게 하며, 폐쇄는 물체 크기를 늘리지 않으면서 구멍을 메울 수 있습니다. 그리고 이러한 작업을 필요에 맞게 반복 및 조합할 수도 있습니다. 간단한 작업에 대해 나쁘지 않죠?</p>
<p>이전 글은 여기서 확인할 수 있습니다. 여기에서는 핵심 코드만을 보여줬지만, 사용된 모든 코드는 여기에 있습니다.</p>
<h2>어떻게 생각하세요? 이러한 작업을 시도해 보셨나요? 댓글로 알려주세요.</h2>
<h1>흥미로우셨다면:</h1>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>제 다른 글을 찾아보실 수 있고, LinkedIn에서 연락이나 소통할 수도 있습니다. 매주 업데이트되는 머신 러닝 및 인공 지능 뉴스가 포함된 이 저장소를 확인해보세요. 협업 및 프로젝트에 대해 열려 있으며 LinkedIn에서 저에게 연락할 수 있습니다.</p>
<p>제 GitHub 저장소 링크는 다음과 같습니다. 거기에는 머신 러닝, 인공 지능 등과 관련된 코드와 다양한 자료를 모아두고 있습니다.</p>
<p>또는 최근 글 중 하나에 관심이 있을 수도 있습니다:</p>
<h2>추가 자료</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>형태학 연산에 대해: 일반적으로 (여기, 여기, 여기) 및 OpenCV로 (여기, 여기, 여기)</li>
<li>화이트와 블랙 햇에 관해: 여기</li>
</ul>
<h1>평문으로 이해하기 🚀</h1>
<p>In Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 계속 진행하기 전에:</p>
<ul>
<li>작가를 박수 치고 팔로우해 주세요 👏</li>
<li>팔로우: X | LinkedIn | YouTube | Discord | 뉴스레터</li>
<li>다른 플랫폼 방문: Stackademic | CoFeed | Venture</li>
<li>PlainEnglish.io에서 더 많은 콘텐츠 확인하기</li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"형태학적 이미지 처리 실용 가이드","description":"","date":"2024-07-12 20:50","slug":"2024-07-12-Apracticalguidetomorphologicalimageprocessing","content":"\n\n## | 인공지능 | 컴퓨터 비전 | 전처리 |\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_0.png\" /\u003e\n\nPython에서 모폴로지 연산을 어떻게 구현하는지 및 왜 디지털 이미지 처리에서 중요한지에 대해 설명하는 가이드입니다.\n\n이전 시리즈의 기사는 다음과 같습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 형태학 소개\n\n![이미지](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_1.png)\n\n형태학(가끔 수학적 형태학으로도 불립니다)은 이웃 처리의 한 분야로 여겨질 수 있습니다. 1964년 Georges Matheron과 Jean Serra에 의해 개발되었으며, 광물 단면의 특성을 정량화하기 위해 고안되었지만 다른 다양한 응용 분야에서도 가치가 있다는 것이 입증되었습니다. 일반적으로 형태학은 이미지에 일관된 노출이 없는 경우에 발생하는 노이즈를 제거하는 데 사용할 수 있습니다. 실제로 형태학은 역처리로 얻은 바이너리 이미지와 매우 잘 작동하지만(하지만 그레이스케일 이미지에서도 사용할 수 있습니다).\n\n예를 들어, 임계 처리 후 몇 가지 상황이 발생할 수 있고, 이를 형태학으로 해결할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![A practical guide to morphological image processing](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_2.png)\n\n여기서 나는 히트 또는 핏 연산, 팽창, 침식을 적용했는데, 이에 대해 자세히 알아볼 것이다.\n\n형태학은 다양한 흥미로운 응용 프로그램을 갖고 있습니다. 예를 들어 광학 문자 인식(OCR)의 전처리 단계로 사용되며, 바코드 및 자동차 번호판은 감지하는 데 사용됩니다. 형태학 연산은 간단하고 계산 비용이 적고 결합하여 효율적으로 사용할 수 있어 시간과 계산 자원을 절약할 수 있습니다. 실제로 여러 가지 작업을 수행하기 위해 복잡한 알고리즘이 필요하지 않을 때가 많으며, 적은 고급 기술도 우아하고 효율적인 솔루션으로 이어질 수 있습니다. 또한, 이러한 연산은 다양한 컴퓨터 비전 알고리즘에서 매우 유용하며 실제로 학습할 가치가 있습니다.\n\n# 형태학\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_3.png)\n\n임계처리는 전역 작업으로 (이미지의 모든 픽셀에 대해) 지역 위치를 고려하지 않고 수행되며, 결과적으로 과소 세분화 또는 과대 세분화된 영역을 유발할 수 있습니다.\n\n대신, 형태학은 이웃 처리와 비슷하게 적용됩니다. 이 경우에는 값이 아닌 모양이 중요합니다 (상자 모양 커널은 날카로운 모서리를 보존하고 둥근/디스크 모양 커널은 모서리를 둥글게 만듭니다).\n\n![image](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_4.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 커널은 이미지에있는 객체 (또는 요소)에만 적용됩니다. 따라서 커널이 클수록 이미지에 미치는 영향도 커집니다. 이러한 절차는 일반적으로 1이 전경을 나타내고 0이 배경을 나타내는 바이너리 이미지에서 수행됩니다.\n\n## 맞추기와 맞추기\n\n이 알고리즘에서는 위에서 본 것과 같은 모양의 커널을 특정 위치에 놓은 다음 커널에 의해 커버되는 픽셀의 값을 고려합니다. 아이디어는 커널을 고려할 때, 특정 위치에있는 픽셀이 커널에도 1이면 1로 설정하려는 것입니다 (이를 '맞춤'이라고 함). 일치하는 경우 출력 이미지의 픽셀이 1로 설정됩니다. 맞춤 (또는 맞춤)에서 이미지 전체를 스캔하는 것이 아니라 특정 위치와 커널을 선택하고 커널 및 해당 위치의 픽셀의 일치 여부를 확인합니다.\n\n맞춤의 경우에는 커널에있는 것처럼 동일한 위치의 모든 픽셀이 1인지 확인합니다 (참이면 이미지가 맞는 것입니다). 모든 픽셀에 대해 일치하는 경우, 모든 픽셀을 출력 이미지에서 1로 설정하고, 그렇지 않은 경우 모두 0으로 설정합니다. 아래 두 위치에 맞춤 또는 맞춤을 적용합니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![풍부한 이진화와 침식](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_5.png)\n\n## 팽창과 침식\n\n전체 이미지에 히트를 적용하는 것을 '팽창'이라고 합니다. 왜냐하면 그 이미지의 요소들이 변환 후에 크기가 증가하기 때문입니다. 또한, 작은 구멍이 닫히고 일부 객체가 병합됩니다. 증가량은 커널 요소의 크기에 따라 달라지거나, 대안으로 작은 커널을 반복적으로 적용할 수 있습니다. 문제는 잡음이 있는 객체도 확대될 수 있다는 것입니다. 커널 k를 사용한 방정식은 다음과 같습니다:\n\n![팽창과 침식](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_6.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n⊕은 벡터 하위 공간의 합을 나타냅니다.\n\n말했듯이, 커널 크기는 영향을 미치며 작은 커널을 반복적으로 적용할 때 영향이 유사합니다 (예: 6x6 커널은 3x3 커널을 2배 적용한 것과 유사한 효과를 줍니다). 이미지에 다른 커널의 효과를 시도해 보겠습니다. 우선 이전 튜토리얼에서 언급했던대로 이미지에 Otsu의 임계값 처리를 적용한 이미지로 시작하겠습니다 (이는 일정 임계값 이상인 픽셀이 255 또는 흰색이 되고 나머지는 0인 바이너리 이미지를 반환합니다).\n\n![image](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_7.png)\n\n그런 다음 이 바이너리 이미지에 다양한 커널 크기와 팽창을 적용합니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\n# 확장\nfrom scipy import ndimage\nfrom skimage.filters import threshold_otsu\nfrom skimage.morphology import disk\nfrom skimage.morphology import erosion\n\nfig, axes = plt.subplots(ncols=4, nrows=1, sharex=True, sharey=True, figsize=(12, 5))\n\nimage = im\nthresh = threshold_otsu(image)\nbinary = image \u003e thresh\n\ndilated = ndimage.binary_dilation(binary, structure=np.ones((3,3)))\ndilated1 = ndimage.binary_dilation(binary, structure=np.ones((5,5)))\ndilated2 = ndimage.binary_dilation(binary, structure=np.ones((9,9)))\n```\n\n![image](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_8.png)\n\n물체가 커지고 이미지의 구멍이 메꿔지며 일부 잡음 요소가 확대되는 것을 알 수 있습니다.\n\n침식은 확장과 정반대입니다. 이 경우에는 모든 이미지에 대해 맞추고 있습니다. 효과는 객체 크기의 일반적인 축소와 작은 객체의 제거로 이어집니다. 더불어 종종 더 큰 객체가 더 작은 객체로 분할됩니다. 우리는 잡음을 제거하지만 관심 대상 객체는 파손됩니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기 방정식입니다:\n\n![equation](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_9.png)\n\n여기에 Python 구현이 있습니다:\n\n```python\n#침식\n\nfig, axes = plt.subplots(ncols=4, nrows=1, sharex=True, sharey=True, figsize=(12, 5))\n\nimage = im\nthresh = threshold_otsu(image)\nbinary = image \u003e thresh\n\neroded = ndimage.binary_erosion(binary, structure=np.ones((3,3)))\neroded1 = ndimage.binary_erosion(binary, structure=np.ones((5,5)))\neroded2 = ndimage.binary_erosion(binary, structure=np.ones((9,9)))\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래의 표를 마크다운 형식으로 바꿔보세요.\n\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_10.png\" /\u003e\n\n주의할 점은 작은 물체가 사라지는 것과, 관심 대상물체에 구멍이 형성되는 것입니다.\n\n침식과 팽창의 조합으로 우리는 개방, 폐쇄, 경계 감지와 같은 복합 연산을 유도합니다.\n\n## 폐쇄와 개방\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n보통 클로징은 구멍을 메우는 연산입니다. 팽창에 이어 침식이 이루어지면 얻을 수 있습니다. 이미지 내부의 구멍은 보통 이 작업 이후에 닫힙니다. 팽창을 사용하여 객체의 크기 (그리고 잡음의 크기)를 키우고 출력 객체는 입력 크기와 같습니다. 따라서 클로징이 이 문제를 해결합니다. 다음 작업을 위한 커널의 크기도 동일합니다. 클로징 연산은 항등성을 갖고 있어 한 번만 사용할 수 있습니다. 그렇지 않으면 이미지 전체를 축소시키는 것만 일어나서 뚜렷한 효과가 없습니다 (경계 문제). 아래 방정식을 볼 수 있습니다:\n\n![](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_11.png)\n\n여기서 커널의 크기를 다르게 사용하는 경우 무슨 일이 일어나는지 주목해 보세요:\n\n```js\nclosed = ndimage.binary_closing(binary, structure=np.ones((3,3)))\nclosed1 = ndimage.binary_closing(binary, structure=np.ones((5,5)))\nclosed2 = ndimage.binary_closing(binary, structure=np.ones((9,9)))\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Opening operation](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_12.png)\n\nOpening is generally used to avoid fractioning bigger objects when removing the noise. In this case, we use first erosion and then dilation. The output image presents an object with the original size but the noise is removed. Another idempotent transformation and the equation is:\n\n![Idempotent transformation](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_13.png)\n\nLet’s also test the opening operation to see what is happening:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nopened = ndimage.binary_opening(binary, structure=np.ones((3,3)))\nopened1 = ndimage.binary_opening(binary, structure=np.ones((5,5)))\nopened2 = ndimage.binary_opening(binary, structure=np.ones((9,9)))\n```\n\n![Image](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_14.png)\n\n두 가지 과정을 결합할 수도 있지만, 커널은 서로 달라야 합니다 (opening에 사용되는 것과 closing에 사용되는 것이 서로 다른 커널이어야 함)\n\n5x5 커널을 사용하여 모든 연산을 함께 확인해보겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_15.png)\n\nBoundary detection is an edge detection technique on binary images, where you subtract the eroded image, obtaining the boundary. The idea is that with eroding we are obtaining a smaller version of the object and if we subtract the image only the boundary will remain. In formula:\n\n![formula](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_16.png)\n\n```js\neroded = ndimage.binary_erosion(binary, structure=np.ones((3,3)))\nboundary =binary ^ eroded\n``` \n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_17.png\" /\u003e\n\n뺄셈이 아니라 두 개의 논리 마스크 (참/거짓)를 사용하기 때문에 논리 연산자 AND를 사용하는 것에 유의하세요. 그렇지 않으면 Numpy가 오류를 반환합니다. (하지만 원리는 같습니다)\n\n## 약간의 실제 예시\n\n마이크로스코프 이미지에서 핵 윤곽선을 선택하여 분석을 수행하려면 몇 가지 조작만으로 가능합니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 핵을 선택하려고 합니다.\n# 따라서, 파란색 부분만 선택합니다.\nim = a[:,:,2]\nimage = im\nthresh = threshold_otsu(image)\nbinary = image \u003e thresh\neroded = ndimage.binary_erosion(binary, structure=np.ones((7,7)))\nopening = ndimage.binary_opening(eroded, structure=np.ones((11,11)))\nboundary = binary ^ opening\n```\n\n![image](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_18.png)\n\n보너스 예제: 자동차 이미지의 번호판을 읽고 싶다면, 복잡한 딥 러닝 모델 대신 간단한 전처리 단계로 시작할 수 있습니다. 하얀색과 검은색 모자(흰색은 회색 이미지에서 개방 이미지를 뺀 것이고 검은색은 회색 입력 이미지에서 닫힘을 뺀 것)와 같은 몇 가지 간단한 연산을 사용할 수 있습니다. 여기서 우리는 번호판이 가로보다 세로가 길기 때문에 사각형 커널을 사용했습니다. 그리고 임의의 크기의 커널을 사용할 수 있습니다. 몇 가지 간단한 작업만으로도 결과가 꽤 좋아집니다.\n\n```js\nimage = im\nthresh = threshold_otsu(image)\nbinary = image \u003e thresh\nopening = ndimage.binary_opening(binary, structure=np.ones((13,5)))\nclosing = ndimage.binary_closing(binary, structure=np.ones((13,5)))\nblack_hat =  im - closing\nwhite_hat = im - opening\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_19.png\" /\u003e\n\n# 마무리\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_20.png\" /\u003e\n\n우리는 간단한 연산으로 다양한 결과를 얻을 수 있는 형태학적 연산이 얼마나 강력한지 보았습니다. 각 연산에는 그만의 반대가 있다는 것을 주목할 가치가 있으며, 이들을 결합하여 더 정교한 작업을 수행할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n합성에서는 침식 기법을 사용하여 물체를 연결하는 작은 링크를 제거하거나 작은 잡음 물체를 제거하고 바이너리 이미지에서 경계를 감지할 수 있습니다. 반면 팽창은 이미지의 부분을 연결하는 데 유용합니다. 열림은 물체를 파괴하지 않고 작은 물체를 제거할 수 있게 하며, 폐쇄는 물체 크기를 늘리지 않으면서 구멍을 메울 수 있습니다. 그리고 이러한 작업을 필요에 맞게 반복 및 조합할 수도 있습니다. 간단한 작업에 대해 나쁘지 않죠?\n\n이전 글은 여기서 확인할 수 있습니다. 여기에서는 핵심 코드만을 보여줬지만, 사용된 모든 코드는 여기에 있습니다.\n\n## 어떻게 생각하세요? 이러한 작업을 시도해 보셨나요? 댓글로 알려주세요.\n\n# 흥미로우셨다면:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n제 다른 글을 찾아보실 수 있고, LinkedIn에서 연락이나 소통할 수도 있습니다. 매주 업데이트되는 머신 러닝 및 인공 지능 뉴스가 포함된 이 저장소를 확인해보세요. 협업 및 프로젝트에 대해 열려 있으며 LinkedIn에서 저에게 연락할 수 있습니다.\n\n제 GitHub 저장소 링크는 다음과 같습니다. 거기에는 머신 러닝, 인공 지능 등과 관련된 코드와 다양한 자료를 모아두고 있습니다.\n\n또는 최근 글 중 하나에 관심이 있을 수도 있습니다:\n\n## 추가 자료\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 형태학 연산에 대해: 일반적으로 (여기, 여기, 여기) 및 OpenCV로 (여기, 여기, 여기)\n- 화이트와 블랙 햇에 관해: 여기\n\n# 평문으로 이해하기 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 계속 진행하기 전에:\n\n- 작가를 박수 치고 팔로우해 주세요 👏\n- 팔로우: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문: Stackademic | CoFeed | Venture\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_0.png","tag":["Tech"],"readingTime":15},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e| 인공지능 | 컴퓨터 비전 | 전처리 |\u003c/h2\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_0.png\"\u003e\n\u003cp\u003ePython에서 모폴로지 연산을 어떻게 구현하는지 및 왜 디지털 이미지 처리에서 중요한지에 대해 설명하는 가이드입니다.\u003c/p\u003e\n\u003cp\u003e이전 시리즈의 기사는 다음과 같습니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e형태학 소개\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e형태학(가끔 수학적 형태학으로도 불립니다)은 이웃 처리의 한 분야로 여겨질 수 있습니다. 1964년 Georges Matheron과 Jean Serra에 의해 개발되었으며, 광물 단면의 특성을 정량화하기 위해 고안되었지만 다른 다양한 응용 분야에서도 가치가 있다는 것이 입증되었습니다. 일반적으로 형태학은 이미지에 일관된 노출이 없는 경우에 발생하는 노이즈를 제거하는 데 사용할 수 있습니다. 실제로 형태학은 역처리로 얻은 바이너리 이미지와 매우 잘 작동하지만(하지만 그레이스케일 이미지에서도 사용할 수 있습니다).\u003c/p\u003e\n\u003cp\u003e예를 들어, 임계 처리 후 몇 가지 상황이 발생할 수 있고, 이를 형태학으로 해결할 수 있습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_2.png\" alt=\"A practical guide to morphological image processing\"\u003e\u003c/p\u003e\n\u003cp\u003e여기서 나는 히트 또는 핏 연산, 팽창, 침식을 적용했는데, 이에 대해 자세히 알아볼 것이다.\u003c/p\u003e\n\u003cp\u003e형태학은 다양한 흥미로운 응용 프로그램을 갖고 있습니다. 예를 들어 광학 문자 인식(OCR)의 전처리 단계로 사용되며, 바코드 및 자동차 번호판은 감지하는 데 사용됩니다. 형태학 연산은 간단하고 계산 비용이 적고 결합하여 효율적으로 사용할 수 있어 시간과 계산 자원을 절약할 수 있습니다. 실제로 여러 가지 작업을 수행하기 위해 복잡한 알고리즘이 필요하지 않을 때가 많으며, 적은 고급 기술도 우아하고 효율적인 솔루션으로 이어질 수 있습니다. 또한, 이러한 연산은 다양한 컴퓨터 비전 알고리즘에서 매우 유용하며 실제로 학습할 가치가 있습니다.\u003c/p\u003e\n\u003ch1\u003e형태학\u003c/h1\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_3.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e임계처리는 전역 작업으로 (이미지의 모든 픽셀에 대해) 지역 위치를 고려하지 않고 수행되며, 결과적으로 과소 세분화 또는 과대 세분화된 영역을 유발할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e대신, 형태학은 이웃 처리와 비슷하게 적용됩니다. 이 경우에는 값이 아닌 모양이 중요합니다 (상자 모양 커널은 날카로운 모서리를 보존하고 둥근/디스크 모양 커널은 모서리를 둥글게 만듭니다).\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_4.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 커널은 이미지에있는 객체 (또는 요소)에만 적용됩니다. 따라서 커널이 클수록 이미지에 미치는 영향도 커집니다. 이러한 절차는 일반적으로 1이 전경을 나타내고 0이 배경을 나타내는 바이너리 이미지에서 수행됩니다.\u003c/p\u003e\n\u003ch2\u003e맞추기와 맞추기\u003c/h2\u003e\n\u003cp\u003e이 알고리즘에서는 위에서 본 것과 같은 모양의 커널을 특정 위치에 놓은 다음 커널에 의해 커버되는 픽셀의 값을 고려합니다. 아이디어는 커널을 고려할 때, 특정 위치에있는 픽셀이 커널에도 1이면 1로 설정하려는 것입니다 (이를 '맞춤'이라고 함). 일치하는 경우 출력 이미지의 픽셀이 1로 설정됩니다. 맞춤 (또는 맞춤)에서 이미지 전체를 스캔하는 것이 아니라 특정 위치와 커널을 선택하고 커널 및 해당 위치의 픽셀의 일치 여부를 확인합니다.\u003c/p\u003e\n\u003cp\u003e맞춤의 경우에는 커널에있는 것처럼 동일한 위치의 모든 픽셀이 1인지 확인합니다 (참이면 이미지가 맞는 것입니다). 모든 픽셀에 대해 일치하는 경우, 모든 픽셀을 출력 이미지에서 1로 설정하고, 그렇지 않은 경우 모두 0으로 설정합니다. 아래 두 위치에 맞춤 또는 맞춤을 적용합니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_5.png\" alt=\"풍부한 이진화와 침식\"\u003e\u003c/p\u003e\n\u003ch2\u003e팽창과 침식\u003c/h2\u003e\n\u003cp\u003e전체 이미지에 히트를 적용하는 것을 '팽창'이라고 합니다. 왜냐하면 그 이미지의 요소들이 변환 후에 크기가 증가하기 때문입니다. 또한, 작은 구멍이 닫히고 일부 객체가 병합됩니다. 증가량은 커널 요소의 크기에 따라 달라지거나, 대안으로 작은 커널을 반복적으로 적용할 수 있습니다. 문제는 잡음이 있는 객체도 확대될 수 있다는 것입니다. 커널 k를 사용한 방정식은 다음과 같습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_6.png\" alt=\"팽창과 침식\"\u003e\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e⊕은 벡터 하위 공간의 합을 나타냅니다.\u003c/p\u003e\n\u003cp\u003e말했듯이, 커널 크기는 영향을 미치며 작은 커널을 반복적으로 적용할 때 영향이 유사합니다 (예: 6x6 커널은 3x3 커널을 2배 적용한 것과 유사한 효과를 줍니다). 이미지에 다른 커널의 효과를 시도해 보겠습니다. 우선 이전 튜토리얼에서 언급했던대로 이미지에 Otsu의 임계값 처리를 적용한 이미지로 시작하겠습니다 (이는 일정 임계값 이상인 픽셀이 255 또는 흰색이 되고 나머지는 0인 바이너리 이미지를 반환합니다).\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_7.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e그런 다음 이 바이너리 이미지에 다양한 커널 크기와 팽창을 적용합니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-comment\"\u003e# 확장\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e scipy \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e ndimage\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e skimage.filters \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e threshold_otsu\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e skimage.morphology \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e disk\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e skimage.morphology \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e erosion\n\nfig, axes = plt.subplots(ncols=\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, nrows=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, sharex=\u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e, sharey=\u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e, figsize=(\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e))\n\nimage = im\nthresh = threshold_otsu(image)\nbinary = image \u003e thresh\n\ndilated = ndimage.binary_dilation(binary, structure=np.ones((\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e)))\ndilated1 = ndimage.binary_dilation(binary, structure=np.ones((\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e)))\ndilated2 = ndimage.binary_dilation(binary, structure=np.ones((\u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e)))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_8.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e물체가 커지고 이미지의 구멍이 메꿔지며 일부 잡음 요소가 확대되는 것을 알 수 있습니다.\u003c/p\u003e\n\u003cp\u003e침식은 확장과 정반대입니다. 이 경우에는 모든 이미지에 대해 맞추고 있습니다. 효과는 객체 크기의 일반적인 축소와 작은 객체의 제거로 이어집니다. 더불어 종종 더 큰 객체가 더 작은 객체로 분할됩니다. 우리는 잡음을 제거하지만 관심 대상 객체는 파손됩니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e여기 방정식입니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_9.png\" alt=\"equation\"\u003e\u003c/p\u003e\n\u003cp\u003e여기에 Python 구현이 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-comment\"\u003e#침식\u003c/span\u003e\n\nfig, axes = plt.subplots(ncols=\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, nrows=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, sharex=\u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e, sharey=\u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e, figsize=(\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e))\n\nimage = im\nthresh = threshold_otsu(image)\nbinary = image \u003e thresh\n\neroded = ndimage.binary_erosion(binary, structure=np.ones((\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e)))\neroded1 = ndimage.binary_erosion(binary, structure=np.ones((\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e)))\neroded2 = ndimage.binary_erosion(binary, structure=np.ones((\u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e)))\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e아래의 표를 마크다운 형식으로 바꿔보세요.\u003c/p\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_10.png\"\u003e\n\u003cp\u003e주의할 점은 작은 물체가 사라지는 것과, 관심 대상물체에 구멍이 형성되는 것입니다.\u003c/p\u003e\n\u003cp\u003e침식과 팽창의 조합으로 우리는 개방, 폐쇄, 경계 감지와 같은 복합 연산을 유도합니다.\u003c/p\u003e\n\u003ch2\u003e폐쇄와 개방\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e보통 클로징은 구멍을 메우는 연산입니다. 팽창에 이어 침식이 이루어지면 얻을 수 있습니다. 이미지 내부의 구멍은 보통 이 작업 이후에 닫힙니다. 팽창을 사용하여 객체의 크기 (그리고 잡음의 크기)를 키우고 출력 객체는 입력 크기와 같습니다. 따라서 클로징이 이 문제를 해결합니다. 다음 작업을 위한 커널의 크기도 동일합니다. 클로징 연산은 항등성을 갖고 있어 한 번만 사용할 수 있습니다. 그렇지 않으면 이미지 전체를 축소시키는 것만 일어나서 뚜렷한 효과가 없습니다 (경계 문제). 아래 방정식을 볼 수 있습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_11.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e여기서 커널의 크기를 다르게 사용하는 경우 무슨 일이 일어나는지 주목해 보세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eclosed = ndimage.\u003cspan class=\"hljs-title function_\"\u003ebinary_closing\u003c/span\u003e(binary, structure=np.\u003cspan class=\"hljs-title function_\"\u003eones\u003c/span\u003e((\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e)))\nclosed1 = ndimage.\u003cspan class=\"hljs-title function_\"\u003ebinary_closing\u003c/span\u003e(binary, structure=np.\u003cspan class=\"hljs-title function_\"\u003eones\u003c/span\u003e((\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e)))\nclosed2 = ndimage.\u003cspan class=\"hljs-title function_\"\u003ebinary_closing\u003c/span\u003e(binary, structure=np.\u003cspan class=\"hljs-title function_\"\u003eones\u003c/span\u003e((\u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e)))\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_12.png\" alt=\"Opening operation\"\u003e\u003c/p\u003e\n\u003cp\u003eOpening is generally used to avoid fractioning bigger objects when removing the noise. In this case, we use first erosion and then dilation. The output image presents an object with the original size but the noise is removed. Another idempotent transformation and the equation is:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_13.png\" alt=\"Idempotent transformation\"\u003e\u003c/p\u003e\n\u003cp\u003eLet’s also test the opening operation to see what is happening:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003eopened = ndimage.binary_opening(binary, structure=np.ones((\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e)))\nopened1 = ndimage.binary_opening(binary, structure=np.ones((\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e)))\nopened2 = ndimage.binary_opening(binary, structure=np.ones((\u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e)))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_14.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003e두 가지 과정을 결합할 수도 있지만, 커널은 서로 달라야 합니다 (opening에 사용되는 것과 closing에 사용되는 것이 서로 다른 커널이어야 함)\u003c/p\u003e\n\u003cp\u003e5x5 커널을 사용하여 모든 연산을 함께 확인해보겠습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_15.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003eBoundary detection is an edge detection technique on binary images, where you subtract the eroded image, obtaining the boundary. The idea is that with eroding we are obtaining a smaller version of the object and if we subtract the image only the boundary will remain. In formula:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_16.png\" alt=\"formula\"\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eeroded = ndimage.\u003cspan class=\"hljs-title function_\"\u003ebinary_erosion\u003c/span\u003e(binary, structure=np.\u003cspan class=\"hljs-title function_\"\u003eones\u003c/span\u003e((\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e)))\nboundary =binary ^ eroded\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_17.png\"\u003e\n\u003cp\u003e뺄셈이 아니라 두 개의 논리 마스크 (참/거짓)를 사용하기 때문에 논리 연산자 AND를 사용하는 것에 유의하세요. 그렇지 않으면 Numpy가 오류를 반환합니다. (하지만 원리는 같습니다)\u003c/p\u003e\n\u003ch2\u003e약간의 실제 예시\u003c/h2\u003e\n\u003cp\u003e마이크로스코프 이미지에서 핵 윤곽선을 선택하여 분석을 수행하려면 몇 가지 조작만으로 가능합니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 핵을 선택하려고 합니다.\n# 따라서, 파란색 부분만 선택합니다.\nim = a[:,:,\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e]\nimage = im\nthresh = \u003cspan class=\"hljs-title function_\"\u003ethreshold_otsu\u003c/span\u003e(image)\nbinary = image \u003e thresh\neroded = ndimage.\u003cspan class=\"hljs-title function_\"\u003ebinary_erosion\u003c/span\u003e(binary, structure=np.\u003cspan class=\"hljs-title function_\"\u003eones\u003c/span\u003e((\u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e)))\nopening = ndimage.\u003cspan class=\"hljs-title function_\"\u003ebinary_opening\u003c/span\u003e(eroded, structure=np.\u003cspan class=\"hljs-title function_\"\u003eones\u003c/span\u003e((\u003cspan class=\"hljs-number\"\u003e11\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e11\u003c/span\u003e)))\nboundary = binary ^ opening\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_18.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e보너스 예제: 자동차 이미지의 번호판을 읽고 싶다면, 복잡한 딥 러닝 모델 대신 간단한 전처리 단계로 시작할 수 있습니다. 하얀색과 검은색 모자(흰색은 회색 이미지에서 개방 이미지를 뺀 것이고 검은색은 회색 입력 이미지에서 닫힘을 뺀 것)와 같은 몇 가지 간단한 연산을 사용할 수 있습니다. 여기서 우리는 번호판이 가로보다 세로가 길기 때문에 사각형 커널을 사용했습니다. 그리고 임의의 크기의 커널을 사용할 수 있습니다. 몇 가지 간단한 작업만으로도 결과가 꽤 좋아집니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eimage = im\nthresh = \u003cspan class=\"hljs-title function_\"\u003ethreshold_otsu\u003c/span\u003e(image)\nbinary = image \u003e thresh\nopening = ndimage.\u003cspan class=\"hljs-title function_\"\u003ebinary_opening\u003c/span\u003e(binary, structure=np.\u003cspan class=\"hljs-title function_\"\u003eones\u003c/span\u003e((\u003cspan class=\"hljs-number\"\u003e13\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e)))\nclosing = ndimage.\u003cspan class=\"hljs-title function_\"\u003ebinary_closing\u003c/span\u003e(binary, structure=np.\u003cspan class=\"hljs-title function_\"\u003eones\u003c/span\u003e((\u003cspan class=\"hljs-number\"\u003e13\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e)))\nblack_hat =  im - closing\nwhite_hat = im - opening\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_19.png\"\u003e\n\u003ch1\u003e마무리\u003c/h1\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_20.png\"\u003e\n\u003cp\u003e우리는 간단한 연산으로 다양한 결과를 얻을 수 있는 형태학적 연산이 얼마나 강력한지 보았습니다. 각 연산에는 그만의 반대가 있다는 것을 주목할 가치가 있으며, 이들을 결합하여 더 정교한 작업을 수행할 수 있습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e합성에서는 침식 기법을 사용하여 물체를 연결하는 작은 링크를 제거하거나 작은 잡음 물체를 제거하고 바이너리 이미지에서 경계를 감지할 수 있습니다. 반면 팽창은 이미지의 부분을 연결하는 데 유용합니다. 열림은 물체를 파괴하지 않고 작은 물체를 제거할 수 있게 하며, 폐쇄는 물체 크기를 늘리지 않으면서 구멍을 메울 수 있습니다. 그리고 이러한 작업을 필요에 맞게 반복 및 조합할 수도 있습니다. 간단한 작업에 대해 나쁘지 않죠?\u003c/p\u003e\n\u003cp\u003e이전 글은 여기서 확인할 수 있습니다. 여기에서는 핵심 코드만을 보여줬지만, 사용된 모든 코드는 여기에 있습니다.\u003c/p\u003e\n\u003ch2\u003e어떻게 생각하세요? 이러한 작업을 시도해 보셨나요? 댓글로 알려주세요.\u003c/h2\u003e\n\u003ch1\u003e흥미로우셨다면:\u003c/h1\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e제 다른 글을 찾아보실 수 있고, LinkedIn에서 연락이나 소통할 수도 있습니다. 매주 업데이트되는 머신 러닝 및 인공 지능 뉴스가 포함된 이 저장소를 확인해보세요. 협업 및 프로젝트에 대해 열려 있으며 LinkedIn에서 저에게 연락할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e제 GitHub 저장소 링크는 다음과 같습니다. 거기에는 머신 러닝, 인공 지능 등과 관련된 코드와 다양한 자료를 모아두고 있습니다.\u003c/p\u003e\n\u003cp\u003e또는 최근 글 중 하나에 관심이 있을 수도 있습니다:\u003c/p\u003e\n\u003ch2\u003e추가 자료\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e형태학 연산에 대해: 일반적으로 (여기, 여기, 여기) 및 OpenCV로 (여기, 여기, 여기)\u003c/li\u003e\n\u003cli\u003e화이트와 블랙 햇에 관해: 여기\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e평문으로 이해하기 🚀\u003c/h1\u003e\n\u003cp\u003eIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 계속 진행하기 전에:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e작가를 박수 치고 팔로우해 주세요 👏\u003c/li\u003e\n\u003cli\u003e팔로우: X | LinkedIn | YouTube | Discord | 뉴스레터\u003c/li\u003e\n\u003cli\u003e다른 플랫폼 방문: Stackademic | CoFeed | Venture\u003c/li\u003e\n\u003cli\u003ePlainEnglish.io에서 더 많은 콘텐츠 확인하기\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-12-Apracticalguidetomorphologicalimageprocessing"},"buildId":"N1mNhRlQaHCliEGDvPEpG","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>