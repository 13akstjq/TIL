<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>심볼릭 회귀로 데이터 속 숨겨진 법칙 찾는 방법 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2024-07-13-FindHiddenLawsWithinYourDatawithSymbolicRegression" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="심볼릭 회귀로 데이터 속 숨겨진 법칙 찾는 방법 | TIL" data-gatsby-head="true"/><meta property="og:title" content="심볼릭 회귀로 데이터 속 숨겨진 법칙 찾는 방법 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/2024-07-13-FindHiddenLawsWithinYourDatawithSymbolicRegression_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2024-07-13-FindHiddenLawsWithinYourDatawithSymbolicRegression" data-gatsby-head="true"/><meta name="twitter:title" content="심볼릭 회귀로 데이터 속 숨겨진 법칙 찾는 방법 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/2024-07-13-FindHiddenLawsWithinYourDatawithSymbolicRegression_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-13 19:30" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-5ecfd58aae5a7e3d.js" defer=""></script><script src="/_next/static/GnJ8pEcO5t2Vzpus740Q5/_buildManifest.js" defer=""></script><script src="/_next/static/GnJ8pEcO5t2Vzpus740Q5/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">심볼릭 회귀로 데이터 속 숨겨진 법칙 찾는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="심볼릭 회귀로 데이터 속 숨겨진 법칙 찾는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 13, 2024</span><span class="posts_reading_time__f7YPP">10<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-07-13-FindHiddenLawsWithinYourDatawithSymbolicRegression&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/TIL/assets/img/2024-07-13-FindHiddenLawsWithinYourDatawithSymbolicRegression_0.png">
<p>기계 학습 전문가로서, 보통 데이터셋(X, y)을 갖고 있고, M이라고도 불리는 함수를 찾고 싶어합니다. M(X) ≈ y를 만족하는 함수입니다. 보통, 우리는 M의 함수 형태에 크게 신경 쓰지 않습니다. 우리 관점에서는, 모델이 신경망, 트리 기반 알고리즘 또는 완전히 다른 것이든 간에 테스트 세트에서 좋은 성능을 보이면 만족합니다.</p>
<p>하지만, 이러한 복잡한 모델을 사용하면 흥미로운 패턴이나 때로는 데이터 내에 잠재된 물리학이나 경제법칙을 놓칠 수 있습니다. 더 나은 결과를 얻기 위해, Symbolic Regression을 사용하여 모델을 구축하는 방법을 보여드리겠습니다. 이러한 모델은 소수의 항만으로 구성되어 어디서든 쉽게 구현할 수 있습니다. 이것이 무엇인지 살펴볼까요?</p>
<h1>물리학 실험</h1>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>실험 물리학자로서 지정한 높이 h에서 물체를 떨어뜨렸을 때 땅에 도달하는 데 얼마나 걸리는지 알아보고 싶습니다. 예를 들어, h = 1.5m의 높이에서 (공기 저항에 영향받지 않을만큼 충분히 무거운) 물체를 떨어뜨린다면, 땅에 도달하는 데 약 0.55초가 걸립니다. 한 번 시도해보세요!</p>
<p>그러나 이는 지구나 중력 가속도가 9.8067m/s²인 다른 천체에만 해당됩니다. 예를 들어, 달은 1.625m/s²의 중력 가속도를 갖고 있어 같은 물체를 1.5m에서 떨어뜨리면 약 1.36초가 더 걸립니다. 영화에서 보던 것과 일치할 것입니다.</p>
<p>이제, 우리의 작업은 땅에 도달하는 데 필요한 시간을 알려주는 일반적인 공식 t(h, g)를 찾는 것입니다. 이는 단순히 높이 h와 중력 가속도 g 값을 가져와 시간 t를 예측하는 모델을 만드는 것에 불과합니다. 나에게 참아주십시오, 친애하는 물리학자분들. 😃</p>
<h2>데이터 수집 및 모델 훈련</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>우주선을 타고 날아다닌 다음 다양한 높이와 행성에서 몇 가지 물건을 떨어뜨렸고, 항상 땅에 도달하는 데 걸리는 시간을 측정했다고 가정해 봅시다. 측정값의 첫 번째 행들은 다음과 같습니다:</p>

























<table><thead><tr><th>높이 (h)</th><th>중력 (g)</th><th>시간 (t)</th></tr></thead><tbody><tr><td>10</td><td>9.81</td><td>1.43</td></tr><tr><td>20</td><td>9.81</td><td>2.01</td></tr><tr><td>30</td><td>3.72</td><td>2.67</td></tr></tbody></table>
<p>이제 이를 훈련 세트와 테스트 세트로 나누어 표준 기계 학습 모델을 훈련시켜 볼 수 있습니다.</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestRegressor
<span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split

data = pd.read_csv(<span class="hljs-string">"https://raw.githubusercontent.com/Garve/towards_data_science/main/Symbolic%20Regression/free_fall.csv"</span>)
X = data[[<span class="hljs-string">"h"</span>, <span class="hljs-string">"g"</span>]]
y = data[<span class="hljs-string">"t"</span>]
X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=<span class="hljs-number">123</span>)

rf = RandomForestRegressor(random_state=<span class="hljs-number">123</span>).fit(X_train, y_train)
<span class="hljs-built_in">print</span>(rf.score(X_test, y_test))

<span class="hljs-comment"># 출력:</span>
<span class="hljs-comment"># 0.9874788707086176</span>
</code></pre>
<p>언제든지 궁금한 점이 있으면 물어봐 주세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>좋아요, 매우 잘 숨겨진 패턴을 학습하는 모델을 만들었네요. 근데... 그 패턴이 뭘까요?</p>
<h2>모델 해석</h2>
<p>실제로 모델 내부에 존재하는 복잡한 공식 때문에 알아내기 어렵습니다. Shapley 값들을 사용하여 모델이 무엇을 배웠는지 살펴볼 수 있습니다. 이 기사에서는 그들이 무엇인지 정말로 알 필요는 없지만, 여전히 관심이 있다면 제 다른 글을 확인하는 것을 추천합니다:</p>
<p>기본적으로, 다양한 특징이 모델의 결과에 어떤 영향을 미치는지를 결정할 수 있게 해줍니다. 멋진 shap 라이브러리를 사용하여 다음을 할 수 있어요:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"># !pip install shap
<span class="hljs-keyword">import</span> shap

te = shap.<span class="hljs-title class_">TreeExplainer</span>(rf, feature_names=[<span class="hljs-string">"h"</span>, <span class="hljs-string">"g"</span>])
shapley_values = <span class="hljs-title function_">te</span>(X)
shap.<span class="hljs-property">plots</span>.<span class="hljs-title function_">scatter</span>(shap_values=shapley_values)
</code></pre>
<p><img src="/TIL/assets/img/2024-07-13-FindHiddenLawsWithinYourDatawithSymbolicRegression_2.png" alt="FindHiddenLawsWithinYourDatawithSymbolicRegression_2"></p>
<p>왼쪽에서는 높은 h 값이 더 높은 모델 출력, 즉 더 높은 t 값을 초래한다는 것을 볼 수 있습니다. 오른쪽에서는 g 값이 낮을수록 모델에 따르면 더 높은 t 값을 얻는 것을 볼 수 있습니다. 두 관측 결과는 모두 이해하기 쉽습니다: 높은 곳에서 물체를 떨어뜨리면 땅에 닿을 때까지 더 오래 걸립니다. 그리고 지면 쪽으로 강한 힘으로 끌려오게 되면 그것은 더 빨리 땅에 닿을 것입니다.</p>
<p>보통 이러한 결과가 나오면 만족하고 모델을 배포할 수 있습니다. 그럼에도 불구하고, 이 접근 방식에는 몇 가지 문제가 있다고 주장할 수도 있습니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>모델이 꽤 복잡하므로 이론적 통찰이 전혀 없습니다.</li>
<li>그래서 우리는 scikit-learn 모델로 배포해야 하는데, 우리의 배포 서비스가 scikit-learn 모델을 좋아하지 않을 때 쉽게 다시 구현할 수 없습니다.</li>
</ul>
<p>이 두 문제를 해결하는 다른 모델을 어떻게 구축할 수 있는지 살펴봅시다.</p>
<h1>기호 회귀</h1>
<p>기호 회귀라는 기술을 활용할 수 있습니다. 이 기술은 데이터를 설명하는 간단한 대수적 표현을 찾으려고 합니다. 예를 들어, 특성 x₁, x₂ 및 x₃ 및 타겟 y로 구성된 데이터 세트에서 모델 학습 결과는 y = √x₁ + sin(x₂/(x₃+1)) 또는 y = exp(x₁²) - x₂ 와 같을 수 있습니다. "자유 낙하" 데이터 세트에서 이 모델이 어떻게 수행되는지 확인해봅시다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>심볼릭 회귀를 위한 많은 패키지가 있습니다. 예를 들어 gplearn과 PySR이 있어요. 여기서는 gplearn을 사용할 거에요. 살짝 더 쉽게 사용할 수 있어서요. 하지만 안타깝게도 2년 동안 업데이트되지 않았어요. PySR은 활발히 개발 중이지만 밑바닥에는 Julia를 사용하기 때문에 또 다른 종속성이 생기는 거에요.</p>
<h2>심볼릭 회귀 맞춤</h2>
<p>먼저 gplearn을 설치해볼게요. pip install gplearn을 통해 간단하게 설치할 수 있어요. 그리고 SymbolicRegressor를 정의하고, 덧셈이나 로그 취하기와 같은 연산을 공식 내에서 사용할 수 있도록 설정해보아요.</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">from</span> gplearn.genetic <span class="hljs-keyword">import</span> SymbolicRegressor

sr = SymbolicRegressor(
    function_set=(
        <span class="hljs-string">"add"</span>,
        <span class="hljs-string">"sub"</span>,
        <span class="hljs-string">"mul"</span>,
        <span class="hljs-string">"div"</span>,
        <span class="hljs-string">"sqrt"</span>,
        <span class="hljs-string">"log"</span>,
        <span class="hljs-string">"abs"</span>,
        <span class="hljs-string">"neg"</span>,
    ),
    random_state=<span class="hljs-number">0</span>,
)

sr.fit(X_train, y_train)
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>지금 모델은 다음과 같은 공식을 찾으려고 노력합니다:</p>
<ul>
<li>간단하면서도</li>
<li>데이터를 잘 설명하는 즉, 손실이 적은 공식</li>
</ul>
<p>제 경우에는 다음과 같은 결과가 나왔어요:</p>
<p><img src="/TIL/assets/img/2024-07-13-FindHiddenLawsWithinYourDatawithSymbolicRegression_3.png" alt="이미지"></p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>아래는</p>
<p><img src="/TIL/assets/img/2024-07-13-FindHiddenLawsWithinYourDatawithSymbolicRegression_4.png" alt="Physical laws rediscovered by PySR authors"></p>
<p>since x₀ = h and x₁ = g. Apart from having a test r² of over 0.999, this is actually the correct physics formula that describes falling objects without air resistance! You might also find the equivalent formula h = 0.5 · g · t² in literature.</p>
<p>And don’t only take it from me. The authors of PySR published a paper in which they show how many more physical laws could be rediscovered. On page 16, you can see this table:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>표 태그를 Markdown 형식으로 변경하세요.</p>
<p>열을 보면 심볼릭 회귀 라이브러리들이 나와 있어요. 왼쪽에는 물리 법칙이 있구요. 셀 안의 분수는 올바른 표현을 찾은 횟수를 전체 시도 횟수로 나눈 것이에요. 다음은 수식들이에요:</p>
<p>Planck의 법칙과 Rydberg 공식은 어떤 라이브러리도 발견하기 어려웠어요. 그래도 PySR만 다른 경우에 잘하고 있었어요. gnlearn은 비교 대상이 아니었어요.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>어떻게 이 마법이 작동할까요?</h2>
<p>우리 모델의 기능 형태는 완전히 미친 것일 수 있습니다. 이는 신경망에서 일어나는 일과 근본적으로 다릅니다. 신경망에서는 공식 자체가 고정되어 있고 매개변수만 조정됩니다. 또는 그라디언트 부스팅과 같은 트리 기반 알고리즘에서는 결과가 언제나 조각별 상수 함수가 됩니다.</p>
<p>길게 말하면, 이 기사에서 다루기에는 너무 길 것인 내재하는 진화 알고리즘을 사용합니다. 이들은 매우 무작위하고 휴리스틱한 프로세스이며, 극도로 분석하기 어렵습니다. 그래도 실전에서는 상당히 잘 작동할 수 있습니다. 만약 진화 알고리즘에 대해 초보자를 위한 기사를 읽고 싶다면, 제 다른 기사를 확인해 보세요:</p>
<p>지금 읽기 싫다면, 현재 사용 사례에 대한 핵심 아이디어는 여기에 있습니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>간단한 무작위 수식들로 시작해보세요, 예를 들어 t = h, t = g², t = g + h, t = √h, ...</li>
<li>평가 지표로 예를 들어 평균 제곱 오차를 사용해 그들이 얼마나 좋은지 확인해보세요.</li>
<li>가장 좋은 수식들을 선택하여 결합해보세요, 예를 들어 t = h와 t = g²를 결합하면 t = h + g²가 될 수 있습니다. 또는 t = √h와 t = h · g를 결합하면 t = √(h · g)가 될 수 있습니다.</li>
<li>그들을 변형할 수도 있습니다. 예를 들어, t = √(h·g)를 약간 변경하여 t = √(h + g)로 변형할 수 있습니다.</li>
<li>이제 새로운 수식 집합이 있으므로 다시 1단계로 돌아갈 수 있습니다. 또는 이미 아주 좋은 수식을 찾은 경우 중단할 수도 있습니다.</li>
</ul>
<p>이러한 절차를 구현하는 방법은 사용하는 라이브러리에 따라 다를 수 있습니다. 이러한 알고리즘을 작성하는 것이 정말 재미있는 일이 될 수 있도록 이러한 단계를 설계하는 데 많은 자유가 주어집니다. PySR 저자들은 논문에서 그들만의 진화 알고리즘 특정 버전을 설명하고 있습니다.</p>
<h1>결론</h1>
<p>이 글에서는 의미 있는 수식으로 모델을 구축하는 것이 얼마나 쉬운지 살펴보았습니다. 예를 들어, 우리의 예제에서는 테스트 세트의 성능뿐만 아니라, 더 나았습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>예를 들어, SQL로 이동하여 다음과 같이 작성할 수 있어요:</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span>
  h,
  g,
  <span class="hljs-title function_">SQRT</span>(<span class="hljs-number">2</span> * h / g) <span class="hljs-variable constant_">AS</span> t_pred
<span class="hljs-variable constant_">FROM</span>
  your_table
</code></pre>
<p>그럼 이제 시작해봅시다! 이 공식을 선택하는 어떤 프로그래밍 언어에서도 쉽게 다시 구현할 수 있어요.</p>
<p>물론 공식이 항상 간단하거나 데이터를 잘 설명하지는 않을 수 있어요. 이 경우에는 항상 사인, 지수 함수와 같은 다른 연산을 추가하거나, 자체 작은 빌딩 블록을 만들 수 있어요. 이것은 다시 명확한 공식을 만드는 데 도움이 될 수 있어요.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>오늘 새롭고 흥미로운, 가치있는 것을 배우셨기를 바랍니다. 읽어 주셔서 감사합니다!</p>
<p>그리고 알고리즘의 세계로 더 깊이 파고들고 싶다면, 제 새로운 출간물 '알고리즘에 관한 모든 것'을 한 번 살펴보세요! 아직 작가를 모집 중입니다!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"심볼릭 회귀로 데이터 속 숨겨진 법칙 찾는 방법","description":"","date":"2024-07-13 19:30","slug":"2024-07-13-FindHiddenLawsWithinYourDatawithSymbolicRegression","content":"\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-FindHiddenLawsWithinYourDatawithSymbolicRegression_0.png\" /\u003e\n\n기계 학습 전문가로서, 보통 데이터셋(X, y)을 갖고 있고, M이라고도 불리는 함수를 찾고 싶어합니다. M(X) ≈ y를 만족하는 함수입니다. 보통, 우리는 M의 함수 형태에 크게 신경 쓰지 않습니다. 우리 관점에서는, 모델이 신경망, 트리 기반 알고리즘 또는 완전히 다른 것이든 간에 테스트 세트에서 좋은 성능을 보이면 만족합니다.\n\n하지만, 이러한 복잡한 모델을 사용하면 흥미로운 패턴이나 때로는 데이터 내에 잠재된 물리학이나 경제법칙을 놓칠 수 있습니다. 더 나은 결과를 얻기 위해, Symbolic Regression을 사용하여 모델을 구축하는 방법을 보여드리겠습니다. 이러한 모델은 소수의 항만으로 구성되어 어디서든 쉽게 구현할 수 있습니다. 이것이 무엇인지 살펴볼까요?\n\n# 물리학 실험\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n실험 물리학자로서 지정한 높이 h에서 물체를 떨어뜨렸을 때 땅에 도달하는 데 얼마나 걸리는지 알아보고 싶습니다. 예를 들어, h = 1.5m의 높이에서 (공기 저항에 영향받지 않을만큼 충분히 무거운) 물체를 떨어뜨린다면, 땅에 도달하는 데 약 0.55초가 걸립니다. 한 번 시도해보세요!\n\n그러나 이는 지구나 중력 가속도가 9.8067m/s²인 다른 천체에만 해당됩니다. 예를 들어, 달은 1.625m/s²의 중력 가속도를 갖고 있어 같은 물체를 1.5m에서 떨어뜨리면 약 1.36초가 더 걸립니다. 영화에서 보던 것과 일치할 것입니다.\n\n이제, 우리의 작업은 땅에 도달하는 데 필요한 시간을 알려주는 일반적인 공식 t(h, g)를 찾는 것입니다. 이는 단순히 높이 h와 중력 가속도 g 값을 가져와 시간 t를 예측하는 모델을 만드는 것에 불과합니다. 나에게 참아주십시오, 친애하는 물리학자분들. 😃\n\n## 데이터 수집 및 모델 훈련\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우주선을 타고 날아다닌 다음 다양한 높이와 행성에서 몇 가지 물건을 떨어뜨렸고, 항상 땅에 도달하는 데 걸리는 시간을 측정했다고 가정해 봅시다. 측정값의 첫 번째 행들은 다음과 같습니다:\n\n| 높이 (h) | 중력 (g) | 시간 (t) |\n| ------- | ------- | ------- |\n| 10      | 9.81    | 1.43    |\n| 20      | 9.81    | 2.01    |\n| 30      | 3.72    | 2.67    |\n\n이제 이를 훈련 세트와 테스트 세트로 나누어 표준 기계 학습 모델을 훈련시켜 볼 수 있습니다.\n\n```python\nimport pandas as pd\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.model_selection import train_test_split\n\ndata = pd.read_csv(\"https://raw.githubusercontent.com/Garve/towards_data_science/main/Symbolic%20Regression/free_fall.csv\")\nX = data[[\"h\", \"g\"]]\ny = data[\"t\"]\nX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=123)\n\nrf = RandomForestRegressor(random_state=123).fit(X_train, y_train)\nprint(rf.score(X_test, y_test))\n\n# 출력:\n# 0.9874788707086176\n```\n\n언제든지 궁금한 점이 있으면 물어봐 주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n좋아요, 매우 잘 숨겨진 패턴을 학습하는 모델을 만들었네요. 근데... 그 패턴이 뭘까요?\n\n## 모델 해석\n\n실제로 모델 내부에 존재하는 복잡한 공식 때문에 알아내기 어렵습니다. Shapley 값들을 사용하여 모델이 무엇을 배웠는지 살펴볼 수 있습니다. 이 기사에서는 그들이 무엇인지 정말로 알 필요는 없지만, 여전히 관심이 있다면 제 다른 글을 확인하는 것을 추천합니다:\n\n기본적으로, 다양한 특징이 모델의 결과에 어떤 영향을 미치는지를 결정할 수 있게 해줍니다. 멋진 shap 라이브러리를 사용하여 다음을 할 수 있어요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# !pip install shap\nimport shap\n\nte = shap.TreeExplainer(rf, feature_names=[\"h\", \"g\"])\nshapley_values = te(X)\nshap.plots.scatter(shap_values=shapley_values)\n```\n\n![FindHiddenLawsWithinYourDatawithSymbolicRegression_2](/TIL/assets/img/2024-07-13-FindHiddenLawsWithinYourDatawithSymbolicRegression_2.png)\n\n왼쪽에서는 높은 h 값이 더 높은 모델 출력, 즉 더 높은 t 값을 초래한다는 것을 볼 수 있습니다. 오른쪽에서는 g 값이 낮을수록 모델에 따르면 더 높은 t 값을 얻는 것을 볼 수 있습니다. 두 관측 결과는 모두 이해하기 쉽습니다: 높은 곳에서 물체를 떨어뜨리면 땅에 닿을 때까지 더 오래 걸립니다. 그리고 지면 쪽으로 강한 힘으로 끌려오게 되면 그것은 더 빨리 땅에 닿을 것입니다.\n\n보통 이러한 결과가 나오면 만족하고 모델을 배포할 수 있습니다. 그럼에도 불구하고, 이 접근 방식에는 몇 가지 문제가 있다고 주장할 수도 있습니다:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 모델이 꽤 복잡하므로 이론적 통찰이 전혀 없습니다.\n- 그래서 우리는 scikit-learn 모델로 배포해야 하는데, 우리의 배포 서비스가 scikit-learn 모델을 좋아하지 않을 때 쉽게 다시 구현할 수 없습니다.\n\n이 두 문제를 해결하는 다른 모델을 어떻게 구축할 수 있는지 살펴봅시다.\n\n# 기호 회귀\n\n기호 회귀라는 기술을 활용할 수 있습니다. 이 기술은 데이터를 설명하는 간단한 대수적 표현을 찾으려고 합니다. 예를 들어, 특성 x₁, x₂ 및 x₃ 및 타겟 y로 구성된 데이터 세트에서 모델 학습 결과는 y = √x₁ + sin(x₂/(x₃+1)) 또는 y = exp(x₁²) - x₂ 와 같을 수 있습니다. \"자유 낙하\" 데이터 세트에서 이 모델이 어떻게 수행되는지 확인해봅시다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n심볼릭 회귀를 위한 많은 패키지가 있습니다. 예를 들어 gplearn과 PySR이 있어요. 여기서는 gplearn을 사용할 거에요. 살짝 더 쉽게 사용할 수 있어서요. 하지만 안타깝게도 2년 동안 업데이트되지 않았어요. PySR은 활발히 개발 중이지만 밑바닥에는 Julia를 사용하기 때문에 또 다른 종속성이 생기는 거에요.\n\n## 심볼릭 회귀 맞춤\n\n먼저 gplearn을 설치해볼게요. pip install gplearn을 통해 간단하게 설치할 수 있어요. 그리고 SymbolicRegressor를 정의하고, 덧셈이나 로그 취하기와 같은 연산을 공식 내에서 사용할 수 있도록 설정해보아요.\n\n```python\nfrom gplearn.genetic import SymbolicRegressor\n\nsr = SymbolicRegressor(\n    function_set=(\n        \"add\",\n        \"sub\",\n        \"mul\",\n        \"div\",\n        \"sqrt\",\n        \"log\",\n        \"abs\",\n        \"neg\",\n    ),\n    random_state=0,\n)\n\nsr.fit(X_train, y_train)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금 모델은 다음과 같은 공식을 찾으려고 노력합니다:\n\n- 간단하면서도\n- 데이터를 잘 설명하는 즉, 손실이 적은 공식\n\n제 경우에는 다음과 같은 결과가 나왔어요:\n\n![이미지](/TIL/assets/img/2024-07-13-FindHiddenLawsWithinYourDatawithSymbolicRegression_3.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는\n\n\n![Physical laws rediscovered by PySR authors](/TIL/assets/img/2024-07-13-FindHiddenLawsWithinYourDatawithSymbolicRegression_4.png)\n\nsince x₀ = h and x₁ = g. Apart from having a test r² of over 0.999, this is actually the correct physics formula that describes falling objects without air resistance! You might also find the equivalent formula h = 0.5 · g · t² in literature.\n\nAnd don’t only take it from me. The authors of PySR published a paper in which they show how many more physical laws could be rediscovered. On page 16, you can see this table:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n표 태그를 Markdown 형식으로 변경하세요.\n\n열을 보면 심볼릭 회귀 라이브러리들이 나와 있어요. 왼쪽에는 물리 법칙이 있구요. 셀 안의 분수는 올바른 표현을 찾은 횟수를 전체 시도 횟수로 나눈 것이에요. 다음은 수식들이에요:\n\nPlanck의 법칙과 Rydberg 공식은 어떤 라이브러리도 발견하기 어려웠어요. 그래도 PySR만 다른 경우에 잘하고 있었어요. gnlearn은 비교 대상이 아니었어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 어떻게 이 마법이 작동할까요?\n\n우리 모델의 기능 형태는 완전히 미친 것일 수 있습니다. 이는 신경망에서 일어나는 일과 근본적으로 다릅니다. 신경망에서는 공식 자체가 고정되어 있고 매개변수만 조정됩니다. 또는 그라디언트 부스팅과 같은 트리 기반 알고리즘에서는 결과가 언제나 조각별 상수 함수가 됩니다.\n\n길게 말하면, 이 기사에서 다루기에는 너무 길 것인 내재하는 진화 알고리즘을 사용합니다. 이들은 매우 무작위하고 휴리스틱한 프로세스이며, 극도로 분석하기 어렵습니다. 그래도 실전에서는 상당히 잘 작동할 수 있습니다. 만약 진화 알고리즘에 대해 초보자를 위한 기사를 읽고 싶다면, 제 다른 기사를 확인해 보세요:\n\n지금 읽기 싫다면, 현재 사용 사례에 대한 핵심 아이디어는 여기에 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 간단한 무작위 수식들로 시작해보세요, 예를 들어 t = h, t = g², t = g + h, t = √h, ...\n- 평가 지표로 예를 들어 평균 제곱 오차를 사용해 그들이 얼마나 좋은지 확인해보세요.\n- 가장 좋은 수식들을 선택하여 결합해보세요, 예를 들어 t = h와 t = g²를 결합하면 t = h + g²가 될 수 있습니다. 또는 t = √h와 t = h · g를 결합하면 t = √(h · g)가 될 수 있습니다.\n- 그들을 변형할 수도 있습니다. 예를 들어, t = √(h·g)를 약간 변경하여 t = √(h + g)로 변형할 수 있습니다.\n- 이제 새로운 수식 집합이 있으므로 다시 1단계로 돌아갈 수 있습니다. 또는 이미 아주 좋은 수식을 찾은 경우 중단할 수도 있습니다.\n\n이러한 절차를 구현하는 방법은 사용하는 라이브러리에 따라 다를 수 있습니다. 이러한 알고리즘을 작성하는 것이 정말 재미있는 일이 될 수 있도록 이러한 단계를 설계하는 데 많은 자유가 주어집니다. PySR 저자들은 논문에서 그들만의 진화 알고리즘 특정 버전을 설명하고 있습니다.\n\n# 결론\n\n이 글에서는 의미 있는 수식으로 모델을 구축하는 것이 얼마나 쉬운지 살펴보았습니다. 예를 들어, 우리의 예제에서는 테스트 세트의 성능뿐만 아니라, 더 나았습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, SQL로 이동하여 다음과 같이 작성할 수 있어요:\n\n```js\nSELECT\n  h,\n  g,\n  SQRT(2 * h / g) AS t_pred\nFROM\n  your_table\n```\n\n그럼 이제 시작해봅시다! 이 공식을 선택하는 어떤 프로그래밍 언어에서도 쉽게 다시 구현할 수 있어요.\n\n물론 공식이 항상 간단하거나 데이터를 잘 설명하지는 않을 수 있어요. 이 경우에는 항상 사인, 지수 함수와 같은 다른 연산을 추가하거나, 자체 작은 빌딩 블록을 만들 수 있어요. 이것은 다시 명확한 공식을 만드는 데 도움이 될 수 있어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n오늘 새롭고 흥미로운, 가치있는 것을 배우셨기를 바랍니다. 읽어 주셔서 감사합니다!\n\n그리고 알고리즘의 세계로 더 깊이 파고들고 싶다면, 제 새로운 출간물 '알고리즘에 관한 모든 것'을 한 번 살펴보세요! 아직 작가를 모집 중입니다!","ogImage":{"url":"/TIL/assets/img/2024-07-13-FindHiddenLawsWithinYourDatawithSymbolicRegression_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-FindHiddenLawsWithinYourDatawithSymbolicRegression_0.png","tag":["Tech"],"readingTime":10},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-13-FindHiddenLawsWithinYourDatawithSymbolicRegression_0.png\"\u003e\n\u003cp\u003e기계 학습 전문가로서, 보통 데이터셋(X, y)을 갖고 있고, M이라고도 불리는 함수를 찾고 싶어합니다. M(X) ≈ y를 만족하는 함수입니다. 보통, 우리는 M의 함수 형태에 크게 신경 쓰지 않습니다. 우리 관점에서는, 모델이 신경망, 트리 기반 알고리즘 또는 완전히 다른 것이든 간에 테스트 세트에서 좋은 성능을 보이면 만족합니다.\u003c/p\u003e\n\u003cp\u003e하지만, 이러한 복잡한 모델을 사용하면 흥미로운 패턴이나 때로는 데이터 내에 잠재된 물리학이나 경제법칙을 놓칠 수 있습니다. 더 나은 결과를 얻기 위해, Symbolic Regression을 사용하여 모델을 구축하는 방법을 보여드리겠습니다. 이러한 모델은 소수의 항만으로 구성되어 어디서든 쉽게 구현할 수 있습니다. 이것이 무엇인지 살펴볼까요?\u003c/p\u003e\n\u003ch1\u003e물리학 실험\u003c/h1\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e실험 물리학자로서 지정한 높이 h에서 물체를 떨어뜨렸을 때 땅에 도달하는 데 얼마나 걸리는지 알아보고 싶습니다. 예를 들어, h = 1.5m의 높이에서 (공기 저항에 영향받지 않을만큼 충분히 무거운) 물체를 떨어뜨린다면, 땅에 도달하는 데 약 0.55초가 걸립니다. 한 번 시도해보세요!\u003c/p\u003e\n\u003cp\u003e그러나 이는 지구나 중력 가속도가 9.8067m/s²인 다른 천체에만 해당됩니다. 예를 들어, 달은 1.625m/s²의 중력 가속도를 갖고 있어 같은 물체를 1.5m에서 떨어뜨리면 약 1.36초가 더 걸립니다. 영화에서 보던 것과 일치할 것입니다.\u003c/p\u003e\n\u003cp\u003e이제, 우리의 작업은 땅에 도달하는 데 필요한 시간을 알려주는 일반적인 공식 t(h, g)를 찾는 것입니다. 이는 단순히 높이 h와 중력 가속도 g 값을 가져와 시간 t를 예측하는 모델을 만드는 것에 불과합니다. 나에게 참아주십시오, 친애하는 물리학자분들. 😃\u003c/p\u003e\n\u003ch2\u003e데이터 수집 및 모델 훈련\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e우주선을 타고 날아다닌 다음 다양한 높이와 행성에서 몇 가지 물건을 떨어뜨렸고, 항상 땅에 도달하는 데 걸리는 시간을 측정했다고 가정해 봅시다. 측정값의 첫 번째 행들은 다음과 같습니다:\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e높이 (h)\u003c/th\u003e\u003cth\u003e중력 (g)\u003c/th\u003e\u003cth\u003e시간 (t)\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e10\u003c/td\u003e\u003ctd\u003e9.81\u003c/td\u003e\u003ctd\u003e1.43\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e20\u003c/td\u003e\u003ctd\u003e9.81\u003c/td\u003e\u003ctd\u003e2.01\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e30\u003c/td\u003e\u003ctd\u003e3.72\u003c/td\u003e\u003ctd\u003e2.67\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e이제 이를 훈련 세트와 테스트 세트로 나누어 표준 기계 학습 모델을 훈련시켜 볼 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pandas \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pd\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e sklearn.ensemble \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e RandomForestRegressor\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e sklearn.model_selection \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e train_test_split\n\ndata = pd.read_csv(\u003cspan class=\"hljs-string\"\u003e\"https://raw.githubusercontent.com/Garve/towards_data_science/main/Symbolic%20Regression/free_fall.csv\"\u003c/span\u003e)\nX = data[[\u003cspan class=\"hljs-string\"\u003e\"h\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"g\"\u003c/span\u003e]]\ny = data[\u003cspan class=\"hljs-string\"\u003e\"t\"\u003c/span\u003e]\nX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=\u003cspan class=\"hljs-number\"\u003e123\u003c/span\u003e)\n\nrf = RandomForestRegressor(random_state=\u003cspan class=\"hljs-number\"\u003e123\u003c/span\u003e).fit(X_train, y_train)\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(rf.score(X_test, y_test))\n\n\u003cspan class=\"hljs-comment\"\u003e# 출력:\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e# 0.9874788707086176\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e언제든지 궁금한 점이 있으면 물어봐 주세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e좋아요, 매우 잘 숨겨진 패턴을 학습하는 모델을 만들었네요. 근데... 그 패턴이 뭘까요?\u003c/p\u003e\n\u003ch2\u003e모델 해석\u003c/h2\u003e\n\u003cp\u003e실제로 모델 내부에 존재하는 복잡한 공식 때문에 알아내기 어렵습니다. Shapley 값들을 사용하여 모델이 무엇을 배웠는지 살펴볼 수 있습니다. 이 기사에서는 그들이 무엇인지 정말로 알 필요는 없지만, 여전히 관심이 있다면 제 다른 글을 확인하는 것을 추천합니다:\u003c/p\u003e\n\u003cp\u003e기본적으로, 다양한 특징이 모델의 결과에 어떤 영향을 미치는지를 결정할 수 있게 해줍니다. 멋진 shap 라이브러리를 사용하여 다음을 할 수 있어요:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# !pip install shap\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e shap\n\nte = shap.\u003cspan class=\"hljs-title class_\"\u003eTreeExplainer\u003c/span\u003e(rf, feature_names=[\u003cspan class=\"hljs-string\"\u003e\"h\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"g\"\u003c/span\u003e])\nshapley_values = \u003cspan class=\"hljs-title function_\"\u003ete\u003c/span\u003e(X)\nshap.\u003cspan class=\"hljs-property\"\u003eplots\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003escatter\u003c/span\u003e(shap_values=shapley_values)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-FindHiddenLawsWithinYourDatawithSymbolicRegression_2.png\" alt=\"FindHiddenLawsWithinYourDatawithSymbolicRegression_2\"\u003e\u003c/p\u003e\n\u003cp\u003e왼쪽에서는 높은 h 값이 더 높은 모델 출력, 즉 더 높은 t 값을 초래한다는 것을 볼 수 있습니다. 오른쪽에서는 g 값이 낮을수록 모델에 따르면 더 높은 t 값을 얻는 것을 볼 수 있습니다. 두 관측 결과는 모두 이해하기 쉽습니다: 높은 곳에서 물체를 떨어뜨리면 땅에 닿을 때까지 더 오래 걸립니다. 그리고 지면 쪽으로 강한 힘으로 끌려오게 되면 그것은 더 빨리 땅에 닿을 것입니다.\u003c/p\u003e\n\u003cp\u003e보통 이러한 결과가 나오면 만족하고 모델을 배포할 수 있습니다. 그럼에도 불구하고, 이 접근 방식에는 몇 가지 문제가 있다고 주장할 수도 있습니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e모델이 꽤 복잡하므로 이론적 통찰이 전혀 없습니다.\u003c/li\u003e\n\u003cli\u003e그래서 우리는 scikit-learn 모델로 배포해야 하는데, 우리의 배포 서비스가 scikit-learn 모델을 좋아하지 않을 때 쉽게 다시 구현할 수 없습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 두 문제를 해결하는 다른 모델을 어떻게 구축할 수 있는지 살펴봅시다.\u003c/p\u003e\n\u003ch1\u003e기호 회귀\u003c/h1\u003e\n\u003cp\u003e기호 회귀라는 기술을 활용할 수 있습니다. 이 기술은 데이터를 설명하는 간단한 대수적 표현을 찾으려고 합니다. 예를 들어, 특성 x₁, x₂ 및 x₃ 및 타겟 y로 구성된 데이터 세트에서 모델 학습 결과는 y = √x₁ + sin(x₂/(x₃+1)) 또는 y = exp(x₁²) - x₂ 와 같을 수 있습니다. \"자유 낙하\" 데이터 세트에서 이 모델이 어떻게 수행되는지 확인해봅시다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e심볼릭 회귀를 위한 많은 패키지가 있습니다. 예를 들어 gplearn과 PySR이 있어요. 여기서는 gplearn을 사용할 거에요. 살짝 더 쉽게 사용할 수 있어서요. 하지만 안타깝게도 2년 동안 업데이트되지 않았어요. PySR은 활발히 개발 중이지만 밑바닥에는 Julia를 사용하기 때문에 또 다른 종속성이 생기는 거에요.\u003c/p\u003e\n\u003ch2\u003e심볼릭 회귀 맞춤\u003c/h2\u003e\n\u003cp\u003e먼저 gplearn을 설치해볼게요. pip install gplearn을 통해 간단하게 설치할 수 있어요. 그리고 SymbolicRegressor를 정의하고, 덧셈이나 로그 취하기와 같은 연산을 공식 내에서 사용할 수 있도록 설정해보아요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e gplearn.genetic \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e SymbolicRegressor\n\nsr = SymbolicRegressor(\n    function_set=(\n        \u003cspan class=\"hljs-string\"\u003e\"add\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"sub\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"mul\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"div\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"sqrt\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"log\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"abs\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"neg\"\u003c/span\u003e,\n    ),\n    random_state=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n)\n\nsr.fit(X_train, y_train)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e지금 모델은 다음과 같은 공식을 찾으려고 노력합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e간단하면서도\u003c/li\u003e\n\u003cli\u003e데이터를 잘 설명하는 즉, 손실이 적은 공식\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e제 경우에는 다음과 같은 결과가 나왔어요:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-FindHiddenLawsWithinYourDatawithSymbolicRegression_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e아래는\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-FindHiddenLawsWithinYourDatawithSymbolicRegression_4.png\" alt=\"Physical laws rediscovered by PySR authors\"\u003e\u003c/p\u003e\n\u003cp\u003esince x₀ = h and x₁ = g. Apart from having a test r² of over 0.999, this is actually the correct physics formula that describes falling objects without air resistance! You might also find the equivalent formula h = 0.5 · g · t² in literature.\u003c/p\u003e\n\u003cp\u003eAnd don’t only take it from me. The authors of PySR published a paper in which they show how many more physical laws could be rediscovered. On page 16, you can see this table:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e표 태그를 Markdown 형식으로 변경하세요.\u003c/p\u003e\n\u003cp\u003e열을 보면 심볼릭 회귀 라이브러리들이 나와 있어요. 왼쪽에는 물리 법칙이 있구요. 셀 안의 분수는 올바른 표현을 찾은 횟수를 전체 시도 횟수로 나눈 것이에요. 다음은 수식들이에요:\u003c/p\u003e\n\u003cp\u003ePlanck의 법칙과 Rydberg 공식은 어떤 라이브러리도 발견하기 어려웠어요. 그래도 PySR만 다른 경우에 잘하고 있었어요. gnlearn은 비교 대상이 아니었어요.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e어떻게 이 마법이 작동할까요?\u003c/h2\u003e\n\u003cp\u003e우리 모델의 기능 형태는 완전히 미친 것일 수 있습니다. 이는 신경망에서 일어나는 일과 근본적으로 다릅니다. 신경망에서는 공식 자체가 고정되어 있고 매개변수만 조정됩니다. 또는 그라디언트 부스팅과 같은 트리 기반 알고리즘에서는 결과가 언제나 조각별 상수 함수가 됩니다.\u003c/p\u003e\n\u003cp\u003e길게 말하면, 이 기사에서 다루기에는 너무 길 것인 내재하는 진화 알고리즘을 사용합니다. 이들은 매우 무작위하고 휴리스틱한 프로세스이며, 극도로 분석하기 어렵습니다. 그래도 실전에서는 상당히 잘 작동할 수 있습니다. 만약 진화 알고리즘에 대해 초보자를 위한 기사를 읽고 싶다면, 제 다른 기사를 확인해 보세요:\u003c/p\u003e\n\u003cp\u003e지금 읽기 싫다면, 현재 사용 사례에 대한 핵심 아이디어는 여기에 있습니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e간단한 무작위 수식들로 시작해보세요, 예를 들어 t = h, t = g², t = g + h, t = √h, ...\u003c/li\u003e\n\u003cli\u003e평가 지표로 예를 들어 평균 제곱 오차를 사용해 그들이 얼마나 좋은지 확인해보세요.\u003c/li\u003e\n\u003cli\u003e가장 좋은 수식들을 선택하여 결합해보세요, 예를 들어 t = h와 t = g²를 결합하면 t = h + g²가 될 수 있습니다. 또는 t = √h와 t = h · g를 결합하면 t = √(h · g)가 될 수 있습니다.\u003c/li\u003e\n\u003cli\u003e그들을 변형할 수도 있습니다. 예를 들어, t = √(h·g)를 약간 변경하여 t = √(h + g)로 변형할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e이제 새로운 수식 집합이 있으므로 다시 1단계로 돌아갈 수 있습니다. 또는 이미 아주 좋은 수식을 찾은 경우 중단할 수도 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 절차를 구현하는 방법은 사용하는 라이브러리에 따라 다를 수 있습니다. 이러한 알고리즘을 작성하는 것이 정말 재미있는 일이 될 수 있도록 이러한 단계를 설계하는 데 많은 자유가 주어집니다. PySR 저자들은 논문에서 그들만의 진화 알고리즘 특정 버전을 설명하고 있습니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e이 글에서는 의미 있는 수식으로 모델을 구축하는 것이 얼마나 쉬운지 살펴보았습니다. 예를 들어, 우리의 예제에서는 테스트 세트의 성능뿐만 아니라, 더 나았습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e예를 들어, SQL로 이동하여 다음과 같이 작성할 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e\n  h,\n  g,\n  \u003cspan class=\"hljs-title function_\"\u003eSQRT\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e * h / g) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e t_pred\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e\n  your_table\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그럼 이제 시작해봅시다! 이 공식을 선택하는 어떤 프로그래밍 언어에서도 쉽게 다시 구현할 수 있어요.\u003c/p\u003e\n\u003cp\u003e물론 공식이 항상 간단하거나 데이터를 잘 설명하지는 않을 수 있어요. 이 경우에는 항상 사인, 지수 함수와 같은 다른 연산을 추가하거나, 자체 작은 빌딩 블록을 만들 수 있어요. 이것은 다시 명확한 공식을 만드는 데 도움이 될 수 있어요.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e오늘 새롭고 흥미로운, 가치있는 것을 배우셨기를 바랍니다. 읽어 주셔서 감사합니다!\u003c/p\u003e\n\u003cp\u003e그리고 알고리즘의 세계로 더 깊이 파고들고 싶다면, 제 새로운 출간물 '알고리즘에 관한 모든 것'을 한 번 살펴보세요! 아직 작가를 모집 중입니다!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-13-FindHiddenLawsWithinYourDatawithSymbolicRegression"},"buildId":"GnJ8pEcO5t2Vzpus740Q5","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>