<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>첫 로컬 LLM 실행 방법  | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2024-07-13-HowtorunyourfirstlocalLLMs" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="첫 로컬 LLM 실행 방법  | TIL" data-gatsby-head="true"/><meta property="og:title" content="첫 로컬 LLM 실행 방법  | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2024-07-13-HowtorunyourfirstlocalLLMs" data-gatsby-head="true"/><meta name="twitter:title" content="첫 로컬 LLM 실행 방법  | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-13 20:12" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-8ded8b979ba73586.js" defer=""></script><script src="/TIL/_next/static/X4OrKfmLtU3-3BijwfHe6/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/X4OrKfmLtU3-3BijwfHe6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">첫 로컬 LLM 실행 방법 </h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="첫 로컬 LLM 실행 방법 " loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 13, 2024</span><span class="posts_reading_time__f7YPP">22<!-- --> min read</span></span></div></div></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_0.png" alt="How to run your first local LLMs"></p>
<p>작년 동안 (2024년에 이 글을 쓰고 있기 때문에) 대형 언어 모델(LLMs)은 전문적인 환경과 작업 수행 방식을 변화시켰습니다.</p>
<p>Chat GPT와 그들의 Chat 버전에 익숙하실 것입니다. 당신은 Chat GPT Plus 사용자(OpenAI의 유료 플랜)일 수도 있습니다. 또는 Anthropic이나 Google Bard와 같은 다른 유사한 제공 업체를 사용해본 적이 있을 수도 있습니다. 심지어 OpenAI와 경쟁 업체 모두 강력한 도구를 제공하지만, 여기 몇 가지 이유가 있어서 LLMs를 로컬에서 실행해 보려고 하는 것을 고려해볼만 합니다 (더 많을 수 있습니다!):</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>생태계에 대해 더 알고 새로운 모델을 시도하며 자신만의 경험을 소유하고 싶다면.</li>
<li>딥 러닝과 LLMs에 대해 배우고 싶지만 시작할 곳을 모르겠거나 더 알고 싶다면; 오픈 소스 모델을 로컬에서 실행하는 것이 훌륭한 시작점이 될 수 있습니다.</li>
<li>개인 정보를 오픈AI나 구글과 같은 대기업에 제공하고 싶지 않다면.</li>
<li>인터넷 연결이 필요하지 않고 오프라인에서 실행할 수 있는 채팅 애플리케이션을 원한다면.</li>
<li>금융이나 문학 작성과 같은 특정 작업을 위해 더 작고 특화된 모델로 실험하고 싶다면.</li>
</ul>
<p>얼마 전 나 또한 모든 이러한 요구 사항을 만족시켰습니다. 모든 이 기술 주변의 정보 양에 압도되었다고 느꼈습니다. 일반적인 조언으로 말할 때 목표가 오르막길처럼 느껴진다면 산만 바라보지 말고 가능한 한 빨리 첫 번째 발을 내딛어 올라가세요. 그리고 계속 그렇게 계단을 올라가다 보면 다음 산이 보이게 될 것입니다 (ㅋ).</p>
<p>이 여정에서 첫 단계를 내딛도록 도와드리기 위해 프로세스를 아래 네 부분으로 나누어 설명했습니다:</p>
<ul>
<li>기본 개념 몇 가지: 이 섹션에서는 미리 알려진 지식을 가정하지 않고 자습서 전반에 걸쳐 사용되는 주요 용어와 아이디어를 소개합니다.</li>
<li>GPT4All에서 모델 실행: 오픈 소스 GUI 애플리케이션을 사용하여 로컬에서 모델을 실행합니다.</li>
<li>Jupyter 노트북에서 LangChain을 사용하여 로컬 LLMs 실행, Python 프로그래밍 기술은 필요하지만 LLMs에 대한 사전 경험이 없어도 됩니다.</li>
<li>LangChain과 Taipy를 사용하여 챗봇 생성.</li>
</ul>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>책임의 한계:</p>
<ul>
<li>이는 "초보자용" 접근법이므로 텍스트 생성 모델에 대해 작성하겠습니다.</li>
<li>일부 모델은 기술적으로 로컬에서 실행할 수 있지만 자원을 많이 소비합니다(일반 가정용 컴퓨터나 노트북에서는 적어요). 만약 컴퓨터에 4GB의 RAM이 있다면, 실행 가능한 모델을 찾기 어려울 것입니다(그래도 여전히 몇 가지 모델을 즐겁게 시도해 볼 수 있습니다). 8GB(현재 대부분의 컴퓨터에 탑재된 메모리)가 있으면 여러 모델을 찾을 수 있지만 여전히 도전적 일 것입니다. 7GB에서 10GB 사이의 RAM이 필요한 모델을 찾기 쉽습니다.</li>
<li>로컬에서 모델을 실행할 때 컴퓨터 소리가 전투기가 이륙하는 것처럼 들릴 수 있습니다. 이는 정상입니다.</li>
<li>GGUF 모델을 CPU로 로컬 컴퓨터에서 실행하는 방법에 대해 이야기하며 이것이 내가 알고 있는 가장 쉬운 옵션입니다. 입문자에게 100% 친숙합니다.</li>
<li>모든 내용은 Windows 10에서 작동합니다.</li>
</ul>
<p><img src="/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_1.png" alt="그림링크"></p>
<h1>몇 가지 기본 개념</h1>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>LLM 랜드스케이프는 수십 개(아마 수백 개)의 새로운 용어, 용어, 개념 및 약어들을 가져왔어요. 쉽게 길을 잃을 수 있습니다. 이 섹션의 목표는 로컬에서 첫 번째 오픈 소스 모델을 사용하는 데 중요한 일부 주요 개념을 간단하게 설명하는 것입니다.</p>
<ul>
<li>GGML 파일 : 이 파일 시스템은 이제 구식입니다(AI 세계는 빠르게 변화해요!), 하지만 여전히 주변에서 찾을 수 있습니다(그리고 이에 대한 튜토리얼도 많습니다). GPT-생성된 모델 언어를 나타냅니다. 이제 GGUF 모델을 다운로드해야 합니다.</li>
<li>GPT4All : 로컬(컴퓨터에서)에서 실행되는 그래픽 사용자 인터페이스(GUI)입니다. 챗 GPT 인터페이스와 비슷해요. 이 인터페이스를 사용하여 LLM을 로컬에서 실행할 수 있어요.</li>
<li>GGUF (GPT-생성된 통일 형식) 파일 : 로컬로 다운로드하고 실행할 수 있는 LLM 모델을 포함하는 파일입니다.</li>
<li>Hugging Face : 자연어 처리(NLP)에 초점을 맞춘 이익을 위한 회사로서, 최신 LLM의 개발 및 사용을 위한 플랫폼을 제공합니다. 이 플랫폼을 Hugging Face로도 참조할 수 있습니다. 이 플랫폼에서 많은 모델을 찾을 수 있어요(일부 모델은 로컬에서 실행할 수 있습니다).</li>
<li>LangChain : LLM 응용 프로그램을 만들기 위해 프레임워크를 개발한 회사입니다. 대부분의 경우 LangChain을 프레임워크를 가리키는 데 사용합니다. 이것은 LLM API(또는 로컬 파일!), 데이터베이스 연결, HTML 및 문서 파서에 연결할 수 있는 도구상자입니다. LangChain에는 Python API가 있습니다. 이 튜토리얼의 3부와 4부에서 사용할 겁니다.</li>
<li>양자화 : 모델의 가중치와 바이어스의 정밀도를 줄여서 리소스가 제한된 장치에서 더 효율적으로 사용할 수 있도록 하는 것으로, 메모리 및 계산 요구 사항에 도움을 줍니다. 예를 들어, 2.45는 2.45 236987의 양자화 된 버전입니다. 덜 정확하지만 공간을 적게 차지하고 계산이 더 쉬운 숫자에 대해 더 적은 비트를 저장할 수 있습니다.</li>
</ul>
<h2>Hugging Face</h2>
<p>Hugging Face은 다양한 LLM 모델을 다운로드할 수 있는 한 곳(주요한 곳?)입니다(다른 LLM 관련 도구들과 함께). 여기 목표는:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>GGUF 모델을 다운로드하는 방법을 안내해 드릴게요.</li>
<li>다운로드하기 전에 확인해야 할 중요한 사항들을 몇 가지 소개해 드릴게요.</li>
</ul>
<p>이 글의 다음 부분에서는 GPT4all의 인터페이스에서 모델을 직접 다운로드하는 방법을 설명할 거에요. 따라서 가능한 더 적은 귀찮음을 원하신다면, 직접 그쪽으로 가셔서 모델을 다운로드할 수 있지만, 거기서는 다운로드할 수 있는 모델들이 적기 때문에, 적어도 이 글의 이 부분을 일반적인 지식으로 읽어보길 권장해 드려요.</p>
<p>컴퓨터에서 로컬로 실행되는 GGUF 모델을 가져오려면, 먼저 모델 페이지로 이동해주세요.</p>
<p>다음 단계는 모델을 필터링해서 GGUF 파일만 표시되도록 하는 것입니다. 페이지의 왼쪽 상단에 "라이브러리"를 선택하고 GGUF를 클릭하면 됩니다. 아래 이미지와 같이 하시면 되요:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_2.png" alt="이미지"></p>
<p>아마도 많은 모델들이 특정 사용자 "The Bloke"로부터 온 것을 알게 될 것입니다. 다음 자습서에서는 그의 모델 중 일부를 사용할 것이지만, 선호하는 다른 모델을 선택해도 괜찮습니다!</p>
<p>The Bloke가 제공하는 GGUF 모델은 다른 모델의 양자화 버전입니다.</p>
<p>이 예에서는 Mistral 7B Instruct v0.2 — GGUF라는 모델을 사용할 것입니다 (그리고 이외에도 1개의 아주 작은 모델이 있습니다. 아래 참조).</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 모델은 Mistral-7B-Instruct-v0.2라고 하는 원래 모델의 양자화된 버전입니다. 해당 Hugging Face 페이지를 확인할 수 있습니다 (해당 페이지에서 파일을 다운로드하지 마세요!) 및 Readme 페이지(주 페이지)의 정보, 파일 확장명 등을 양자화된 모델의 정보와 비교할 수 있습니다. 이 모델은 오픈 소스 LLMs 분야에서 중요한 역할을 하는 Mistral이 개발한 것입니다.</p>
<p>다시 양자화된 모델 페이지(Mistral 7B Instruct v0.2 - GGUF)로 돌아가면, 다양한 크기의 버전을 다운로드할 수 있으며 필요한 최대 RAM을 확인할 수 있습니다. 4GB 컴퓨터로는 이 모델을 실행하기 어려울 것으로 보입니다 (이 섹션 맨 끝에 작은 모델을 나열해 두겠습니다). 8GB 컴퓨터를 사용하는 경우, 가장 무거운 모델을 실행할 수 없을 것입니다. 제 경우에는 mistral-7b-instruct-v0.2.Q4_K_M.gguf를 다운로드하기로 결정했습니다:</p>
<ul>
<li>Q4_K_M은 양자화 방법입니다.</li>
<li>파일 크기는 4.37GB입니다.</li>
<li>6.87GB의 RAM이 필요합니다.</li>
</ul>
<p><img src="/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_3.png" alt="이미지"></p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>더 작은 모델</h2>
<p>더 작은 모델을 사용하려면 TinyLlama-1.1B-Chat-v1.0-GGUF를 시도해볼 수 있어요.</p>
<p>저도 사용할 거에요 (Taipy 앱을 위해), 왜냐하면 더 가벼우니까요 (더 빠르고... 그리고 덜 정확하죠). Mistral 7B Instruct v0.2 — GGUF와 똑같은 과정이에요.</p>
<h2>모델과 대화하기 위한 일부 Python 라이브러리</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>만약 파이썬 방식에 따라 가시려면, 여기 몇 가지 라이브러리를 소개해 드릴게요. 이 라이브러리들을 사용하면 로컬 또는 비로컬로 간단한 채팅 인터페이스를 만들 수 있어요:</p>
<ul>
<li>Taipy : 이 글의 마지막 부분에서 로컬 모델을 위한 매우 간단한 Taipy 채팅을 어떻게 만드는지 보여드릴 거에요.</li>
<li>Streamlit : Streamlit 애플리케이션을 만드는 것도 쉬워요. 다양한 튜토리얼이 많이 있어요.</li>
<li>Gradio : Gradio 앱은 Hugging Face 생태계에서 인기가 있어요. 이것을 아직은 제가 잘 알지 못하긴 한데요.</li>
</ul>
<h1>GPT4All 사용하기</h1>
<p>GPT4All은 로컬 컴퓨터에서 실행되는 채팅 인터페이스에요. 홈페이지에서 직접 설치 파일을 다운로드할 수 있어요. Windows용으로는 .exe 파일이며, 열어서 설치하면 되요... 그렇게 간단해요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>위 이미지를 보시면 ChatGPT의 인터페이스와 비슷하게 보입니다:</p>
<p><img src="/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_4.png" alt="ChatGPT Interface"></p>
<p>상당히 직관적인 것 같아요. 그러나 위 그림에 있는 것과 같이 3가지 중요한 요소를 언급하고 싶어요:</p>
<ul>
<li>프롬프팅 존... 이용하기 전에 모델을 로드해야 해요!</li>
<li>왼쪽 상단의 "버거 메뉴"를 통해 채팅 기록을 확인할 수 있고, 해당 채팅에 사용한 모델을 기억합니다... 여기서 인터페이스에서 모델을 직접 다운로드할 수도 있어요.</li>
<li>설정 버튼. 여기서 HuggingFace나 다른 곳에서 GGUF 파일을 다운로드할 디렉토리를 볼 수 있어요. 올바른 폴더에 다운로드하면 GPT4all이 그 파일들을 "인식"할 거예요.</li>
<li>폴더에 여러 모델이 있는 경우, GUI 상단 중앙의 메뉴로 선택할 수 있어요.</li>
</ul>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>GPT4All에서 모델 다운로드하기</h2>
<p>GPT4All에서 모델을 다운로드하려면 화면 오른쪽 상단의 버거 메뉴로 이동하십시오. 그리고 "다운로드"를 선택하십시오.</p>
<p><img src="/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_5.png" alt="다운로드"></p>
<p>선택할 모델 목록이 표시됩니다. 원하는 모델을 선택하고 "다운로드"를 클릭하면 첫 번째 모델을 사용할 수 있습니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>미스트랄의 OpenOrca를 사용하고 있는데, 이 채팅 봇은 상당히 좋아요. 여기에서는 API 키를 제공하여 ChatGPT 모델을 선택할 수도 있습니다. 이 마지막 옵션은 아직 시도해보지 않았는데, 개인적으로는 의미가 없다고 생각해요.</p>
<p><img src="/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_6.png" alt="이미지"></p>
<h2>다른 모델을 다운로드할 GPT4All 폴더 선택하기</h2>
<p>HuggingFace와 같은 다른 모델을 사용하고 싶다면, 그 모델이 GPT4All이 모델을 찾는 폴더에 다운로드하면 됩니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>해당 위치를 찾으려면 설정 메뉴(오른쪽 상단의 작은 휠)를 클릭하세요. "애플리케이션"을 선택합니다. 로컬 폴더 경로는 "다운로드 경로" 옆에 있습니다:</p>
<p><img src="/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_7.png" alt="이미지"></p>
<p>첫 번째 LLM 모델을 로컬에서 실행하는 가장 쉬운 방법은 아니더라도 가깝습니다! 즐겁게 사용하시길 바랍니다!</p>
<h1>LangChain 사용하기</h1>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>알림: 이 방법은 Python의 기본적인 이해가 필요하지만 따르기 쉬워요. 노트북 사용자들(Jupyter Notebook, JupyterLab...)에 적합해요.</p>
<p>LangChain은 LLM (Language Model)을 사용하여 LLM 애플리케이션을 만들 수 있게 해주는 Python 라이브러리에요 (당연한 얘기겠지만... LangChain과 LLM이 없이도 앱을 만들 수는 있어요. 다만, 그것들은 LLM 앱이 아닐 뿐이죠). LangChain은 데이터베이스에 연결하거나 문서나 웹을 파싱하거나 다양한 서비스에 쿼리를 날리는 API 클라이언트 등 Python 라이브러리들과 연결할 수 있어요.</p>
<p>이번에는 LangChain을 사용하여 GGUF 파일을 가져와 대화하는 방법을 알려드릴게요.</p>
<p>LangChain을 사용하기 위해 다음이 필요해요:</p>
<ul>
<li>Langchain_community: Langchain을 위한 타사 통합 기능을 포함하고 있어요.</li>
<li>llama_cpp_python: llama.cpp를 위한 Python 바인더에요.</li>
</ul>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Llama.cpp은 다른 파일들과 함께 GGUF 파일을 다룰 수 있게 해줍니다!</p>
<p>여기 나타난 예시를 보면, 단순히 llama_cpp_python만 사용할 수도 있지만, LangChain을 익히는 것이 더 좋은 아이디어이며 복잡성을 더하는 일이 거의 없습니다.</p>
<p>JupyterLab을 사용하여 LLM 모델을 호출할 것이고, 이 작업은 다른 어떤 노트북이나 ^Python 파일에서도 작동해야 합니다.</p>
<p>먼저 라이브러리를 가져와주세요:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-python"><span class="hljs-keyword">from</span> langchain.callbacks.manager <span class="hljs-keyword">import</span> CallbackManager
<span class="hljs-keyword">from</span> langchain.callbacks.streaming_stdout <span class="hljs-keyword">import</span> StreamingStdOutCallbackHandler
<span class="hljs-keyword">from</span> langchain.prompts <span class="hljs-keyword">import</span> PromptTemplate
<span class="hljs-keyword">from</span> langchain_community.llms <span class="hljs-keyword">import</span> LlamaCpp
</code></pre>
<p>그 후, GGUF 파일로 모델 변수를 만들어보세요. 선택적으로 callback_manager도 만들 수 있습니다:</p>
<pre><code class="hljs language-python">model = <span class="hljs-string">"path/to/model/mistral-7b-instruct-v0.2.Q4_K_M.ggu"</span>

<span class="hljs-comment"># Callbacks support token-wise streaming</span>
callback_manager = CallbackManager([StreamingStdOutCallbackHandler()])
</code></pre>
<p>이제, prompts를 인수로 받아 답변을 생성할 llm 객체를 만들 수 있습니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-python">llm = LlamaCpp(
    model_path=model,
    callback_manager=callback_manager, <span class="hljs-comment">#Optional, streams the response as it is generated</span>
    verbose=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># Verbose is required to pass to the callback manager</span>
)
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">prompt_addon = <span class="hljs-string">"&#x3C;s>[INST]파이썬 명령어를 만들어 'hello world'를 출력하도록 합니다[/INST]print('hello world')&#x3C;/s>"</span>
prompt = <span class="hljs-string">""</span><span class="hljs-string">"
주어진 숫자까지의 피보나치 수열을 반환하는 파이썬 함수를 작성하십시오. 독스트링을 추가하세요.
"</span><span class="hljs-string">""</span>
llm.<span class="hljs-title function_">invoke</span>(f<span class="hljs-string">"{prompt_addon}[INST]{prompt}[/INST]"</span>)
</code></pre>
<img src="/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_8.png">
<h1>Taipy를 사용하여 작은 채팅 인터페이스 만들기</h1>
<p>LangChain 보드 대신에, Taipy와 같은 Python 웹 애플리케이션 빌더와 함께 사용할 수 있습니다. 이 라이브러리에 대해 더 알고 싶으시다면, 이전에 관련한 기사를 썼었지만, 라이브러리에 대해 많이 알지 못해도 어플리케이션을 작동시킬 수 있을 것입니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>저는 다음 예시를 Taipy 팀의 튜토리얼에서 수정했어요. 그래서 많은 창의성은 그들에게 돌아갑니다. 다른 점은 OpenAI의 GPT 모델(그들의 API로) 대신 로컬 모델을 사용한다는 것이에요.</p>
<p>위 예시의 라이브러리들(LangChain와 Llama_Cpp)이 필요하고 당연히 Taipy를 설치해야 해요 ( pip install taipy ).</p>
<p>Python 함수와 Taipy 코드를 모두 넣을 main.py 라는 파일을 만들어야 해요.</p>
<p>첫째, 라이브러리를 가져와요. 앱이 채팅을 표시할 것이기 때문에 출력을 스트리밍할 필요 없어요. 그냥 가져오세요:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-python"><span class="hljs-keyword">from</span> langchain.callbacks.manager <span class="hljs-keyword">import</span> CallbackManager
<span class="hljs-keyword">from</span> langchain_community.llms <span class="hljs-keyword">import</span> LlamaCpp
<span class="hljs-keyword">from</span> taipy.gui <span class="hljs-keyword">import</span> Gui, State
</code></pre>
<p>타이피(Taipy)에서 상태(State)는 앱에서 변수의 "현재 상태"를 가리킵니다. 이러한 변수에 초기 값을 할당한 후, 그 값은 앱에서 변경됩니다: 사용자가 값 변경하거나 함수의 결과로 값이 변경될 수 있습니다.</p>
<p>두 개의 변수, conversation(대화)와 current_user_message(현재 사용자 메시지)를 만들어 봅시다. 대화는 대화창에 보낸 메시지와 그에 대한 답변의 기록입니다. current_user_message는 사용자가 프롬프트로 입력할 메시지를 나타냅니다.</p>
<p>성능상의 이유로 tinyllama-1.1b-chat-v1.0.Q4_K_M 모델을 사용하겠습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">대화 = {
    <span class="hljs-string">"Conversation"</span>: [
        <span class="hljs-string">"너 누구니?"</span>,
        <span class="hljs-string">"안녕! 나는 작은 LLama야. 너의 컴퓨터에서 돌아가는 모델이지. 오늘 어떻게 도와줄까?"</span>,
    ]
}

current_user_message = <span class="hljs-string">""</span>
</code></pre>
<p>다음으로, 모델을 실행하는 함수를 만들어보겠어요. 여기서 예시로 Tiny LLama 모델 GGUF 파일을 사용합니다.</p>
<pre><code class="hljs language-js">모델 = (
    <span class="hljs-string">"경로/모델/tinyllama-1.1b-chat-v1.0.Q4_K_M.gguf"</span>
)

llm = <span class="hljs-title class_">LlamaCpp</span>(model_path=모델)
</code></pre>
<p>그런 다음, 채팅을 처리하는 2개의 함수를 만들 수 있어요. 먼저, 모델에 질문을 보내고 답변을 받는 request()라는 함수를 정의해주세요.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><strong>Note:</strong> The function generates a prompt based on the model specified in the documentation. According to the documentation, you should follow the prompt template "Zephyr", which is different from the one used for Mistral 7B shown above:</p>
<pre><code class="hljs language-js">&#x3C;|system|>
{system_message}&#x3C;/s>
&#x3C;|user|>
{prompt}&#x3C;/s>
&#x3C;|assistant|>
</code></pre>
<p>Below is the function:</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">request</span>(<span class="hljs-attr">state</span>: <span class="hljs-title class_">State</span>, <span class="hljs-attr">prompt</span>: str, <span class="hljs-attr">conv_list</span>: list) -> <span class="hljs-attr">str</span>:
    <span class="hljs-string">""</span><span class="hljs-string">"
    Send a prompt to the local LLM and return the response.

    Args:
        - state: The current state.
        - prompt: The prompt to send to the LLM.

    Returns:
        The response from the LLM.
    "</span><span class="hljs-string">""</span>

    # <span class="hljs-title class_">Get</span> the previous conversations to create the prompt history
    system_message = <span class="hljs-string">"&#x3C;|system|>\nYou are a geography expert and assist users by answering their questions&#x3C;/s>\n"</span>
    # <span class="hljs-title class_">Get</span> the previous conversations to create the prompt history
    history_prompt = <span class="hljs-string">""</span>
    <span class="hljs-keyword">for</span> index, conv_element <span class="hljs-keyword">in</span> <span class="hljs-title function_">enumerate</span>(conv_list):
        <span class="hljs-keyword">if</span> index % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:
            history_prompt += f<span class="hljs-string">"&#x3C;|user|>\n{conv_element}&#x3C;/s>\n"</span>
        <span class="hljs-attr">else</span>:
            history_prompt += f<span class="hljs-string">"&#x3C;|assistant|>\n{conv_element}&#x3C;/s>\n"</span>
    full_prompt = (
        f<span class="hljs-string">"{system_message}{history_prompt}&#x3C;|user|>\n{prompt}&#x3C;/s>\n&#x3C;|assistant|>"</span>
    )

    response = state.<span class="hljs-title function_">llm</span>(full_prompt)

    <span class="hljs-keyword">return</span> response
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그리고 이제 Taipy GUI 인터페이스와 상호 작용하는 send_message() 함수를 정의할 수 있습니다:</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">send_message</span>(<span class="hljs-attr">state</span>: <span class="hljs-title class_">State</span>) -> <span class="hljs-title class_">None</span>:
    <span class="hljs-string">""</span><span class="hljs-string">"
    사용자의 메시지를 llm 함수로 전송합니다.
    Args:
        - state: 현재 상태.
    "</span><span class="hljs-string">""</span>
    # 입력 필드 지우기
    conv = state.<span class="hljs-property">conversation</span>.<span class="hljs-property">_dict</span>.<span class="hljs-title function_">copy</span>()

    # 사용자 질문을 지역 <span class="hljs-variable constant_">LLM</span> 모델에 요청합니다.
    conv_list = conv[<span class="hljs-string">"Conversation"</span>]
    answer = <span class="hljs-title function_">request</span>(state, state.<span class="hljs-property">current_user_message</span>, conv_list).<span class="hljs-title function_">replace</span>(<span class="hljs-string">"\n"</span>, <span class="hljs-string">""</span>)

    conv[<span class="hljs-string">"Conversation"</span>] += [state.<span class="hljs-property">current_user_message</span>, answer]
    state.<span class="hljs-property">current_user_message</span> = <span class="hljs-string">""</span>
    state.<span class="hljs-property">conversation</span> = conv
</code></pre>
<h2>사용자 인터페이스 만들기</h2>
<p>페이지를 초기화하려면 아래 코드를 추가하면 됩니다. 페이지 객체는 페이지 구조를 정의합니다. 원하신다면 markdown 구문을 추가할 수 있습니다(제목 또는 원하는 내용). 여기에는 없습니다. 그리고 Taipy 요소를 <code>|...|</code> 사이에 추가할 수 있습니다. 더 자세한 정보가 필요하다면 Taipy에 관한 다른 글을 참조하는 것을 권장합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">page = <span class="hljs-string">""</span><span class="hljs-string">"
&#x3C;|{대화}|table|show_all|>
&#x3C;|{current_user_message}|input|label=메시지를 입력하세요...|on_action=send_message|class_name=fullwidth|>
"</span><span class="hljs-string">""</span>

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    <span class="hljs-title class_">Gui</span>(page).<span class="hljs-title function_">run</span>(dark_mode=<span class="hljs-title class_">True</span>, title=<span class="hljs-string">"Taipy와 지역 LLM 채팅"</span>)
</code></pre>
<h2>선택 사항: CSS 변경</h2>
<p>Taipy의 튜토리얼에는 CSS 코드와 적용하는 함수가 있습니다. 여기에 완벽한 지침이 있도록 무심코 그것을 복사합니다. 이 부분에 대해 100%의 크레딧은 그들에게 갑니다.</p>
<p>main.py 파일 옆에 main.css 파일을 만들어 다음 코드를 붙여넣으세요:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">.<span class="hljs-property">gpt_message</span> td {
    margin-<span class="hljs-attr">left</span>: 30px;
    margin-<span class="hljs-attr">bottom</span>: 20px;
    margin-<span class="hljs-attr">top</span>: 20px;
    <span class="hljs-attr">position</span>: relative;
    <span class="hljs-attr">display</span>: inline-block;
    <span class="hljs-attr">padding</span>: 20px;
    background-<span class="hljs-attr">color</span>: #ff462b;
    border-<span class="hljs-attr">radius</span>: 20px;
    max-<span class="hljs-attr">width</span>: <span class="hljs-number">80</span>%;
    box-<span class="hljs-attr">shadow</span>: <span class="hljs-number">0</span> 4px 8px <span class="hljs-number">0</span> <span class="hljs-title function_">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.2</span>), <span class="hljs-number">0</span> 6px 20px <span class="hljs-number">0</span> <span class="hljs-title function_">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.19</span>);
    font-<span class="hljs-attr">size</span>: large;
}

.<span class="hljs-property">user_message</span> td {
    margin-<span class="hljs-attr">right</span>: 30px;
    margin-<span class="hljs-attr">bottom</span>: 20px;
    margin-<span class="hljs-attr">top</span>: 20px;
    <span class="hljs-attr">position</span>: relative;
    <span class="hljs-attr">display</span>: inline-block;
    <span class="hljs-attr">padding</span>: 20px;
    background-<span class="hljs-attr">color</span>: #140a1e;
    border-<span class="hljs-attr">radius</span>: 20px;
    max-<span class="hljs-attr">width</span>: <span class="hljs-number">80</span>%;
    <span class="hljs-attr">float</span>: right;
    box-<span class="hljs-attr">shadow</span>: <span class="hljs-number">0</span> 4px 8px <span class="hljs-number">0</span> <span class="hljs-title function_">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.2</span>), <span class="hljs-number">0</span> 6px 20px <span class="hljs-number">0</span> <span class="hljs-title function_">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.19</span>);
    font-<span class="hljs-attr">size</span>: large;
}
</code></pre>
<p>그리고 다음 Python 함수를 만들어주세요. 해당 함수는 main.py 파일에 위치시키실 수 있습니다. 이 함수는 페이지에 스타일을 적용합니다:</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">style_conv</span>(<span class="hljs-attr">state</span>: <span class="hljs-title class_">State</span>, <span class="hljs-attr">idx</span>: int, <span class="hljs-attr">row</span>: int) -> <span class="hljs-attr">str</span>:
    <span class="hljs-string">""</span><span class="hljs-string">"
    Apply a style to the conversation table depending on the message's author.

    Args:
        - state: The current state of the app.
        - idx: The index of the message in the table.
        - row: The row of the message in the table.

    Returns:
        The style to apply to the message.
    "</span><span class="hljs-string">""</span>
    <span class="hljs-keyword">if</span> idx is <span class="hljs-title class_">None</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">None</span>
    elif idx % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"user_message"</span>
    <span class="hljs-attr">else</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"gpt_message"</span>
</code></pre>
<p>다음으로, 페이지 객체를 수정하시어 스타일이 적용되도록 하실 수 있습니다. 아래와 같이 conversation 요소에 style=style_conv|를 추가해주세요:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">페이지 = <span class="hljs-string">""</span><span class="hljs-string">"
&#x3C;|{conversation}|표|모든_표시|스타일=style_conv|>
&#x3C;|{current_user_message}|입력|레이블=여기에 메시지를 입력하세요...|작업=send_message|클래스_이름=전체너비|>
"</span><span class="hljs-string">""</span>
</code></pre>
<h2>앱 실행하기</h2>
<p>앱을 실행하려면 main.py 파일을 다른 Python 파일처럼 호출하면 됩니다!</p>
<p>아래 이미지에서 보시다시피, 작은 모델이 좋지 않고 지리가 주 용도가 아닌 것 같습니다. 하지만 한 가지 확실한 것은 웹 앱에서 로컬 모델이 실행되고 있다는 것이며, 이것은 정말 멋집니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_9.png" alt="image"></p>
<p>Thank you for reading!</p>
<p>If you enjoyed my content and would like to connect:</p>
<p>👉 You can connect with me on LinkedIn</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>👉 제 개인 웹사이트를 확인해보세요</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"첫 로컬 LLM 실행 방법 ","description":"","date":"2024-07-13 20:12","slug":"2024-07-13-HowtorunyourfirstlocalLLMs","content":"\n\n![How to run your first local LLMs](/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_0.png)\n\n작년 동안 (2024년에 이 글을 쓰고 있기 때문에) 대형 언어 모델(LLMs)은 전문적인 환경과 작업 수행 방식을 변화시켰습니다.\n\nChat GPT와 그들의 Chat 버전에 익숙하실 것입니다. 당신은 Chat GPT Plus 사용자(OpenAI의 유료 플랜)일 수도 있습니다. 또는 Anthropic이나 Google Bard와 같은 다른 유사한 제공 업체를 사용해본 적이 있을 수도 있습니다. 심지어 OpenAI와 경쟁 업체 모두 강력한 도구를 제공하지만, 여기 몇 가지 이유가 있어서 LLMs를 로컬에서 실행해 보려고 하는 것을 고려해볼만 합니다 (더 많을 수 있습니다!):\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 생태계에 대해 더 알고 새로운 모델을 시도하며 자신만의 경험을 소유하고 싶다면.\n- 딥 러닝과 LLMs에 대해 배우고 싶지만 시작할 곳을 모르겠거나 더 알고 싶다면; 오픈 소스 모델을 로컬에서 실행하는 것이 훌륭한 시작점이 될 수 있습니다.\n- 개인 정보를 오픈AI나 구글과 같은 대기업에 제공하고 싶지 않다면.\n- 인터넷 연결이 필요하지 않고 오프라인에서 실행할 수 있는 채팅 애플리케이션을 원한다면.\n- 금융이나 문학 작성과 같은 특정 작업을 위해 더 작고 특화된 모델로 실험하고 싶다면.\n\n얼마 전 나 또한 모든 이러한 요구 사항을 만족시켰습니다. 모든 이 기술 주변의 정보 양에 압도되었다고 느꼈습니다. 일반적인 조언으로 말할 때 목표가 오르막길처럼 느껴진다면 산만 바라보지 말고 가능한 한 빨리 첫 번째 발을 내딛어 올라가세요. 그리고 계속 그렇게 계단을 올라가다 보면 다음 산이 보이게 될 것입니다 (ㅋ).\n\n이 여정에서 첫 단계를 내딛도록 도와드리기 위해 프로세스를 아래 네 부분으로 나누어 설명했습니다:\n\n- 기본 개념 몇 가지: 이 섹션에서는 미리 알려진 지식을 가정하지 않고 자습서 전반에 걸쳐 사용되는 주요 용어와 아이디어를 소개합니다.\n- GPT4All에서 모델 실행: 오픈 소스 GUI 애플리케이션을 사용하여 로컬에서 모델을 실행합니다.\n- Jupyter 노트북에서 LangChain을 사용하여 로컬 LLMs 실행, Python 프로그래밍 기술은 필요하지만 LLMs에 대한 사전 경험이 없어도 됩니다.\n- LangChain과 Taipy를 사용하여 챗봇 생성.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n책임의 한계:\n\n- 이는 \"초보자용\" 접근법이므로 텍스트 생성 모델에 대해 작성하겠습니다.\n- 일부 모델은 기술적으로 로컬에서 실행할 수 있지만 자원을 많이 소비합니다(일반 가정용 컴퓨터나 노트북에서는 적어요). 만약 컴퓨터에 4GB의 RAM이 있다면, 실행 가능한 모델을 찾기 어려울 것입니다(그래도 여전히 몇 가지 모델을 즐겁게 시도해 볼 수 있습니다). 8GB(현재 대부분의 컴퓨터에 탑재된 메모리)가 있으면 여러 모델을 찾을 수 있지만 여전히 도전적 일 것입니다. 7GB에서 10GB 사이의 RAM이 필요한 모델을 찾기 쉽습니다.\n- 로컬에서 모델을 실행할 때 컴퓨터 소리가 전투기가 이륙하는 것처럼 들릴 수 있습니다. 이는 정상입니다.\n- GGUF 모델을 CPU로 로컬 컴퓨터에서 실행하는 방법에 대해 이야기하며 이것이 내가 알고 있는 가장 쉬운 옵션입니다. 입문자에게 100% 친숙합니다.\n- 모든 내용은 Windows 10에서 작동합니다.\n\n![그림링크](/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_1.png)\n\n# 몇 가지 기본 개념\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLLM 랜드스케이프는 수십 개(아마 수백 개)의 새로운 용어, 용어, 개념 및 약어들을 가져왔어요. 쉽게 길을 잃을 수 있습니다. 이 섹션의 목표는 로컬에서 첫 번째 오픈 소스 모델을 사용하는 데 중요한 일부 주요 개념을 간단하게 설명하는 것입니다.\n\n- GGML 파일 : 이 파일 시스템은 이제 구식입니다(AI 세계는 빠르게 변화해요!), 하지만 여전히 주변에서 찾을 수 있습니다(그리고 이에 대한 튜토리얼도 많습니다). GPT-생성된 모델 언어를 나타냅니다. 이제 GGUF 모델을 다운로드해야 합니다.\n- GPT4All : 로컬(컴퓨터에서)에서 실행되는 그래픽 사용자 인터페이스(GUI)입니다. 챗 GPT 인터페이스와 비슷해요. 이 인터페이스를 사용하여 LLM을 로컬에서 실행할 수 있어요.\n- GGUF (GPT-생성된 통일 형식) 파일 : 로컬로 다운로드하고 실행할 수 있는 LLM 모델을 포함하는 파일입니다.\n- Hugging Face : 자연어 처리(NLP)에 초점을 맞춘 이익을 위한 회사로서, 최신 LLM의 개발 및 사용을 위한 플랫폼을 제공합니다. 이 플랫폼을 Hugging Face로도 참조할 수 있습니다. 이 플랫폼에서 많은 모델을 찾을 수 있어요(일부 모델은 로컬에서 실행할 수 있습니다).\n- LangChain : LLM 응용 프로그램을 만들기 위해 프레임워크를 개발한 회사입니다. 대부분의 경우 LangChain을 프레임워크를 가리키는 데 사용합니다. 이것은 LLM API(또는 로컬 파일!), 데이터베이스 연결, HTML 및 문서 파서에 연결할 수 있는 도구상자입니다. LangChain에는 Python API가 있습니다. 이 튜토리얼의 3부와 4부에서 사용할 겁니다.\n- 양자화 : 모델의 가중치와 바이어스의 정밀도를 줄여서 리소스가 제한된 장치에서 더 효율적으로 사용할 수 있도록 하는 것으로, 메모리 및 계산 요구 사항에 도움을 줍니다. 예를 들어, 2.45는 2.45 236987의 양자화 된 버전입니다. 덜 정확하지만 공간을 적게 차지하고 계산이 더 쉬운 숫자에 대해 더 적은 비트를 저장할 수 있습니다.\n\n## Hugging Face\n\nHugging Face은 다양한 LLM 모델을 다운로드할 수 있는 한 곳(주요한 곳?)입니다(다른 LLM 관련 도구들과 함께). 여기 목표는:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- GGUF 모델을 다운로드하는 방법을 안내해 드릴게요.\n- 다운로드하기 전에 확인해야 할 중요한 사항들을 몇 가지 소개해 드릴게요.\n\n이 글의 다음 부분에서는 GPT4all의 인터페이스에서 모델을 직접 다운로드하는 방법을 설명할 거에요. 따라서 가능한 더 적은 귀찮음을 원하신다면, 직접 그쪽으로 가셔서 모델을 다운로드할 수 있지만, 거기서는 다운로드할 수 있는 모델들이 적기 때문에, 적어도 이 글의 이 부분을 일반적인 지식으로 읽어보길 권장해 드려요.\n\n컴퓨터에서 로컬로 실행되는 GGUF 모델을 가져오려면, 먼저 모델 페이지로 이동해주세요.\n\n다음 단계는 모델을 필터링해서 GGUF 파일만 표시되도록 하는 것입니다. 페이지의 왼쪽 상단에 \"라이브러리\"를 선택하고 GGUF를 클릭하면 됩니다. 아래 이미지와 같이 하시면 되요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![이미지](/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_2.png)\n\n아마도 많은 모델들이 특정 사용자 \"The Bloke\"로부터 온 것을 알게 될 것입니다. 다음 자습서에서는 그의 모델 중 일부를 사용할 것이지만, 선호하는 다른 모델을 선택해도 괜찮습니다!\n\nThe Bloke가 제공하는 GGUF 모델은 다른 모델의 양자화 버전입니다.\n\n이 예에서는 Mistral 7B Instruct v0.2 — GGUF라는 모델을 사용할 것입니다 (그리고 이외에도 1개의 아주 작은 모델이 있습니다. 아래 참조).\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 모델은 Mistral-7B-Instruct-v0.2라고 하는 원래 모델의 양자화된 버전입니다. 해당 Hugging Face 페이지를 확인할 수 있습니다 (해당 페이지에서 파일을 다운로드하지 마세요!) 및 Readme 페이지(주 페이지)의 정보, 파일 확장명 등을 양자화된 모델의 정보와 비교할 수 있습니다. 이 모델은 오픈 소스 LLMs 분야에서 중요한 역할을 하는 Mistral이 개발한 것입니다.\n\n다시 양자화된 모델 페이지(Mistral 7B Instruct v0.2 - GGUF)로 돌아가면, 다양한 크기의 버전을 다운로드할 수 있으며 필요한 최대 RAM을 확인할 수 있습니다. 4GB 컴퓨터로는 이 모델을 실행하기 어려울 것으로 보입니다 (이 섹션 맨 끝에 작은 모델을 나열해 두겠습니다). 8GB 컴퓨터를 사용하는 경우, 가장 무거운 모델을 실행할 수 없을 것입니다. 제 경우에는 mistral-7b-instruct-v0.2.Q4_K_M.gguf를 다운로드하기로 결정했습니다:\n\n- Q4_K_M은 양자화 방법입니다.\n- 파일 크기는 4.37GB입니다.\n- 6.87GB의 RAM이 필요합니다.\n\n![이미지](/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_3.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 더 작은 모델\n\n더 작은 모델을 사용하려면 TinyLlama-1.1B-Chat-v1.0-GGUF를 시도해볼 수 있어요.\n\n저도 사용할 거에요 (Taipy 앱을 위해), 왜냐하면 더 가벼우니까요 (더 빠르고... 그리고 덜 정확하죠). Mistral 7B Instruct v0.2 — GGUF와 똑같은 과정이에요.\n\n## 모델과 대화하기 위한 일부 Python 라이브러리\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 파이썬 방식에 따라 가시려면, 여기 몇 가지 라이브러리를 소개해 드릴게요. 이 라이브러리들을 사용하면 로컬 또는 비로컬로 간단한 채팅 인터페이스를 만들 수 있어요:\n\n- Taipy : 이 글의 마지막 부분에서 로컬 모델을 위한 매우 간단한 Taipy 채팅을 어떻게 만드는지 보여드릴 거에요.\n- Streamlit : Streamlit 애플리케이션을 만드는 것도 쉬워요. 다양한 튜토리얼이 많이 있어요.\n- Gradio : Gradio 앱은 Hugging Face 생태계에서 인기가 있어요. 이것을 아직은 제가 잘 알지 못하긴 한데요.\n\n# GPT4All 사용하기\n\nGPT4All은 로컬 컴퓨터에서 실행되는 채팅 인터페이스에요. 홈페이지에서 직접 설치 파일을 다운로드할 수 있어요. Windows용으로는 .exe 파일이며, 열어서 설치하면 되요... 그렇게 간단해요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 이미지를 보시면 ChatGPT의 인터페이스와 비슷하게 보입니다:\n\n![ChatGPT Interface](/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_4.png)\n\n상당히 직관적인 것 같아요. 그러나 위 그림에 있는 것과 같이 3가지 중요한 요소를 언급하고 싶어요:\n\n- 프롬프팅 존... 이용하기 전에 모델을 로드해야 해요!\n- 왼쪽 상단의 \"버거 메뉴\"를 통해 채팅 기록을 확인할 수 있고, 해당 채팅에 사용한 모델을 기억합니다... 여기서 인터페이스에서 모델을 직접 다운로드할 수도 있어요.\n- 설정 버튼. 여기서 HuggingFace나 다른 곳에서 GGUF 파일을 다운로드할 디렉토리를 볼 수 있어요. 올바른 폴더에 다운로드하면 GPT4all이 그 파일들을 \"인식\"할 거예요.\n- 폴더에 여러 모델이 있는 경우, GUI 상단 중앙의 메뉴로 선택할 수 있어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## GPT4All에서 모델 다운로드하기\n\nGPT4All에서 모델을 다운로드하려면 화면 오른쪽 상단의 버거 메뉴로 이동하십시오. 그리고 \"다운로드\"를 선택하십시오.\n\n![다운로드](/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_5.png)\n\n선택할 모델 목록이 표시됩니다. 원하는 모델을 선택하고 \"다운로드\"를 클릭하면 첫 번째 모델을 사용할 수 있습니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n미스트랄의 OpenOrca를 사용하고 있는데, 이 채팅 봇은 상당히 좋아요. 여기에서는 API 키를 제공하여 ChatGPT 모델을 선택할 수도 있습니다. 이 마지막 옵션은 아직 시도해보지 않았는데, 개인적으로는 의미가 없다고 생각해요.\n\n![이미지](/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_6.png)\n\n## 다른 모델을 다운로드할 GPT4All 폴더 선택하기\n\nHuggingFace와 같은 다른 모델을 사용하고 싶다면, 그 모델이 GPT4All이 모델을 찾는 폴더에 다운로드하면 됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n해당 위치를 찾으려면 설정 메뉴(오른쪽 상단의 작은 휠)를 클릭하세요. \"애플리케이션\"을 선택합니다. 로컬 폴더 경로는 \"다운로드 경로\" 옆에 있습니다:\n\n![이미지](/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_7.png)\n\n첫 번째 LLM 모델을 로컬에서 실행하는 가장 쉬운 방법은 아니더라도 가깝습니다! 즐겁게 사용하시길 바랍니다!\n\n# LangChain 사용하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n알림: 이 방법은 Python의 기본적인 이해가 필요하지만 따르기 쉬워요. 노트북 사용자들(Jupyter Notebook, JupyterLab...)에 적합해요.\n\nLangChain은 LLM (Language Model)을 사용하여 LLM 애플리케이션을 만들 수 있게 해주는 Python 라이브러리에요 (당연한 얘기겠지만... LangChain과 LLM이 없이도 앱을 만들 수는 있어요. 다만, 그것들은 LLM 앱이 아닐 뿐이죠). LangChain은 데이터베이스에 연결하거나 문서나 웹을 파싱하거나 다양한 서비스에 쿼리를 날리는 API 클라이언트 등 Python 라이브러리들과 연결할 수 있어요.\n\n이번에는 LangChain을 사용하여 GGUF 파일을 가져와 대화하는 방법을 알려드릴게요.\n\nLangChain을 사용하기 위해 다음이 필요해요: \n\n- Langchain_community: Langchain을 위한 타사 통합 기능을 포함하고 있어요.\n- llama_cpp_python: llama.cpp를 위한 Python 바인더에요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLlama.cpp은 다른 파일들과 함께 GGUF 파일을 다룰 수 있게 해줍니다!\n\n여기 나타난 예시를 보면, 단순히 llama_cpp_python만 사용할 수도 있지만, LangChain을 익히는 것이 더 좋은 아이디어이며 복잡성을 더하는 일이 거의 없습니다.\n\nJupyterLab을 사용하여 LLM 모델을 호출할 것이고, 이 작업은 다른 어떤 노트북이나 ^Python 파일에서도 작동해야 합니다.\n\n먼저 라이브러리를 가져와주세요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom langchain.callbacks.manager import CallbackManager\nfrom langchain.callbacks.streaming_stdout import StreamingStdOutCallbackHandler\nfrom langchain.prompts import PromptTemplate\nfrom langchain_community.llms import LlamaCpp\n```\n\n그 후, GGUF 파일로 모델 변수를 만들어보세요. 선택적으로 callback_manager도 만들 수 있습니다:\n\n```python\nmodel = \"path/to/model/mistral-7b-instruct-v0.2.Q4_K_M.ggu\"\n\n# Callbacks support token-wise streaming\ncallback_manager = CallbackManager([StreamingStdOutCallbackHandler()])\n```\n\n이제, prompts를 인수로 받아 답변을 생성할 llm 객체를 만들 수 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nllm = LlamaCpp(\n    model_path=model,\n    callback_manager=callback_manager, #Optional, streams the response as it is generated\n    verbose=True,  # Verbose is required to pass to the callback manager\n)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nprompt_addon = \"\u003cs\u003e[INST]파이썬 명령어를 만들어 'hello world'를 출력하도록 합니다[/INST]print('hello world')\u003c/s\u003e\"\nprompt = \"\"\"\n주어진 숫자까지의 피보나치 수열을 반환하는 파이썬 함수를 작성하십시오. 독스트링을 추가하세요.\n\"\"\"\nllm.invoke(f\"{prompt_addon}[INST]{prompt}[/INST]\")\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_8.png\" /\u003e\n\n# Taipy를 사용하여 작은 채팅 인터페이스 만들기\n\nLangChain 보드 대신에, Taipy와 같은 Python 웹 애플리케이션 빌더와 함께 사용할 수 있습니다. 이 라이브러리에 대해 더 알고 싶으시다면, 이전에 관련한 기사를 썼었지만, 라이브러리에 대해 많이 알지 못해도 어플리케이션을 작동시킬 수 있을 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저는 다음 예시를 Taipy 팀의 튜토리얼에서 수정했어요. 그래서 많은 창의성은 그들에게 돌아갑니다. 다른 점은 OpenAI의 GPT 모델(그들의 API로) 대신 로컬 모델을 사용한다는 것이에요.\n\n위 예시의 라이브러리들(LangChain와 Llama_Cpp)이 필요하고 당연히 Taipy를 설치해야 해요 ( pip install taipy ).\n\nPython 함수와 Taipy 코드를 모두 넣을 main.py 라는 파일을 만들어야 해요.\n\n첫째, 라이브러리를 가져와요. 앱이 채팅을 표시할 것이기 때문에 출력을 스트리밍할 필요 없어요. 그냥 가져오세요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom langchain.callbacks.manager import CallbackManager\nfrom langchain_community.llms import LlamaCpp\nfrom taipy.gui import Gui, State\n```\n\n타이피(Taipy)에서 상태(State)는 앱에서 변수의 \"현재 상태\"를 가리킵니다. 이러한 변수에 초기 값을 할당한 후, 그 값은 앱에서 변경됩니다: 사용자가 값 변경하거나 함수의 결과로 값이 변경될 수 있습니다.\n\n두 개의 변수, conversation(대화)와 current_user_message(현재 사용자 메시지)를 만들어 봅시다. 대화는 대화창에 보낸 메시지와 그에 대한 답변의 기록입니다. current_user_message는 사용자가 프롬프트로 입력할 메시지를 나타냅니다.\n\n성능상의 이유로 tinyllama-1.1b-chat-v1.0.Q4_K_M 모델을 사용하겠습니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n대화 = {\n    \"Conversation\": [\n        \"너 누구니?\",\n        \"안녕! 나는 작은 LLama야. 너의 컴퓨터에서 돌아가는 모델이지. 오늘 어떻게 도와줄까?\",\n    ]\n}\n\ncurrent_user_message = \"\"\n```\n\n다음으로, 모델을 실행하는 함수를 만들어보겠어요. 여기서 예시로 Tiny LLama 모델 GGUF 파일을 사용합니다.\n\n```js\n모델 = (\n    \"경로/모델/tinyllama-1.1b-chat-v1.0.Q4_K_M.gguf\"\n)\n\nllm = LlamaCpp(model_path=모델)\n```\n\n그런 다음, 채팅을 처리하는 2개의 함수를 만들 수 있어요. 먼저, 모델에 질문을 보내고 답변을 받는 request()라는 함수를 정의해주세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n**Note:** The function generates a prompt based on the model specified in the documentation. According to the documentation, you should follow the prompt template \"Zephyr\", which is different from the one used for Mistral 7B shown above:\n\n```js\n\u003c|system|\u003e\n{system_message}\u003c/s\u003e\n\u003c|user|\u003e\n{prompt}\u003c/s\u003e\n\u003c|assistant|\u003e\n```\n\nBelow is the function:\n\n```js\ndef request(state: State, prompt: str, conv_list: list) -\u003e str:\n    \"\"\"\n    Send a prompt to the local LLM and return the response.\n\n    Args:\n        - state: The current state.\n        - prompt: The prompt to send to the LLM.\n\n    Returns:\n        The response from the LLM.\n    \"\"\"\n\n    # Get the previous conversations to create the prompt history\n    system_message = \"\u003c|system|\u003e\\nYou are a geography expert and assist users by answering their questions\u003c/s\u003e\\n\"\n    # Get the previous conversations to create the prompt history\n    history_prompt = \"\"\n    for index, conv_element in enumerate(conv_list):\n        if index % 2 == 0:\n            history_prompt += f\"\u003c|user|\u003e\\n{conv_element}\u003c/s\u003e\\n\"\n        else:\n            history_prompt += f\"\u003c|assistant|\u003e\\n{conv_element}\u003c/s\u003e\\n\"\n    full_prompt = (\n        f\"{system_message}{history_prompt}\u003c|user|\u003e\\n{prompt}\u003c/s\u003e\\n\u003c|assistant|\u003e\"\n    )\n\n    response = state.llm(full_prompt)\n\n    return response\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그리고 이제 Taipy GUI 인터페이스와 상호 작용하는 send_message() 함수를 정의할 수 있습니다:\n\n```js\ndef send_message(state: State) -\u003e None:\n    \"\"\"\n    사용자의 메시지를 llm 함수로 전송합니다.\n    Args:\n        - state: 현재 상태.\n    \"\"\"\n    # 입력 필드 지우기\n    conv = state.conversation._dict.copy()\n\n    # 사용자 질문을 지역 LLM 모델에 요청합니다.\n    conv_list = conv[\"Conversation\"]\n    answer = request(state, state.current_user_message, conv_list).replace(\"\\n\", \"\")\n\n    conv[\"Conversation\"] += [state.current_user_message, answer]\n    state.current_user_message = \"\"\n    state.conversation = conv\n```\n\n## 사용자 인터페이스 만들기\n\n페이지를 초기화하려면 아래 코드를 추가하면 됩니다. 페이지 객체는 페이지 구조를 정의합니다. 원하신다면 markdown 구문을 추가할 수 있습니다(제목 또는 원하는 내용). 여기에는 없습니다. 그리고 Taipy 요소를 `|...|` 사이에 추가할 수 있습니다. 더 자세한 정보가 필요하다면 Taipy에 관한 다른 글을 참조하는 것을 권장합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\npage = \"\"\"\n\u003c|{대화}|table|show_all|\u003e\n\u003c|{current_user_message}|input|label=메시지를 입력하세요...|on_action=send_message|class_name=fullwidth|\u003e\n\"\"\"\n\nif __name__ == \"__main__\":\n    Gui(page).run(dark_mode=True, title=\"Taipy와 지역 LLM 채팅\")\n```\n\n## 선택 사항: CSS 변경\n\nTaipy의 튜토리얼에는 CSS 코드와 적용하는 함수가 있습니다. 여기에 완벽한 지침이 있도록 무심코 그것을 복사합니다. 이 부분에 대해 100%의 크레딧은 그들에게 갑니다.\n\nmain.py 파일 옆에 main.css 파일을 만들어 다음 코드를 붙여넣으세요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n.gpt_message td {\n    margin-left: 30px;\n    margin-bottom: 20px;\n    margin-top: 20px;\n    position: relative;\n    display: inline-block;\n    padding: 20px;\n    background-color: #ff462b;\n    border-radius: 20px;\n    max-width: 80%;\n    box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);\n    font-size: large;\n}\n\n.user_message td {\n    margin-right: 30px;\n    margin-bottom: 20px;\n    margin-top: 20px;\n    position: relative;\n    display: inline-block;\n    padding: 20px;\n    background-color: #140a1e;\n    border-radius: 20px;\n    max-width: 80%;\n    float: right;\n    box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);\n    font-size: large;\n}\n```\n\n그리고 다음 Python 함수를 만들어주세요. 해당 함수는 main.py 파일에 위치시키실 수 있습니다. 이 함수는 페이지에 스타일을 적용합니다:\n\n```js\ndef style_conv(state: State, idx: int, row: int) -\u003e str:\n    \"\"\"\n    Apply a style to the conversation table depending on the message's author.\n\n    Args:\n        - state: The current state of the app.\n        - idx: The index of the message in the table.\n        - row: The row of the message in the table.\n\n    Returns:\n        The style to apply to the message.\n    \"\"\"\n    if idx is None:\n        return None\n    elif idx % 2 == 0:\n        return \"user_message\"\n    else:\n        return \"gpt_message\"\n```\n\n다음으로, 페이지 객체를 수정하시어 스타일이 적용되도록 하실 수 있습니다. 아래와 같이 conversation 요소에 style=style_conv|를 추가해주세요:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n페이지 = \"\"\"\n\u003c|{conversation}|표|모든_표시|스타일=style_conv|\u003e\n\u003c|{current_user_message}|입력|레이블=여기에 메시지를 입력하세요...|작업=send_message|클래스_이름=전체너비|\u003e\n\"\"\"\n```\n\n## 앱 실행하기\n\n앱을 실행하려면 main.py 파일을 다른 Python 파일처럼 호출하면 됩니다!\n\n아래 이미지에서 보시다시피, 작은 모델이 좋지 않고 지리가 주 용도가 아닌 것 같습니다. 하지만 한 가지 확실한 것은 웹 앱에서 로컬 모델이 실행되고 있다는 것이며, 이것은 정말 멋집니다!\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_9.png)\n\nThank you for reading!\n\nIf you enjoyed my content and would like to connect:\n\n👉 You can connect with me on LinkedIn\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n👉 제 개인 웹사이트를 확인해보세요","ogImage":{"url":"/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_0.png","tag":["Tech"],"readingTime":22},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_0.png\" alt=\"How to run your first local LLMs\"\u003e\u003c/p\u003e\n\u003cp\u003e작년 동안 (2024년에 이 글을 쓰고 있기 때문에) 대형 언어 모델(LLMs)은 전문적인 환경과 작업 수행 방식을 변화시켰습니다.\u003c/p\u003e\n\u003cp\u003eChat GPT와 그들의 Chat 버전에 익숙하실 것입니다. 당신은 Chat GPT Plus 사용자(OpenAI의 유료 플랜)일 수도 있습니다. 또는 Anthropic이나 Google Bard와 같은 다른 유사한 제공 업체를 사용해본 적이 있을 수도 있습니다. 심지어 OpenAI와 경쟁 업체 모두 강력한 도구를 제공하지만, 여기 몇 가지 이유가 있어서 LLMs를 로컬에서 실행해 보려고 하는 것을 고려해볼만 합니다 (더 많을 수 있습니다!):\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e생태계에 대해 더 알고 새로운 모델을 시도하며 자신만의 경험을 소유하고 싶다면.\u003c/li\u003e\n\u003cli\u003e딥 러닝과 LLMs에 대해 배우고 싶지만 시작할 곳을 모르겠거나 더 알고 싶다면; 오픈 소스 모델을 로컬에서 실행하는 것이 훌륭한 시작점이 될 수 있습니다.\u003c/li\u003e\n\u003cli\u003e개인 정보를 오픈AI나 구글과 같은 대기업에 제공하고 싶지 않다면.\u003c/li\u003e\n\u003cli\u003e인터넷 연결이 필요하지 않고 오프라인에서 실행할 수 있는 채팅 애플리케이션을 원한다면.\u003c/li\u003e\n\u003cli\u003e금융이나 문학 작성과 같은 특정 작업을 위해 더 작고 특화된 모델로 실험하고 싶다면.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e얼마 전 나 또한 모든 이러한 요구 사항을 만족시켰습니다. 모든 이 기술 주변의 정보 양에 압도되었다고 느꼈습니다. 일반적인 조언으로 말할 때 목표가 오르막길처럼 느껴진다면 산만 바라보지 말고 가능한 한 빨리 첫 번째 발을 내딛어 올라가세요. 그리고 계속 그렇게 계단을 올라가다 보면 다음 산이 보이게 될 것입니다 (ㅋ).\u003c/p\u003e\n\u003cp\u003e이 여정에서 첫 단계를 내딛도록 도와드리기 위해 프로세스를 아래 네 부분으로 나누어 설명했습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e기본 개념 몇 가지: 이 섹션에서는 미리 알려진 지식을 가정하지 않고 자습서 전반에 걸쳐 사용되는 주요 용어와 아이디어를 소개합니다.\u003c/li\u003e\n\u003cli\u003eGPT4All에서 모델 실행: 오픈 소스 GUI 애플리케이션을 사용하여 로컬에서 모델을 실행합니다.\u003c/li\u003e\n\u003cli\u003eJupyter 노트북에서 LangChain을 사용하여 로컬 LLMs 실행, Python 프로그래밍 기술은 필요하지만 LLMs에 대한 사전 경험이 없어도 됩니다.\u003c/li\u003e\n\u003cli\u003eLangChain과 Taipy를 사용하여 챗봇 생성.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e책임의 한계:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이는 \"초보자용\" 접근법이므로 텍스트 생성 모델에 대해 작성하겠습니다.\u003c/li\u003e\n\u003cli\u003e일부 모델은 기술적으로 로컬에서 실행할 수 있지만 자원을 많이 소비합니다(일반 가정용 컴퓨터나 노트북에서는 적어요). 만약 컴퓨터에 4GB의 RAM이 있다면, 실행 가능한 모델을 찾기 어려울 것입니다(그래도 여전히 몇 가지 모델을 즐겁게 시도해 볼 수 있습니다). 8GB(현재 대부분의 컴퓨터에 탑재된 메모리)가 있으면 여러 모델을 찾을 수 있지만 여전히 도전적 일 것입니다. 7GB에서 10GB 사이의 RAM이 필요한 모델을 찾기 쉽습니다.\u003c/li\u003e\n\u003cli\u003e로컬에서 모델을 실행할 때 컴퓨터 소리가 전투기가 이륙하는 것처럼 들릴 수 있습니다. 이는 정상입니다.\u003c/li\u003e\n\u003cli\u003eGGUF 모델을 CPU로 로컬 컴퓨터에서 실행하는 방법에 대해 이야기하며 이것이 내가 알고 있는 가장 쉬운 옵션입니다. 입문자에게 100% 친숙합니다.\u003c/li\u003e\n\u003cli\u003e모든 내용은 Windows 10에서 작동합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_1.png\" alt=\"그림링크\"\u003e\u003c/p\u003e\n\u003ch1\u003e몇 가지 기본 개념\u003c/h1\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eLLM 랜드스케이프는 수십 개(아마 수백 개)의 새로운 용어, 용어, 개념 및 약어들을 가져왔어요. 쉽게 길을 잃을 수 있습니다. 이 섹션의 목표는 로컬에서 첫 번째 오픈 소스 모델을 사용하는 데 중요한 일부 주요 개념을 간단하게 설명하는 것입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGGML 파일 : 이 파일 시스템은 이제 구식입니다(AI 세계는 빠르게 변화해요!), 하지만 여전히 주변에서 찾을 수 있습니다(그리고 이에 대한 튜토리얼도 많습니다). GPT-생성된 모델 언어를 나타냅니다. 이제 GGUF 모델을 다운로드해야 합니다.\u003c/li\u003e\n\u003cli\u003eGPT4All : 로컬(컴퓨터에서)에서 실행되는 그래픽 사용자 인터페이스(GUI)입니다. 챗 GPT 인터페이스와 비슷해요. 이 인터페이스를 사용하여 LLM을 로컬에서 실행할 수 있어요.\u003c/li\u003e\n\u003cli\u003eGGUF (GPT-생성된 통일 형식) 파일 : 로컬로 다운로드하고 실행할 수 있는 LLM 모델을 포함하는 파일입니다.\u003c/li\u003e\n\u003cli\u003eHugging Face : 자연어 처리(NLP)에 초점을 맞춘 이익을 위한 회사로서, 최신 LLM의 개발 및 사용을 위한 플랫폼을 제공합니다. 이 플랫폼을 Hugging Face로도 참조할 수 있습니다. 이 플랫폼에서 많은 모델을 찾을 수 있어요(일부 모델은 로컬에서 실행할 수 있습니다).\u003c/li\u003e\n\u003cli\u003eLangChain : LLM 응용 프로그램을 만들기 위해 프레임워크를 개발한 회사입니다. 대부분의 경우 LangChain을 프레임워크를 가리키는 데 사용합니다. 이것은 LLM API(또는 로컬 파일!), 데이터베이스 연결, HTML 및 문서 파서에 연결할 수 있는 도구상자입니다. LangChain에는 Python API가 있습니다. 이 튜토리얼의 3부와 4부에서 사용할 겁니다.\u003c/li\u003e\n\u003cli\u003e양자화 : 모델의 가중치와 바이어스의 정밀도를 줄여서 리소스가 제한된 장치에서 더 효율적으로 사용할 수 있도록 하는 것으로, 메모리 및 계산 요구 사항에 도움을 줍니다. 예를 들어, 2.45는 2.45 236987의 양자화 된 버전입니다. 덜 정확하지만 공간을 적게 차지하고 계산이 더 쉬운 숫자에 대해 더 적은 비트를 저장할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eHugging Face\u003c/h2\u003e\n\u003cp\u003eHugging Face은 다양한 LLM 모델을 다운로드할 수 있는 한 곳(주요한 곳?)입니다(다른 LLM 관련 도구들과 함께). 여기 목표는:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003eGGUF 모델을 다운로드하는 방법을 안내해 드릴게요.\u003c/li\u003e\n\u003cli\u003e다운로드하기 전에 확인해야 할 중요한 사항들을 몇 가지 소개해 드릴게요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 글의 다음 부분에서는 GPT4all의 인터페이스에서 모델을 직접 다운로드하는 방법을 설명할 거에요. 따라서 가능한 더 적은 귀찮음을 원하신다면, 직접 그쪽으로 가셔서 모델을 다운로드할 수 있지만, 거기서는 다운로드할 수 있는 모델들이 적기 때문에, 적어도 이 글의 이 부분을 일반적인 지식으로 읽어보길 권장해 드려요.\u003c/p\u003e\n\u003cp\u003e컴퓨터에서 로컬로 실행되는 GGUF 모델을 가져오려면, 먼저 모델 페이지로 이동해주세요.\u003c/p\u003e\n\u003cp\u003e다음 단계는 모델을 필터링해서 GGUF 파일만 표시되도록 하는 것입니다. 페이지의 왼쪽 상단에 \"라이브러리\"를 선택하고 GGUF를 클릭하면 됩니다. 아래 이미지와 같이 하시면 되요:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e아마도 많은 모델들이 특정 사용자 \"The Bloke\"로부터 온 것을 알게 될 것입니다. 다음 자습서에서는 그의 모델 중 일부를 사용할 것이지만, 선호하는 다른 모델을 선택해도 괜찮습니다!\u003c/p\u003e\n\u003cp\u003eThe Bloke가 제공하는 GGUF 모델은 다른 모델의 양자화 버전입니다.\u003c/p\u003e\n\u003cp\u003e이 예에서는 Mistral 7B Instruct v0.2 — GGUF라는 모델을 사용할 것입니다 (그리고 이외에도 1개의 아주 작은 모델이 있습니다. 아래 참조).\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 모델은 Mistral-7B-Instruct-v0.2라고 하는 원래 모델의 양자화된 버전입니다. 해당 Hugging Face 페이지를 확인할 수 있습니다 (해당 페이지에서 파일을 다운로드하지 마세요!) 및 Readme 페이지(주 페이지)의 정보, 파일 확장명 등을 양자화된 모델의 정보와 비교할 수 있습니다. 이 모델은 오픈 소스 LLMs 분야에서 중요한 역할을 하는 Mistral이 개발한 것입니다.\u003c/p\u003e\n\u003cp\u003e다시 양자화된 모델 페이지(Mistral 7B Instruct v0.2 - GGUF)로 돌아가면, 다양한 크기의 버전을 다운로드할 수 있으며 필요한 최대 RAM을 확인할 수 있습니다. 4GB 컴퓨터로는 이 모델을 실행하기 어려울 것으로 보입니다 (이 섹션 맨 끝에 작은 모델을 나열해 두겠습니다). 8GB 컴퓨터를 사용하는 경우, 가장 무거운 모델을 실행할 수 없을 것입니다. 제 경우에는 mistral-7b-instruct-v0.2.Q4_K_M.gguf를 다운로드하기로 결정했습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eQ4_K_M은 양자화 방법입니다.\u003c/li\u003e\n\u003cli\u003e파일 크기는 4.37GB입니다.\u003c/li\u003e\n\u003cli\u003e6.87GB의 RAM이 필요합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e더 작은 모델\u003c/h2\u003e\n\u003cp\u003e더 작은 모델을 사용하려면 TinyLlama-1.1B-Chat-v1.0-GGUF를 시도해볼 수 있어요.\u003c/p\u003e\n\u003cp\u003e저도 사용할 거에요 (Taipy 앱을 위해), 왜냐하면 더 가벼우니까요 (더 빠르고... 그리고 덜 정확하죠). Mistral 7B Instruct v0.2 — GGUF와 똑같은 과정이에요.\u003c/p\u003e\n\u003ch2\u003e모델과 대화하기 위한 일부 Python 라이브러리\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e만약 파이썬 방식에 따라 가시려면, 여기 몇 가지 라이브러리를 소개해 드릴게요. 이 라이브러리들을 사용하면 로컬 또는 비로컬로 간단한 채팅 인터페이스를 만들 수 있어요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTaipy : 이 글의 마지막 부분에서 로컬 모델을 위한 매우 간단한 Taipy 채팅을 어떻게 만드는지 보여드릴 거에요.\u003c/li\u003e\n\u003cli\u003eStreamlit : Streamlit 애플리케이션을 만드는 것도 쉬워요. 다양한 튜토리얼이 많이 있어요.\u003c/li\u003e\n\u003cli\u003eGradio : Gradio 앱은 Hugging Face 생태계에서 인기가 있어요. 이것을 아직은 제가 잘 알지 못하긴 한데요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003eGPT4All 사용하기\u003c/h1\u003e\n\u003cp\u003eGPT4All은 로컬 컴퓨터에서 실행되는 채팅 인터페이스에요. 홈페이지에서 직접 설치 파일을 다운로드할 수 있어요. Windows용으로는 .exe 파일이며, 열어서 설치하면 되요... 그렇게 간단해요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e위 이미지를 보시면 ChatGPT의 인터페이스와 비슷하게 보입니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_4.png\" alt=\"ChatGPT Interface\"\u003e\u003c/p\u003e\n\u003cp\u003e상당히 직관적인 것 같아요. 그러나 위 그림에 있는 것과 같이 3가지 중요한 요소를 언급하고 싶어요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e프롬프팅 존... 이용하기 전에 모델을 로드해야 해요!\u003c/li\u003e\n\u003cli\u003e왼쪽 상단의 \"버거 메뉴\"를 통해 채팅 기록을 확인할 수 있고, 해당 채팅에 사용한 모델을 기억합니다... 여기서 인터페이스에서 모델을 직접 다운로드할 수도 있어요.\u003c/li\u003e\n\u003cli\u003e설정 버튼. 여기서 HuggingFace나 다른 곳에서 GGUF 파일을 다운로드할 디렉토리를 볼 수 있어요. 올바른 폴더에 다운로드하면 GPT4all이 그 파일들을 \"인식\"할 거예요.\u003c/li\u003e\n\u003cli\u003e폴더에 여러 모델이 있는 경우, GUI 상단 중앙의 메뉴로 선택할 수 있어요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003eGPT4All에서 모델 다운로드하기\u003c/h2\u003e\n\u003cp\u003eGPT4All에서 모델을 다운로드하려면 화면 오른쪽 상단의 버거 메뉴로 이동하십시오. 그리고 \"다운로드\"를 선택하십시오.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_5.png\" alt=\"다운로드\"\u003e\u003c/p\u003e\n\u003cp\u003e선택할 모델 목록이 표시됩니다. 원하는 모델을 선택하고 \"다운로드\"를 클릭하면 첫 번째 모델을 사용할 수 있습니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e미스트랄의 OpenOrca를 사용하고 있는데, 이 채팅 봇은 상당히 좋아요. 여기에서는 API 키를 제공하여 ChatGPT 모델을 선택할 수도 있습니다. 이 마지막 옵션은 아직 시도해보지 않았는데, 개인적으로는 의미가 없다고 생각해요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_6.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003e다른 모델을 다운로드할 GPT4All 폴더 선택하기\u003c/h2\u003e\n\u003cp\u003eHuggingFace와 같은 다른 모델을 사용하고 싶다면, 그 모델이 GPT4All이 모델을 찾는 폴더에 다운로드하면 됩니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e해당 위치를 찾으려면 설정 메뉴(오른쪽 상단의 작은 휠)를 클릭하세요. \"애플리케이션\"을 선택합니다. 로컬 폴더 경로는 \"다운로드 경로\" 옆에 있습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_7.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e첫 번째 LLM 모델을 로컬에서 실행하는 가장 쉬운 방법은 아니더라도 가깝습니다! 즐겁게 사용하시길 바랍니다!\u003c/p\u003e\n\u003ch1\u003eLangChain 사용하기\u003c/h1\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e알림: 이 방법은 Python의 기본적인 이해가 필요하지만 따르기 쉬워요. 노트북 사용자들(Jupyter Notebook, JupyterLab...)에 적합해요.\u003c/p\u003e\n\u003cp\u003eLangChain은 LLM (Language Model)을 사용하여 LLM 애플리케이션을 만들 수 있게 해주는 Python 라이브러리에요 (당연한 얘기겠지만... LangChain과 LLM이 없이도 앱을 만들 수는 있어요. 다만, 그것들은 LLM 앱이 아닐 뿐이죠). LangChain은 데이터베이스에 연결하거나 문서나 웹을 파싱하거나 다양한 서비스에 쿼리를 날리는 API 클라이언트 등 Python 라이브러리들과 연결할 수 있어요.\u003c/p\u003e\n\u003cp\u003e이번에는 LangChain을 사용하여 GGUF 파일을 가져와 대화하는 방법을 알려드릴게요.\u003c/p\u003e\n\u003cp\u003eLangChain을 사용하기 위해 다음이 필요해요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLangchain_community: Langchain을 위한 타사 통합 기능을 포함하고 있어요.\u003c/li\u003e\n\u003cli\u003ellama_cpp_python: llama.cpp를 위한 Python 바인더에요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eLlama.cpp은 다른 파일들과 함께 GGUF 파일을 다룰 수 있게 해줍니다!\u003c/p\u003e\n\u003cp\u003e여기 나타난 예시를 보면, 단순히 llama_cpp_python만 사용할 수도 있지만, LangChain을 익히는 것이 더 좋은 아이디어이며 복잡성을 더하는 일이 거의 없습니다.\u003c/p\u003e\n\u003cp\u003eJupyterLab을 사용하여 LLM 모델을 호출할 것이고, 이 작업은 다른 어떤 노트북이나 ^Python 파일에서도 작동해야 합니다.\u003c/p\u003e\n\u003cp\u003e먼저 라이브러리를 가져와주세요:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain.callbacks.manager \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e CallbackManager\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain.callbacks.streaming_stdout \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e StreamingStdOutCallbackHandler\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain.prompts \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e PromptTemplate\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain_community.llms \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e LlamaCpp\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그 후, GGUF 파일로 모델 변수를 만들어보세요. 선택적으로 callback_manager도 만들 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003emodel = \u003cspan class=\"hljs-string\"\u003e\"path/to/model/mistral-7b-instruct-v0.2.Q4_K_M.ggu\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e# Callbacks support token-wise streaming\u003c/span\u003e\ncallback_manager = CallbackManager([StreamingStdOutCallbackHandler()])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제, prompts를 인수로 받아 답변을 생성할 llm 객체를 만들 수 있습니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003ellm = LlamaCpp(\n    model_path=model,\n    callback_manager=callback_manager, \u003cspan class=\"hljs-comment\"\u003e#Optional, streams the response as it is generated\u003c/span\u003e\n    verbose=\u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e,  \u003cspan class=\"hljs-comment\"\u003e# Verbose is required to pass to the callback manager\u003c/span\u003e\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eprompt_addon = \u003cspan class=\"hljs-string\"\u003e\"\u0026#x3C;s\u003e[INST]파이썬 명령어를 만들어 'hello world'를 출력하도록 합니다[/INST]print('hello world')\u0026#x3C;/s\u003e\"\u003c/span\u003e\nprompt = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\n주어진 숫자까지의 피보나치 수열을 반환하는 파이썬 함수를 작성하십시오. 독스트링을 추가하세요.\n\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\nllm.\u003cspan class=\"hljs-title function_\"\u003einvoke\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"{prompt_addon}[INST]{prompt}[/INST]\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_8.png\"\u003e\n\u003ch1\u003eTaipy를 사용하여 작은 채팅 인터페이스 만들기\u003c/h1\u003e\n\u003cp\u003eLangChain 보드 대신에, Taipy와 같은 Python 웹 애플리케이션 빌더와 함께 사용할 수 있습니다. 이 라이브러리에 대해 더 알고 싶으시다면, 이전에 관련한 기사를 썼었지만, 라이브러리에 대해 많이 알지 못해도 어플리케이션을 작동시킬 수 있을 것입니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e저는 다음 예시를 Taipy 팀의 튜토리얼에서 수정했어요. 그래서 많은 창의성은 그들에게 돌아갑니다. 다른 점은 OpenAI의 GPT 모델(그들의 API로) 대신 로컬 모델을 사용한다는 것이에요.\u003c/p\u003e\n\u003cp\u003e위 예시의 라이브러리들(LangChain와 Llama_Cpp)이 필요하고 당연히 Taipy를 설치해야 해요 ( pip install taipy ).\u003c/p\u003e\n\u003cp\u003ePython 함수와 Taipy 코드를 모두 넣을 main.py 라는 파일을 만들어야 해요.\u003c/p\u003e\n\u003cp\u003e첫째, 라이브러리를 가져와요. 앱이 채팅을 표시할 것이기 때문에 출력을 스트리밍할 필요 없어요. 그냥 가져오세요:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain.callbacks.manager \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e CallbackManager\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain_community.llms \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e LlamaCpp\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e taipy.gui \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e Gui, State\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e타이피(Taipy)에서 상태(State)는 앱에서 변수의 \"현재 상태\"를 가리킵니다. 이러한 변수에 초기 값을 할당한 후, 그 값은 앱에서 변경됩니다: 사용자가 값 변경하거나 함수의 결과로 값이 변경될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e두 개의 변수, conversation(대화)와 current_user_message(현재 사용자 메시지)를 만들어 봅시다. 대화는 대화창에 보낸 메시지와 그에 대한 답변의 기록입니다. current_user_message는 사용자가 프롬프트로 입력할 메시지를 나타냅니다.\u003c/p\u003e\n\u003cp\u003e성능상의 이유로 tinyllama-1.1b-chat-v1.0.Q4_K_M 모델을 사용하겠습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e대화 = {\n    \u003cspan class=\"hljs-string\"\u003e\"Conversation\"\u003c/span\u003e: [\n        \u003cspan class=\"hljs-string\"\u003e\"너 누구니?\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"안녕! 나는 작은 LLama야. 너의 컴퓨터에서 돌아가는 모델이지. 오늘 어떻게 도와줄까?\"\u003c/span\u003e,\n    ]\n}\n\ncurrent_user_message = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로, 모델을 실행하는 함수를 만들어보겠어요. 여기서 예시로 Tiny LLama 모델 GGUF 파일을 사용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e모델 = (\n    \u003cspan class=\"hljs-string\"\u003e\"경로/모델/tinyllama-1.1b-chat-v1.0.Q4_K_M.gguf\"\u003c/span\u003e\n)\n\nllm = \u003cspan class=\"hljs-title class_\"\u003eLlamaCpp\u003c/span\u003e(model_path=모델)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런 다음, 채팅을 처리하는 2개의 함수를 만들 수 있어요. 먼저, 모델에 질문을 보내고 답변을 받는 request()라는 함수를 정의해주세요.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e The function generates a prompt based on the model specified in the documentation. According to the documentation, you should follow the prompt template \"Zephyr\", which is different from the one used for Mistral 7B shown above:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;|system|\u003e\n{system_message}\u0026#x3C;/s\u003e\n\u0026#x3C;|user|\u003e\n{prompt}\u0026#x3C;/s\u003e\n\u0026#x3C;|assistant|\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBelow is the function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003erequest\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003estate\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eprompt\u003c/span\u003e: str, \u003cspan class=\"hljs-attr\"\u003econv_list\u003c/span\u003e: list) -\u003e \u003cspan class=\"hljs-attr\"\u003estr\u003c/span\u003e:\n    \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\n    Send a prompt to the local LLM and return the response.\n\n    Args:\n        - state: The current state.\n        - prompt: The prompt to send to the LLM.\n\n    Returns:\n        The response from the LLM.\n    \"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n\n    # \u003cspan class=\"hljs-title class_\"\u003eGet\u003c/span\u003e the previous conversations to create the prompt history\n    system_message = \u003cspan class=\"hljs-string\"\u003e\"\u0026#x3C;|system|\u003e\\nYou are a geography expert and assist users by answering their questions\u0026#x3C;/s\u003e\\n\"\u003c/span\u003e\n    # \u003cspan class=\"hljs-title class_\"\u003eGet\u003c/span\u003e the previous conversations to create the prompt history\n    history_prompt = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e index, conv_element \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eenumerate\u003c/span\u003e(conv_list):\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e index % \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e:\n            history_prompt += f\u003cspan class=\"hljs-string\"\u003e\"\u0026#x3C;|user|\u003e\\n{conv_element}\u0026#x3C;/s\u003e\\n\"\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eelse\u003c/span\u003e:\n            history_prompt += f\u003cspan class=\"hljs-string\"\u003e\"\u0026#x3C;|assistant|\u003e\\n{conv_element}\u0026#x3C;/s\u003e\\n\"\u003c/span\u003e\n    full_prompt = (\n        f\u003cspan class=\"hljs-string\"\u003e\"{system_message}{history_prompt}\u0026#x3C;|user|\u003e\\n{prompt}\u0026#x3C;/s\u003e\\n\u0026#x3C;|assistant|\u003e\"\u003c/span\u003e\n    )\n\n    response = state.\u003cspan class=\"hljs-title function_\"\u003ellm\u003c/span\u003e(full_prompt)\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e response\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그리고 이제 Taipy GUI 인터페이스와 상호 작용하는 send_message() 함수를 정의할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003esend_message\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003estate\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e:\n    \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\n    사용자의 메시지를 llm 함수로 전송합니다.\n    Args:\n        - state: 현재 상태.\n    \"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    # 입력 필드 지우기\n    conv = state.\u003cspan class=\"hljs-property\"\u003econversation\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e_dict\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecopy\u003c/span\u003e()\n\n    # 사용자 질문을 지역 \u003cspan class=\"hljs-variable constant_\"\u003eLLM\u003c/span\u003e 모델에 요청합니다.\n    conv_list = conv[\u003cspan class=\"hljs-string\"\u003e\"Conversation\"\u003c/span\u003e]\n    answer = \u003cspan class=\"hljs-title function_\"\u003erequest\u003c/span\u003e(state, state.\u003cspan class=\"hljs-property\"\u003ecurrent_user_message\u003c/span\u003e, conv_list).\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e)\n\n    conv[\u003cspan class=\"hljs-string\"\u003e\"Conversation\"\u003c/span\u003e] += [state.\u003cspan class=\"hljs-property\"\u003ecurrent_user_message\u003c/span\u003e, answer]\n    state.\u003cspan class=\"hljs-property\"\u003ecurrent_user_message\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    state.\u003cspan class=\"hljs-property\"\u003econversation\u003c/span\u003e = conv\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e사용자 인터페이스 만들기\u003c/h2\u003e\n\u003cp\u003e페이지를 초기화하려면 아래 코드를 추가하면 됩니다. 페이지 객체는 페이지 구조를 정의합니다. 원하신다면 markdown 구문을 추가할 수 있습니다(제목 또는 원하는 내용). 여기에는 없습니다. 그리고 Taipy 요소를 \u003ccode\u003e|...|\u003c/code\u003e 사이에 추가할 수 있습니다. 더 자세한 정보가 필요하다면 Taipy에 관한 다른 글을 참조하는 것을 권장합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epage = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\n\u0026#x3C;|{대화}|table|show_all|\u003e\n\u0026#x3C;|{current_user_message}|input|label=메시지를 입력하세요...|on_action=send_message|class_name=fullwidth|\u003e\n\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e __name__ == \u003cspan class=\"hljs-string\"\u003e\"__main__\"\u003c/span\u003e:\n    \u003cspan class=\"hljs-title class_\"\u003eGui\u003c/span\u003e(page).\u003cspan class=\"hljs-title function_\"\u003erun\u003c/span\u003e(dark_mode=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e, title=\u003cspan class=\"hljs-string\"\u003e\"Taipy와 지역 LLM 채팅\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e선택 사항: CSS 변경\u003c/h2\u003e\n\u003cp\u003eTaipy의 튜토리얼에는 CSS 코드와 적용하는 함수가 있습니다. 여기에 완벽한 지침이 있도록 무심코 그것을 복사합니다. 이 부분에 대해 100%의 크레딧은 그들에게 갑니다.\u003c/p\u003e\n\u003cp\u003emain.py 파일 옆에 main.css 파일을 만들어 다음 코드를 붙여넣으세요:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e.\u003cspan class=\"hljs-property\"\u003egpt_message\u003c/span\u003e td {\n    margin-\u003cspan class=\"hljs-attr\"\u003eleft\u003c/span\u003e: 30px;\n    margin-\u003cspan class=\"hljs-attr\"\u003ebottom\u003c/span\u003e: 20px;\n    margin-\u003cspan class=\"hljs-attr\"\u003etop\u003c/span\u003e: 20px;\n    \u003cspan class=\"hljs-attr\"\u003eposition\u003c/span\u003e: relative;\n    \u003cspan class=\"hljs-attr\"\u003edisplay\u003c/span\u003e: inline-block;\n    \u003cspan class=\"hljs-attr\"\u003epadding\u003c/span\u003e: 20px;\n    background-\u003cspan class=\"hljs-attr\"\u003ecolor\u003c/span\u003e: #ff462b;\n    border-\u003cspan class=\"hljs-attr\"\u003eradius\u003c/span\u003e: 20px;\n    max-\u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e80\u003c/span\u003e%;\n    box-\u003cspan class=\"hljs-attr\"\u003eshadow\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e 4px 8px \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ergba\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.2\u003c/span\u003e), \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e 6px 20px \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ergba\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.19\u003c/span\u003e);\n    font-\u003cspan class=\"hljs-attr\"\u003esize\u003c/span\u003e: large;\n}\n\n.\u003cspan class=\"hljs-property\"\u003euser_message\u003c/span\u003e td {\n    margin-\u003cspan class=\"hljs-attr\"\u003eright\u003c/span\u003e: 30px;\n    margin-\u003cspan class=\"hljs-attr\"\u003ebottom\u003c/span\u003e: 20px;\n    margin-\u003cspan class=\"hljs-attr\"\u003etop\u003c/span\u003e: 20px;\n    \u003cspan class=\"hljs-attr\"\u003eposition\u003c/span\u003e: relative;\n    \u003cspan class=\"hljs-attr\"\u003edisplay\u003c/span\u003e: inline-block;\n    \u003cspan class=\"hljs-attr\"\u003epadding\u003c/span\u003e: 20px;\n    background-\u003cspan class=\"hljs-attr\"\u003ecolor\u003c/span\u003e: #140a1e;\n    border-\u003cspan class=\"hljs-attr\"\u003eradius\u003c/span\u003e: 20px;\n    max-\u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e80\u003c/span\u003e%;\n    \u003cspan class=\"hljs-attr\"\u003efloat\u003c/span\u003e: right;\n    box-\u003cspan class=\"hljs-attr\"\u003eshadow\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e 4px 8px \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ergba\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.2\u003c/span\u003e), \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e 6px 20px \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ergba\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.19\u003c/span\u003e);\n    font-\u003cspan class=\"hljs-attr\"\u003esize\u003c/span\u003e: large;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 다음 Python 함수를 만들어주세요. 해당 함수는 main.py 파일에 위치시키실 수 있습니다. 이 함수는 페이지에 스타일을 적용합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003estyle_conv\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003estate\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eidx\u003c/span\u003e: int, \u003cspan class=\"hljs-attr\"\u003erow\u003c/span\u003e: int) -\u003e \u003cspan class=\"hljs-attr\"\u003estr\u003c/span\u003e:\n    \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\n    Apply a style to the conversation table depending on the message's author.\n\n    Args:\n        - state: The current state of the app.\n        - idx: The index of the message in the table.\n        - row: The row of the message in the table.\n\n    Returns:\n        The style to apply to the message.\n    \"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e idx is \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e\n    elif idx % \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"user_message\"\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eelse\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"gpt_message\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로, 페이지 객체를 수정하시어 스타일이 적용되도록 하실 수 있습니다. 아래와 같이 conversation 요소에 style=style_conv|를 추가해주세요:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e페이지 = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\n\u0026#x3C;|{conversation}|표|모든_표시|스타일=style_conv|\u003e\n\u0026#x3C;|{current_user_message}|입력|레이블=여기에 메시지를 입력하세요...|작업=send_message|클래스_이름=전체너비|\u003e\n\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e앱 실행하기\u003c/h2\u003e\n\u003cp\u003e앱을 실행하려면 main.py 파일을 다른 Python 파일처럼 호출하면 됩니다!\u003c/p\u003e\n\u003cp\u003e아래 이미지에서 보시다시피, 작은 모델이 좋지 않고 지리가 주 용도가 아닌 것 같습니다. 하지만 한 가지 확실한 것은 웹 앱에서 로컬 모델이 실행되고 있다는 것이며, 이것은 정말 멋집니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_9.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003eThank you for reading!\u003c/p\u003e\n\u003cp\u003eIf you enjoyed my content and would like to connect:\u003c/p\u003e\n\u003cp\u003e👉 You can connect with me on LinkedIn\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e👉 제 개인 웹사이트를 확인해보세요\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-13-HowtorunyourfirstlocalLLMs"},"buildId":"X4OrKfmLtU3-3BijwfHe6","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>