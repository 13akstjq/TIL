<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>nextjs 15 서버 컴포넌트에서 데이터 업데이트 하는 방법  | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-Howtoupdatedata" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="nextjs 15 서버 컴포넌트에서 데이터 업데이트 하는 방법  | TIL" data-gatsby-head="true"/><meta property="og:title" content="nextjs 15 서버 컴포넌트에서 데이터 업데이트 하는 방법  | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-Howtoupdatedata" data-gatsby-head="true"/><meta name="twitter:title" content="nextjs 15 서버 컴포넌트에서 데이터 업데이트 하는 방법  | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2025-04-22 01:15" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-8ded8b979ba73586.js" defer=""></script><script src="/TIL/_next/static/X4OrKfmLtU3-3BijwfHe6/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/X4OrKfmLtU3-3BijwfHe6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">nextjs 15 서버 컴포넌트에서 데이터 업데이트 하는 방법 </h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="nextjs 15 서버 컴포넌트에서 데이터 업데이트 하는 방법 " loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Apr 22, 2025</span><span class="posts_reading_time__f7YPP">12<!-- --> min read</span></span></div></div></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>데이터 업데이트하는 방법</h1>
<p>Next.js에서 데이터를 업데이트할 때는 React의 Server Functions를 활용할 수 있어요. 이번 글에서는 Server Functions를 어떻게 만들고, 호출하는지 쉽고 간단하게 살펴볼게요.</p>
<h2>Server Functions 만들기</h2>
<p>Server Function은 <code>use server</code>라는 지시어(directive)를 사용해서 정의할 수 있어요. <code>async</code> 함수 맨 위에 <code>use server</code>를 적으면 그 함수가 Server Function으로 인식돼요. 또는 파일 맨 위에 <code>use server</code>를 적으면, 그 파일이 내보내는(export) 모든 함수들이 Server Function으로 동작하게 돼요.</p>
<hr>
<blockquote>
<p>예를 들어, 아래처럼 쓸 수 있습니다.</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-string">'use server'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateData</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 서버에서 실행할 로직</span>
}
</code></pre>
<hr>
<p>이렇게 하면 프론트엔드에서 API를 호출하는 느낌 대신, 마치 서버 안에서 직접 호출하는 것처럼 데이터를 처리할 수 있어요. 서버에서 실행되기 때문에 보안이나 성능 측면에서도 이점이 크고, 코드도 깔끔해집니다.</p>
<p>혹시 여기서 <code>use server</code>가 뭔지 궁금할 수도 있는데, 이건 Next.js 13 이후에 도입된 기능으로, React 컴포넌트 내에서 서버 전용 함수를 만드는데 사용하는 문법이에요. 쉽게 말해 서버에서만 실행되는 함수임을 표시하는 태그라고 생각하면 됩니다.</p>
<p>다음엔 이 Server Function을 실제 컴포넌트에서 어떻게 호출하는지도 보여드릴게요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이번 글에서는 Next.js 13부터 새롭게 도입된 Server Actions, 즉 서버에서 직접 실행되는 함수 작성법에 대해 살펴볼게요. 특히, Server Functions를 어떻게 작성하고, 이걸 Server Component 안에 어떻게 쉽게 넣을 수 있는지 가볍게 정리해봤습니다.</p>
<hr>
<h3>Server Functions 기본 작성법</h3>
<p>예를 들어, 게시글을 생성하거나 삭제하는 함수를 작성할 때 아래처럼 <code>FormData</code>를 받아서 처리할 수 있어요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createPost</span>(<span class="hljs-params">formData: FormData</span>) {
  <span class="hljs-string">'use server'</span>   <span class="hljs-comment">// 여기가 포인트! 이 지시어로 서버에서 실행됨을 명시</span>
  <span class="hljs-keyword">const</span> title = formData.<span class="hljs-title function_">get</span>(<span class="hljs-string">'title'</span>)
  <span class="hljs-keyword">const</span> content = formData.<span class="hljs-title function_">get</span>(<span class="hljs-string">'content'</span>)

  <span class="hljs-comment">// 여기서 데이터베이스에 글 저장하거나,</span>
  <span class="hljs-comment">// 혹은 캐시를 재검증(revalidate)하는 작업을 할 수 있죠</span>
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">deletePost</span>(<span class="hljs-params">formData: FormData</span>) {
  <span class="hljs-string">'use server'</span>
  <span class="hljs-keyword">const</span> id = formData.<span class="hljs-title function_">get</span>(<span class="hljs-string">'id'</span>)

  <span class="hljs-comment">// 삭제 처리 및 캐시 갱신</span>
}
</code></pre>
<p><code>'use server'</code>를 함수 맨 위에 적으면, 이 함수가 클라이언트가 아닌 서버에서 실행될 함수임을 명확히 하게 됩니다. 이게 Next.js가 Server Actions를 인식하고 별도로 처리하게 만들어주죠.</p>
<hr>
<h3>Server Functions를 Server Component 안에 작성하기</h3>
<p>서버 컴포넌트 내부에 이런 Server Action 함수를 바로 써도 OK인데요, 이런 식으로 함수 위에 <code>'use server'</code> 지시어를 붙이면 됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 서버에서 실행될 함수 (Server Action)</span>
  <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createPost</span>(<span class="hljs-params">formData: FormData</span>) {
    <span class="hljs-string">'use server'</span>
    <span class="hljs-comment">// ...게시글 생성 로직</span>
  }

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;></span><span class="hljs-tag">&#x3C;/></span></span>
}
</code></pre>
<p>이렇게 하면 해당 함수를 컴포넌트 바깥으로 따로 빼지 않아도 되고, 컴포넌트와 함수의 관계를 내비치기 좋아요.</p>
<hr>
<h3>알아두면 좋은 팁</h3>
<ul>
<li>Server Actions로 넘겨받는 <code>formData</code>는 <code>&#x3C;form></code>에서 전송한 데이터를 쉽게 받아서 쓸 수 있어서, API 엔드포인트 없이도 폼 제출을 깔끔하게 처리할 수 있어요.</li>
<li>서버 함수는 클라이언트 코드에 포함되지 않으니, 보안상 민감한 작업을 하기에 좋아요.</li>
<li>데이터 변경 후에는 꼭 필요한 경우 <code>revalidatePath()</code> 같은 Next.js의 캐시 재검증 함수를 호출해 UI에 최신 상태가 반영되게 만들어야 해요.</li>
</ul>
<hr>
<p>다음 포스팅에서는 Server Actions를 실제 폼과 연동해서 구현하는 간단한 예시도 준비해볼게요. 서버와 클라이언트 경계를 넘나드는 작업이 점점 더 좋아지고 있어 기대해 주세요! 😊</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>클라이언트 컴포넌트(Client Components)</h3>
<p>서버 함수(Server Functions)는 클라이언트 컴포넌트 안에서 직접 정의할 수는 없어요. 하지만 서버 함수가 담긴 파일에 <code>'use server'</code>라는 지시어를 맨 위에 붙여서 내보내면, 클라이언트 컴포넌트에서 이 함수를 불러와서 실행할 수 있답니다!</p>
<p>예를 들어, 이런 식으로 서버 함수가 정의되어 있어요:</p>
<pre><code class="hljs language-js"><span class="hljs-string">'use server'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createPost</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 서버에서 처리할 로직</span>
}
</code></pre>
<p>그리고 클라이언트 컴포넌트에서는 이렇게 import해서 사용할 수 있죠:</p>
<pre><code class="hljs language-js"><span class="hljs-string">'use client'</span>

<span class="hljs-keyword">import</span> { createPost } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/app/actions'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Button</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">formAction</span>=<span class="hljs-string">{createPost}</span>></span>Create<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span></span>
}
</code></pre>
<p>여기서 핵심은, <code>createPost</code> 같은 함수는 실제로는 서버에서 작동하지만, 클라이언트 컴포넌트가 그 함수를 호출하는 이벤트를 연결해준다는 점이에요. 덕분에 UI는 클라이언트에서 매끄럽게 돌아가면서도, 중요한 데이터 처리나 DB 작업 등은 안전하게 서버에서 수행할 수 있죠.</p>
<p>추가로 알아두면 좋은 점!</p>
<ul>
<li><code>'use server'</code> 디렉티브가 있는 파일은 Next.js가 서버 전용이라는 걸 인지해서 클라이언트 번들에서 제외해줘서 코드가 더 깔끔해져요.</li>
<li><code>formAction</code> prop을 사용하면 폼 제출 시 서버 함수를 바로 트리거할 수 있어서 React의 상태 관리 없이도 서버와 통신하기 편해요.</li>
<li>이렇게 Server Function을 클라이언트 컴포넌트에서 활용하면, 복잡한 API 라우트 없이도 양방향 데이터 흐름을 간단히 구현할 수 있습니다.</li>
</ul>
<p>이 방식 덕분에 Next.js에서 서버/클라이언트 코드 구분이 더 명확하고, 개발자는 로직을 더 효율적으로 나눌 수 있답니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>서버 함수 호출하기</h2>
<p>서버 함수를 호출하는 방법은 크게 두 가지가 있어요:</p>
<ul>
<li>서버 컴포넌트와 클라이언트 컴포넌트에서의 폼(form) 사용</li>
<li>클라이언트 컴포넌트에서 이벤트 핸들러 사용</li>
</ul>
<h3>폼(Form)이용하기</h3>
<p>폼 태그는 HTML에서 서버와 데이터를 주고받을 때 가장 기본적인 방법 중 하나인데요, Next.js 같은 프레임워크에서 서버 컴포넌트나 클라이언트 컴포넌트 내에서 쉽게 사용할 수 있어요. 폼이 제출되면 지정한 서버 함수가 호출되고, 그 서버 함수 안에서 데이터를 처리할 수 있죠.</p>
<p>예를 들어, 간단한 로그인 폼을 만들어 서버 함수로 데이터를 보내는 경우를 생각해보면 이해가 쉬워요. 폼 안에 input 필드를 넣고, submit 버튼을 누르면 서버 함수가 자동으로 실행되는 거죠.</p>
<p>또한, 요즘은 fetch API나 axios 같은 클라이언트 사이드 호출 방식을 많이 쓰긴 하지만, 폼을 이용한 방법은 여전히 직관적이고 간단하게 서버에 데이터를 보내는 좋은 방법이에요. 특히 서버 컴포넌트가 지원되는 환경에서는 폼을 통해 자연스럽게 서버 함수를 호출할 수 있다는 점 꼭 기억하세요!</p>
<p>필요하면 다음에 폼 예제 코드를 공유할게요.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>React에서 <code>form</code> 태그를 확장해서 Server Function을 HTML <code>action</code> 속성으로 바로 호출할 수 있다는 사실, 알고 계셨나요?</p>
<p>보통 우리가 폼을 제출할 때는 프론트엔드에서 이벤트 핸들러를 따로 만들어서 처리하곤 하죠. 하지만 React에서는 폼의 <code>action</code> 속성에 서버에서 실행할 함수를 직접 연결할 수 있어요. 이 함수는 폼 제출 시 자동으로 <code>FormData</code> 객체를 받아서 안에 담긴 값들을 쉽게 꺼내 쓸 수 있답니다.</p>
<p>예를 들어, 아래처럼 <code>createPost</code>라는 서버 함수를 <code>action</code>에 할당하면, 폼이 제출될 때 자동으로 <code>createPost</code>가 호출되면서 제출한 데이터가 <code>FormData</code> 형태로 전달돼요.</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">import</span> { createPost } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/app/actions'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Form</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">{createPost}</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"title"</span> /></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"content"</span> /></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>></span>Create<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">form</span>></span></span>
  )
}
</code></pre>
<p>서버 함수는 이렇게 작성할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-string">'use server'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createPost</span>(<span class="hljs-params">formData: FormData</span>) {
  <span class="hljs-keyword">const</span> title = formData.<span class="hljs-title function_">get</span>(<span class="hljs-string">'title'</span>)
  <span class="hljs-keyword">const</span> content = formData.<span class="hljs-title function_">get</span>(<span class="hljs-string">'content'</span>)

  <span class="hljs-comment">// 여기서 DB에 저장하거나, 캐시를 재검증하는 작업을 할 수 있어요.</span>
}
</code></pre>
<h3>조금 더 알아두면 좋은 팁!</h3>
<ul>
<li><code>FormData.get()</code> 메서드는 반환값이 <code>FormDataEntryValue | null</code>이기 때문에, 실제 값이 문자열인지 확인하거나 기본값을 설정하는 게 좋습니다.</li>
<li>서버 함수 내에서는 서버 전용 코드(ex. 데이터베이스 쿼리, 파일 시스템 접근)를 자유롭게 사용할 수 있어요.</li>
<li>클라이언트에서 별도의 API 호출 없이도 서버로 데이터를 보낼 수 있어서 코드가 더 깔끔해지고 유지보수가 쉬워집니다.</li>
<li>물론, 복잡한 폼 유효성 검사나 사용자가 바로 피드백을 받아야 하는 경우엔 클라이언트 측에서 미리 체크하는 걸 추천합니다.</li>
</ul>
<p>이 방식은 특히 Next.js 같은 React 기반 프레임워크에서 유용하게 쓰이는데요, 서버 함수와 폼을 연동하는 새로운 흐름을 경험해보고 싶다면 한 번 시도해보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<blockquote>
<p>참고할 점: action prop에 전달될 때 Server Functions는 Server Actions라고도 불러요.</p>
</blockquote>
<h3>이벤트 핸들러(Event Handlers)</h3>
<p>클라이언트 컴포넌트에서 서버 기능(Server Function)을 호출할 때는 onClick 같은 이벤트 핸들러를 활용할 수 있어요. 예를 들어, 좋아요 버튼을 만들고 클릭할 때마다 서버에 좋아요 수를 업데이트하는 기능을 구현해볼게요.</p>
<pre><code class="hljs language-jsx"><span class="hljs-string">'use client'</span>

<span class="hljs-keyword">import</span> { incrementLike } <span class="hljs-keyword">from</span> <span class="hljs-string">'./actions'</span>
<span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">LikeButton</span>(<span class="hljs-params">{ initialLikes }: { initialLikes: number }</span>) {
  <span class="hljs-keyword">const</span> [likes, setLikes] = <span class="hljs-title function_">useState</span>(initialLikes)

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>Total Likes: {likes}<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span>
        <span class="hljs-attr">onClick</span>=<span class="hljs-string">{async</span> () =></span> {
          // 서버에 좋아요 증가 요청을 보내고, 업데이트 된 좋아요 수를 받아서 상태를 갱신해요
          const updatedLikes = await incrementLike()
          setLikes(updatedLikes)
        }}
      >
        Like
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
    <span class="hljs-tag">&#x3C;/></span></span>
  )
}
</code></pre>
<p>여기서 중요한 점은, 클라이언트 컴포넌트 내부에서 직접 서버 사이드 코드를 호출할 수 없기 때문에, <code>incrementLike</code> 같은 서버 기능을 <code>actions</code>라는 별도의 파일에서 정의해두고 import해서 사용한다는 거예요. 그리고 비동기 처리를 위해 <code>async/await</code>를 활용한 점도 기억해두면 좋아요.</p>
<p>또한, 이렇게 서버 함수 호출 시 상태를 업데이트하는 패턴은 사용자 인터랙션에 실시간 피드백을 주는 데 아주 유용합니다. 만약 서버 함수 호출 중에 로딩 상태 표시가 필요하다면, <code>useState</code>로 로딩 상태를 관리해서 버튼을 비활성화하거나 스피너를 보여주는 것도 좋은 UX를 위한 팁이에요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>예시</h2>
<h3>대기 상태 표시하기</h3>
<p>서버 함수를 실행하는 동안, React의 <code>useActionState</code> 훅을 사용해서 로딩 인디케이터를 보여줄 수 있어요. 이 훅은 <code>pending</code>이라는 불리언 값을 반환하는데, 이 값이 <code>true</code>일 때는 작업이 진행 중임을 뜻하죠.</p>
<p>예를 들어, 게시글 생성 버튼을 눌렀을 때 로딩 스피너를 보여주는 컴포넌트 코드는 아래와 같습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-string">'use client'</span>

<span class="hljs-keyword">import</span> { useActionState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> { createPost } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/app/actions'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">LoadingSpinner</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/app/ui/loading-spinner'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Button</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [state, action, pending] = <span class="hljs-title function_">useActionState</span>(createPost, <span class="hljs-literal">false</span>)

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{async</span> () =></span> action()}>
      {pending ? <span class="hljs-tag">&#x3C;<span class="hljs-name">LoadingSpinner</span> /></span> : 'Create Post'}
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span></span>
  )
}
</code></pre>
<p>여기서 중요한 점은 <code>pending</code> 값 덕분에 사용자에게 작업이 진행 중이라는 피드백을 줄 수 있다는 거예요. 보통 서버와의 통신이 느릴 때는 이렇게 대기 상태를 표시해주는 게 UX 측면에서 정말 중요하답니다.</p>
<p>또 한 가지 팁을 드리자면, 이 훅은 작업이 끝난 후 결과값이나 에러 상태도 함께 관리할 수 있어서, 로딩뿐만 아니라 성공, 실패 상태에 따른 UI 업데이트도 함께 처리할 수 있어요. 필요에 따라 <code>state</code>를 활용해보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>캐시 재검증하기</h3>
<p>데이터를 업데이트한 뒤, Next.js 캐시를 재검증(revalidate)해서 최신 데이터를 보여주고 싶을 때가 있죠? 그럴 땐 Server Function 내부에서 <code>revalidatePath</code>나 <code>revalidateTag</code> 함수를 사용하면 간편하게 해결할 수 있어요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { revalidatePath } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/cache'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createPost</span>(<span class="hljs-params">formData: FormData</span>) {
  <span class="hljs-string">'use server'</span>
  
  <span class="hljs-comment">// 데이터 업데이트 작업 수행</span>
  <span class="hljs-comment">// ...</span>
  
  <span class="hljs-comment">// 특정 경로에 대한 캐시를 재검증해서 최신 데이터 반영</span>
  <span class="hljs-title function_">revalidatePath</span>(<span class="hljs-string">'/posts'</span>)
}
</code></pre>
<p>위 예제처럼, 글을 새로 만들거나 수정한 뒤 <code>/posts</code> 경로의 캐시를 재검증하면 사용자에게 항상 최신 게시물 목록을 보여줄 수 있답니다.</p>
<blockquote>
<p>추가 팁!<br>
비슷하게 <code>revalidateTag</code>를 사용하면 태그 단위로 캐시를 재검증할 수도 있는데, 이 방법은 특정 데이터 그룹을 관리할 때 유용해요. 상황에 맞게 선택해서 사용해보세요.</p>
</blockquote>
<h3>리다이렉트하기</h3>
<p>서버 함수에서 작업을 마친 후 사용자를 다른 페이지로 이동시키고 싶을 때는 어떻게 할까요? Next.js에서는 <code>redirect</code> 함수를 활용하면 쉽게 처리할 수 있답니다.</p>
<p>예를 들어, 글 작성 후 게시물 목록 페이지로 이동시키고 싶을 때:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { redirect } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/navigation'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createPost</span>(<span class="hljs-params">formData: FormData</span>) {
  <span class="hljs-string">'use server'</span>
  
  <span class="hljs-comment">// 데이터 생성 로직</span>
  <span class="hljs-comment">// ...</span>
  
  <span class="hljs-comment">// 작업 후 /posts 페이지로 리다이렉트</span>
  <span class="hljs-title function_">redirect</span>(<span class="hljs-string">'/posts'</span>)
}
</code></pre>
<p><code>redirect</code> 함수를 호출하면, 클라이언트가 자동으로 지정한 경로로 이동하게 됩니다. 이 방법 덕분에 별도의 클라이언트 사이드 코드 없이도 깔끔한 흐름 제어가 가능해요.</p>
<hr>
<p>이처럼 Next.js의 Server Function 내에서 캐시 재검증과 리다이렉트를 함께 활용하면, 데이터 일관성을 유지하면서 사용자 경험도 한층 좋아지니 꼭 알아두세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>업데이트 작업을 수행한 후에 사용자를 다른 페이지로 이동시키고 싶을 때가 있죠? 그럴 때는 Next.js의 Server Function 안에서 <code>redirect</code> 함수를 사용할 수 있어요.</p>
<p>아래 예시 코드를 한 번 볼게요!</p>
<pre><code class="hljs language-js"><span class="hljs-string">'use server'</span>

<span class="hljs-keyword">import</span> { redirect } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/navigation'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createPost</span>(<span class="hljs-params">formData: FormData</span>) {
  <span class="hljs-comment">// 데이터 업데이트 작업 수행</span>
  <span class="hljs-comment">// ...</span>
  
  <span class="hljs-comment">// 업데이트 후 /posts 페이지로 리디렉션</span>
  <span class="hljs-title function_">redirect</span>(<span class="hljs-string">'/posts'</span>)
}
</code></pre>
<p>여기서 포인트는, <code>redirect</code>가 호출되면 그 즉시 클라이언트에게 지정한 URL로 이동하라고 지시한다는 점이에요. 그래서 서버 함수 내에서 업데이트가 끝난 뒤에 자연스럽게 다른 페이지로 사용자를 안내할 수 있죠.</p>
<p>또 한 가지 팁! <code>redirect</code>를 사용할 때, 이 함수는 호출과 동시에 훅을 멈추고 이동을 처리하기 때문에 그 이후 코드는 실행되지 않는다는 점 기억해주세요. 만약 안전하게 특정 조건에서만 리디렉션을 하고 싶다면, 조건문 안에 넣어서 사용하면 돼요.</p>
<p>요약하자면, Next.js 13 이상의 서버 함수에서 업데이트 후 바로 페이지 전환을 원할 땐 <code>redirect</code>를 활용해보세요. 페이지 새로고침 없이 부드럽게 이동할 수 있어서 사용자 경험도 좋아진답니다!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"nextjs 15 서버 컴포넌트에서 데이터 업데이트 하는 방법 ","description":"","date":"2025-04-22 01:15","slug":"2025-04-22-Howtoupdatedata","content":"\n\n# 데이터 업데이트하는 방법\n\nNext.js에서 데이터를 업데이트할 때는 React의 Server Functions를 활용할 수 있어요. 이번 글에서는 Server Functions를 어떻게 만들고, 호출하는지 쉽고 간단하게 살펴볼게요.\n\n## Server Functions 만들기\n\nServer Function은 `use server`라는 지시어(directive)를 사용해서 정의할 수 있어요. `async` 함수 맨 위에 `use server`를 적으면 그 함수가 Server Function으로 인식돼요. 또는 파일 맨 위에 `use server`를 적으면, 그 파일이 내보내는(export) 모든 함수들이 Server Function으로 동작하게 돼요.\n\n---\n\n\u003e 예를 들어, 아래처럼 쓸 수 있습니다.\n\n```js\n'use server'\n\nexport async function updateData() {\n  // 서버에서 실행할 로직\n}\n```\n\n---\n\n이렇게 하면 프론트엔드에서 API를 호출하는 느낌 대신, 마치 서버 안에서 직접 호출하는 것처럼 데이터를 처리할 수 있어요. 서버에서 실행되기 때문에 보안이나 성능 측면에서도 이점이 크고, 코드도 깔끔해집니다.\n\n혹시 여기서 `use server`가 뭔지 궁금할 수도 있는데, 이건 Next.js 13 이후에 도입된 기능으로, React 컴포넌트 내에서 서버 전용 함수를 만드는데 사용하는 문법이에요. 쉽게 말해 서버에서만 실행되는 함수임을 표시하는 태그라고 생각하면 됩니다.\n\n다음엔 이 Server Function을 실제 컴포넌트에서 어떻게 호출하는지도 보여드릴게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번 글에서는 Next.js 13부터 새롭게 도입된 Server Actions, 즉 서버에서 직접 실행되는 함수 작성법에 대해 살펴볼게요. 특히, Server Functions를 어떻게 작성하고, 이걸 Server Component 안에 어떻게 쉽게 넣을 수 있는지 가볍게 정리해봤습니다.\n\n---\n\n### Server Functions 기본 작성법\n\n예를 들어, 게시글을 생성하거나 삭제하는 함수를 작성할 때 아래처럼 `FormData`를 받아서 처리할 수 있어요.\n\n```js\nexport async function createPost(formData: FormData) {\n  'use server'   // 여기가 포인트! 이 지시어로 서버에서 실행됨을 명시\n  const title = formData.get('title')\n  const content = formData.get('content')\n\n  // 여기서 데이터베이스에 글 저장하거나,\n  // 혹은 캐시를 재검증(revalidate)하는 작업을 할 수 있죠\n}\n\nexport async function deletePost(formData: FormData) {\n  'use server'\n  const id = formData.get('id')\n\n  // 삭제 처리 및 캐시 갱신\n}\n```\n\n`'use server'`를 함수 맨 위에 적으면, 이 함수가 클라이언트가 아닌 서버에서 실행될 함수임을 명확히 하게 됩니다. 이게 Next.js가 Server Actions를 인식하고 별도로 처리하게 만들어주죠.\n\n---\n\n### Server Functions를 Server Component 안에 작성하기\n\n서버 컴포넌트 내부에 이런 Server Action 함수를 바로 써도 OK인데요, 이런 식으로 함수 위에 `'use server'` 지시어를 붙이면 됩니다.\n\n```js\nexport default function Page() {\n  // 서버에서 실행될 함수 (Server Action)\n  async function createPost(formData: FormData) {\n    'use server'\n    // ...게시글 생성 로직\n  }\n\n  return \u003c\u003e\u003c/\u003e\n}\n```\n\n이렇게 하면 해당 함수를 컴포넌트 바깥으로 따로 빼지 않아도 되고, 컴포넌트와 함수의 관계를 내비치기 좋아요.\n\n---\n\n### 알아두면 좋은 팁\n\n- Server Actions로 넘겨받는 `formData`는 `\u003cform\u003e`에서 전송한 데이터를 쉽게 받아서 쓸 수 있어서, API 엔드포인트 없이도 폼 제출을 깔끔하게 처리할 수 있어요.\n- 서버 함수는 클라이언트 코드에 포함되지 않으니, 보안상 민감한 작업을 하기에 좋아요.\n- 데이터 변경 후에는 꼭 필요한 경우 `revalidatePath()` 같은 Next.js의 캐시 재검증 함수를 호출해 UI에 최신 상태가 반영되게 만들어야 해요.\n\n---\n\n다음 포스팅에서는 Server Actions를 실제 폼과 연동해서 구현하는 간단한 예시도 준비해볼게요. 서버와 클라이언트 경계를 넘나드는 작업이 점점 더 좋아지고 있어 기대해 주세요! 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 클라이언트 컴포넌트(Client Components)\n\n서버 함수(Server Functions)는 클라이언트 컴포넌트 안에서 직접 정의할 수는 없어요. 하지만 서버 함수가 담긴 파일에 `'use server'`라는 지시어를 맨 위에 붙여서 내보내면, 클라이언트 컴포넌트에서 이 함수를 불러와서 실행할 수 있답니다!\n\n예를 들어, 이런 식으로 서버 함수가 정의되어 있어요:\n\n```js\n'use server'\n\nexport async function createPost() {\n  // 서버에서 처리할 로직\n}\n```\n\n그리고 클라이언트 컴포넌트에서는 이렇게 import해서 사용할 수 있죠:\n\n```js\n'use client'\n\nimport { createPost } from '@/app/actions'\n\nexport function Button() {\n  return \u003cbutton formAction={createPost}\u003eCreate\u003c/button\u003e\n}\n```\n\n여기서 핵심은, `createPost` 같은 함수는 실제로는 서버에서 작동하지만, 클라이언트 컴포넌트가 그 함수를 호출하는 이벤트를 연결해준다는 점이에요. 덕분에 UI는 클라이언트에서 매끄럽게 돌아가면서도, 중요한 데이터 처리나 DB 작업 등은 안전하게 서버에서 수행할 수 있죠.\n\n추가로 알아두면 좋은 점!\n- `'use server'` 디렉티브가 있는 파일은 Next.js가 서버 전용이라는 걸 인지해서 클라이언트 번들에서 제외해줘서 코드가 더 깔끔해져요.\n- `formAction` prop을 사용하면 폼 제출 시 서버 함수를 바로 트리거할 수 있어서 React의 상태 관리 없이도 서버와 통신하기 편해요.\n- 이렇게 Server Function을 클라이언트 컴포넌트에서 활용하면, 복잡한 API 라우트 없이도 양방향 데이터 흐름을 간단히 구현할 수 있습니다.\n\n이 방식 덕분에 Next.js에서 서버/클라이언트 코드 구분이 더 명확하고, 개발자는 로직을 더 효율적으로 나눌 수 있답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 서버 함수 호출하기\n\n서버 함수를 호출하는 방법은 크게 두 가지가 있어요:\n\n- 서버 컴포넌트와 클라이언트 컴포넌트에서의 폼(form) 사용\n- 클라이언트 컴포넌트에서 이벤트 핸들러 사용\n\n### 폼(Form)이용하기\n\n폼 태그는 HTML에서 서버와 데이터를 주고받을 때 가장 기본적인 방법 중 하나인데요, Next.js 같은 프레임워크에서 서버 컴포넌트나 클라이언트 컴포넌트 내에서 쉽게 사용할 수 있어요. 폼이 제출되면 지정한 서버 함수가 호출되고, 그 서버 함수 안에서 데이터를 처리할 수 있죠.\n\n예를 들어, 간단한 로그인 폼을 만들어 서버 함수로 데이터를 보내는 경우를 생각해보면 이해가 쉬워요. 폼 안에 input 필드를 넣고, submit 버튼을 누르면 서버 함수가 자동으로 실행되는 거죠.\n\n또한, 요즘은 fetch API나 axios 같은 클라이언트 사이드 호출 방식을 많이 쓰긴 하지만, 폼을 이용한 방법은 여전히 직관적이고 간단하게 서버에 데이터를 보내는 좋은 방법이에요. 특히 서버 컴포넌트가 지원되는 환경에서는 폼을 통해 자연스럽게 서버 함수를 호출할 수 있다는 점 꼭 기억하세요!\n\n필요하면 다음에 폼 예제 코드를 공유할게요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nReact에서 `form` 태그를 확장해서 Server Function을 HTML `action` 속성으로 바로 호출할 수 있다는 사실, 알고 계셨나요?\n\n보통 우리가 폼을 제출할 때는 프론트엔드에서 이벤트 핸들러를 따로 만들어서 처리하곤 하죠. 하지만 React에서는 폼의 `action` 속성에 서버에서 실행할 함수를 직접 연결할 수 있어요. 이 함수는 폼 제출 시 자동으로 `FormData` 객체를 받아서 안에 담긴 값들을 쉽게 꺼내 쓸 수 있답니다.\n\n예를 들어, 아래처럼 `createPost`라는 서버 함수를 `action`에 할당하면, 폼이 제출될 때 자동으로 `createPost`가 호출되면서 제출한 데이터가 `FormData` 형태로 전달돼요.\n\n```jsx\nimport { createPost } from '@/app/actions'\n\nexport function Form() {\n  return (\n    \u003cform action={createPost}\u003e\n      \u003cinput type=\"text\" name=\"title\" /\u003e\n      \u003cinput type=\"text\" name=\"content\" /\u003e\n      \u003cbutton type=\"submit\"\u003eCreate\u003c/button\u003e\n    \u003c/form\u003e\n  )\n}\n```\n\n서버 함수는 이렇게 작성할 수 있습니다:\n\n```js\n'use server'\n\nexport async function createPost(formData: FormData) {\n  const title = formData.get('title')\n  const content = formData.get('content')\n\n  // 여기서 DB에 저장하거나, 캐시를 재검증하는 작업을 할 수 있어요.\n}\n```\n\n### 조금 더 알아두면 좋은 팁!\n\n- `FormData.get()` 메서드는 반환값이 `FormDataEntryValue | null`이기 때문에, 실제 값이 문자열인지 확인하거나 기본값을 설정하는 게 좋습니다.\n- 서버 함수 내에서는 서버 전용 코드(ex. 데이터베이스 쿼리, 파일 시스템 접근)를 자유롭게 사용할 수 있어요.\n- 클라이언트에서 별도의 API 호출 없이도 서버로 데이터를 보낼 수 있어서 코드가 더 깔끔해지고 유지보수가 쉬워집니다.\n- 물론, 복잡한 폼 유효성 검사나 사용자가 바로 피드백을 받아야 하는 경우엔 클라이언트 측에서 미리 체크하는 걸 추천합니다.\n\n이 방식은 특히 Next.js 같은 React 기반 프레임워크에서 유용하게 쓰이는데요, 서버 함수와 폼을 연동하는 새로운 흐름을 경험해보고 싶다면 한 번 시도해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003e 참고할 점: action prop에 전달될 때 Server Functions는 Server Actions라고도 불러요.\n\n### 이벤트 핸들러(Event Handlers)\n\n클라이언트 컴포넌트에서 서버 기능(Server Function)을 호출할 때는 onClick 같은 이벤트 핸들러를 활용할 수 있어요. 예를 들어, 좋아요 버튼을 만들고 클릭할 때마다 서버에 좋아요 수를 업데이트하는 기능을 구현해볼게요.\n\n```jsx\n'use client'\n\nimport { incrementLike } from './actions'\nimport { useState } from 'react'\n\nexport default function LikeButton({ initialLikes }: { initialLikes: number }) {\n  const [likes, setLikes] = useState(initialLikes)\n\n  return (\n    \u003c\u003e\n      \u003cp\u003eTotal Likes: {likes}\u003c/p\u003e\n      \u003cbutton\n        onClick={async () =\u003e {\n          // 서버에 좋아요 증가 요청을 보내고, 업데이트 된 좋아요 수를 받아서 상태를 갱신해요\n          const updatedLikes = await incrementLike()\n          setLikes(updatedLikes)\n        }}\n      \u003e\n        Like\n      \u003c/button\u003e\n    \u003c/\u003e\n  )\n}\n```\n\n여기서 중요한 점은, 클라이언트 컴포넌트 내부에서 직접 서버 사이드 코드를 호출할 수 없기 때문에, `incrementLike` 같은 서버 기능을 `actions`라는 별도의 파일에서 정의해두고 import해서 사용한다는 거예요. 그리고 비동기 처리를 위해 `async/await`를 활용한 점도 기억해두면 좋아요.\n\n또한, 이렇게 서버 함수 호출 시 상태를 업데이트하는 패턴은 사용자 인터랙션에 실시간 피드백을 주는 데 아주 유용합니다. 만약 서버 함수 호출 중에 로딩 상태 표시가 필요하다면, `useState`로 로딩 상태를 관리해서 버튼을 비활성화하거나 스피너를 보여주는 것도 좋은 UX를 위한 팁이에요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 예시\n\n### 대기 상태 표시하기\n\n서버 함수를 실행하는 동안, React의 `useActionState` 훅을 사용해서 로딩 인디케이터를 보여줄 수 있어요. 이 훅은 `pending`이라는 불리언 값을 반환하는데, 이 값이 `true`일 때는 작업이 진행 중임을 뜻하죠.\n\n예를 들어, 게시글 생성 버튼을 눌렀을 때 로딩 스피너를 보여주는 컴포넌트 코드는 아래와 같습니다:\n\n```js\n'use client'\n\nimport { useActionState } from 'react'\nimport { createPost } from '@/app/actions'\nimport { LoadingSpinner } from '@/app/ui/loading-spinner'\n\nexport function Button() {\n  const [state, action, pending] = useActionState(createPost, false)\n\n  return (\n    \u003cbutton onClick={async () =\u003e action()}\u003e\n      {pending ? \u003cLoadingSpinner /\u003e : 'Create Post'}\n    \u003c/button\u003e\n  )\n}\n```\n\n여기서 중요한 점은 `pending` 값 덕분에 사용자에게 작업이 진행 중이라는 피드백을 줄 수 있다는 거예요. 보통 서버와의 통신이 느릴 때는 이렇게 대기 상태를 표시해주는 게 UX 측면에서 정말 중요하답니다.\n\n또 한 가지 팁을 드리자면, 이 훅은 작업이 끝난 후 결과값이나 에러 상태도 함께 관리할 수 있어서, 로딩뿐만 아니라 성공, 실패 상태에 따른 UI 업데이트도 함께 처리할 수 있어요. 필요에 따라 `state`를 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 캐시 재검증하기\n\n데이터를 업데이트한 뒤, Next.js 캐시를 재검증(revalidate)해서 최신 데이터를 보여주고 싶을 때가 있죠? 그럴 땐 Server Function 내부에서 `revalidatePath`나 `revalidateTag` 함수를 사용하면 간편하게 해결할 수 있어요.\n\n```js\nimport { revalidatePath } from 'next/cache'\n\nexport async function createPost(formData: FormData) {\n  'use server'\n  \n  // 데이터 업데이트 작업 수행\n  // ...\n  \n  // 특정 경로에 대한 캐시를 재검증해서 최신 데이터 반영\n  revalidatePath('/posts')\n}\n```\n\n위 예제처럼, 글을 새로 만들거나 수정한 뒤 `/posts` 경로의 캐시를 재검증하면 사용자에게 항상 최신 게시물 목록을 보여줄 수 있답니다.\n\n\u003e 추가 팁!  \n\u003e 비슷하게 `revalidateTag`를 사용하면 태그 단위로 캐시를 재검증할 수도 있는데, 이 방법은 특정 데이터 그룹을 관리할 때 유용해요. 상황에 맞게 선택해서 사용해보세요.\n\n### 리다이렉트하기\n\n서버 함수에서 작업을 마친 후 사용자를 다른 페이지로 이동시키고 싶을 때는 어떻게 할까요? Next.js에서는 `redirect` 함수를 활용하면 쉽게 처리할 수 있답니다.\n\n예를 들어, 글 작성 후 게시물 목록 페이지로 이동시키고 싶을 때:\n\n```js\nimport { redirect } from 'next/navigation'\n\nexport async function createPost(formData: FormData) {\n  'use server'\n  \n  // 데이터 생성 로직\n  // ...\n  \n  // 작업 후 /posts 페이지로 리다이렉트\n  redirect('/posts')\n}\n```\n\n`redirect` 함수를 호출하면, 클라이언트가 자동으로 지정한 경로로 이동하게 됩니다. 이 방법 덕분에 별도의 클라이언트 사이드 코드 없이도 깔끔한 흐름 제어가 가능해요.\n\n---\n\n이처럼 Next.js의 Server Function 내에서 캐시 재검증과 리다이렉트를 함께 활용하면, 데이터 일관성을 유지하면서 사용자 경험도 한층 좋아지니 꼭 알아두세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n업데이트 작업을 수행한 후에 사용자를 다른 페이지로 이동시키고 싶을 때가 있죠? 그럴 때는 Next.js의 Server Function 안에서 `redirect` 함수를 사용할 수 있어요.\n\n아래 예시 코드를 한 번 볼게요!\n\n```js\n'use server'\n\nimport { redirect } from 'next/navigation'\n\nexport async function createPost(formData: FormData) {\n  // 데이터 업데이트 작업 수행\n  // ...\n  \n  // 업데이트 후 /posts 페이지로 리디렉션\n  redirect('/posts')\n}\n```\n\n여기서 포인트는, `redirect`가 호출되면 그 즉시 클라이언트에게 지정한 URL로 이동하라고 지시한다는 점이에요. 그래서 서버 함수 내에서 업데이트가 끝난 뒤에 자연스럽게 다른 페이지로 사용자를 안내할 수 있죠.\n\n또 한 가지 팁! `redirect`를 사용할 때, 이 함수는 호출과 동시에 훅을 멈추고 이동을 처리하기 때문에 그 이후 코드는 실행되지 않는다는 점 기억해주세요. 만약 안전하게 특정 조건에서만 리디렉션을 하고 싶다면, 조건문 안에 넣어서 사용하면 돼요.\n\n요약하자면, Next.js 13 이상의 서버 함수에서 업데이트 후 바로 페이지 전환을 원할 땐 `redirect`를 활용해보세요. 페이지 새로고침 없이 부드럽게 이동할 수 있어서 사용자 경험도 좋아진답니다!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":12},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003e데이터 업데이트하는 방법\u003c/h1\u003e\n\u003cp\u003eNext.js에서 데이터를 업데이트할 때는 React의 Server Functions를 활용할 수 있어요. 이번 글에서는 Server Functions를 어떻게 만들고, 호출하는지 쉽고 간단하게 살펴볼게요.\u003c/p\u003e\n\u003ch2\u003eServer Functions 만들기\u003c/h2\u003e\n\u003cp\u003eServer Function은 \u003ccode\u003euse server\u003c/code\u003e라는 지시어(directive)를 사용해서 정의할 수 있어요. \u003ccode\u003easync\u003c/code\u003e 함수 맨 위에 \u003ccode\u003euse server\u003c/code\u003e를 적으면 그 함수가 Server Function으로 인식돼요. 또는 파일 맨 위에 \u003ccode\u003euse server\u003c/code\u003e를 적으면, 그 파일이 내보내는(export) 모든 함수들이 Server Function으로 동작하게 돼요.\u003c/p\u003e\n\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003e예를 들어, 아래처럼 쓸 수 있습니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e'use server'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eupdateData\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 서버에서 실행할 로직\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003cp\u003e이렇게 하면 프론트엔드에서 API를 호출하는 느낌 대신, 마치 서버 안에서 직접 호출하는 것처럼 데이터를 처리할 수 있어요. 서버에서 실행되기 때문에 보안이나 성능 측면에서도 이점이 크고, 코드도 깔끔해집니다.\u003c/p\u003e\n\u003cp\u003e혹시 여기서 \u003ccode\u003euse server\u003c/code\u003e가 뭔지 궁금할 수도 있는데, 이건 Next.js 13 이후에 도입된 기능으로, React 컴포넌트 내에서 서버 전용 함수를 만드는데 사용하는 문법이에요. 쉽게 말해 서버에서만 실행되는 함수임을 표시하는 태그라고 생각하면 됩니다.\u003c/p\u003e\n\u003cp\u003e다음엔 이 Server Function을 실제 컴포넌트에서 어떻게 호출하는지도 보여드릴게요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이번 글에서는 Next.js 13부터 새롭게 도입된 Server Actions, 즉 서버에서 직접 실행되는 함수 작성법에 대해 살펴볼게요. 특히, Server Functions를 어떻게 작성하고, 이걸 Server Component 안에 어떻게 쉽게 넣을 수 있는지 가볍게 정리해봤습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003eServer Functions 기본 작성법\u003c/h3\u003e\n\u003cp\u003e예를 들어, 게시글을 생성하거나 삭제하는 함수를 작성할 때 아래처럼 \u003ccode\u003eFormData\u003c/code\u003e를 받아서 처리할 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreatePost\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eformData: FormData\u003c/span\u003e) {\n  \u003cspan class=\"hljs-string\"\u003e'use server'\u003c/span\u003e   \u003cspan class=\"hljs-comment\"\u003e// 여기가 포인트! 이 지시어로 서버에서 실행됨을 명시\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e title = formData.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'title'\u003c/span\u003e)\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e content = formData.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'content'\u003c/span\u003e)\n\n  \u003cspan class=\"hljs-comment\"\u003e// 여기서 데이터베이스에 글 저장하거나,\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 혹은 캐시를 재검증(revalidate)하는 작업을 할 수 있죠\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edeletePost\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eformData: FormData\u003c/span\u003e) {\n  \u003cspan class=\"hljs-string\"\u003e'use server'\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e id = formData.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'id'\u003c/span\u003e)\n\n  \u003cspan class=\"hljs-comment\"\u003e// 삭제 처리 및 캐시 갱신\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e'use server'\u003c/code\u003e를 함수 맨 위에 적으면, 이 함수가 클라이언트가 아닌 서버에서 실행될 함수임을 명확히 하게 됩니다. 이게 Next.js가 Server Actions를 인식하고 별도로 처리하게 만들어주죠.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003eServer Functions를 Server Component 안에 작성하기\u003c/h3\u003e\n\u003cp\u003e서버 컴포넌트 내부에 이런 Server Action 함수를 바로 써도 OK인데요, 이런 식으로 함수 위에 \u003ccode\u003e'use server'\u003c/code\u003e 지시어를 붙이면 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 서버에서 실행될 함수 (Server Action)\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreatePost\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eformData: FormData\u003c/span\u003e) {\n    \u003cspan class=\"hljs-string\"\u003e'use server'\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// ...게시글 생성 로직\u003c/span\u003e\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003e\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 해당 함수를 컴포넌트 바깥으로 따로 빼지 않아도 되고, 컴포넌트와 함수의 관계를 내비치기 좋아요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e알아두면 좋은 팁\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eServer Actions로 넘겨받는 \u003ccode\u003eformData\u003c/code\u003e는 \u003ccode\u003e\u0026#x3C;form\u003e\u003c/code\u003e에서 전송한 데이터를 쉽게 받아서 쓸 수 있어서, API 엔드포인트 없이도 폼 제출을 깔끔하게 처리할 수 있어요.\u003c/li\u003e\n\u003cli\u003e서버 함수는 클라이언트 코드에 포함되지 않으니, 보안상 민감한 작업을 하기에 좋아요.\u003c/li\u003e\n\u003cli\u003e데이터 변경 후에는 꼭 필요한 경우 \u003ccode\u003erevalidatePath()\u003c/code\u003e 같은 Next.js의 캐시 재검증 함수를 호출해 UI에 최신 상태가 반영되게 만들어야 해요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e다음 포스팅에서는 Server Actions를 실제 폼과 연동해서 구현하는 간단한 예시도 준비해볼게요. 서버와 클라이언트 경계를 넘나드는 작업이 점점 더 좋아지고 있어 기대해 주세요! 😊\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003e클라이언트 컴포넌트(Client Components)\u003c/h3\u003e\n\u003cp\u003e서버 함수(Server Functions)는 클라이언트 컴포넌트 안에서 직접 정의할 수는 없어요. 하지만 서버 함수가 담긴 파일에 \u003ccode\u003e'use server'\u003c/code\u003e라는 지시어를 맨 위에 붙여서 내보내면, 클라이언트 컴포넌트에서 이 함수를 불러와서 실행할 수 있답니다!\u003c/p\u003e\n\u003cp\u003e예를 들어, 이런 식으로 서버 함수가 정의되어 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e'use server'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreatePost\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 서버에서 처리할 로직\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 클라이언트 컴포넌트에서는 이렇게 import해서 사용할 수 있죠:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e'use client'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { createPost } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@/app/actions'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eButton\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eformAction\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{createPost}\u003c/span\u003e\u003e\u003c/span\u003eCreate\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 핵심은, \u003ccode\u003ecreatePost\u003c/code\u003e 같은 함수는 실제로는 서버에서 작동하지만, 클라이언트 컴포넌트가 그 함수를 호출하는 이벤트를 연결해준다는 점이에요. 덕분에 UI는 클라이언트에서 매끄럽게 돌아가면서도, 중요한 데이터 처리나 DB 작업 등은 안전하게 서버에서 수행할 수 있죠.\u003c/p\u003e\n\u003cp\u003e추가로 알아두면 좋은 점!\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e'use server'\u003c/code\u003e 디렉티브가 있는 파일은 Next.js가 서버 전용이라는 걸 인지해서 클라이언트 번들에서 제외해줘서 코드가 더 깔끔해져요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eformAction\u003c/code\u003e prop을 사용하면 폼 제출 시 서버 함수를 바로 트리거할 수 있어서 React의 상태 관리 없이도 서버와 통신하기 편해요.\u003c/li\u003e\n\u003cli\u003e이렇게 Server Function을 클라이언트 컴포넌트에서 활용하면, 복잡한 API 라우트 없이도 양방향 데이터 흐름을 간단히 구현할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 방식 덕분에 Next.js에서 서버/클라이언트 코드 구분이 더 명확하고, 개발자는 로직을 더 효율적으로 나눌 수 있답니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e서버 함수 호출하기\u003c/h2\u003e\n\u003cp\u003e서버 함수를 호출하는 방법은 크게 두 가지가 있어요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e서버 컴포넌트와 클라이언트 컴포넌트에서의 폼(form) 사용\u003c/li\u003e\n\u003cli\u003e클라이언트 컴포넌트에서 이벤트 핸들러 사용\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e폼(Form)이용하기\u003c/h3\u003e\n\u003cp\u003e폼 태그는 HTML에서 서버와 데이터를 주고받을 때 가장 기본적인 방법 중 하나인데요, Next.js 같은 프레임워크에서 서버 컴포넌트나 클라이언트 컴포넌트 내에서 쉽게 사용할 수 있어요. 폼이 제출되면 지정한 서버 함수가 호출되고, 그 서버 함수 안에서 데이터를 처리할 수 있죠.\u003c/p\u003e\n\u003cp\u003e예를 들어, 간단한 로그인 폼을 만들어 서버 함수로 데이터를 보내는 경우를 생각해보면 이해가 쉬워요. 폼 안에 input 필드를 넣고, submit 버튼을 누르면 서버 함수가 자동으로 실행되는 거죠.\u003c/p\u003e\n\u003cp\u003e또한, 요즘은 fetch API나 axios 같은 클라이언트 사이드 호출 방식을 많이 쓰긴 하지만, 폼을 이용한 방법은 여전히 직관적이고 간단하게 서버에 데이터를 보내는 좋은 방법이에요. 특히 서버 컴포넌트가 지원되는 환경에서는 폼을 통해 자연스럽게 서버 함수를 호출할 수 있다는 점 꼭 기억하세요!\u003c/p\u003e\n\u003cp\u003e필요하면 다음에 폼 예제 코드를 공유할게요.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eReact에서 \u003ccode\u003eform\u003c/code\u003e 태그를 확장해서 Server Function을 HTML \u003ccode\u003eaction\u003c/code\u003e 속성으로 바로 호출할 수 있다는 사실, 알고 계셨나요?\u003c/p\u003e\n\u003cp\u003e보통 우리가 폼을 제출할 때는 프론트엔드에서 이벤트 핸들러를 따로 만들어서 처리하곤 하죠. 하지만 React에서는 폼의 \u003ccode\u003eaction\u003c/code\u003e 속성에 서버에서 실행할 함수를 직접 연결할 수 있어요. 이 함수는 폼 제출 시 자동으로 \u003ccode\u003eFormData\u003c/code\u003e 객체를 받아서 안에 담긴 값들을 쉽게 꺼내 쓸 수 있답니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 아래처럼 \u003ccode\u003ecreatePost\u003c/code\u003e라는 서버 함수를 \u003ccode\u003eaction\u003c/code\u003e에 할당하면, 폼이 제출될 때 자동으로 \u003ccode\u003ecreatePost\u003c/code\u003e가 호출되면서 제출한 데이터가 \u003ccode\u003eFormData\u003c/code\u003e 형태로 전달돼요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { createPost } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@/app/actions'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eForm\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eform\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eaction\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{createPost}\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003einput\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"text\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"title\"\u003c/span\u003e /\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003einput\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"text\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e /\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"submit\"\u003c/span\u003e\u003e\u003c/span\u003eCreate\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eform\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e서버 함수는 이렇게 작성할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e'use server'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreatePost\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eformData: FormData\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e title = formData.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'title'\u003c/span\u003e)\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e content = formData.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'content'\u003c/span\u003e)\n\n  \u003cspan class=\"hljs-comment\"\u003e// 여기서 DB에 저장하거나, 캐시를 재검증하는 작업을 할 수 있어요.\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e조금 더 알아두면 좋은 팁!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eFormData.get()\u003c/code\u003e 메서드는 반환값이 \u003ccode\u003eFormDataEntryValue | null\u003c/code\u003e이기 때문에, 실제 값이 문자열인지 확인하거나 기본값을 설정하는 게 좋습니다.\u003c/li\u003e\n\u003cli\u003e서버 함수 내에서는 서버 전용 코드(ex. 데이터베이스 쿼리, 파일 시스템 접근)를 자유롭게 사용할 수 있어요.\u003c/li\u003e\n\u003cli\u003e클라이언트에서 별도의 API 호출 없이도 서버로 데이터를 보낼 수 있어서 코드가 더 깔끔해지고 유지보수가 쉬워집니다.\u003c/li\u003e\n\u003cli\u003e물론, 복잡한 폼 유효성 검사나 사용자가 바로 피드백을 받아야 하는 경우엔 클라이언트 측에서 미리 체크하는 걸 추천합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 방식은 특히 Next.js 같은 React 기반 프레임워크에서 유용하게 쓰이는데요, 서버 함수와 폼을 연동하는 새로운 흐름을 경험해보고 싶다면 한 번 시도해보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cblockquote\u003e\n\u003cp\u003e참고할 점: action prop에 전달될 때 Server Functions는 Server Actions라고도 불러요.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3\u003e이벤트 핸들러(Event Handlers)\u003c/h3\u003e\n\u003cp\u003e클라이언트 컴포넌트에서 서버 기능(Server Function)을 호출할 때는 onClick 같은 이벤트 핸들러를 활용할 수 있어요. 예를 들어, 좋아요 버튼을 만들고 클릭할 때마다 서버에 좋아요 수를 업데이트하는 기능을 구현해볼게요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-string\"\u003e'use client'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { incrementLike } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./actions'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useState } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eLikeButton\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ initialLikes }: { initialLikes: number }\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [likes, setLikes] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(initialLikes)\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003eTotal Likes: {likes}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{async\u003c/span\u003e () =\u003e\u003c/span\u003e {\n          // 서버에 좋아요 증가 요청을 보내고, 업데이트 된 좋아요 수를 받아서 상태를 갱신해요\n          const updatedLikes = await incrementLike()\n          setLikes(updatedLikes)\n        }}\n      \u003e\n        Like\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 중요한 점은, 클라이언트 컴포넌트 내부에서 직접 서버 사이드 코드를 호출할 수 없기 때문에, \u003ccode\u003eincrementLike\u003c/code\u003e 같은 서버 기능을 \u003ccode\u003eactions\u003c/code\u003e라는 별도의 파일에서 정의해두고 import해서 사용한다는 거예요. 그리고 비동기 처리를 위해 \u003ccode\u003easync/await\u003c/code\u003e를 활용한 점도 기억해두면 좋아요.\u003c/p\u003e\n\u003cp\u003e또한, 이렇게 서버 함수 호출 시 상태를 업데이트하는 패턴은 사용자 인터랙션에 실시간 피드백을 주는 데 아주 유용합니다. 만약 서버 함수 호출 중에 로딩 상태 표시가 필요하다면, \u003ccode\u003euseState\u003c/code\u003e로 로딩 상태를 관리해서 버튼을 비활성화하거나 스피너를 보여주는 것도 좋은 UX를 위한 팁이에요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e예시\u003c/h2\u003e\n\u003ch3\u003e대기 상태 표시하기\u003c/h3\u003e\n\u003cp\u003e서버 함수를 실행하는 동안, React의 \u003ccode\u003euseActionState\u003c/code\u003e 훅을 사용해서 로딩 인디케이터를 보여줄 수 있어요. 이 훅은 \u003ccode\u003epending\u003c/code\u003e이라는 불리언 값을 반환하는데, 이 값이 \u003ccode\u003etrue\u003c/code\u003e일 때는 작업이 진행 중임을 뜻하죠.\u003c/p\u003e\n\u003cp\u003e예를 들어, 게시글 생성 버튼을 눌렀을 때 로딩 스피너를 보여주는 컴포넌트 코드는 아래와 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e'use client'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useActionState } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { createPost } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@/app/actions'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eLoadingSpinner\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@/app/ui/loading-spinner'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eButton\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [state, action, pending] = \u003cspan class=\"hljs-title function_\"\u003euseActionState\u003c/span\u003e(createPost, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e)\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{async\u003c/span\u003e () =\u003e\u003c/span\u003e action()}\u003e\n      {pending ? \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eLoadingSpinner\u003c/span\u003e /\u003e\u003c/span\u003e : 'Create Post'}\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 중요한 점은 \u003ccode\u003epending\u003c/code\u003e 값 덕분에 사용자에게 작업이 진행 중이라는 피드백을 줄 수 있다는 거예요. 보통 서버와의 통신이 느릴 때는 이렇게 대기 상태를 표시해주는 게 UX 측면에서 정말 중요하답니다.\u003c/p\u003e\n\u003cp\u003e또 한 가지 팁을 드리자면, 이 훅은 작업이 끝난 후 결과값이나 에러 상태도 함께 관리할 수 있어서, 로딩뿐만 아니라 성공, 실패 상태에 따른 UI 업데이트도 함께 처리할 수 있어요. 필요에 따라 \u003ccode\u003estate\u003c/code\u003e를 활용해보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003e캐시 재검증하기\u003c/h3\u003e\n\u003cp\u003e데이터를 업데이트한 뒤, Next.js 캐시를 재검증(revalidate)해서 최신 데이터를 보여주고 싶을 때가 있죠? 그럴 땐 Server Function 내부에서 \u003ccode\u003erevalidatePath\u003c/code\u003e나 \u003ccode\u003erevalidateTag\u003c/code\u003e 함수를 사용하면 간편하게 해결할 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { revalidatePath } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/cache'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreatePost\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eformData: FormData\u003c/span\u003e) {\n  \u003cspan class=\"hljs-string\"\u003e'use server'\u003c/span\u003e\n  \n  \u003cspan class=\"hljs-comment\"\u003e// 데이터 업데이트 작업 수행\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n  \n  \u003cspan class=\"hljs-comment\"\u003e// 특정 경로에 대한 캐시를 재검증해서 최신 데이터 반영\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003erevalidatePath\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/posts'\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 예제처럼, 글을 새로 만들거나 수정한 뒤 \u003ccode\u003e/posts\u003c/code\u003e 경로의 캐시를 재검증하면 사용자에게 항상 최신 게시물 목록을 보여줄 수 있답니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e추가 팁!\u003cbr\u003e\n비슷하게 \u003ccode\u003erevalidateTag\u003c/code\u003e를 사용하면 태그 단위로 캐시를 재검증할 수도 있는데, 이 방법은 특정 데이터 그룹을 관리할 때 유용해요. 상황에 맞게 선택해서 사용해보세요.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3\u003e리다이렉트하기\u003c/h3\u003e\n\u003cp\u003e서버 함수에서 작업을 마친 후 사용자를 다른 페이지로 이동시키고 싶을 때는 어떻게 할까요? Next.js에서는 \u003ccode\u003eredirect\u003c/code\u003e 함수를 활용하면 쉽게 처리할 수 있답니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 글 작성 후 게시물 목록 페이지로 이동시키고 싶을 때:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { redirect } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/navigation'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreatePost\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eformData: FormData\u003c/span\u003e) {\n  \u003cspan class=\"hljs-string\"\u003e'use server'\u003c/span\u003e\n  \n  \u003cspan class=\"hljs-comment\"\u003e// 데이터 생성 로직\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n  \n  \u003cspan class=\"hljs-comment\"\u003e// 작업 후 /posts 페이지로 리다이렉트\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003eredirect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/posts'\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eredirect\u003c/code\u003e 함수를 호출하면, 클라이언트가 자동으로 지정한 경로로 이동하게 됩니다. 이 방법 덕분에 별도의 클라이언트 사이드 코드 없이도 깔끔한 흐름 제어가 가능해요.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e이처럼 Next.js의 Server Function 내에서 캐시 재검증과 리다이렉트를 함께 활용하면, 데이터 일관성을 유지하면서 사용자 경험도 한층 좋아지니 꼭 알아두세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e업데이트 작업을 수행한 후에 사용자를 다른 페이지로 이동시키고 싶을 때가 있죠? 그럴 때는 Next.js의 Server Function 안에서 \u003ccode\u003eredirect\u003c/code\u003e 함수를 사용할 수 있어요.\u003c/p\u003e\n\u003cp\u003e아래 예시 코드를 한 번 볼게요!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e'use server'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { redirect } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/navigation'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreatePost\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eformData: FormData\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 데이터 업데이트 작업 수행\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n  \n  \u003cspan class=\"hljs-comment\"\u003e// 업데이트 후 /posts 페이지로 리디렉션\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003eredirect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/posts'\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 포인트는, \u003ccode\u003eredirect\u003c/code\u003e가 호출되면 그 즉시 클라이언트에게 지정한 URL로 이동하라고 지시한다는 점이에요. 그래서 서버 함수 내에서 업데이트가 끝난 뒤에 자연스럽게 다른 페이지로 사용자를 안내할 수 있죠.\u003c/p\u003e\n\u003cp\u003e또 한 가지 팁! \u003ccode\u003eredirect\u003c/code\u003e를 사용할 때, 이 함수는 호출과 동시에 훅을 멈추고 이동을 처리하기 때문에 그 이후 코드는 실행되지 않는다는 점 기억해주세요. 만약 안전하게 특정 조건에서만 리디렉션을 하고 싶다면, 조건문 안에 넣어서 사용하면 돼요.\u003c/p\u003e\n\u003cp\u003e요약하자면, Next.js 13 이상의 서버 함수에서 업데이트 후 바로 페이지 전환을 원할 땐 \u003ccode\u003eredirect\u003c/code\u003e를 활용해보세요. 페이지 새로고침 없이 부드럽게 이동할 수 있어서 사용자 경험도 좋아진답니다!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2025-04-22-Howtoupdatedata"},"buildId":"X4OrKfmLtU3-3BijwfHe6","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>