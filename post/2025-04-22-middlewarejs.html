<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Next.js 15에서 Middleware.js로 서버 데이터 처리하는 방법 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-middlewarejs" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Next.js 15에서 Middleware.js로 서버 데이터 처리하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:title" content="Next.js 15에서 Middleware.js로 서버 데이터 처리하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-middlewarejs" data-gatsby-head="true"/><meta name="twitter:title" content="Next.js 15에서 Middleware.js로 서버 데이터 처리하는 방법 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2025-04-22 02:41" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-8ded8b979ba73586.js" defer=""></script><script src="/TIL/_next/static/o6AmBAY_j9v9JmbaRA39X/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/o6AmBAY_j9v9JmbaRA39X/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Next.js 15에서 Middleware.js로 서버 데이터 처리하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Next.js 15에서 Middleware.js로 서버 데이터 처리하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Apr 22, 2025</span><span class="posts_reading_time__f7YPP">12<!-- --> min read</span></span></div></div></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>middleware.js란?</h1>
<p>middleware.js(또는 middleware.ts)는 서버에서 요청이 완료되기 전에 중간에 끼어들어 특정 코드를 실행할 수 있도록 도와주는 파일이에요. 즉, 클라이언트가 서버에 요청을 보내면, 해당 요청을 처리하기 전에 이 미들웨어가 먼저 동작하게 되죠.</p>
<p>이걸 쓰면 어떻게 좋냐고요? 예를 들어, 들어오는 요청에 따라 응답을 바꾸거나 리다이렉트 시키거나, 요청이나 응답 헤더를 수정하는 일이 가능해요. 심지어는 바로 응답을 보내버릴 수도 있답니다!</p>
<p>미들웨어는 라우트가 렌더링되기 전에 작동하기 때문에, 인증(auth) 처리, 로깅(logging), 그리고 복잡한 리다이렉트 같은 서버 사이드 로직을 구현할 때 아주 유용하게 쓰여요.</p>
<p>보통 프로젝트 루트에 <code>middleware.ts</code> 또는 <code>middleware.js</code> 파일을 만들어서 정의합니다. 이 위치는 <code>app</code>이나 <code>pages</code> 폴더와 같은 수준이거나, <code>src</code> 폴더 안일 수도 있어요.</p>
<hr>
<h3>참고로!</h3>
<ul>
<li>미들웨어에서는 <strong>응답을 직접 반환</strong>하면 그 뒤에 라우트 렌더링은 안 되고, 그냥 그 응답이 바로 전송돼요.</li>
<li>요청을 <strong>리라이트(rewrite)</strong> 하면 내부 경로 변경이, <strong>리다이렉트(redirect)</strong> 하면 클라이언트에게 다른 주소로 이동하라고 지시하는 의미예요.</li>
<li>요청이나 응답 헤더를 자유롭게 조작할 수 있으니, 예를 들어 사용자 에이전트(user-agent)를 검사하거나 쿠키 작업도 가능합니다.</li>
</ul>
<p>이러면 서버가 좀 더 똑똑해지고, 클라이언트에 맞춤형 응답을 줄 수 있어요!</p>
<hr>
<p>필요하시다면 다음 글에서는 실제 코드 예제와 함께 미들웨어의 구체적인 사용법도 다뤄볼게요~!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Next.js에서 middleware 작성할 때 기본적으로 export하는 함수는 단 하나여야 한다는 점, 알고 계셨나요? 오늘은 그 부분을 중심으로 간단하게 설명해 보려고 해요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">NextResponse</span>, <span class="hljs-title class_">NextRequest</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/server'</span>
 
<span class="hljs-comment">// 이 함수는 요청을 가로채서 /about 경로 하위에 있는 모든 경로 요청을 /home 으로 리다이렉트 해줘요.</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">middleware</span>(<span class="hljs-params">request: NextRequest</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">redirect</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'/home'</span>, request.<span class="hljs-property">url</span>))
}
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> config = {
  <span class="hljs-attr">matcher</span>: <span class="hljs-string">'/about/:path*'</span>,
}
</code></pre>
<p>위 코드에서 핵심은 <code>middleware</code> 함수 하나만 export 하고 있다는 거예요. Next.js는 한 파일에서 여러 미들웨어 함수를 내보내는 것을 지원하지 않아요. 따라서 두 개 이상의 미들웨어가 필요한 경우엔 각각 따로 파일을 만들어야 하죠.</p>
<p>그리고, <code>config</code> 객체의 <code>matcher</code> 속성은 어떤 경로에 이 미들웨어를 적용할지 정해주는 역할을 해요. 여기서는 <code>/about/</code> 경로 이하 모든 경로를 지정했죠. 참고로 <code>:path*</code> 부분은 와일드카드 같은 역할을 해서 하위 경로 전체를 포괄할 수 있어요.</p>
<h3>정리하면</h3>





















<table><thead><tr><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>미들웨어 함수</td><td>꼭 하나만 export 해야 한다</td></tr><tr><td><code>matcher</code> 설정</td><td>어떤 URL 패턴에 대해 미들웨어를 실행할지 지정</td></tr><tr><td>리다이렉션 처리</td><td><code>NextResponse.redirect</code> 로 요청을 원하는 경로로 보낼 수 있다</td></tr></tbody></table>
<p>이런 룰들은 Next.js 내부에서 미들웨어 처리 방식을 단순화하고, 성능 최적화를 위한 부분이에요. 프로젝트 설계 시 이 점 꼭 기억해 두시면 쓸데없는 에러를 예방할 수 있답니다.</p>
<p>또한, 만약 복잡한 미들웨어 로직이 필요하다면 여러 파일로 분리하거나, 환경변수에 따라 미들웨어를 다르게 실행하도록 코드를 짜는 것도 좋은 전략이에요.</p>
<p>다음에는 미들웨어에서 자주 쓰이는 다른 기능들도 한번 같이 살펴봐요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-comment">// 기본 export 예제</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">middleware</span>(<span class="hljs-params">request</span>) {
  <span class="hljs-comment">// 미들웨어 로직 작성</span>
}
</code></pre>
<h3>config 객체 (선택 사항)</h3>
<p>미들웨어 함수와 함께 config 객체를 export할 수도 있어요. 이 객체 안에는 <code>matcher</code>가 들어가는데, 이 matcher를 통해 미들웨어가 적용될 경로를 지정할 수 있습니다.</p>
<h4>matcher</h4>
<p>matcher는 미들웨어가 실행될 URL 경로나 패턴을 지정하는 역할을 해요. 예를 들어, 특정 경로나 API 엔드포인트에만 미들웨어가 동작하도록 설정할 수 있죠.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> config = {
  <span class="hljs-attr">matcher</span>: [<span class="hljs-string">'/about/:path*'</span>, <span class="hljs-string">'/dashboard/:path*'</span>],
};
</code></pre>
<p>위 예시는 <code>/about</code>과 <code>/dashboard</code>로 시작하는 모든 하위 경로에 미들웨어가 적용된다는 뜻이에요.</p>
<p>참고로, matcher에 지정할 수 있는 패턴은 Next.js의 라우팅 규칙과 비슷해서 익숙하시다면 편하게 쓸 수 있을 거예요.</p>
<p>만약 더 세밀한 조건이 필요하다면, 직접 미들웨어 안에서 request 객체를 검사하는 방법도 있어요. 예를 들어, 쿠키나 헤더에 따라 동작을 조절할 수도 있죠.</p>
<p>미들웨어 설정 시 알아두면 좋은 팁!</p>
<ul>
<li><code>matcher</code>를 구체적으로 지정하면 불필요한 미들웨어 실행을 줄여서 퍼포먼스를 개선할 수 있어요.</li>
<li>여러 경로를 배열로 전달할 수 있으니 한꺼번에 관리하기 편합니다.</li>
<li>잘못된 matcher 패턴은 미들웨어가 의도치 않게 작동하지 않을 수 있으니, 꼭 테스트해보세요!</li>
</ul>
<p>다음에는 미들웨어 내부에서 실제 request 요청을 다루는 법과 응답 처리 방법에 대해 이야기해볼게요. 그럼 같이 공부해봐요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><code>matcher</code> 옵션은 Middleware가 특정 경로에서만 실행되도록 설정할 때 사용해요. 쉽게 말해, 이 옵션을 통해 ‘어떤 경로에 Middleware를 적용할지’를 정할 수 있다는 뜻이죠.</p>
<p>그 방법은 크게 세 가지예요:</p>
<ul>
<li>
<p><strong>단일 경로 지정:</strong><br>
그냥 문자열로 경로를 적으면 돼요. 예를 들어, <code>/about</code>이면 <code>/about</code> 경로에서만 Middleware가 실행됩니다.</p>
</li>
<li>
<p><strong>여러 경로 지정:</strong><br>
배열을 사용해서 여러 경로를 한 번에 지정할 수 있어요.<br>
예시) <code>matcher: ['/about', '/contact']</code> 이렇게 하면 <code>/about</code>과 <code>/contact</code> 두 경로 모두 적용됩니다.</p>
</li>
<li>
<p><strong>정규 표현식(Regex) 사용:</strong><br>
더 정교한 경로 필터링이 필요할 땐 정규식도 사용할 수 있어요.<br>
예를 들면,<br>
js
matcher: ['/((?!api|_next/static|_next/image|.<em>\.png$).</em>)']</p>
<p>이렇게 하면 <code>api</code>, <code>_next/static</code>, <code>_next/image</code> 폴더나 <code>.png</code> 파일 경로는 제외하고 나머지 경로에만 Middleware를 적용해요.<br>
정규 표현식의 부정형 전방탐색(negative lookahead)을 활용해 특정 경로나 파일 형식을 꼼꼼히 걸러낼 수 있답니다.</p>
</li>
</ul>
<p>그리고 <code>matcher</code> 옵션에는 배열 안에 객체 형식으로 경로를 더 세분화해서 지정할 수도 있는데, 이 객체에는 다음과 같은 키들이 있어요:</p>

























<table><thead><tr><th>키 이름</th><th>설명</th></tr></thead><tbody><tr><td><code>src</code></td><td>적용할 경로를 정의 (문자열 또는 정규식)</td></tr><tr><td><code>methods</code></td><td>적용할 HTTP 메소드 배열 (예: <code>['GET', 'POST']</code>)</td></tr><tr><td><code>has</code></td><td>요청에 특정 헤더, 쿠키, 쿼리 파라미터가 있는지 조건 지정</td></tr><tr><td><code>missing</code></td><td>요청에 특정 헤더, 쿠키, 쿼리 파라미터가 없는지 조건 지정</td></tr></tbody></table>
<p>이런 식으로 복잡한 조건을 걸 수 있어서, 예를 들어 <code>POST</code> 요청이고 특정 쿠키가 있을 때만 Middleware를 적용하는 것도 가능하답니다.</p>
<hr>
<h3>추가 팁</h3>
<p>Router 미들웨어를 효과적으로 사용하려면, 불필요하게 모든 경로에 Middleware가 실행되지 않도록 <code>matcher</code>를 잘 설정하는 게 좋아요. 안 그러면 성능에 영향이 있을 수 있거든요! 또한, Next.js에서 자주 쓰는 <code>_next/static</code> 같은 내부 리소스 경로들은 보통 Middleware 대상에서 제외하는 게 일반적이에요.</p>
<p>이 정도만 잘 활용해도 경로별로 딱 맞는 Middleware 적용이 훨씬 수월해질 거예요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>요즘 웹 개발할 때, 특정 요청 경로에 맞춰서 로직을 처리하거나 미들웨어를 적용하는 경우가 많죠? 이번에 소개할 내용은 이런 요청 경로 매칭을 세밀하게 조정할 수 있는 설정 방법이에요.</p>
<hr>
<h3>주요 옵션 설명</h3>





























<table><thead><tr><th>옵션명</th><th>설명</th></tr></thead><tbody><tr><td>source</td><td>요청 경로를 매칭하는 경로 또는 패턴이에요. 문자열로 직접 지정하거나 복잡한 패턴을 지정할 수 있어요.</td></tr><tr><td>regexp</td><td>정규표현식으로 source를 세밀하게 조절할 수 있어요. 포함하거나 제외할 경로를 더욱 정확하게 조절할 때 쓸 수 있죠.</td></tr><tr><td>locale</td><td>불리언 값인데, false로 하면 로케일(언어 설정 등)을 매칭에서 무시해요. 기본값은 true로 다루는 경우가 많습니다.</td></tr><tr><td>has</td><td>요청 헤더, 쿼리 파라미터, 쿠키 등의 특정 요소가 있을 때 조건을 걸고 싶을 때 사용해요.</td></tr><tr><td>missing</td><td>반대로, 헤더나 쿠키 같은 특정 요소가 없을 때만 동작하도록 조건을 걸고 싶을 때 쓰면 좋아요.</td></tr></tbody></table>
<hr>
<h3>실제 예제</h3>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> config = {
  <span class="hljs-attr">matcher</span>: [
    {
      <span class="hljs-attr">source</span>: <span class="hljs-string">'/api/*'</span>,
      <span class="hljs-attr">regexp</span>: <span class="hljs-string">'^/api/(.*)'</span>,
      <span class="hljs-attr">locale</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">has</span>: [
        { <span class="hljs-attr">type</span>: <span class="hljs-string">'header'</span>, <span class="hljs-attr">key</span>: <span class="hljs-string">'Authorization'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'Bearer Token'</span> },
        { <span class="hljs-attr">type</span>: <span class="hljs-string">'query'</span>, <span class="hljs-attr">key</span>: <span class="hljs-string">'userId'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'123'</span> },
      ],
      <span class="hljs-attr">missing</span>: [{ <span class="hljs-attr">type</span>: <span class="hljs-string">'cookie'</span>, <span class="hljs-attr">key</span>: <span class="hljs-string">'session'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'active'</span> }],
    },
  ],
}
</code></pre>
<ul>
<li><code>/api/*</code> 경로에 대해 매칭합니다.</li>
<li><code>regexp</code>로 좀 더 정교하게 <code>/api/</code> 뒤에 어떤 값이 오든 매칭하도록 했어요.</li>
<li>로케일 기반 매칭은 무시(<code>locale: false</code>)하고요.</li>
<li>요청 헤더에 <code>Authorization</code>이 <code>'Bearer Token'</code> 이고, 쿼리 파라미터에 <code>userId=123</code> 이 있어야 합니다.</li>
<li>그리고 <code>session</code> 쿠키가 없을 때만 이 설정이 적용되는 거죠.</li>
</ul>
<hr>
<h3>참고로!</h3>
<ul>
<li><code>has</code>와 <code>missing</code> 조건은 다중으로 걸 수 있으니, 복합 조건 처리도 편리하게 구성할 수 있습니다.</li>
<li><code>regexp</code> 쓰면 경로를 한 층 더 정교하게 제어할 수 있어서, 간단한 경로나 특수 문자 포함 경로도 문제없이 처리 가능해요.</li>
<li><code>locale</code> 설정은 멀티랭귀지 사이트 만들 때 유용하고, 단일 언어 사이트는 보통 false로 두고 쓰기도 합니다.</li>
</ul>
<p>이렇게 매칭 설정을 잘 사용하면, Next.js나 비슷한 프레임워크에서 요청 경로 조건에 맞는 미들웨어나 특정 API 처리 로직을 깔끔하게 관리할 수 있답니다.</p>
<hr>
<p>다음 글에서는 이 설정을 실제 미들웨어에 어떻게 적용할 수 있는지, 그리고 성능 최적화 팁도 함께 다뤄볼게요! 궁금한 점 있으면 댓글로 남겨주세요~</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Middleware를 정의할 때 기본 내보내기 함수는 하나의 매개변수인 request를 받습니다. 이 request는 NextRequest의 인스턴스로, 들어온 HTTP 요청을 나타내죠.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> type { <span class="hljs-title class_">NextRequest</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/server'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">middleware</span>(<span class="hljs-params">request: NextRequest</span>) {
  <span class="hljs-comment">// 여기에 Middleware 로직을 작성하세요</span>
}
</code></pre>
<blockquote>
<p>알아두면 좋은 점:
NextRequest는 Next.js Middleware에서 들어오는 HTTP 요청을 나타내는 타입이에요. 반면에 NextResponse는 HTTP 응답을 조작하고 돌려보낼 때 사용하는 클래스로 구분되어 있습니다.</p>
</blockquote>
<h2>NextResponse</h2>
<p>NextResponse는 Middleware 안에서 주로 클라이언트에게 반환할 응답을 조작할 때 사용합니다. 예를 들어, 요청을 리다이렉트하거나 쿠키를 설정하는 등의 작업을 할 수 있죠.</p>
<p>간단한 예시를 보면:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">NextResponse</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/server'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">middleware</span>(<span class="hljs-params">request</span>) {
  <span class="hljs-comment">// 특정 경로로 리다이렉트하기</span>
  <span class="hljs-keyword">if</span> (request.<span class="hljs-property">nextUrl</span>.<span class="hljs-property">pathname</span> === <span class="hljs-string">'/old-path'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">redirect</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'/new-path'</span>, request.<span class="hljs-property">url</span>))
  }
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">next</span>()
}
</code></pre>
<p>이렇게 요청된 경로가 <code>/old-path</code>라면 <code>/new-path</code>로 리다이렉트 시키고, 그렇지 않으면 다음 미들웨어나 라우터로 요청을 넘기게 됩니다.</p>
<p>또한 NextResponse를 이용해 쿠키를 설정할 수도 있어요. 예를 들어:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">NextResponse</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/server'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">middleware</span>(<span class="hljs-params">request</span>) {
  <span class="hljs-keyword">const</span> response = <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">next</span>()
  response.<span class="hljs-property">cookies</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">'my-cookie'</span>, <span class="hljs-string">'my-value'</span>, { <span class="hljs-attr">path</span>: <span class="hljs-string">'/'</span>, <span class="hljs-attr">maxAge</span>: <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> }) <span class="hljs-comment">// 1일간 유지되는 쿠키</span>
  <span class="hljs-keyword">return</span> response
}
</code></pre>
<p>위 예시에서는 응답에 'my-cookie'라는 이름의 쿠키를 추가하는 거죠.</p>
<p>Middleware에서 NextRequest와 NextResponse의 역할을 잘 구분해두면 효과적인 요청 처리 및 응답 제어가 가능하니 꼭 기억해두세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>미들웨어(Middleware)는 NextResponse 객체를 사용할 수 있는데, 이 객체는 Web Response API를 확장한 거예요. NextResponse 객체를 반환하면 쿠키를 직접 조작하거나, 헤더를 설정하고, 리다이렉트를 구현하거나, 경로를 다시 쓸 수 있어서 정말 유용하답니다.</p>
<blockquote>
<p>참고로 리다이렉트를 구현할 땐 NextResponse.redirect 대신 Response.redirect를 써도 된다는 점! 상황에 맞게 골라 쓰시면 돼요.</p>
</blockquote>
<h2>실행 환경(Runtime)</h2>
<p>미들웨어는 Edge 런타임에서만 동작해요. 그래서 Node.js 런타임에서는 사용할 수 없다는 점, 꼭 기억해주세요.</p>
<hr>
<h3>미들웨어에서 NextResponse를 쓰면 좋은 점</h3>
<ul>
<li>쿠키 설정/삭제가 편리해요.</li>
<li>헤더를 자유자재로 조작할 수 있어서 보안이나 캐싱 정책 등을 설정할 때 유리하죠.</li>
<li>경로 재작성(Rewrite) 기능으로 SEO 최적화나 사용자 맞춤 라우팅이 쉬워져요.</li>
</ul>
<p>Edge 런타임이라는 건, 쉽게 말해 요청이 사용자와 가까운 서버(Edge)에서 빠르게 처리된다는 뜻인데요. 그래서 미들웨어가 빠른 응답 속도에 도움을 줘서 좋은 사용자 경험을 만들 수 있답니다.</p>
<p>필요할 때 미들웨어와 NextResponse를 적절히 활용해보세요! 개발할 때 꽤 큰 힘이 되어줄 거예요.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>버전 히스토리 (Version History)</h2>





























<table><thead><tr><th>버전</th><th>변경 사항</th></tr></thead><tbody><tr><td><code>v13.1.0</code></td><td>고급 미들웨어 플래그(Advanced Middleware flags) 추가</td></tr><tr><td><code>v13.0.0</code></td><td>미들웨어가 요청 헤더, 응답 헤더를 수정할 수 있고, 응답도 직접 보낼 수 있게 개선</td></tr><tr><td><code>v12.2.0</code></td><td>미들웨어가 안정화됨. 자세한 업그레이드 가이드는 <a href="https://nextjs.org/docs/messages/middleware-upgrade-guide" rel="nofollow" target="_blank">여기</a> 참고</td></tr><tr><td><code>v12.0.9</code></td><td>Edge Runtime에서 절대 URL 강제 적용 (<a href="https://github.com/vercel/next.js/pull/33410" rel="nofollow" target="_blank">관련 PR</a>)</td></tr><tr><td><code>v12.0.0</code></td><td>미들웨어(Beta) 기능 추가</td></tr></tbody></table>
<hr>
<p><em>잠깐!</em></p>
<p>여기서 말하는 '미들웨어'는 Next.js에서 API 요청과 응답 사이에 원하는 로직을 끼워 넣을 수 있는 기능이에요. 예를 들어 로그인 검증, A/B 테스트, 사용자 맞춤 리디렉션 등을 처리할 때 아주 유용하답니다.</p>
<p>그리고 <code>v13.0.0</code>부터는 요청과 응답 헤더를 수정하거나 직접 응답을 보내는 등 훨씬 더 강력한 제어가 가능해져서, 미들웨어를 활용하는 범위가 정말 넓어졌어요.</p>
<p>버전이 올라가면서 미들웨어가 안정화되고 기능도 점점 확장되고 있으니, 현재 개발 중인 프로젝트에 맞춰 적절히 선택해서 쓰시면 좋겠네요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Next.js 15에서 Middleware.js로 서버 데이터 처리하는 방법","description":"","date":"2025-04-22 02:41","slug":"2025-04-22-middlewarejs","content":"\n\n# middleware.js란?\n\nmiddleware.js(또는 middleware.ts)는 서버에서 요청이 완료되기 전에 중간에 끼어들어 특정 코드를 실행할 수 있도록 도와주는 파일이에요. 즉, 클라이언트가 서버에 요청을 보내면, 해당 요청을 처리하기 전에 이 미들웨어가 먼저 동작하게 되죠.\n\n이걸 쓰면 어떻게 좋냐고요? 예를 들어, 들어오는 요청에 따라 응답을 바꾸거나 리다이렉트 시키거나, 요청이나 응답 헤더를 수정하는 일이 가능해요. 심지어는 바로 응답을 보내버릴 수도 있답니다!\n\n미들웨어는 라우트가 렌더링되기 전에 작동하기 때문에, 인증(auth) 처리, 로깅(logging), 그리고 복잡한 리다이렉트 같은 서버 사이드 로직을 구현할 때 아주 유용하게 쓰여요.\n\n보통 프로젝트 루트에 `middleware.ts` 또는 `middleware.js` 파일을 만들어서 정의합니다. 이 위치는 `app`이나 `pages` 폴더와 같은 수준이거나, `src` 폴더 안일 수도 있어요.\n\n---\n\n### 참고로!\n\n- 미들웨어에서는 **응답을 직접 반환**하면 그 뒤에 라우트 렌더링은 안 되고, 그냥 그 응답이 바로 전송돼요.\n- 요청을 **리라이트(rewrite)** 하면 내부 경로 변경이, **리다이렉트(redirect)** 하면 클라이언트에게 다른 주소로 이동하라고 지시하는 의미예요.\n- 요청이나 응답 헤더를 자유롭게 조작할 수 있으니, 예를 들어 사용자 에이전트(user-agent)를 검사하거나 쿠키 작업도 가능합니다.\n\n이러면 서버가 좀 더 똑똑해지고, 클라이언트에 맞춤형 응답을 줄 수 있어요!\n\n---\n\n필요하시다면 다음 글에서는 실제 코드 예제와 함께 미들웨어의 구체적인 사용법도 다뤄볼게요~!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 middleware 작성할 때 기본적으로 export하는 함수는 단 하나여야 한다는 점, 알고 계셨나요? 오늘은 그 부분을 중심으로 간단하게 설명해 보려고 해요.\n\n```js\nimport { NextResponse, NextRequest } from 'next/server'\n \n// 이 함수는 요청을 가로채서 /about 경로 하위에 있는 모든 경로 요청을 /home 으로 리다이렉트 해줘요.\nexport function middleware(request: NextRequest) {\n  return NextResponse.redirect(new URL('/home', request.url))\n}\n \nexport const config = {\n  matcher: '/about/:path*',\n}\n```\n\n위 코드에서 핵심은 `middleware` 함수 하나만 export 하고 있다는 거예요. Next.js는 한 파일에서 여러 미들웨어 함수를 내보내는 것을 지원하지 않아요. 따라서 두 개 이상의 미들웨어가 필요한 경우엔 각각 따로 파일을 만들어야 하죠.\n\n그리고, `config` 객체의 `matcher` 속성은 어떤 경로에 이 미들웨어를 적용할지 정해주는 역할을 해요. 여기서는 `/about/` 경로 이하 모든 경로를 지정했죠. 참고로 `:path*` 부분은 와일드카드 같은 역할을 해서 하위 경로 전체를 포괄할 수 있어요.\n\n### 정리하면\n\n| 항목                 | 설명                                                  |\n|--------------------|-----------------------------------------------------|\n| 미들웨어 함수          | 꼭 하나만 export 해야 한다                               |\n| `matcher` 설정        | 어떤 URL 패턴에 대해 미들웨어를 실행할지 지정               |\n| 리다이렉션 처리         | `NextResponse.redirect` 로 요청을 원하는 경로로 보낼 수 있다  |\n\n이런 룰들은 Next.js 내부에서 미들웨어 처리 방식을 단순화하고, 성능 최적화를 위한 부분이에요. 프로젝트 설계 시 이 점 꼭 기억해 두시면 쓸데없는 에러를 예방할 수 있답니다.\n\n또한, 만약 복잡한 미들웨어 로직이 필요하다면 여러 파일로 분리하거나, 환경변수에 따라 미들웨어를 다르게 실행하도록 코드를 짜는 것도 좋은 전략이에요. \n\n다음에는 미들웨어에서 자주 쓰이는 다른 기능들도 한번 같이 살펴봐요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n// 기본 export 예제\nexport default function middleware(request) {\n  // 미들웨어 로직 작성\n}\n```\n\n### config 객체 (선택 사항)\n\n미들웨어 함수와 함께 config 객체를 export할 수도 있어요. 이 객체 안에는 `matcher`가 들어가는데, 이 matcher를 통해 미들웨어가 적용될 경로를 지정할 수 있습니다.\n\n#### matcher\n\nmatcher는 미들웨어가 실행될 URL 경로나 패턴을 지정하는 역할을 해요. 예를 들어, 특정 경로나 API 엔드포인트에만 미들웨어가 동작하도록 설정할 수 있죠.\n\n```js\nexport const config = {\n  matcher: ['/about/:path*', '/dashboard/:path*'],\n};\n```\n\n위 예시는 `/about`과 `/dashboard`로 시작하는 모든 하위 경로에 미들웨어가 적용된다는 뜻이에요.\n\n참고로, matcher에 지정할 수 있는 패턴은 Next.js의 라우팅 규칙과 비슷해서 익숙하시다면 편하게 쓸 수 있을 거예요.\n\n만약 더 세밀한 조건이 필요하다면, 직접 미들웨어 안에서 request 객체를 검사하는 방법도 있어요. 예를 들어, 쿠키나 헤더에 따라 동작을 조절할 수도 있죠.\n\n미들웨어 설정 시 알아두면 좋은 팁!\n- `matcher`를 구체적으로 지정하면 불필요한 미들웨어 실행을 줄여서 퍼포먼스를 개선할 수 있어요.\n- 여러 경로를 배열로 전달할 수 있으니 한꺼번에 관리하기 편합니다.\n- 잘못된 matcher 패턴은 미들웨어가 의도치 않게 작동하지 않을 수 있으니, 꼭 테스트해보세요!\n\n다음에는 미들웨어 내부에서 실제 request 요청을 다루는 법과 응답 처리 방법에 대해 이야기해볼게요. 그럼 같이 공부해봐요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n`matcher` 옵션은 Middleware가 특정 경로에서만 실행되도록 설정할 때 사용해요. 쉽게 말해, 이 옵션을 통해 ‘어떤 경로에 Middleware를 적용할지’를 정할 수 있다는 뜻이죠.\n\n그 방법은 크게 세 가지예요:\n\n- **단일 경로 지정:**  \n  그냥 문자열로 경로를 적으면 돼요. 예를 들어, `/about`이면 `/about` 경로에서만 Middleware가 실행됩니다.\n\n- **여러 경로 지정:**  \n  배열을 사용해서 여러 경로를 한 번에 지정할 수 있어요.  \n  예시) `matcher: ['/about', '/contact']` 이렇게 하면 `/about`과 `/contact` 두 경로 모두 적용됩니다.\n\n- **정규 표현식(Regex) 사용:**  \n  더 정교한 경로 필터링이 필요할 땐 정규식도 사용할 수 있어요.  \n  예를 들면,  \n  js\n  matcher: ['/((?!api|_next/static|_next/image|.*\\\\.png$).*)']\n  \n  이렇게 하면 `api`, `_next/static`, `_next/image` 폴더나 `.png` 파일 경로는 제외하고 나머지 경로에만 Middleware를 적용해요.  \n  정규 표현식의 부정형 전방탐색(negative lookahead)을 활용해 특정 경로나 파일 형식을 꼼꼼히 걸러낼 수 있답니다.\n\n그리고 `matcher` 옵션에는 배열 안에 객체 형식으로 경로를 더 세분화해서 지정할 수도 있는데, 이 객체에는 다음과 같은 키들이 있어요:\n\n| 키 이름      | 설명                                               |\n|--------------|----------------------------------------------------|\n| `src`        | 적용할 경로를 정의 (문자열 또는 정규식)             |\n| `methods`    | 적용할 HTTP 메소드 배열 (예: `['GET', 'POST']`)     |\n| `has`        | 요청에 특정 헤더, 쿠키, 쿼리 파라미터가 있는지 조건 지정 |\n| `missing`    | 요청에 특정 헤더, 쿠키, 쿼리 파라미터가 없는지 조건 지정 |\n\n이런 식으로 복잡한 조건을 걸 수 있어서, 예를 들어 `POST` 요청이고 특정 쿠키가 있을 때만 Middleware를 적용하는 것도 가능하답니다.\n\n---\n\n### 추가 팁  \nRouter 미들웨어를 효과적으로 사용하려면, 불필요하게 모든 경로에 Middleware가 실행되지 않도록 `matcher`를 잘 설정하는 게 좋아요. 안 그러면 성능에 영향이 있을 수 있거든요! 또한, Next.js에서 자주 쓰는 `_next/static` 같은 내부 리소스 경로들은 보통 Middleware 대상에서 제외하는 게 일반적이에요.\n\n이 정도만 잘 활용해도 경로별로 딱 맞는 Middleware 적용이 훨씬 수월해질 거예요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요즘 웹 개발할 때, 특정 요청 경로에 맞춰서 로직을 처리하거나 미들웨어를 적용하는 경우가 많죠? 이번에 소개할 내용은 이런 요청 경로 매칭을 세밀하게 조정할 수 있는 설정 방법이에요.\n\n---\n\n### 주요 옵션 설명\n\n| 옵션명     | 설명                                                                                           |\n|------------|------------------------------------------------------------------------------------------------|\n| source     | 요청 경로를 매칭하는 경로 또는 패턴이에요. 문자열로 직접 지정하거나 복잡한 패턴을 지정할 수 있어요.             |\n| regexp     | 정규표현식으로 source를 세밀하게 조절할 수 있어요. 포함하거나 제외할 경로를 더욱 정확하게 조절할 때 쓸 수 있죠. |\n| locale     | 불리언 값인데, false로 하면 로케일(언어 설정 등)을 매칭에서 무시해요. 기본값은 true로 다루는 경우가 많습니다.  |\n| has        | 요청 헤더, 쿼리 파라미터, 쿠키 등의 특정 요소가 있을 때 조건을 걸고 싶을 때 사용해요.                            |\n| missing    | 반대로, 헤더나 쿠키 같은 특정 요소가 없을 때만 동작하도록 조건을 걸고 싶을 때 쓰면 좋아요.                         |\n\n---\n\n### 실제 예제\n\n```js\nexport const config = {\n  matcher: [\n    {\n      source: '/api/*',\n      regexp: '^/api/(.*)',\n      locale: false,\n      has: [\n        { type: 'header', key: 'Authorization', value: 'Bearer Token' },\n        { type: 'query', key: 'userId', value: '123' },\n      ],\n      missing: [{ type: 'cookie', key: 'session', value: 'active' }],\n    },\n  ],\n}\n```\n\n- `/api/*` 경로에 대해 매칭합니다.\n- `regexp`로 좀 더 정교하게 `/api/` 뒤에 어떤 값이 오든 매칭하도록 했어요.\n- 로케일 기반 매칭은 무시(`locale: false`)하고요.\n- 요청 헤더에 `Authorization`이 `'Bearer Token'` 이고, 쿼리 파라미터에 `userId=123` 이 있어야 합니다.\n- 그리고 `session` 쿠키가 없을 때만 이 설정이 적용되는 거죠.\n\n---\n\n### 참고로!\n\n- `has`와 `missing` 조건은 다중으로 걸 수 있으니, 복합 조건 처리도 편리하게 구성할 수 있습니다.\n- `regexp` 쓰면 경로를 한 층 더 정교하게 제어할 수 있어서, 간단한 경로나 특수 문자 포함 경로도 문제없이 처리 가능해요.\n- `locale` 설정은 멀티랭귀지 사이트 만들 때 유용하고, 단일 언어 사이트는 보통 false로 두고 쓰기도 합니다.\n\n이렇게 매칭 설정을 잘 사용하면, Next.js나 비슷한 프레임워크에서 요청 경로 조건에 맞는 미들웨어나 특정 API 처리 로직을 깔끔하게 관리할 수 있답니다.\n\n---\n\n다음 글에서는 이 설정을 실제 미들웨어에 어떻게 적용할 수 있는지, 그리고 성능 최적화 팁도 함께 다뤄볼게요! 궁금한 점 있으면 댓글로 남겨주세요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nMiddleware를 정의할 때 기본 내보내기 함수는 하나의 매개변수인 request를 받습니다. 이 request는 NextRequest의 인스턴스로, 들어온 HTTP 요청을 나타내죠.\n\n```js\nimport type { NextRequest } from 'next/server'\n\nexport function middleware(request: NextRequest) {\n  // 여기에 Middleware 로직을 작성하세요\n}\n```\n\n\u003e 알아두면 좋은 점:\nNextRequest는 Next.js Middleware에서 들어오는 HTTP 요청을 나타내는 타입이에요. 반면에 NextResponse는 HTTP 응답을 조작하고 돌려보낼 때 사용하는 클래스로 구분되어 있습니다.\n\n## NextResponse\n\nNextResponse는 Middleware 안에서 주로 클라이언트에게 반환할 응답을 조작할 때 사용합니다. 예를 들어, 요청을 리다이렉트하거나 쿠키를 설정하는 등의 작업을 할 수 있죠.\n\n간단한 예시를 보면:\n\n```js\nimport { NextResponse } from 'next/server'\n\nexport function middleware(request) {\n  // 특정 경로로 리다이렉트하기\n  if (request.nextUrl.pathname === '/old-path') {\n    return NextResponse.redirect(new URL('/new-path', request.url))\n  }\n  return NextResponse.next()\n}\n```\n\n이렇게 요청된 경로가 `/old-path`라면 `/new-path`로 리다이렉트 시키고, 그렇지 않으면 다음 미들웨어나 라우터로 요청을 넘기게 됩니다.\n\n또한 NextResponse를 이용해 쿠키를 설정할 수도 있어요. 예를 들어:\n\n```js\nimport { NextResponse } from 'next/server'\n\nexport function middleware(request) {\n  const response = NextResponse.next()\n  response.cookies.set('my-cookie', 'my-value', { path: '/', maxAge: 60 * 60 * 24 }) // 1일간 유지되는 쿠키\n  return response\n}\n```\n\n위 예시에서는 응답에 'my-cookie'라는 이름의 쿠키를 추가하는 거죠.\n\nMiddleware에서 NextRequest와 NextResponse의 역할을 잘 구분해두면 효과적인 요청 처리 및 응답 제어가 가능하니 꼭 기억해두세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n미들웨어(Middleware)는 NextResponse 객체를 사용할 수 있는데, 이 객체는 Web Response API를 확장한 거예요. NextResponse 객체를 반환하면 쿠키를 직접 조작하거나, 헤더를 설정하고, 리다이렉트를 구현하거나, 경로를 다시 쓸 수 있어서 정말 유용하답니다.\n\n\u003e 참고로 리다이렉트를 구현할 땐 NextResponse.redirect 대신 Response.redirect를 써도 된다는 점! 상황에 맞게 골라 쓰시면 돼요.\n\n## 실행 환경(Runtime)\n\n미들웨어는 Edge 런타임에서만 동작해요. 그래서 Node.js 런타임에서는 사용할 수 없다는 점, 꼭 기억해주세요.\n\n---\n\n### 미들웨어에서 NextResponse를 쓰면 좋은 점\n\n- 쿠키 설정/삭제가 편리해요.\n- 헤더를 자유자재로 조작할 수 있어서 보안이나 캐싱 정책 등을 설정할 때 유리하죠.\n- 경로 재작성(Rewrite) 기능으로 SEO 최적화나 사용자 맞춤 라우팅이 쉬워져요.\n\nEdge 런타임이라는 건, 쉽게 말해 요청이 사용자와 가까운 서버(Edge)에서 빠르게 처리된다는 뜻인데요. 그래서 미들웨어가 빠른 응답 속도에 도움을 줘서 좋은 사용자 경험을 만들 수 있답니다.\n\n필요할 때 미들웨어와 NextResponse를 적절히 활용해보세요! 개발할 때 꽤 큰 힘이 되어줄 거예요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 버전 히스토리 (Version History)\n\n| 버전       | 변경 사항                                                                                         |\n|------------|--------------------------------------------------------------------------------------------------|\n| `v13.1.0`  | 고급 미들웨어 플래그(Advanced Middleware flags) 추가                                           |\n| `v13.0.0`  | 미들웨어가 요청 헤더, 응답 헤더를 수정할 수 있고, 응답도 직접 보낼 수 있게 개선                  |\n| `v12.2.0`  | 미들웨어가 안정화됨. 자세한 업그레이드 가이드는 [여기](https://nextjs.org/docs/messages/middleware-upgrade-guide) 참고 |\n| `v12.0.9`  | Edge Runtime에서 절대 URL 강제 적용 ([관련 PR](https://github.com/vercel/next.js/pull/33410))                  |\n| `v12.0.0`  | 미들웨어(Beta) 기능 추가                                                                         |\n\n---\n\n*잠깐!*\n\n여기서 말하는 '미들웨어'는 Next.js에서 API 요청과 응답 사이에 원하는 로직을 끼워 넣을 수 있는 기능이에요. 예를 들어 로그인 검증, A/B 테스트, 사용자 맞춤 리디렉션 등을 처리할 때 아주 유용하답니다.\n\n그리고 `v13.0.0`부터는 요청과 응답 헤더를 수정하거나 직접 응답을 보내는 등 훨씬 더 강력한 제어가 가능해져서, 미들웨어를 활용하는 범위가 정말 넓어졌어요.\n\n버전이 올라가면서 미들웨어가 안정화되고 기능도 점점 확장되고 있으니, 현재 개발 중인 프로젝트에 맞춰 적절히 선택해서 쓰시면 좋겠네요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":12},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003emiddleware.js란?\u003c/h1\u003e\n\u003cp\u003emiddleware.js(또는 middleware.ts)는 서버에서 요청이 완료되기 전에 중간에 끼어들어 특정 코드를 실행할 수 있도록 도와주는 파일이에요. 즉, 클라이언트가 서버에 요청을 보내면, 해당 요청을 처리하기 전에 이 미들웨어가 먼저 동작하게 되죠.\u003c/p\u003e\n\u003cp\u003e이걸 쓰면 어떻게 좋냐고요? 예를 들어, 들어오는 요청에 따라 응답을 바꾸거나 리다이렉트 시키거나, 요청이나 응답 헤더를 수정하는 일이 가능해요. 심지어는 바로 응답을 보내버릴 수도 있답니다!\u003c/p\u003e\n\u003cp\u003e미들웨어는 라우트가 렌더링되기 전에 작동하기 때문에, 인증(auth) 처리, 로깅(logging), 그리고 복잡한 리다이렉트 같은 서버 사이드 로직을 구현할 때 아주 유용하게 쓰여요.\u003c/p\u003e\n\u003cp\u003e보통 프로젝트 루트에 \u003ccode\u003emiddleware.ts\u003c/code\u003e 또는 \u003ccode\u003emiddleware.js\u003c/code\u003e 파일을 만들어서 정의합니다. 이 위치는 \u003ccode\u003eapp\u003c/code\u003e이나 \u003ccode\u003epages\u003c/code\u003e 폴더와 같은 수준이거나, \u003ccode\u003esrc\u003c/code\u003e 폴더 안일 수도 있어요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e참고로!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e미들웨어에서는 \u003cstrong\u003e응답을 직접 반환\u003c/strong\u003e하면 그 뒤에 라우트 렌더링은 안 되고, 그냥 그 응답이 바로 전송돼요.\u003c/li\u003e\n\u003cli\u003e요청을 \u003cstrong\u003e리라이트(rewrite)\u003c/strong\u003e 하면 내부 경로 변경이, \u003cstrong\u003e리다이렉트(redirect)\u003c/strong\u003e 하면 클라이언트에게 다른 주소로 이동하라고 지시하는 의미예요.\u003c/li\u003e\n\u003cli\u003e요청이나 응답 헤더를 자유롭게 조작할 수 있으니, 예를 들어 사용자 에이전트(user-agent)를 검사하거나 쿠키 작업도 가능합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러면 서버가 좀 더 똑똑해지고, 클라이언트에 맞춤형 응답을 줄 수 있어요!\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e필요하시다면 다음 글에서는 실제 코드 예제와 함께 미들웨어의 구체적인 사용법도 다뤄볼게요~!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eNext.js에서 middleware 작성할 때 기본적으로 export하는 함수는 단 하나여야 한다는 점, 알고 계셨나요? 오늘은 그 부분을 중심으로 간단하게 설명해 보려고 해요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eNextRequest\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/server'\u003c/span\u003e\n \n\u003cspan class=\"hljs-comment\"\u003e// 이 함수는 요청을 가로채서 /about 경로 하위에 있는 모든 경로 요청을 /home 으로 리다이렉트 해줘요.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emiddleware\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003erequest: NextRequest\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eredirect\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eURL\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/home'\u003c/span\u003e, request.\u003cspan class=\"hljs-property\"\u003eurl\u003c/span\u003e))\n}\n \n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e config = {\n  \u003cspan class=\"hljs-attr\"\u003ematcher\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/about/:path*'\u003c/span\u003e,\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드에서 핵심은 \u003ccode\u003emiddleware\u003c/code\u003e 함수 하나만 export 하고 있다는 거예요. Next.js는 한 파일에서 여러 미들웨어 함수를 내보내는 것을 지원하지 않아요. 따라서 두 개 이상의 미들웨어가 필요한 경우엔 각각 따로 파일을 만들어야 하죠.\u003c/p\u003e\n\u003cp\u003e그리고, \u003ccode\u003econfig\u003c/code\u003e 객체의 \u003ccode\u003ematcher\u003c/code\u003e 속성은 어떤 경로에 이 미들웨어를 적용할지 정해주는 역할을 해요. 여기서는 \u003ccode\u003e/about/\u003c/code\u003e 경로 이하 모든 경로를 지정했죠. 참고로 \u003ccode\u003e:path*\u003c/code\u003e 부분은 와일드카드 같은 역할을 해서 하위 경로 전체를 포괄할 수 있어요.\u003c/p\u003e\n\u003ch3\u003e정리하면\u003c/h3\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e항목\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e미들웨어 함수\u003c/td\u003e\u003ctd\u003e꼭 하나만 export 해야 한다\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ematcher\u003c/code\u003e 설정\u003c/td\u003e\u003ctd\u003e어떤 URL 패턴에 대해 미들웨어를 실행할지 지정\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e리다이렉션 처리\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eNextResponse.redirect\u003c/code\u003e 로 요청을 원하는 경로로 보낼 수 있다\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e이런 룰들은 Next.js 내부에서 미들웨어 처리 방식을 단순화하고, 성능 최적화를 위한 부분이에요. 프로젝트 설계 시 이 점 꼭 기억해 두시면 쓸데없는 에러를 예방할 수 있답니다.\u003c/p\u003e\n\u003cp\u003e또한, 만약 복잡한 미들웨어 로직이 필요하다면 여러 파일로 분리하거나, 환경변수에 따라 미들웨어를 다르게 실행하도록 코드를 짜는 것도 좋은 전략이에요.\u003c/p\u003e\n\u003cp\u003e다음에는 미들웨어에서 자주 쓰이는 다른 기능들도 한번 같이 살펴봐요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 기본 export 예제\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emiddleware\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003erequest\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 미들웨어 로직 작성\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003econfig 객체 (선택 사항)\u003c/h3\u003e\n\u003cp\u003e미들웨어 함수와 함께 config 객체를 export할 수도 있어요. 이 객체 안에는 \u003ccode\u003ematcher\u003c/code\u003e가 들어가는데, 이 matcher를 통해 미들웨어가 적용될 경로를 지정할 수 있습니다.\u003c/p\u003e\n\u003ch4\u003ematcher\u003c/h4\u003e\n\u003cp\u003ematcher는 미들웨어가 실행될 URL 경로나 패턴을 지정하는 역할을 해요. 예를 들어, 특정 경로나 API 엔드포인트에만 미들웨어가 동작하도록 설정할 수 있죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e config = {\n  \u003cspan class=\"hljs-attr\"\u003ematcher\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e'/about/:path*'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'/dashboard/:path*'\u003c/span\u003e],\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 예시는 \u003ccode\u003e/about\u003c/code\u003e과 \u003ccode\u003e/dashboard\u003c/code\u003e로 시작하는 모든 하위 경로에 미들웨어가 적용된다는 뜻이에요.\u003c/p\u003e\n\u003cp\u003e참고로, matcher에 지정할 수 있는 패턴은 Next.js의 라우팅 규칙과 비슷해서 익숙하시다면 편하게 쓸 수 있을 거예요.\u003c/p\u003e\n\u003cp\u003e만약 더 세밀한 조건이 필요하다면, 직접 미들웨어 안에서 request 객체를 검사하는 방법도 있어요. 예를 들어, 쿠키나 헤더에 따라 동작을 조절할 수도 있죠.\u003c/p\u003e\n\u003cp\u003e미들웨어 설정 시 알아두면 좋은 팁!\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ematcher\u003c/code\u003e를 구체적으로 지정하면 불필요한 미들웨어 실행을 줄여서 퍼포먼스를 개선할 수 있어요.\u003c/li\u003e\n\u003cli\u003e여러 경로를 배열로 전달할 수 있으니 한꺼번에 관리하기 편합니다.\u003c/li\u003e\n\u003cli\u003e잘못된 matcher 패턴은 미들웨어가 의도치 않게 작동하지 않을 수 있으니, 꼭 테스트해보세요!\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음에는 미들웨어 내부에서 실제 request 요청을 다루는 법과 응답 처리 방법에 대해 이야기해볼게요. 그럼 같이 공부해봐요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003ccode\u003ematcher\u003c/code\u003e 옵션은 Middleware가 특정 경로에서만 실행되도록 설정할 때 사용해요. 쉽게 말해, 이 옵션을 통해 ‘어떤 경로에 Middleware를 적용할지’를 정할 수 있다는 뜻이죠.\u003c/p\u003e\n\u003cp\u003e그 방법은 크게 세 가지예요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e단일 경로 지정:\u003c/strong\u003e\u003cbr\u003e\n그냥 문자열로 경로를 적으면 돼요. 예를 들어, \u003ccode\u003e/about\u003c/code\u003e이면 \u003ccode\u003e/about\u003c/code\u003e 경로에서만 Middleware가 실행됩니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e여러 경로 지정:\u003c/strong\u003e\u003cbr\u003e\n배열을 사용해서 여러 경로를 한 번에 지정할 수 있어요.\u003cbr\u003e\n예시) \u003ccode\u003ematcher: ['/about', '/contact']\u003c/code\u003e 이렇게 하면 \u003ccode\u003e/about\u003c/code\u003e과 \u003ccode\u003e/contact\u003c/code\u003e 두 경로 모두 적용됩니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e정규 표현식(Regex) 사용:\u003c/strong\u003e\u003cbr\u003e\n더 정교한 경로 필터링이 필요할 땐 정규식도 사용할 수 있어요.\u003cbr\u003e\n예를 들면,\u003cbr\u003e\njs\nmatcher: ['/((?!api|_next/static|_next/image|.\u003cem\u003e\\.png$).\u003c/em\u003e)']\u003c/p\u003e\n\u003cp\u003e이렇게 하면 \u003ccode\u003eapi\u003c/code\u003e, \u003ccode\u003e_next/static\u003c/code\u003e, \u003ccode\u003e_next/image\u003c/code\u003e 폴더나 \u003ccode\u003e.png\u003c/code\u003e 파일 경로는 제외하고 나머지 경로에만 Middleware를 적용해요.\u003cbr\u003e\n정규 표현식의 부정형 전방탐색(negative lookahead)을 활용해 특정 경로나 파일 형식을 꼼꼼히 걸러낼 수 있답니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e그리고 \u003ccode\u003ematcher\u003c/code\u003e 옵션에는 배열 안에 객체 형식으로 경로를 더 세분화해서 지정할 수도 있는데, 이 객체에는 다음과 같은 키들이 있어요:\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e키 이름\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003esrc\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e적용할 경로를 정의 (문자열 또는 정규식)\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003emethods\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e적용할 HTTP 메소드 배열 (예: \u003ccode\u003e['GET', 'POST']\u003c/code\u003e)\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ehas\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e요청에 특정 헤더, 쿠키, 쿼리 파라미터가 있는지 조건 지정\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003emissing\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e요청에 특정 헤더, 쿠키, 쿼리 파라미터가 없는지 조건 지정\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e이런 식으로 복잡한 조건을 걸 수 있어서, 예를 들어 \u003ccode\u003ePOST\u003c/code\u003e 요청이고 특정 쿠키가 있을 때만 Middleware를 적용하는 것도 가능하답니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e추가 팁\u003c/h3\u003e\n\u003cp\u003eRouter 미들웨어를 효과적으로 사용하려면, 불필요하게 모든 경로에 Middleware가 실행되지 않도록 \u003ccode\u003ematcher\u003c/code\u003e를 잘 설정하는 게 좋아요. 안 그러면 성능에 영향이 있을 수 있거든요! 또한, Next.js에서 자주 쓰는 \u003ccode\u003e_next/static\u003c/code\u003e 같은 내부 리소스 경로들은 보통 Middleware 대상에서 제외하는 게 일반적이에요.\u003c/p\u003e\n\u003cp\u003e이 정도만 잘 활용해도 경로별로 딱 맞는 Middleware 적용이 훨씬 수월해질 거예요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e요즘 웹 개발할 때, 특정 요청 경로에 맞춰서 로직을 처리하거나 미들웨어를 적용하는 경우가 많죠? 이번에 소개할 내용은 이런 요청 경로 매칭을 세밀하게 조정할 수 있는 설정 방법이에요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e주요 옵션 설명\u003c/h3\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e옵션명\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003esource\u003c/td\u003e\u003ctd\u003e요청 경로를 매칭하는 경로 또는 패턴이에요. 문자열로 직접 지정하거나 복잡한 패턴을 지정할 수 있어요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eregexp\u003c/td\u003e\u003ctd\u003e정규표현식으로 source를 세밀하게 조절할 수 있어요. 포함하거나 제외할 경로를 더욱 정확하게 조절할 때 쓸 수 있죠.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003elocale\u003c/td\u003e\u003ctd\u003e불리언 값인데, false로 하면 로케일(언어 설정 등)을 매칭에서 무시해요. 기본값은 true로 다루는 경우가 많습니다.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003ehas\u003c/td\u003e\u003ctd\u003e요청 헤더, 쿼리 파라미터, 쿠키 등의 특정 요소가 있을 때 조건을 걸고 싶을 때 사용해요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003emissing\u003c/td\u003e\u003ctd\u003e반대로, 헤더나 쿠키 같은 특정 요소가 없을 때만 동작하도록 조건을 걸고 싶을 때 쓰면 좋아요.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003ch3\u003e실제 예제\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e config = {\n  \u003cspan class=\"hljs-attr\"\u003ematcher\u003c/span\u003e: [\n    {\n      \u003cspan class=\"hljs-attr\"\u003esource\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/api/*'\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eregexp\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'^/api/(.*)'\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003elocale\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003ehas\u003c/span\u003e: [\n        { \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'header'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Authorization'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Bearer Token'\u003c/span\u003e },\n        { \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'query'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'userId'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'123'\u003c/span\u003e },\n      ],\n      \u003cspan class=\"hljs-attr\"\u003emissing\u003c/span\u003e: [{ \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'cookie'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'session'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'active'\u003c/span\u003e }],\n    },\n  ],\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e/api/*\u003c/code\u003e 경로에 대해 매칭합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eregexp\u003c/code\u003e로 좀 더 정교하게 \u003ccode\u003e/api/\u003c/code\u003e 뒤에 어떤 값이 오든 매칭하도록 했어요.\u003c/li\u003e\n\u003cli\u003e로케일 기반 매칭은 무시(\u003ccode\u003elocale: false\u003c/code\u003e)하고요.\u003c/li\u003e\n\u003cli\u003e요청 헤더에 \u003ccode\u003eAuthorization\u003c/code\u003e이 \u003ccode\u003e'Bearer Token'\u003c/code\u003e 이고, 쿼리 파라미터에 \u003ccode\u003euserId=123\u003c/code\u003e 이 있어야 합니다.\u003c/li\u003e\n\u003cli\u003e그리고 \u003ccode\u003esession\u003c/code\u003e 쿠키가 없을 때만 이 설정이 적용되는 거죠.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003e참고로!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ehas\u003c/code\u003e와 \u003ccode\u003emissing\u003c/code\u003e 조건은 다중으로 걸 수 있으니, 복합 조건 처리도 편리하게 구성할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eregexp\u003c/code\u003e 쓰면 경로를 한 층 더 정교하게 제어할 수 있어서, 간단한 경로나 특수 문자 포함 경로도 문제없이 처리 가능해요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elocale\u003c/code\u003e 설정은 멀티랭귀지 사이트 만들 때 유용하고, 단일 언어 사이트는 보통 false로 두고 쓰기도 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이렇게 매칭 설정을 잘 사용하면, Next.js나 비슷한 프레임워크에서 요청 경로 조건에 맞는 미들웨어나 특정 API 처리 로직을 깔끔하게 관리할 수 있답니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e다음 글에서는 이 설정을 실제 미들웨어에 어떻게 적용할 수 있는지, 그리고 성능 최적화 팁도 함께 다뤄볼게요! 궁금한 점 있으면 댓글로 남겨주세요~\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eMiddleware를 정의할 때 기본 내보내기 함수는 하나의 매개변수인 request를 받습니다. 이 request는 NextRequest의 인스턴스로, 들어온 HTTP 요청을 나타내죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e type { \u003cspan class=\"hljs-title class_\"\u003eNextRequest\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/server'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emiddleware\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003erequest: NextRequest\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 여기에 Middleware 로직을 작성하세요\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e알아두면 좋은 점:\nNextRequest는 Next.js Middleware에서 들어오는 HTTP 요청을 나타내는 타입이에요. 반면에 NextResponse는 HTTP 응답을 조작하고 돌려보낼 때 사용하는 클래스로 구분되어 있습니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003eNextResponse\u003c/h2\u003e\n\u003cp\u003eNextResponse는 Middleware 안에서 주로 클라이언트에게 반환할 응답을 조작할 때 사용합니다. 예를 들어, 요청을 리다이렉트하거나 쿠키를 설정하는 등의 작업을 할 수 있죠.\u003c/p\u003e\n\u003cp\u003e간단한 예시를 보면:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/server'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emiddleware\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003erequest\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 특정 경로로 리다이렉트하기\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (request.\u003cspan class=\"hljs-property\"\u003enextUrl\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003epathname\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e'/old-path'\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eredirect\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eURL\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/new-path'\u003c/span\u003e, request.\u003cspan class=\"hljs-property\"\u003eurl\u003c/span\u003e))\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 요청된 경로가 \u003ccode\u003e/old-path\u003c/code\u003e라면 \u003ccode\u003e/new-path\u003c/code\u003e로 리다이렉트 시키고, 그렇지 않으면 다음 미들웨어나 라우터로 요청을 넘기게 됩니다.\u003c/p\u003e\n\u003cp\u003e또한 NextResponse를 이용해 쿠키를 설정할 수도 있어요. 예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/server'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emiddleware\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003erequest\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e response = \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e()\n  response.\u003cspan class=\"hljs-property\"\u003ecookies\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eset\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'my-cookie'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'my-value'\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003emaxAge\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e24\u003c/span\u003e }) \u003cspan class=\"hljs-comment\"\u003e// 1일간 유지되는 쿠키\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e response\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 예시에서는 응답에 'my-cookie'라는 이름의 쿠키를 추가하는 거죠.\u003c/p\u003e\n\u003cp\u003eMiddleware에서 NextRequest와 NextResponse의 역할을 잘 구분해두면 효과적인 요청 처리 및 응답 제어가 가능하니 꼭 기억해두세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e미들웨어(Middleware)는 NextResponse 객체를 사용할 수 있는데, 이 객체는 Web Response API를 확장한 거예요. NextResponse 객체를 반환하면 쿠키를 직접 조작하거나, 헤더를 설정하고, 리다이렉트를 구현하거나, 경로를 다시 쓸 수 있어서 정말 유용하답니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e참고로 리다이렉트를 구현할 땐 NextResponse.redirect 대신 Response.redirect를 써도 된다는 점! 상황에 맞게 골라 쓰시면 돼요.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e실행 환경(Runtime)\u003c/h2\u003e\n\u003cp\u003e미들웨어는 Edge 런타임에서만 동작해요. 그래서 Node.js 런타임에서는 사용할 수 없다는 점, 꼭 기억해주세요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e미들웨어에서 NextResponse를 쓰면 좋은 점\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e쿠키 설정/삭제가 편리해요.\u003c/li\u003e\n\u003cli\u003e헤더를 자유자재로 조작할 수 있어서 보안이나 캐싱 정책 등을 설정할 때 유리하죠.\u003c/li\u003e\n\u003cli\u003e경로 재작성(Rewrite) 기능으로 SEO 최적화나 사용자 맞춤 라우팅이 쉬워져요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eEdge 런타임이라는 건, 쉽게 말해 요청이 사용자와 가까운 서버(Edge)에서 빠르게 처리된다는 뜻인데요. 그래서 미들웨어가 빠른 응답 속도에 도움을 줘서 좋은 사용자 경험을 만들 수 있답니다.\u003c/p\u003e\n\u003cp\u003e필요할 때 미들웨어와 NextResponse를 적절히 활용해보세요! 개발할 때 꽤 큰 힘이 되어줄 거예요.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e버전 히스토리 (Version History)\u003c/h2\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e버전\u003c/th\u003e\u003cth\u003e변경 사항\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev13.1.0\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e고급 미들웨어 플래그(Advanced Middleware flags) 추가\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev13.0.0\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e미들웨어가 요청 헤더, 응답 헤더를 수정할 수 있고, 응답도 직접 보낼 수 있게 개선\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev12.2.0\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e미들웨어가 안정화됨. 자세한 업그레이드 가이드는 \u003ca href=\"https://nextjs.org/docs/messages/middleware-upgrade-guide\" rel=\"nofollow\" target=\"_blank\"\u003e여기\u003c/a\u003e 참고\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev12.0.9\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eEdge Runtime에서 절대 URL 강제 적용 (\u003ca href=\"https://github.com/vercel/next.js/pull/33410\" rel=\"nofollow\" target=\"_blank\"\u003e관련 PR\u003c/a\u003e)\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev12.0.0\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e미들웨어(Beta) 기능 추가\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cem\u003e잠깐!\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e여기서 말하는 '미들웨어'는 Next.js에서 API 요청과 응답 사이에 원하는 로직을 끼워 넣을 수 있는 기능이에요. 예를 들어 로그인 검증, A/B 테스트, 사용자 맞춤 리디렉션 등을 처리할 때 아주 유용하답니다.\u003c/p\u003e\n\u003cp\u003e그리고 \u003ccode\u003ev13.0.0\u003c/code\u003e부터는 요청과 응답 헤더를 수정하거나 직접 응답을 보내는 등 훨씬 더 강력한 제어가 가능해져서, 미들웨어를 활용하는 범위가 정말 넓어졌어요.\u003c/p\u003e\n\u003cp\u003e버전이 올라가면서 미들웨어가 안정화되고 기능도 점점 확장되고 있으니, 현재 개발 중인 프로젝트에 맞춰 적절히 선택해서 쓰시면 좋겠네요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2025-04-22-middlewarejs"},"buildId":"o6AmBAY_j9v9JmbaRA39X","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>