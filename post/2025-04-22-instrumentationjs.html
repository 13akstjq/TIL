<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>instrumentation.js로 웹사이트 성능 측정 도구 만들기 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-instrumentationjs" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="instrumentation.js로 웹사이트 성능 측정 도구 만들기 | TIL" data-gatsby-head="true"/><meta property="og:title" content="instrumentation.js로 웹사이트 성능 측정 도구 만들기 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-instrumentationjs" data-gatsby-head="true"/><meta name="twitter:title" content="instrumentation.js로 웹사이트 성능 측정 도구 만들기 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2025-04-22 02:38" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/0eef537492fed77a.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/0eef537492fed77a.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-8ded8b979ba73586.js" defer=""></script><script src="/TIL/_next/static/olPs1cVezSGTqD7OaewDI/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/olPs1cVezSGTqD7OaewDI/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">instrumentation.js로 웹사이트 성능 측정 도구 만들기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="instrumentation.js로 웹사이트 성능 측정 도구 만들기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Apr 22, 2025</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>instrumentation.js</h1>
<p>instrumentation.js|ts 파일은 애플리케이션에 관찰 가능성(Observability) 도구를 통합하는 용도로 사용돼요. 이를 통해 애플리케이션의 성능과 동작을 추적할 수 있고, 실제 서비스 중에 발생하는 문제를 더 효과적으로 디버깅할 수 있답니다.</p>
<p>사용법도 간단해요! 프로젝트 루트 디렉토리에 파일을 두거나, 만약 src 폴더를 사용한다면 그 안에 넣으면 되죠.</p>
<h2>파일에서 제공하는 주요 기능 (Exports)</h2>
<p>(여기에 실제로 어떤 내용이 export 되는지 명시되어야 하는데요, 이어서 있으면 같이 정리해보겠습니다.)</p>
<hr>
<h3>조금 더 알아두면 좋은 점!</h3>
<ul>
<li>관찰 가능성 도구에는 여러 가지가 있는데, 예를 들어 로그 수집, 메트릭 수집, 트레이싱 등이 있어요. instrumentation.js를 통해 이런 도구들을 한 곳에 모아 효율적으로 관리할 수 있어요.</li>
<li>실제 운영 환경에서 문제가 발생했을 때, 미리 설정한 instrumentation 덕분에 원인을 빠르게 파악할 수 있으니 개발, 운영 모두에 큰 도움이 된답니다.</li>
<li>TypeScript를 사용한다면 .ts 확장자를 사용해 타입 안정성을 더할 수도 있어요.</li>
</ul>
<p>다음에는 instrumentation.js 안에 어떤 코드가 들어가는지, 구체적인 예시를 하나씩 살펴보도록 할게요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>register (선택 사항)</h3>
<p>Next.js 서버가 새로 시작될 때 한 번 호출되는 <code>register</code> 함수를 파일에서 export할 수 있어요. 이 함수는 async 함수여도 되고, 주로 초기 설정이나 라이브러리 등록 같은 작업에 사용되죠.</p>
<p>예를 들어, 아래처럼 OpenTelemetry를 연동하는 작업을 할 수 있어요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { registerOTel } <span class="hljs-keyword">from</span> <span class="hljs-string">'@vercel/otel'</span>
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">register</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title function_">registerOTel</span>(<span class="hljs-string">'next-app'</span>)
}
</code></pre>
<p>위 코드에서 <code>registerOTel</code> 함수는 'next-app'이라는 이름으로 OpenTelemetry를 설정해주는 역할을 해요. 이 부분은 프로젝트에서 필요한 모니터링이나 트레이싱을 할 때 유용하답니다.</p>
<h3>onRequestError (선택 사항)</h3>
<p><code>onRequestError</code> 함수도 선택 사항인데요, 이 함수는 HTTP 요청 중 에러가 발생했을 때 실행되도록 만들어져 있어요. 만약 API 라우트나 서버 함수에서 에러 로그를 따로 남기거나 오류를 처리하고 싶을 때 이 함수를 정의해서 사용할 수 있답니다.</p>
<hr>
<p>참고로, <code>register</code> 함수 같은 초기화 함수는 앱이 구동될 때 한 번만 실행되기 때문에 무거운 초기 작업이나 설정을 이곳에 모아두면 깔끔하게 관리할 수 있어요. Next.js를 활용할 때, 이런 선택적 함수들로 서버 사이드의 세밀한 로직을 다루는 팁을 꼭 알아두시면 좋아요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Next.js에서 onRequestError라는 함수를 선택적으로 내보내서 서버 에러를 커스텀한 관측(Observability) 도구로 추적할 수 있어요.</p>
<ul>
<li>만약 onRequestError 안에서 비동기 작업을 한다면 꼭 <code>await</code> 해줘야 해요. 이 함수는 Next.js 서버가 에러를 포착할 때 실행되거든요.</li>
<li>여기서 주의할 점! 에러 인스턴스가 실제로 던져진 원본 에러가 아닐 수도 있어요. 특히 Server Components 렌더링 도중 React가 처리한 에러라면 그럴 수 있는데, 이럴 때는 에러 객체의 <code>digest</code> 속성을 이용해서 실제 에러 타입을 확인할 수 있답니다.</li>
</ul>
<p>아래 코드를 보면 실제로 onRequestError에서 에러 정보를 외부 서버로 POST 요청을 보내서 보고하는 간단한 예시를 보여주고 있어요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { type <span class="hljs-title class_">Instrumentation</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'next'</span>
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">onRequestError</span>: <span class="hljs-title class_">Instrumentation</span>.<span class="hljs-property">onRequestError</span> = <span class="hljs-keyword">async</span> (
  err,
  request,
  context
) => {
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://.../report-error'</span>, {
    <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
    <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
      <span class="hljs-attr">message</span>: err.<span class="hljs-property">message</span>,
      request,
      context,
    }),
    <span class="hljs-attr">headers</span>: {
      <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>,
    },
  })
}
</code></pre>
<h3>onRequestError 함수 파라미터</h3>





















<table><thead><tr><th>파라미터명</th><th>설명</th></tr></thead><tbody><tr><td><code>err</code></td><td>발생한 에러 객체입니다. React가 가공할 수도 있어요.</td></tr><tr><td><code>request</code></td><td>현재 요청 정보가 담긴 객체입니다.</td></tr><tr><td><code>context</code></td><td>요청에 관련된 추가 컨텍스트 정보가 들어있습니다.</td></tr></tbody></table>
<p>이걸 활용하면 서버 에러를 커스텀 로그 서버나 Sentry, Datadog 같은 외부 모니터링 서비스에 손쉽게 연결할 수 있어요. 특히 여러 비동기 작업을 할 때 <code>await</code>를 빠뜨리지 않도록 주의해주세요! 안 그러면 에러 추적이 중간에 끊길 수 있거든요.</p>
<p>그리고 <code>digest</code> 프로퍼티를 써서 에러 타입을 확인하는 팁! React에서 처리된 에러는 내부적으론 변형될 수 있기 때문에, 원래 에러를 정확히 파악하려면 이걸 참고하면 좋아요.</p>
<p>이 기능을 잘 쓰면 서버 안정성 모니터링에 훨씬 도움 돼서, 문제 발생 시 빠르게 대응 가능하니 꼭 한번 적용해보시길 추천드립니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이번에는 <code>onRequestError</code> 함수에 대해 알아볼게요. 이 함수는 에러가 발생했을 때 호출되며, 세 가지 매개변수를 받아요: <code>error</code>, <code>request</code>, 그리고 <code>context</code>입니다.</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">onRequestError</span>(<span class="hljs-params">
  error: { digest: <span class="hljs-built_in">string</span> } &#x26; <span class="hljs-built_in">Error</span>,
  request: {
    path: <span class="hljs-built_in">string</span>; // 리소스 경로, 예: /blog?name=foo
    method: <span class="hljs-built_in">string</span>; // 요청 메서드, 예: GET, POST 등
    headers: { [key: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span> };
  },
  context: {
    routerKind: <span class="hljs-string">'Pages Router'</span> | <span class="hljs-string">'App Router'</span>; // 사용하는 라우터 종류
    routePath: <span class="hljs-built_in">string</span>; // 라우트 파일 경로, 예: /app/blog/[dynamic]
    routeType: <span class="hljs-string">'render'</span> | <span class="hljs-string">'route'</span> | <span class="hljs-string">'action'</span> | <span class="hljs-string">'middleware'</span>; // 에러 발생 컨텍스트
    renderSource:
      | <span class="hljs-string">'react-server-components'</span>
      | <span class="hljs-string">'react-server-components-payload'</span>
      | <span class="hljs-string">'server-rendering'</span>; // 렌더링 소스
    revalidateReason: <span class="hljs-string">'on-demand'</span> | <span class="hljs-string">'stale'</span> | <span class="hljs-literal">undefined</span>; // 재검증 사유, <span class="hljs-literal">undefined</span> 는 일반 요청 의미
    renderType: <span class="hljs-string">'dynamic'</span> | <span class="hljs-string">'dynamic-resume'</span>; // <span class="hljs-string">'dynamic-resume'</span>은 PPR 사용 시
  }
</span>): <span class="hljs-built_in">void</span> | <span class="hljs-title class_">Promise</span>&#x3C;<span class="hljs-built_in">void</span>>;
</code></pre>





















<table><thead><tr><th>파라미터</th><th>설명</th></tr></thead><tbody><tr><td><code>error</code></td><td>발생한 실제 에러, 고유 ID인 <code>digest</code> 포함</td></tr><tr><td><code>request</code></td><td>에러와 관련된 요청 정보</td></tr><tr><td><code>context</code></td><td>에러가 발생한 환경 정보를 담고 있음</td></tr></tbody></table>
<h3>파라미터 자세히 살펴보기</h3>
<ul>
<li><code>error</code>: 항상 Error 타입이며, 여기에 <code>digest</code>라는 고유 ID가 있어 에러를 추적하기 좋습니다. 예를 들어, 같은 에러가 여러 번 발생할 경우 이 ID로 쉽게 분류할 수 있죠.</li>
<li><code>request</code>: 실제 요청 정보입니다. 어떤 경로(<code>path</code>)로, 어떤 메서드(<code>method</code>)가 쓰였고, 헤더에는 어떤 정보가 담겨있는지 확인할 수 있어요.</li>
<li><code>context</code>: 어느 라우터에서 발생했는지(<code>routerKind</code>), 어떤 라우트 파일에서 발생했는지(<code>routePath</code>), 그리고 에러가 일어난 시점(<code>routeType</code>)을 알려줍니다. 렌더링 소스(<code>renderSource</code>)나 재검증 사유(<code>revalidateReason</code>)도 담겨있어, 상황별 대응에 유용해요.</li>
</ul>
<h3>추가 팁: 왜 이렇게 복잡한 정보가 필요할까?</h3>
<p>에러 핸들링은 단순히 에러 메시지를 로그에 남기는 걸 넘어서, 상황에 맞게 대처하거나 사용자에게 정확한 안내를 해주는 데 중요해요. 예를 들어 <code>revalidateReason</code>이 <code>'stale'</code>이면 캐시된 데이터를 다시 불러오는 중 문제가 생긴 거고, 이를 활용하면 재시도 로직이나 사용자 안내 메시지를 다르게 할 수 있겠죠.</p>
<p>최근 Next.js 같은 프레임워크가 여러 라우터 시스템과 다양한 렌더링 방식을 지원하면서, 이런 세분화된 정보가 꼭 필요해졌답니다.</p>
<hr>
<p>다음에 이어서 <code>### Specifying the runtime</code> 부분도 한 번 살펴볼게요! 혹시 여기까지 궁금한 점 있으면 댓글로 물어봐 주세요 :)</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>instrumentation.js 파일은 Node.js와 Edge 런타임 둘 다에서 동작하는데요, 만약 특정 런타임을 대상으로 하고 싶다면 process.env.NEXT_RUNTIME 값을 활용하면 됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">register</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NEXT_RUNTIME</span> === <span class="hljs-string">'edge'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">require</span>(<span class="hljs-string">'./register.edge'</span>)
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">require</span>(<span class="hljs-string">'./register.node'</span>)
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">onRequestError</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NEXT_RUNTIME</span> === <span class="hljs-string">'edge'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">require</span>(<span class="hljs-string">'./on-request-error.edge'</span>)
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">require</span>(<span class="hljs-string">'./on-request-error.node'</span>)
  }
}
</code></pre>
<p>여기서 중요한 점은 process.env.NEXT_RUNTIME이 'edge'인지 아닌지에 따라서 각각 다른 모듈을 require해서 사용하는 방식이에요. 이렇게 하면 동일한 코드베이스에서 런타임 환경에 맞게 동작 방식을 유연하게 바꿀 수 있어서 정말 편리합니다.</p>
<hr>
<h2>버전 히스토리</h2>





















<table><thead><tr><th>Version</th><th>Changes</th></tr></thead><tbody><tr><td>v15.0.0</td><td><code>onRequestError</code> 추가, <code>instrumentation</code> 안정화</td></tr><tr><td>v14.0.4</td><td><code>instrumentation</code>에 Turbopack 지원 추가</td></tr><tr><td>v13.2.0</td><td><code>instrumentation</code> 실험적 기능으로 처음 소개</td></tr></tbody></table>
<p>버전 히스토리를 보면 알 수 있듯, instrumentation 기능이 처음에는 실험적으로 도입됐다가 이후 안정화 되고, Turbopack 같은 최신 툴도 지원이 추가되면서 점점 완성도 있게 발전해온 걸 확인할 수 있어요.</p>
<hr>
<p>개발할 때 runtime 환경 구분이 필요한 경우에는 이렇게 환경변수를 통해 동적으로 모듈을 분기하는 패턴을 자주 쓰게 되는데, Next.js 같은 프레임워크에서 공식적으로 지원하니까 훨씬 편하게 적용할 수 있는 것 같더라고요. 혹시 특정 런타임에서만 동작하는 코드를 작성하려고 하면 참고해보시면 좋을 것 같아요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"instrumentation.js로 웹사이트 성능 측정 도구 만들기","description":"","date":"2025-04-22 02:38","slug":"2025-04-22-instrumentationjs","content":"\n\n# instrumentation.js\n\ninstrumentation.js|ts 파일은 애플리케이션에 관찰 가능성(Observability) 도구를 통합하는 용도로 사용돼요. 이를 통해 애플리케이션의 성능과 동작을 추적할 수 있고, 실제 서비스 중에 발생하는 문제를 더 효과적으로 디버깅할 수 있답니다.\n\n사용법도 간단해요! 프로젝트 루트 디렉토리에 파일을 두거나, 만약 src 폴더를 사용한다면 그 안에 넣으면 되죠.\n\n## 파일에서 제공하는 주요 기능 (Exports)\n\n(여기에 실제로 어떤 내용이 export 되는지 명시되어야 하는데요, 이어서 있으면 같이 정리해보겠습니다.)\n\n---\n\n### 조금 더 알아두면 좋은 점!\n\n- 관찰 가능성 도구에는 여러 가지가 있는데, 예를 들어 로그 수집, 메트릭 수집, 트레이싱 등이 있어요. instrumentation.js를 통해 이런 도구들을 한 곳에 모아 효율적으로 관리할 수 있어요.\n- 실제 운영 환경에서 문제가 발생했을 때, 미리 설정한 instrumentation 덕분에 원인을 빠르게 파악할 수 있으니 개발, 운영 모두에 큰 도움이 된답니다.\n- TypeScript를 사용한다면 .ts 확장자를 사용해 타입 안정성을 더할 수도 있어요.\n\n다음에는 instrumentation.js 안에 어떤 코드가 들어가는지, 구체적인 예시를 하나씩 살펴보도록 할게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### register (선택 사항)\n\nNext.js 서버가 새로 시작될 때 한 번 호출되는 `register` 함수를 파일에서 export할 수 있어요. 이 함수는 async 함수여도 되고, 주로 초기 설정이나 라이브러리 등록 같은 작업에 사용되죠.\n\n예를 들어, 아래처럼 OpenTelemetry를 연동하는 작업을 할 수 있어요:\n\n```js\nimport { registerOTel } from '@vercel/otel'\n \nexport function register() {\n  registerOTel('next-app')\n}\n```\n\n위 코드에서 `registerOTel` 함수는 'next-app'이라는 이름으로 OpenTelemetry를 설정해주는 역할을 해요. 이 부분은 프로젝트에서 필요한 모니터링이나 트레이싱을 할 때 유용하답니다.\n\n### onRequestError (선택 사항)\n\n`onRequestError` 함수도 선택 사항인데요, 이 함수는 HTTP 요청 중 에러가 발생했을 때 실행되도록 만들어져 있어요. 만약 API 라우트나 서버 함수에서 에러 로그를 따로 남기거나 오류를 처리하고 싶을 때 이 함수를 정의해서 사용할 수 있답니다.\n\n---\n\n참고로, `register` 함수 같은 초기화 함수는 앱이 구동될 때 한 번만 실행되기 때문에 무거운 초기 작업이나 설정을 이곳에 모아두면 깔끔하게 관리할 수 있어요. Next.js를 활용할 때, 이런 선택적 함수들로 서버 사이드의 세밀한 로직을 다루는 팁을 꼭 알아두시면 좋아요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 onRequestError라는 함수를 선택적으로 내보내서 서버 에러를 커스텀한 관측(Observability) 도구로 추적할 수 있어요.\n\n- 만약 onRequestError 안에서 비동기 작업을 한다면 꼭 `await` 해줘야 해요. 이 함수는 Next.js 서버가 에러를 포착할 때 실행되거든요.\n- 여기서 주의할 점! 에러 인스턴스가 실제로 던져진 원본 에러가 아닐 수도 있어요. 특히 Server Components 렌더링 도중 React가 처리한 에러라면 그럴 수 있는데, 이럴 때는 에러 객체의 `digest` 속성을 이용해서 실제 에러 타입을 확인할 수 있답니다.\n\n아래 코드를 보면 실제로 onRequestError에서 에러 정보를 외부 서버로 POST 요청을 보내서 보고하는 간단한 예시를 보여주고 있어요:\n\n```js\nimport { type Instrumentation } from 'next'\n \nexport const onRequestError: Instrumentation.onRequestError = async (\n  err,\n  request,\n  context\n) =\u003e {\n  await fetch('https://.../report-error', {\n    method: 'POST',\n    body: JSON.stringify({\n      message: err.message,\n      request,\n      context,\n    }),\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  })\n}\n```\n\n### onRequestError 함수 파라미터\n\n| 파라미터명  | 설명                                                   |\n|-------------|--------------------------------------------------------|\n| `err`       | 발생한 에러 객체입니다. React가 가공할 수도 있어요.            |\n| `request`   | 현재 요청 정보가 담긴 객체입니다.                             |\n| `context`   | 요청에 관련된 추가 컨텍스트 정보가 들어있습니다.                   |\n\n이걸 활용하면 서버 에러를 커스텀 로그 서버나 Sentry, Datadog 같은 외부 모니터링 서비스에 손쉽게 연결할 수 있어요. 특히 여러 비동기 작업을 할 때 `await`를 빠뜨리지 않도록 주의해주세요! 안 그러면 에러 추적이 중간에 끊길 수 있거든요.\n\n그리고 `digest` 프로퍼티를 써서 에러 타입을 확인하는 팁! React에서 처리된 에러는 내부적으론 변형될 수 있기 때문에, 원래 에러를 정확히 파악하려면 이걸 참고하면 좋아요.\n\n이 기능을 잘 쓰면 서버 안정성 모니터링에 훨씬 도움 돼서, 문제 발생 시 빠르게 대응 가능하니 꼭 한번 적용해보시길 추천드립니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번에는 `onRequestError` 함수에 대해 알아볼게요. 이 함수는 에러가 발생했을 때 호출되며, 세 가지 매개변수를 받아요: `error`, `request`, 그리고 `context`입니다.\n\n```ts\nexport function onRequestError(\n  error: { digest: string } \u0026 Error,\n  request: {\n    path: string; // 리소스 경로, 예: /blog?name=foo\n    method: string; // 요청 메서드, 예: GET, POST 등\n    headers: { [key: string]: string };\n  },\n  context: {\n    routerKind: 'Pages Router' | 'App Router'; // 사용하는 라우터 종류\n    routePath: string; // 라우트 파일 경로, 예: /app/blog/[dynamic]\n    routeType: 'render' | 'route' | 'action' | 'middleware'; // 에러 발생 컨텍스트\n    renderSource:\n      | 'react-server-components'\n      | 'react-server-components-payload'\n      | 'server-rendering'; // 렌더링 소스\n    revalidateReason: 'on-demand' | 'stale' | undefined; // 재검증 사유, undefined 는 일반 요청 의미\n    renderType: 'dynamic' | 'dynamic-resume'; // 'dynamic-resume'은 PPR 사용 시\n  }\n): void | Promise\u003cvoid\u003e;\n```\n\n| 파라미터 | 설명                        |\n|----------|-----------------------------|\n| `error`  | 발생한 실제 에러, 고유 ID인 `digest` 포함 |\n| `request`| 에러와 관련된 요청 정보      |\n| `context`| 에러가 발생한 환경 정보를 담고 있음 |\n\n### 파라미터 자세히 살펴보기\n\n- `error`: 항상 Error 타입이며, 여기에 `digest`라는 고유 ID가 있어 에러를 추적하기 좋습니다. 예를 들어, 같은 에러가 여러 번 발생할 경우 이 ID로 쉽게 분류할 수 있죠.\n- `request`: 실제 요청 정보입니다. 어떤 경로(`path`)로, 어떤 메서드(`method`)가 쓰였고, 헤더에는 어떤 정보가 담겨있는지 확인할 수 있어요.\n- `context`: 어느 라우터에서 발생했는지(`routerKind`), 어떤 라우트 파일에서 발생했는지(`routePath`), 그리고 에러가 일어난 시점(`routeType`)을 알려줍니다. 렌더링 소스(`renderSource`)나 재검증 사유(`revalidateReason`)도 담겨있어, 상황별 대응에 유용해요.\n\n### 추가 팁: 왜 이렇게 복잡한 정보가 필요할까?\n\n에러 핸들링은 단순히 에러 메시지를 로그에 남기는 걸 넘어서, 상황에 맞게 대처하거나 사용자에게 정확한 안내를 해주는 데 중요해요. 예를 들어 `revalidateReason`이 `'stale'`이면 캐시된 데이터를 다시 불러오는 중 문제가 생긴 거고, 이를 활용하면 재시도 로직이나 사용자 안내 메시지를 다르게 할 수 있겠죠.\n\n최근 Next.js 같은 프레임워크가 여러 라우터 시스템과 다양한 렌더링 방식을 지원하면서, 이런 세분화된 정보가 꼭 필요해졌답니다.\n\n---\n\n다음에 이어서 `### Specifying the runtime` 부분도 한 번 살펴볼게요! 혹시 여기까지 궁금한 점 있으면 댓글로 물어봐 주세요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ninstrumentation.js 파일은 Node.js와 Edge 런타임 둘 다에서 동작하는데요, 만약 특정 런타임을 대상으로 하고 싶다면 process.env.NEXT_RUNTIME 값을 활용하면 됩니다.\n\n```js\nexport function register() {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    return require('./register.edge')\n  } else {\n    return require('./register.node')\n  }\n}\n\nexport function onRequestError() {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    return require('./on-request-error.edge')\n  } else {\n    return require('./on-request-error.node')\n  }\n}\n```\n\n여기서 중요한 점은 process.env.NEXT_RUNTIME이 'edge'인지 아닌지에 따라서 각각 다른 모듈을 require해서 사용하는 방식이에요. 이렇게 하면 동일한 코드베이스에서 런타임 환경에 맞게 동작 방식을 유연하게 바꿀 수 있어서 정말 편리합니다.\n\n---\n\n## 버전 히스토리\n\n| Version   | Changes                                    |\n|-----------|--------------------------------------------|\n| v15.0.0   | `onRequestError` 추가, `instrumentation` 안정화 |\n| v14.0.4   | `instrumentation`에 Turbopack 지원 추가        |\n| v13.2.0   | `instrumentation` 실험적 기능으로 처음 소개      |\n\n버전 히스토리를 보면 알 수 있듯, instrumentation 기능이 처음에는 실험적으로 도입됐다가 이후 안정화 되고, Turbopack 같은 최신 툴도 지원이 추가되면서 점점 완성도 있게 발전해온 걸 확인할 수 있어요.\n\n---\n\n개발할 때 runtime 환경 구분이 필요한 경우에는 이렇게 환경변수를 통해 동적으로 모듈을 분기하는 패턴을 자주 쓰게 되는데, Next.js 같은 프레임워크에서 공식적으로 지원하니까 훨씬 편하게 적용할 수 있는 것 같더라고요. 혹시 특정 런타임에서만 동작하는 코드를 작성하려고 하면 참고해보시면 좋을 것 같아요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":8},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003einstrumentation.js\u003c/h1\u003e\n\u003cp\u003einstrumentation.js|ts 파일은 애플리케이션에 관찰 가능성(Observability) 도구를 통합하는 용도로 사용돼요. 이를 통해 애플리케이션의 성능과 동작을 추적할 수 있고, 실제 서비스 중에 발생하는 문제를 더 효과적으로 디버깅할 수 있답니다.\u003c/p\u003e\n\u003cp\u003e사용법도 간단해요! 프로젝트 루트 디렉토리에 파일을 두거나, 만약 src 폴더를 사용한다면 그 안에 넣으면 되죠.\u003c/p\u003e\n\u003ch2\u003e파일에서 제공하는 주요 기능 (Exports)\u003c/h2\u003e\n\u003cp\u003e(여기에 실제로 어떤 내용이 export 되는지 명시되어야 하는데요, 이어서 있으면 같이 정리해보겠습니다.)\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e조금 더 알아두면 좋은 점!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e관찰 가능성 도구에는 여러 가지가 있는데, 예를 들어 로그 수집, 메트릭 수집, 트레이싱 등이 있어요. instrumentation.js를 통해 이런 도구들을 한 곳에 모아 효율적으로 관리할 수 있어요.\u003c/li\u003e\n\u003cli\u003e실제 운영 환경에서 문제가 발생했을 때, 미리 설정한 instrumentation 덕분에 원인을 빠르게 파악할 수 있으니 개발, 운영 모두에 큰 도움이 된답니다.\u003c/li\u003e\n\u003cli\u003eTypeScript를 사용한다면 .ts 확장자를 사용해 타입 안정성을 더할 수도 있어요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음에는 instrumentation.js 안에 어떤 코드가 들어가는지, 구체적인 예시를 하나씩 살펴보도록 할게요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003eregister (선택 사항)\u003c/h3\u003e\n\u003cp\u003eNext.js 서버가 새로 시작될 때 한 번 호출되는 \u003ccode\u003eregister\u003c/code\u003e 함수를 파일에서 export할 수 있어요. 이 함수는 async 함수여도 되고, 주로 초기 설정이나 라이브러리 등록 같은 작업에 사용되죠.\u003c/p\u003e\n\u003cp\u003e예를 들어, 아래처럼 OpenTelemetry를 연동하는 작업을 할 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { registerOTel } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@vercel/otel'\u003c/span\u003e\n \n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eregister\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-title function_\"\u003eregisterOTel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'next-app'\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드에서 \u003ccode\u003eregisterOTel\u003c/code\u003e 함수는 'next-app'이라는 이름으로 OpenTelemetry를 설정해주는 역할을 해요. 이 부분은 프로젝트에서 필요한 모니터링이나 트레이싱을 할 때 유용하답니다.\u003c/p\u003e\n\u003ch3\u003eonRequestError (선택 사항)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eonRequestError\u003c/code\u003e 함수도 선택 사항인데요, 이 함수는 HTTP 요청 중 에러가 발생했을 때 실행되도록 만들어져 있어요. 만약 API 라우트나 서버 함수에서 에러 로그를 따로 남기거나 오류를 처리하고 싶을 때 이 함수를 정의해서 사용할 수 있답니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e참고로, \u003ccode\u003eregister\u003c/code\u003e 함수 같은 초기화 함수는 앱이 구동될 때 한 번만 실행되기 때문에 무거운 초기 작업이나 설정을 이곳에 모아두면 깔끔하게 관리할 수 있어요. Next.js를 활용할 때, 이런 선택적 함수들로 서버 사이드의 세밀한 로직을 다루는 팁을 꼭 알아두시면 좋아요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eNext.js에서 onRequestError라는 함수를 선택적으로 내보내서 서버 에러를 커스텀한 관측(Observability) 도구로 추적할 수 있어요.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e만약 onRequestError 안에서 비동기 작업을 한다면 꼭 \u003ccode\u003eawait\u003c/code\u003e 해줘야 해요. 이 함수는 Next.js 서버가 에러를 포착할 때 실행되거든요.\u003c/li\u003e\n\u003cli\u003e여기서 주의할 점! 에러 인스턴스가 실제로 던져진 원본 에러가 아닐 수도 있어요. 특히 Server Components 렌더링 도중 React가 처리한 에러라면 그럴 수 있는데, 이럴 때는 에러 객체의 \u003ccode\u003edigest\u003c/code\u003e 속성을 이용해서 실제 에러 타입을 확인할 수 있답니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e아래 코드를 보면 실제로 onRequestError에서 에러 정보를 외부 서버로 POST 요청을 보내서 보고하는 간단한 예시를 보여주고 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { type \u003cspan class=\"hljs-title class_\"\u003eInstrumentation\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next'\u003c/span\u003e\n \n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonRequestError\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eInstrumentation\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eonRequestError\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (\n  err,\n  request,\n  context\n) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'https://.../report-error'\u003c/span\u003e, {\n    \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'POST'\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003estringify\u003c/span\u003e({\n      \u003cspan class=\"hljs-attr\"\u003emessage\u003c/span\u003e: err.\u003cspan class=\"hljs-property\"\u003emessage\u003c/span\u003e,\n      request,\n      context,\n    }),\n    \u003cspan class=\"hljs-attr\"\u003eheaders\u003c/span\u003e: {\n      \u003cspan class=\"hljs-string\"\u003e'Content-Type'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'application/json'\u003c/span\u003e,\n    },\n  })\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eonRequestError 함수 파라미터\u003c/h3\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e파라미터명\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eerr\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e발생한 에러 객체입니다. React가 가공할 수도 있어요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003erequest\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e현재 요청 정보가 담긴 객체입니다.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003econtext\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e요청에 관련된 추가 컨텍스트 정보가 들어있습니다.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e이걸 활용하면 서버 에러를 커스텀 로그 서버나 Sentry, Datadog 같은 외부 모니터링 서비스에 손쉽게 연결할 수 있어요. 특히 여러 비동기 작업을 할 때 \u003ccode\u003eawait\u003c/code\u003e를 빠뜨리지 않도록 주의해주세요! 안 그러면 에러 추적이 중간에 끊길 수 있거든요.\u003c/p\u003e\n\u003cp\u003e그리고 \u003ccode\u003edigest\u003c/code\u003e 프로퍼티를 써서 에러 타입을 확인하는 팁! React에서 처리된 에러는 내부적으론 변형될 수 있기 때문에, 원래 에러를 정확히 파악하려면 이걸 참고하면 좋아요.\u003c/p\u003e\n\u003cp\u003e이 기능을 잘 쓰면 서버 안정성 모니터링에 훨씬 도움 돼서, 문제 발생 시 빠르게 대응 가능하니 꼭 한번 적용해보시길 추천드립니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이번에는 \u003ccode\u003eonRequestError\u003c/code\u003e 함수에 대해 알아볼게요. 이 함수는 에러가 발생했을 때 호출되며, 세 가지 매개변수를 받아요: \u003ccode\u003eerror\u003c/code\u003e, \u003ccode\u003erequest\u003c/code\u003e, 그리고 \u003ccode\u003econtext\u003c/code\u003e입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-ts\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eonRequestError\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\n  error: { digest: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e } \u0026#x26; \u003cspan class=\"hljs-built_in\"\u003eError\u003c/span\u003e,\n  request: {\n    path: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e; // 리소스 경로, 예: /blog?name=foo\n    method: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e; // 요청 메서드, 예: GET, POST 등\n    headers: { [key: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e]: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e };\n  },\n  context: {\n    routerKind: \u003cspan class=\"hljs-string\"\u003e'Pages Router'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'App Router'\u003c/span\u003e; // 사용하는 라우터 종류\n    routePath: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e; // 라우트 파일 경로, 예: /app/blog/[dynamic]\n    routeType: \u003cspan class=\"hljs-string\"\u003e'render'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'route'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'action'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'middleware'\u003c/span\u003e; // 에러 발생 컨텍스트\n    renderSource:\n      | \u003cspan class=\"hljs-string\"\u003e'react-server-components'\u003c/span\u003e\n      | \u003cspan class=\"hljs-string\"\u003e'react-server-components-payload'\u003c/span\u003e\n      | \u003cspan class=\"hljs-string\"\u003e'server-rendering'\u003c/span\u003e; // 렌더링 소스\n    revalidateReason: \u003cspan class=\"hljs-string\"\u003e'on-demand'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'stale'\u003c/span\u003e | \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e; // 재검증 사유, \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e 는 일반 요청 의미\n    renderType: \u003cspan class=\"hljs-string\"\u003e'dynamic'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'dynamic-resume'\u003c/span\u003e; // \u003cspan class=\"hljs-string\"\u003e'dynamic-resume'\u003c/span\u003e은 PPR 사용 시\n  }\n\u003c/span\u003e): \u003cspan class=\"hljs-built_in\"\u003evoid\u003c/span\u003e | \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-built_in\"\u003evoid\u003c/span\u003e\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e파라미터\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eerror\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e발생한 실제 에러, 고유 ID인 \u003ccode\u003edigest\u003c/code\u003e 포함\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003erequest\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e에러와 관련된 요청 정보\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003econtext\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e에러가 발생한 환경 정보를 담고 있음\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e파라미터 자세히 살펴보기\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eerror\u003c/code\u003e: 항상 Error 타입이며, 여기에 \u003ccode\u003edigest\u003c/code\u003e라는 고유 ID가 있어 에러를 추적하기 좋습니다. 예를 들어, 같은 에러가 여러 번 발생할 경우 이 ID로 쉽게 분류할 수 있죠.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erequest\u003c/code\u003e: 실제 요청 정보입니다. 어떤 경로(\u003ccode\u003epath\u003c/code\u003e)로, 어떤 메서드(\u003ccode\u003emethod\u003c/code\u003e)가 쓰였고, 헤더에는 어떤 정보가 담겨있는지 확인할 수 있어요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtext\u003c/code\u003e: 어느 라우터에서 발생했는지(\u003ccode\u003erouterKind\u003c/code\u003e), 어떤 라우트 파일에서 발생했는지(\u003ccode\u003eroutePath\u003c/code\u003e), 그리고 에러가 일어난 시점(\u003ccode\u003erouteType\u003c/code\u003e)을 알려줍니다. 렌더링 소스(\u003ccode\u003erenderSource\u003c/code\u003e)나 재검증 사유(\u003ccode\u003erevalidateReason\u003c/code\u003e)도 담겨있어, 상황별 대응에 유용해요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e추가 팁: 왜 이렇게 복잡한 정보가 필요할까?\u003c/h3\u003e\n\u003cp\u003e에러 핸들링은 단순히 에러 메시지를 로그에 남기는 걸 넘어서, 상황에 맞게 대처하거나 사용자에게 정확한 안내를 해주는 데 중요해요. 예를 들어 \u003ccode\u003erevalidateReason\u003c/code\u003e이 \u003ccode\u003e'stale'\u003c/code\u003e이면 캐시된 데이터를 다시 불러오는 중 문제가 생긴 거고, 이를 활용하면 재시도 로직이나 사용자 안내 메시지를 다르게 할 수 있겠죠.\u003c/p\u003e\n\u003cp\u003e최근 Next.js 같은 프레임워크가 여러 라우터 시스템과 다양한 렌더링 방식을 지원하면서, 이런 세분화된 정보가 꼭 필요해졌답니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e다음에 이어서 \u003ccode\u003e### Specifying the runtime\u003c/code\u003e 부분도 한 번 살펴볼게요! 혹시 여기까지 궁금한 점 있으면 댓글로 물어봐 주세요 :)\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003einstrumentation.js 파일은 Node.js와 Edge 런타임 둘 다에서 동작하는데요, 만약 특정 런타임을 대상으로 하고 싶다면 process.env.NEXT_RUNTIME 값을 활용하면 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eregister\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (process.\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eNEXT_RUNTIME\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e'edge'\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'./register.edge'\u003c/span\u003e)\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'./register.node'\u003c/span\u003e)\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eonRequestError\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (process.\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eNEXT_RUNTIME\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e'edge'\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'./on-request-error.edge'\u003c/span\u003e)\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'./on-request-error.node'\u003c/span\u003e)\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 중요한 점은 process.env.NEXT_RUNTIME이 'edge'인지 아닌지에 따라서 각각 다른 모듈을 require해서 사용하는 방식이에요. 이렇게 하면 동일한 코드베이스에서 런타임 환경에 맞게 동작 방식을 유연하게 바꿀 수 있어서 정말 편리합니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e버전 히스토리\u003c/h2\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eVersion\u003c/th\u003e\u003cth\u003eChanges\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003ev15.0.0\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eonRequestError\u003c/code\u003e 추가, \u003ccode\u003einstrumentation\u003c/code\u003e 안정화\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003ev14.0.4\u003c/td\u003e\u003ctd\u003e\u003ccode\u003einstrumentation\u003c/code\u003e에 Turbopack 지원 추가\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003ev13.2.0\u003c/td\u003e\u003ctd\u003e\u003ccode\u003einstrumentation\u003c/code\u003e 실험적 기능으로 처음 소개\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e버전 히스토리를 보면 알 수 있듯, instrumentation 기능이 처음에는 실험적으로 도입됐다가 이후 안정화 되고, Turbopack 같은 최신 툴도 지원이 추가되면서 점점 완성도 있게 발전해온 걸 확인할 수 있어요.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e개발할 때 runtime 환경 구분이 필요한 경우에는 이렇게 환경변수를 통해 동적으로 모듈을 분기하는 패턴을 자주 쓰게 되는데, Next.js 같은 프레임워크에서 공식적으로 지원하니까 훨씬 편하게 적용할 수 있는 것 같더라고요. 혹시 특정 런타임에서만 동작하는 코드를 작성하려고 하면 참고해보시면 좋을 것 같아요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2025-04-22-instrumentationjs"},"buildId":"olPs1cVezSGTqD7OaewDI","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>