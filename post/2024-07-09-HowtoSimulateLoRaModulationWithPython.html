<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Python으로 LoRa 모듈레이션 시뮬레이션 하는 방법 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2024-07-09-HowtoSimulateLoRaModulationWithPython" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Python으로 LoRa 모듈레이션 시뮬레이션 하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:title" content="Python으로 LoRa 모듈레이션 시뮬레이션 하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-07-09-HowtoSimulateLoRaModulationWithPython_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2024-07-09-HowtoSimulateLoRaModulationWithPython" data-gatsby-head="true"/><meta name="twitter:title" content="Python으로 LoRa 모듈레이션 시뮬레이션 하는 방법 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-07-09-HowtoSimulateLoRaModulationWithPython_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-09 09:09" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/TIL/_next/static/chunks/463-925361deb4cec4b1.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-9d7ebbd29b9e08ce.js" defer=""></script><script src="/TIL/_next/static/OY-qm1-_Mz9jLZ5863EbF/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/OY-qm1-_Mz9jLZ5863EbF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Python으로 LoRa 모듈레이션 시뮬레이션 하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Python으로 LoRa 모듈레이션 시뮬레이션 하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 9, 2024</span><span class="posts_reading_time__f7YPP">6<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-07-09-HowtoSimulateLoRaModulationWithPython&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>소개</h1>
<p>LoRa (Long Range) 변조는 저전력 소비로 장거리 데이터 전송이 가능하게 하는 무선 통신 기술로, 사물 인터넷(IoT) 응용 프로그램에 이상적입니다. 치르프 스프레드 스펙트럼(CSS) 기술을 활용하여, LoRa 변조는 신호를 넓은 주파수 범위에 퍼뜨려 간섭에 대한 저항성을 향상시키고 데이터 전송의 견고성을 향상시킵니다. 이 변조 방법은 다른 통신 기술이 장애물이나 소음으로 인해 어려움을 겪는 환경에서 특히 효과적입니다. 멀리 떨어진 네트워크를 구축하고 확장 가능한 IoT 네트워크를 지원하기 위해 장거리 기능과 최소한의 에너지 요구 사항을 결합한 LoRa 변조는 스마트 시티, 농업 모니터링 및 산업 자동화와 같은 응용 프로그램을 용이하게합니다.</p>
<h1>매개변수 정의</h1>
<p>코드의 첫 번째 섹션은 LoRa 조작에 사용되는 매개변수를 정의합니다. 대역폭 B는 125 kHz (125e3)로 설정되고 샘플링 주기 T는 대역폭의 역수로 계산됩니다. 즉, T = 1 / B 입니다. 확산 계수(SF)는 7로 정의되어 있으며 LoRa 변조를 위한 전형적인 값으로 7에서 12 사이의 값으로 변할 수 있습니다. 이 계수는 심볼 주기 T_s를 결정하며, T_s = (2**SF) * T로 계산됩니다. 이러한 매개변수는 LoRa 시스템에서 심볼의 시간적 행동과 전송 속도를 정의하는 데 필수적입니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt

<span class="hljs-comment"># Parameters</span>
B = <span class="hljs-number">125e3</span>  <span class="hljs-comment"># (125 kHz) bandwidth</span>
T = <span class="hljs-number">1</span> / B  <span class="hljs-comment"># sampling period</span>
SF = <span class="hljs-number">7</span>  <span class="hljs-comment"># spreading factor {7,8,9,10,11,12}</span>
T_s = (<span class="hljs-number">2</span>**SF) * T  <span class="hljs-comment"># symbol period</span>
</code></pre>
<h1>심볼 계산</h1>
<p>이 코드 부분에서, 일곱 개 요소로 구성된 비트 벡터 w가 Spreading Factor (SF) 값에 해당하는 값으로 정의됩니다. 그런 다음 벡터 w는 10진수 값으로 변환됩니다. 먼저 변수 symbol이 0으로 설정됩니다. 그런 다음, for 루프는 w 벡터의 각 비트를 반복하며, 각 비트를 해당하는 <code>2**h</code> 값(여기서 h는 비트 인덱스)으로 곱한 다음 결과를 symbol 변수에 추가합니다. 이 프로세스는 이진 벡터를 변조할 심볼을 나타내는 10진수 값으로 변환합니다. 이 계산은 LoRa 변조에 있어서 중요하며, 디지털 정보를 전송에 적합한 형식으로 변환합니다.</p>
<pre><code class="hljs language-python">w = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]

symbol = <span class="hljs-number">0</span>

<span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(SF):
    symbol += w[h] * (<span class="hljs-number">2</span>**h)
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>시간 및 시간 인덱스 벡터 생성 및 Chirp 계산하기</h1>
<p>코드의 세 번째 부분은 Chirp 신호를 생성하는 데 필요한 시간 벡터를 만듭니다. t 벡터는 np.linspace 함수를 사용하여 생성되며, 이 함수는 0부터 T_s까지 num 개의 동일 간격으로 나누어진 점을 생성합니다. 점의 개수 num은 int(T_s / T)로 계산되어 샘플링 주기 T에 따라 점이 적절히 간격을 두고 생성됩니다. 그다음, k 벡터는 np.arange를 사용하여 생성되는데, len(t)까지 0.01의 간격으로 동일하게 나뉜 값을 생성합니다. 그리고 Chirp 신호는 chirp = np.exp(1j * 2 * np.pi * ((symbol + k) % (2<strong>SF)) / (2</strong>SF) * k) 공식을 사용하여 계산됩니다. 여기서, 1j는 허수 단위를 나타냅니다.</p>
<pre><code class="hljs language-js">t = np.<span class="hljs-title function_">linspace</span>(start=<span class="hljs-number">0</span>, stop=T_s, num=<span class="hljs-title function_">int</span>(T_s / T))

k = np.<span class="hljs-title function_">arange</span>(start=<span class="hljs-number">0</span>, stop=<span class="hljs-title function_">len</span>(t), step=<span class="hljs-number">0.01</span>)

# <span class="hljs-title class_">Chirp</span> 공식
chirp = np.<span class="hljs-title function_">exp</span>(1j * <span class="hljs-number">2</span> * np.<span class="hljs-property">pi</span> * ((symbol + k) % (<span class="hljs-number">2</span>**<span class="hljs-variable constant_">SF</span>)) / (<span class="hljs-number">2</span>**<span class="hljs-variable constant_">SF</span>) * k)
</code></pre>
<h1>Chirp 신호들의 플로팅</h1>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>코드의 마지막 부분은 생성된 Chirp 신호를 시각화하는 부분입니다. 새로운 그림이 plt.figure(figsize=(10, 6))를 사용하여 10x6 인치 크기로 만들어집니다. Chirp 신호는 두 개의 서브플롯에 플로팅됩니다. 첫 번째 서브플롯(plt.subplot(2, 1, 1))은 plt.plot(k, chirp.real, label='실수부', color='blue') 함수를 사용하여 Chirp 신호의 실수부를 플로팅합니다. 제목, 축 레이블, 그리드 및 범례가 플롯에 추가되어 가독성과 데이터 해석이 향상됩니다. 두 번째 서브플롯(plt.subplot(2, 1, 2))은 plt.plot(k, chirp.imag, label='허수부', color='orange') 함수를 사용하여 Chirp 신호의 허수부를 플로팅하며, 마찬가지로 제목, 레이블, 그리드, 범례가 추가됩니다. 마지막으로 plt.tight_layout()은 서브플롯을 자동으로 조절하여 그림에 맞게 조절하고, plt.show()는 그림을 표시합니다. 이 시각화를 통해 Chirp 신호의 특성을 분석할 수 있습니다. 실수 및 허수부 모두를 통해 변조된 신호에 대한 완전한 이해를 제공합니다.</p>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Chirp</span> 신호 플로팅
plt.<span class="hljs-title function_">figure</span>(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))

# <span class="hljs-title class_">Chirp</span> 실수부 플로팅 
plt.<span class="hljs-title function_">subplot</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)
plt.<span class="hljs-title function_">plot</span>(k, chirp.<span class="hljs-property">real</span>, label=<span class="hljs-string">'실수부'</span>, color=<span class="hljs-string">'blue'</span>)
plt.<span class="hljs-title function_">title</span>(<span class="hljs-string">'LoRa 신호 - s(t)의 실수부'</span>)
plt.<span class="hljs-title function_">xlabel</span>(<span class="hljs-string">'시간 색인 [k]'</span>)
plt.<span class="hljs-title function_">ylabel</span>(<span class="hljs-string">'진폭 [mW]'</span>)
plt.<span class="hljs-title function_">grid</span>(<span class="hljs-title class_">True</span>)
plt.<span class="hljs-title function_">legend</span>()

# <span class="hljs-title class_">Chirp</span> 허수부 플로팅
plt.<span class="hljs-title function_">subplot</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
plt.<span class="hljs-title function_">plot</span>(k, chirp.<span class="hljs-property">imag</span>, label=<span class="hljs-string">'허수부'</span>, color=<span class="hljs-string">'orange'</span>)
plt.<span class="hljs-title function_">title</span>(<span class="hljs-string">'LoRa 신호 - s(t)의 허수부'</span>)
plt.<span class="hljs-title function_">xlabel</span>(<span class="hljs-string">'시간 색인 [k]'</span>)
plt.<span class="hljs-title function_">ylabel</span>(<span class="hljs-string">'진폭 [mW]'</span>)
plt.<span class="hljs-title function_">grid</span>(<span class="hljs-title class_">True</span>)
plt.<span class="hljs-title function_">legend</span>()

plt.<span class="hljs-title function_">tight_layout</span>()
plt.<span class="hljs-title function_">show</span>()
</code></pre>
<img src="/assets/img/2024-07-09-HowtoSimulateLoRaModulationWithPython_0.png">
<p>의견과 피드백은 댓글에서 환영합니다. 여기 테스트 용 전체 코드가 있습니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> matplotlib.<span class="hljs-property">pyplot</span> <span class="hljs-keyword">as</span> plt

# <span class="hljs-title class_">Parameters</span>
B = <span class="hljs-number">125e3</span>  # (<span class="hljs-number">125</span> kHz) 대역폭
T = <span class="hljs-number">1</span> / B  # 샘플링 주기
<span class="hljs-variable constant_">SF</span> = <span class="hljs-number">7</span>  # 확산 계수 {<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>}
T_s = (<span class="hljs-number">2</span>**<span class="hljs-variable constant_">SF</span>) * T  # 심볼 주기

w = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]

symbol = <span class="hljs-number">0</span>

<span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-variable constant_">SF</span>):
    symbol += w[h] * (<span class="hljs-number">2</span>**h)

t = np.<span class="hljs-title function_">linspace</span>(start=<span class="hljs-number">0</span>, stop=T_s, num=<span class="hljs-title function_">int</span>(T_s / T))

k = np.<span class="hljs-title function_">arange</span>(start=<span class="hljs-number">0</span>, stop=<span class="hljs-title function_">len</span>(t), step=<span class="hljs-number">0.01</span>)

# 칩 신호 공식
chirp = np.<span class="hljs-title function_">exp</span>(1j * <span class="hljs-number">2</span> * np.<span class="hljs-property">pi</span> * ((symbol + k) % (<span class="hljs-number">2</span>**<span class="hljs-variable constant_">SF</span>)) / (<span class="hljs-number">2</span>**<span class="hljs-variable constant_">SF</span>) * k)

# 칩 신호 플롯
plt.<span class="hljs-title function_">figure</span>(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))

# 칩의 실수부 플롯
plt.<span class="hljs-title function_">subplot</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)
plt.<span class="hljs-title function_">plot</span>(k, chirp.<span class="hljs-property">real</span>, label=<span class="hljs-string">'실수부'</span>, color=<span class="hljs-string">'blue'</span>)
plt.<span class="hljs-title function_">title</span>(<span class="hljs-string">'LoRa 신호 - s(t)의 실수부'</span>)
plt.<span class="hljs-title function_">xlabel</span>(<span class="hljs-string">'시간 인덱스 [k]'</span>)
plt.<span class="hljs-title function_">ylabel</span>(<span class="hljs-string">'진폭 [mW]'</span>)
plt.<span class="hljs-title function_">grid</span>(<span class="hljs-title class_">True</span>)
plt.<span class="hljs-title function_">legend</span>()

# 칩의 허수부 플롯
plt.<span class="hljs-title function_">subplot</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
plt.<span class="hljs-title function_">plot</span>(k, chirp.<span class="hljs-property">imag</span>, label=<span class="hljs-string">'허수부'</span>, color=<span class="hljs-string">'orange'</span>)
plt.<span class="hljs-title function_">title</span>(<span class="hljs-string">'LoRa 신호 - s(t)의 허수부'</span>)
plt.<span class="hljs-title function_">xlabel</span>(<span class="hljs-string">'시간 인덱스 [k]'</span>)
plt.<span class="hljs-title function_">ylabel</span>(<span class="hljs-string">'진폭 [mW]'</span>)
plt.<span class="hljs-title function_">grid</span>(<span class="hljs-title class_">True</span>)
plt.<span class="hljs-title function_">legend</span>()

plt.<span class="hljs-title function_">tight_layout</span>()
plt.<span class="hljs-title function_">show</span>()
</code></pre>
<h1>참고 자료</h1>
<p>VANGELISTA, Lorenzo. Frequency shift chirp modulation: The LoRa modulation. IEEE signal processing letters, v. 24, n. 12, p. 1818–1821, 2017.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Python으로 LoRa 모듈레이션 시뮬레이션 하는 방법","description":"","date":"2024-07-09 09:09","slug":"2024-07-09-HowtoSimulateLoRaModulationWithPython","content":"\n\n# 소개\n\nLoRa (Long Range) 변조는 저전력 소비로 장거리 데이터 전송이 가능하게 하는 무선 통신 기술로, 사물 인터넷(IoT) 응용 프로그램에 이상적입니다. 치르프 스프레드 스펙트럼(CSS) 기술을 활용하여, LoRa 변조는 신호를 넓은 주파수 범위에 퍼뜨려 간섭에 대한 저항성을 향상시키고 데이터 전송의 견고성을 향상시킵니다. 이 변조 방법은 다른 통신 기술이 장애물이나 소음으로 인해 어려움을 겪는 환경에서 특히 효과적입니다. 멀리 떨어진 네트워크를 구축하고 확장 가능한 IoT 네트워크를 지원하기 위해 장거리 기능과 최소한의 에너지 요구 사항을 결합한 LoRa 변조는 스마트 시티, 농업 모니터링 및 산업 자동화와 같은 응용 프로그램을 용이하게합니다.\n\n# 매개변수 정의\n\n코드의 첫 번째 섹션은 LoRa 조작에 사용되는 매개변수를 정의합니다. 대역폭 B는 125 kHz (125e3)로 설정되고 샘플링 주기 T는 대역폭의 역수로 계산됩니다. 즉, T = 1 / B 입니다. 확산 계수(SF)는 7로 정의되어 있으며 LoRa 변조를 위한 전형적인 값으로 7에서 12 사이의 값으로 변할 수 있습니다. 이 계수는 심볼 주기 T_s를 결정하며, T_s = (2**SF) * T로 계산됩니다. 이러한 매개변수는 LoRa 시스템에서 심볼의 시간적 행동과 전송 속도를 정의하는 데 필수적입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Parameters\nB = 125e3  # (125 kHz) bandwidth\nT = 1 / B  # sampling period\nSF = 7  # spreading factor {7,8,9,10,11,12}\nT_s = (2**SF) * T  # symbol period\n```\n\n# 심볼 계산\n\n이 코드 부분에서, 일곱 개 요소로 구성된 비트 벡터 w가 Spreading Factor (SF) 값에 해당하는 값으로 정의됩니다. 그런 다음 벡터 w는 10진수 값으로 변환됩니다. 먼저 변수 symbol이 0으로 설정됩니다. 그런 다음, for 루프는 w 벡터의 각 비트를 반복하며, 각 비트를 해당하는 `2**h` 값(여기서 h는 비트 인덱스)으로 곱한 다음 결과를 symbol 변수에 추가합니다. 이 프로세스는 이진 벡터를 변조할 심볼을 나타내는 10진수 값으로 변환합니다. 이 계산은 LoRa 변조에 있어서 중요하며, 디지털 정보를 전송에 적합한 형식으로 변환합니다.\n\n```python\nw = [1, 1, 0, 1, 0, 1, 1]\n\nsymbol = 0\n\nfor h in range(SF):\n    symbol += w[h] * (2**h)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 시간 및 시간 인덱스 벡터 생성 및 Chirp 계산하기\n\n코드의 세 번째 부분은 Chirp 신호를 생성하는 데 필요한 시간 벡터를 만듭니다. t 벡터는 np.linspace 함수를 사용하여 생성되며, 이 함수는 0부터 T_s까지 num 개의 동일 간격으로 나누어진 점을 생성합니다. 점의 개수 num은 int(T_s / T)로 계산되어 샘플링 주기 T에 따라 점이 적절히 간격을 두고 생성됩니다. 그다음, k 벡터는 np.arange를 사용하여 생성되는데, len(t)까지 0.01의 간격으로 동일하게 나뉜 값을 생성합니다. 그리고 Chirp 신호는 chirp = np.exp(1j * 2 * np.pi * ((symbol + k) % (2**SF)) / (2**SF) * k) 공식을 사용하여 계산됩니다. 여기서, 1j는 허수 단위를 나타냅니다.\n\n```js\nt = np.linspace(start=0, stop=T_s, num=int(T_s / T))\n\nk = np.arange(start=0, stop=len(t), step=0.01)\n\n# Chirp 공식\nchirp = np.exp(1j * 2 * np.pi * ((symbol + k) % (2**SF)) / (2**SF) * k)\n``` \n\n# Chirp 신호들의 플로팅\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n코드의 마지막 부분은 생성된 Chirp 신호를 시각화하는 부분입니다. 새로운 그림이 plt.figure(figsize=(10, 6))를 사용하여 10x6 인치 크기로 만들어집니다. Chirp 신호는 두 개의 서브플롯에 플로팅됩니다. 첫 번째 서브플롯(plt.subplot(2, 1, 1))은 plt.plot(k, chirp.real, label='실수부', color='blue') 함수를 사용하여 Chirp 신호의 실수부를 플로팅합니다. 제목, 축 레이블, 그리드 및 범례가 플롯에 추가되어 가독성과 데이터 해석이 향상됩니다. 두 번째 서브플롯(plt.subplot(2, 1, 2))은 plt.plot(k, chirp.imag, label='허수부', color='orange') 함수를 사용하여 Chirp 신호의 허수부를 플로팅하며, 마찬가지로 제목, 레이블, 그리드, 범례가 추가됩니다. 마지막으로 plt.tight_layout()은 서브플롯을 자동으로 조절하여 그림에 맞게 조절하고, plt.show()는 그림을 표시합니다. 이 시각화를 통해 Chirp 신호의 특성을 분석할 수 있습니다. 실수 및 허수부 모두를 통해 변조된 신호에 대한 완전한 이해를 제공합니다.\n\n```js\n# Chirp 신호 플로팅\nplt.figure(figsize=(10, 6))\n\n# Chirp 실수부 플로팅 \nplt.subplot(2, 1, 1)\nplt.plot(k, chirp.real, label='실수부', color='blue')\nplt.title('LoRa 신호 - s(t)의 실수부')\nplt.xlabel('시간 색인 [k]')\nplt.ylabel('진폭 [mW]')\nplt.grid(True)\nplt.legend()\n\n# Chirp 허수부 플로팅\nplt.subplot(2, 1, 2)\nplt.plot(k, chirp.imag, label='허수부', color='orange')\nplt.title('LoRa 신호 - s(t)의 허수부')\nplt.xlabel('시간 색인 [k]')\nplt.ylabel('진폭 [mW]')\nplt.grid(True)\nplt.legend()\n\nplt.tight_layout()\nplt.show()\n```\n\n\u003cimg src=\"/assets/img/2024-07-09-HowtoSimulateLoRaModulationWithPython_0.png\" /\u003e\n\n의견과 피드백은 댓글에서 환영합니다. 여기 테스트 용 전체 코드가 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Parameters\nB = 125e3  # (125 kHz) 대역폭\nT = 1 / B  # 샘플링 주기\nSF = 7  # 확산 계수 {7,8,9,10,11,12}\nT_s = (2**SF) * T  # 심볼 주기\n\nw = [1, 1, 0, 1, 0, 1, 1]\n\nsymbol = 0\n\nfor h in range(SF):\n    symbol += w[h] * (2**h)\n\nt = np.linspace(start=0, stop=T_s, num=int(T_s / T))\n\nk = np.arange(start=0, stop=len(t), step=0.01)\n\n# 칩 신호 공식\nchirp = np.exp(1j * 2 * np.pi * ((symbol + k) % (2**SF)) / (2**SF) * k)\n\n# 칩 신호 플롯\nplt.figure(figsize=(10, 6))\n\n# 칩의 실수부 플롯\nplt.subplot(2, 1, 1)\nplt.plot(k, chirp.real, label='실수부', color='blue')\nplt.title('LoRa 신호 - s(t)의 실수부')\nplt.xlabel('시간 인덱스 [k]')\nplt.ylabel('진폭 [mW]')\nplt.grid(True)\nplt.legend()\n\n# 칩의 허수부 플롯\nplt.subplot(2, 1, 2)\nplt.plot(k, chirp.imag, label='허수부', color='orange')\nplt.title('LoRa 신호 - s(t)의 허수부')\nplt.xlabel('시간 인덱스 [k]')\nplt.ylabel('진폭 [mW]')\nplt.grid(True)\nplt.legend()\n\nplt.tight_layout()\nplt.show()\n```\n\n# 참고 자료\n\nVANGELISTA, Lorenzo. Frequency shift chirp modulation: The LoRa modulation. IEEE signal processing letters, v. 24, n. 12, p. 1818–1821, 2017.","ogImage":{"url":"/assets/img/2024-07-09-HowtoSimulateLoRaModulationWithPython_0.png"},"coverImage":"/assets/img/2024-07-09-HowtoSimulateLoRaModulationWithPython_0.png","tag":["Tech"],"readingTime":6},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003e소개\u003c/h1\u003e\n\u003cp\u003eLoRa (Long Range) 변조는 저전력 소비로 장거리 데이터 전송이 가능하게 하는 무선 통신 기술로, 사물 인터넷(IoT) 응용 프로그램에 이상적입니다. 치르프 스프레드 스펙트럼(CSS) 기술을 활용하여, LoRa 변조는 신호를 넓은 주파수 범위에 퍼뜨려 간섭에 대한 저항성을 향상시키고 데이터 전송의 견고성을 향상시킵니다. 이 변조 방법은 다른 통신 기술이 장애물이나 소음으로 인해 어려움을 겪는 환경에서 특히 효과적입니다. 멀리 떨어진 네트워크를 구축하고 확장 가능한 IoT 네트워크를 지원하기 위해 장거리 기능과 최소한의 에너지 요구 사항을 결합한 LoRa 변조는 스마트 시티, 농업 모니터링 및 산업 자동화와 같은 응용 프로그램을 용이하게합니다.\u003c/p\u003e\n\u003ch1\u003e매개변수 정의\u003c/h1\u003e\n\u003cp\u003e코드의 첫 번째 섹션은 LoRa 조작에 사용되는 매개변수를 정의합니다. 대역폭 B는 125 kHz (125e3)로 설정되고 샘플링 주기 T는 대역폭의 역수로 계산됩니다. 즉, T = 1 / B 입니다. 확산 계수(SF)는 7로 정의되어 있으며 LoRa 변조를 위한 전형적인 값으로 7에서 12 사이의 값으로 변할 수 있습니다. 이 계수는 심볼 주기 T_s를 결정하며, T_s = (2**SF) * T로 계산됩니다. 이러한 매개변수는 LoRa 시스템에서 심볼의 시간적 행동과 전송 속도를 정의하는 데 필수적입니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e numpy \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e np\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e matplotlib.pyplot \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e plt\n\n\u003cspan class=\"hljs-comment\"\u003e# Parameters\u003c/span\u003e\nB = \u003cspan class=\"hljs-number\"\u003e125e3\u003c/span\u003e  \u003cspan class=\"hljs-comment\"\u003e# (125 kHz) bandwidth\u003c/span\u003e\nT = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e / B  \u003cspan class=\"hljs-comment\"\u003e# sampling period\u003c/span\u003e\nSF = \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e  \u003cspan class=\"hljs-comment\"\u003e# spreading factor {7,8,9,10,11,12}\u003c/span\u003e\nT_s = (\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e**SF) * T  \u003cspan class=\"hljs-comment\"\u003e# symbol period\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e심볼 계산\u003c/h1\u003e\n\u003cp\u003e이 코드 부분에서, 일곱 개 요소로 구성된 비트 벡터 w가 Spreading Factor (SF) 값에 해당하는 값으로 정의됩니다. 그런 다음 벡터 w는 10진수 값으로 변환됩니다. 먼저 변수 symbol이 0으로 설정됩니다. 그런 다음, for 루프는 w 벡터의 각 비트를 반복하며, 각 비트를 해당하는 \u003ccode\u003e2**h\u003c/code\u003e 값(여기서 h는 비트 인덱스)으로 곱한 다음 결과를 symbol 변수에 추가합니다. 이 프로세스는 이진 벡터를 변조할 심볼을 나타내는 10진수 값으로 변환합니다. 이 계산은 LoRa 변조에 있어서 중요하며, 디지털 정보를 전송에 적합한 형식으로 변환합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003ew = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]\n\nsymbol = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e h \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003erange\u003c/span\u003e(SF):\n    symbol += w[h] * (\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e**h)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e시간 및 시간 인덱스 벡터 생성 및 Chirp 계산하기\u003c/h1\u003e\n\u003cp\u003e코드의 세 번째 부분은 Chirp 신호를 생성하는 데 필요한 시간 벡터를 만듭니다. t 벡터는 np.linspace 함수를 사용하여 생성되며, 이 함수는 0부터 T_s까지 num 개의 동일 간격으로 나누어진 점을 생성합니다. 점의 개수 num은 int(T_s / T)로 계산되어 샘플링 주기 T에 따라 점이 적절히 간격을 두고 생성됩니다. 그다음, k 벡터는 np.arange를 사용하여 생성되는데, len(t)까지 0.01의 간격으로 동일하게 나뉜 값을 생성합니다. 그리고 Chirp 신호는 chirp = np.exp(1j * 2 * np.pi * ((symbol + k) % (2\u003cstrong\u003eSF)) / (2\u003c/strong\u003eSF) * k) 공식을 사용하여 계산됩니다. 여기서, 1j는 허수 단위를 나타냅니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003et = np.\u003cspan class=\"hljs-title function_\"\u003elinspace\u003c/span\u003e(start=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, stop=T_s, num=\u003cspan class=\"hljs-title function_\"\u003eint\u003c/span\u003e(T_s / T))\n\nk = np.\u003cspan class=\"hljs-title function_\"\u003earange\u003c/span\u003e(start=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, stop=\u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(t), step=\u003cspan class=\"hljs-number\"\u003e0.01\u003c/span\u003e)\n\n# \u003cspan class=\"hljs-title class_\"\u003eChirp\u003c/span\u003e 공식\nchirp = np.\u003cspan class=\"hljs-title function_\"\u003eexp\u003c/span\u003e(1j * \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e * np.\u003cspan class=\"hljs-property\"\u003epi\u003c/span\u003e * ((symbol + k) % (\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e**\u003cspan class=\"hljs-variable constant_\"\u003eSF\u003c/span\u003e)) / (\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e**\u003cspan class=\"hljs-variable constant_\"\u003eSF\u003c/span\u003e) * k)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eChirp 신호들의 플로팅\u003c/h1\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e코드의 마지막 부분은 생성된 Chirp 신호를 시각화하는 부분입니다. 새로운 그림이 plt.figure(figsize=(10, 6))를 사용하여 10x6 인치 크기로 만들어집니다. Chirp 신호는 두 개의 서브플롯에 플로팅됩니다. 첫 번째 서브플롯(plt.subplot(2, 1, 1))은 plt.plot(k, chirp.real, label='실수부', color='blue') 함수를 사용하여 Chirp 신호의 실수부를 플로팅합니다. 제목, 축 레이블, 그리드 및 범례가 플롯에 추가되어 가독성과 데이터 해석이 향상됩니다. 두 번째 서브플롯(plt.subplot(2, 1, 2))은 plt.plot(k, chirp.imag, label='허수부', color='orange') 함수를 사용하여 Chirp 신호의 허수부를 플로팅하며, 마찬가지로 제목, 레이블, 그리드, 범례가 추가됩니다. 마지막으로 plt.tight_layout()은 서브플롯을 자동으로 조절하여 그림에 맞게 조절하고, plt.show()는 그림을 표시합니다. 이 시각화를 통해 Chirp 신호의 특성을 분석할 수 있습니다. 실수 및 허수부 모두를 통해 변조된 신호에 대한 완전한 이해를 제공합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eChirp\u003c/span\u003e 신호 플로팅\nplt.\u003cspan class=\"hljs-title function_\"\u003efigure\u003c/span\u003e(figsize=(\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e))\n\n# \u003cspan class=\"hljs-title class_\"\u003eChirp\u003c/span\u003e 실수부 플로팅 \nplt.\u003cspan class=\"hljs-title function_\"\u003esubplot\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(k, chirp.\u003cspan class=\"hljs-property\"\u003ereal\u003c/span\u003e, label=\u003cspan class=\"hljs-string\"\u003e'실수부'\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'blue'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003etitle\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'LoRa 신호 - s(t)의 실수부'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003exlabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'시간 색인 [k]'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eylabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'진폭 [mW]'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003egrid\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003elegend\u003c/span\u003e()\n\n# \u003cspan class=\"hljs-title class_\"\u003eChirp\u003c/span\u003e 허수부 플로팅\nplt.\u003cspan class=\"hljs-title function_\"\u003esubplot\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(k, chirp.\u003cspan class=\"hljs-property\"\u003eimag\u003c/span\u003e, label=\u003cspan class=\"hljs-string\"\u003e'허수부'\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'orange'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003etitle\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'LoRa 신호 - s(t)의 허수부'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003exlabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'시간 색인 [k]'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eylabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'진폭 [mW]'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003egrid\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003elegend\u003c/span\u003e()\n\nplt.\u003cspan class=\"hljs-title function_\"\u003etight_layout\u003c/span\u003e()\nplt.\u003cspan class=\"hljs-title function_\"\u003eshow\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-07-09-HowtoSimulateLoRaModulationWithPython_0.png\"\u003e\n\u003cp\u003e의견과 피드백은 댓글에서 환영합니다. 여기 테스트 용 전체 코드가 있습니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e numpy \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e np\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e matplotlib.\u003cspan class=\"hljs-property\"\u003epyplot\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e plt\n\n# \u003cspan class=\"hljs-title class_\"\u003eParameters\u003c/span\u003e\nB = \u003cspan class=\"hljs-number\"\u003e125e3\u003c/span\u003e  # (\u003cspan class=\"hljs-number\"\u003e125\u003c/span\u003e kHz) 대역폭\nT = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e / B  # 샘플링 주기\n\u003cspan class=\"hljs-variable constant_\"\u003eSF\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e  # 확산 계수 {\u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e11\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e}\nT_s = (\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e**\u003cspan class=\"hljs-variable constant_\"\u003eSF\u003c/span\u003e) * T  # 심볼 주기\n\nw = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]\n\nsymbol = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e h \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eSF\u003c/span\u003e):\n    symbol += w[h] * (\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e**h)\n\nt = np.\u003cspan class=\"hljs-title function_\"\u003elinspace\u003c/span\u003e(start=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, stop=T_s, num=\u003cspan class=\"hljs-title function_\"\u003eint\u003c/span\u003e(T_s / T))\n\nk = np.\u003cspan class=\"hljs-title function_\"\u003earange\u003c/span\u003e(start=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, stop=\u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(t), step=\u003cspan class=\"hljs-number\"\u003e0.01\u003c/span\u003e)\n\n# 칩 신호 공식\nchirp = np.\u003cspan class=\"hljs-title function_\"\u003eexp\u003c/span\u003e(1j * \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e * np.\u003cspan class=\"hljs-property\"\u003epi\u003c/span\u003e * ((symbol + k) % (\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e**\u003cspan class=\"hljs-variable constant_\"\u003eSF\u003c/span\u003e)) / (\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e**\u003cspan class=\"hljs-variable constant_\"\u003eSF\u003c/span\u003e) * k)\n\n# 칩 신호 플롯\nplt.\u003cspan class=\"hljs-title function_\"\u003efigure\u003c/span\u003e(figsize=(\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e))\n\n# 칩의 실수부 플롯\nplt.\u003cspan class=\"hljs-title function_\"\u003esubplot\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(k, chirp.\u003cspan class=\"hljs-property\"\u003ereal\u003c/span\u003e, label=\u003cspan class=\"hljs-string\"\u003e'실수부'\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'blue'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003etitle\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'LoRa 신호 - s(t)의 실수부'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003exlabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'시간 인덱스 [k]'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eylabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'진폭 [mW]'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003egrid\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003elegend\u003c/span\u003e()\n\n# 칩의 허수부 플롯\nplt.\u003cspan class=\"hljs-title function_\"\u003esubplot\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(k, chirp.\u003cspan class=\"hljs-property\"\u003eimag\u003c/span\u003e, label=\u003cspan class=\"hljs-string\"\u003e'허수부'\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'orange'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003etitle\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'LoRa 신호 - s(t)의 허수부'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003exlabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'시간 인덱스 [k]'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eylabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'진폭 [mW]'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003egrid\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003elegend\u003c/span\u003e()\n\nplt.\u003cspan class=\"hljs-title function_\"\u003etight_layout\u003c/span\u003e()\nplt.\u003cspan class=\"hljs-title function_\"\u003eshow\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e참고 자료\u003c/h1\u003e\n\u003cp\u003eVANGELISTA, Lorenzo. Frequency shift chirp modulation: The LoRa modulation. IEEE signal processing letters, v. 24, n. 12, p. 1818–1821, 2017.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-09-HowtoSimulateLoRaModulationWithPython"},"buildId":"OY-qm1-_Mz9jLZ5863EbF","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>