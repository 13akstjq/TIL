<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>프로덕션에서 절대 사용하지 않을 9가지 Python 안티 패턴 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2024-07-14-9PythonAntiPatternsThatIWillNeverApplyinProduction" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="프로덕션에서 절대 사용하지 않을 9가지 Python 안티 패턴 | TIL" data-gatsby-head="true"/><meta property="og:title" content="프로덕션에서 절대 사용하지 않을 9가지 Python 안티 패턴 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/2024-07-14-9PythonAntiPatternsThatIWillNeverApplyinProduction_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2024-07-14-9PythonAntiPatternsThatIWillNeverApplyinProduction" data-gatsby-head="true"/><meta name="twitter:title" content="프로덕션에서 절대 사용하지 않을 9가지 Python 안티 패턴 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/2024-07-14-9PythonAntiPatternsThatIWillNeverApplyinProduction_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-14 20:45" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/0eef537492fed77a.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/0eef537492fed77a.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-8ded8b979ba73586.js" defer=""></script><script src="/TIL/_next/static/M7pU9hOcx8u_ZIFMf95sd/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/M7pU9hOcx8u_ZIFMf95sd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">프로덕션에서 절대 사용하지 않을 9가지 Python 안티 패턴</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="프로덕션에서 절대 사용하지 않을 9가지 Python 안티 패턴" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 14, 2024</span><span class="posts_reading_time__f7YPP">13<!-- --> min read</span></span></div></div></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>파이썬</h2>
<p><img src="/TIL/assets/img/2024-07-14-9PythonAntiPatternsThatIWillNeverApplyinProduction_0.png" alt="Python Anti-Patterns"></p>
<p>어떤 언어든, 오래된 만큼 반드시 몇 가지 안티-패턴 기능과 이해하기 어려운 구문이 있습니다.</p>
<p>파이썬이 우아한 언어라고 하더라도 이 운명에서 벗어날 수 없습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>소프트웨어 개발자로서 우리가 할 수 있는 것은 지식을 최신 상태로 유지하고 오래된 또는 부적절한 기능을 사용하지 않는 것입니다.</p>
<p>이 기사는 가독성, 보안 및 디버깅에 해로운 9가지 Python 안티 패턴에 대해 상기시킬 것입니다. 경험 많은 Python 엔지니어는 제품 개발 시 이러한 패턴을 적용해서는 안 됩니다.</p>
<h1>1. For-Else 구조</h1>
<p>Python에는 매우 특별한 구문인 for-else가 있습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>if-else가 아니라 for 루프 후에 "else"가 있다는 거야!</p>
<pre><code class="hljs language-js">leaders = [<span class="hljs-string">"Elon"</span>, <span class="hljs-string">"Tim"</span>, <span class="hljs-string">"Warren"</span>]

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-attr">leaders</span>:
    <span class="hljs-keyword">if</span> i == <span class="hljs-string">"Yang"</span>:
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"Yang is a leader!"</span>)
        <span class="hljs-keyword">break</span>
<span class="hljs-attr">else</span>:
    <span class="hljs-title function_">print</span>(<span class="hljs-string">"Yang을 찾을 수 없어요!"</span>)

# <span class="hljs-title class_">Yang</span>을 찾을 수 없어요!
</code></pre>
<p>위의 코드에서 보듯이 leaders 리스트에는 Yang이 없지만 Yang 또한 지도자입니다. 따라서 for 루프에 break가 없어요.</p>
<p>이 경우, for 루프 뒤에 있는 "else" 블록이 실행되었어요.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그 로직은 간단합니다. "else" 블록은 루프에 중단점이 없을 때만 실행됩니다.</p>
<p>그러나 다른 프로그래밍 언어에서는 else 문을 이렇게 사용할 수 없기 때문에, 이 for-else 구조는 파이썬 원어민이 아닌 대부분의 동료들을 혼란스럽게 만들 수 있습니다.</p>
<p>동료들이 파이썬 마스터라 하더라도, 이 기능이 100% 필요하지 않고, 사용하는 사람이 많지 않으므로, 제품에 적용하는 것은 전혀 좋은 생각이 아닙니다. 그렇지 않으면, 코드베이스의 가독성이 극도로 떨어질 수 있습니다.</p>
<p>그렇다면, for-else 구조 없이 예시 코드를 다시 작성하는 방법은 무엇일까요?</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>테이블 태그를 마크다운 형식으로 변경해주세요:</p>
<p>leaders = ["Elon", "Tim", "Warren"]
found_yang = False</p>
<p>for i in leaders:
if i == "Yang":
print("Yang is a leader!")
found_yang = True
break</p>
<p>if not found_yang:
print("Not found Yang!")</p>
<h2>2. eval() 또는 exec() 함수</h2>
<p>처음 보면, eval() 함수의 힘을 활용하면 일부 기능을 구현하는 것이 더 쉬워 보입니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>예를 들어, 다음 함수는 eval() 함수의 도움을 받아 한 줄의 코드로 기본 계산기를 구현합니다:</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">calculator</span>(a, b, op):
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">eval</span>(f<span class="hljs-string">'{a} {op} {b}'</span>)

<span class="hljs-title function_">print</span>(<span class="hljs-title function_">calculator</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">'+'</span>))
# <span class="hljs-number">5</span>
<span class="hljs-title function_">print</span>(<span class="hljs-title function_">calculator</span>(<span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-string">'-'</span>))
# <span class="hljs-number">1</span>
<span class="hljs-title function_">print</span>(<span class="hljs-title function_">calculator</span>(<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-string">'*'</span>))
# <span class="hljs-number">56</span>
<span class="hljs-title function_">print</span>(<span class="hljs-title function_">calculator</span>(<span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-string">'/'</span>))
# <span class="hljs-number">4.0</span>
</code></pre>
<p>깔끔하고 간결하죠?</p>
<p>사이버 공격자들도 eval() 함수를 좋아합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그 이름에서 알 수 있듯이, eval() 함수는 Python 식을 평가하는 데 사용됩니다.</p>
<p>그러나 입력이 시스템을 해킹하도록 특별히 설계된 경우, eval() 함수는 모든 악의의 근원이 될 수 있습니다.</p>
<p>예를 들어, 누군가 이전의 계산기를 다음과 같은 방식으로 사용한다면, 쉽게 현재 위치의 폴더와 파일 목록을 가져올 수 있습니다:</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">calculator</span>(a, b, op):
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">eval</span>(f<span class="hljs-string">'{a} {op} {b}'</span>)


<span class="hljs-title function_">print</span>(<span class="hljs-title function_">calculator</span>(<span class="hljs-string">"__import__('os').system('ls')"</span>,<span class="hljs-string">''</span>,<span class="hljs-string">''</span>))
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>다음과 같이 입력을 변경해보는 건 어떨까요:</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">print</span>(<span class="hljs-title function_">calculator</span>(<span class="hljs-string">"__import__('os').system('rm -rf *')"</span>,<span class="hljs-string">''</span>,<span class="hljs-string">''</span>))
</code></pre>
<p>따라서, 제작 환경에서는 evel() 함수를 사용하지 않는 것이 가장 좋습니다.</p>
<p>evel() 함수와 유사하게, exec()는 Python 프로그램 코드를 동적으로 실행하는 또 다른 내장 함수입니다. 보안 문제로 인해 이 역시 제작 환경에서 사용하지 않는 것이 좋습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>3. 깊게 중첩된 루프</h1>
<p>어떤 복잡한 경우에는 중첩된 루프를 사용할 수밖에 없는 것처럼 보입니다:</p>
<pre><code class="hljs language-js">list_a = [<span class="hljs-number">1</span>, <span class="hljs-number">2020</span>, <span class="hljs-number">70</span>]
list_b = [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2000</span>]
list_c = [<span class="hljs-number">3</span>, <span class="hljs-number">70</span>, <span class="hljs-number">7</span>]

<span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> <span class="hljs-attr">list_a</span>:
    <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> <span class="hljs-attr">list_b</span>:
        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-attr">list_c</span>:
            <span class="hljs-keyword">if</span> a + b + c == <span class="hljs-number">2077</span>:
                <span class="hljs-title function_">print</span>(a, b, c)
# <span class="hljs-number">70</span> <span class="hljs-number">2000</span> <span class="hljs-number">7</span>
</code></pre>
<p>하지만 깊게 중첩된 루프는 읽기 어렵고 파이썬다운 방식이 아닙니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>나쁜 코딩에서 나오는 안티 패턴입니다. 파이썬은 이 문제를 해결하기 위한 내장 도구를 제공합니다:</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> product

list_a = [<span class="hljs-number">1</span>, <span class="hljs-number">2020</span>, <span class="hljs-number">70</span>]
list_b = [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2000</span>]
list_c = [<span class="hljs-number">3</span>, <span class="hljs-number">70</span>, <span class="hljs-number">7</span>]

<span class="hljs-keyword">for</span> a, b, c <span class="hljs-keyword">in</span> product(list_a, list_b, list_c):
    <span class="hljs-keyword">if</span> a + b + c == <span class="hljs-number">2077</span>:
        <span class="hljs-built_in">print</span>(a, b, c)
<span class="hljs-comment"># 70 2000 7</span>
</code></pre>
<p>위의 예시에서 보다시피, itertools.product() 함수의 도움을 받아 이전 프로그램은 중첩된 루프를 완전히 피할 수 있습니다. 이 함수는 입력 이터러블의 카테시안 곱을 얻기 위한 방법입니다.</p>
<h1>4. 와일드카드로 모두 가져오기(import)</h1>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>와일드카드 임포트(from module import *)는 이름 충돌과 코드 불명확성의 근본이 됩니다.</p>
<p>이것은 모듈에서 모든 객체를 현재 네임스페이스로 가져오기 때문에 어디서 변수 또는 함수가 정의되었는지 추적하기 어렵습니다. 모듈에 의해 소개된 모든 이름을 기억하기 어려울 뿐만 아니라, 특히 대규모 타사 모듈의 경우 더욱 문제입니다.</p>
<p>네임스페이스 오염을 피하기 위해, 우리가 명시적으로 필요한 것만 가져오는 것이 최선의 실천 방법입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> <span class="hljs-variable language_">module</span> <span class="hljs-keyword">import</span> func_a, func_b
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>5. 멋진 한 줄 요약</h1>
<p>한 줄 요약은 프로그래밍의 재미난 부분을 보여줍니다. 재미로 작성하는 건 괜찮아요.</p>
<p>하지만 제품용 코드에 넣는 건 재앙이 될 수 있습니다.</p>
<p>이것은 퀵 정렬의 파이썬 한 줄 요약입니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">퀵정렬 = lambda <span class="hljs-attr">l</span>: 퀵정렬([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> l[<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> i &#x3C; l[<span class="hljs-number">0</span>]]) + [l[<span class="hljs-number">0</span>]] + 퀵정렬([j <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> l[<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> j >= l[<span class="hljs-number">0</span>]]) <span class="hljs-keyword">if</span> l <span class="hljs-keyword">else</span> []
</code></pre>
<p>이 코드는 잘 작동하지만 코드의 로직을 얼마나 빨리 이해할 수 있습니까?</p>
<p>당신만큼 빨리 동료들도 이해할 수 있을까요?</p>
<p>그리고 람다 함수는 많은 멋진 파이썬 한 줄짜리 코드의 기반입니다. 우리는 매우 간단한 함수에만 사용해야 합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>6. 깊은 상속 계층 구조와 복잡한 믹스인</h1>
<p>객체 지향 프로그래밍은 어떤 면에서는 두 각도로 양날의 검입니다.</p>
<p>때로는 메서드의 목적을 이해하기 위해 매우 복잡한 상속 계층을 추적해야 할 수도 있습니다.</p>
<p>게다가 Python은 믹스인을 지원하는데, 이는 객체를 이해하기 어렵게 만들 수 있습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>동료들이 편리하게 일할 수 있도록 상속 체인을 간소화하는 것을 고려해보세요.</p>
<h1>7. 변경 가능한 기본 인수</h1>
<p>파이썬은 값에 의한 호출(call-by-name)도 아니고 참조에 의한 호출(call-by-reference)도 아니며, 공유에 의한 호출(call-by-sharing)이다.</p>
<p>이는 변경 가능한 기본 인수를 정의할 경우 혼란스러운 코드로 이어질 수 있습니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">def <span class="hljs-title function_">get_leaders</span>(element, leader_list=[]):
    leader_list.<span class="hljs-title function_">append</span>(element)
    <span class="hljs-keyword">return</span> leader_list


<span class="hljs-title function_">print</span>(<span class="hljs-title function_">get_leaders</span>(<span class="hljs-string">'Elon'</span>))
# [<span class="hljs-string">'Elon'</span>]
<span class="hljs-title function_">print</span>(<span class="hljs-title function_">get_leaders</span>(<span class="hljs-string">'Yang'</span>))
# [<span class="hljs-string">'Elon'</span>, <span class="hljs-string">'Yang'</span>]
<span class="hljs-title function_">print</span>(<span class="hljs-title function_">get_leaders</span>(<span class="hljs-string">'Warren'</span>))
# [<span class="hljs-string">'Elon'</span>, <span class="hljs-string">'Yang'</span>, <span class="hljs-string">'Warren'</span>]
</code></pre>
<p>위의 함수는 함수를 3번 독립적으로 호출해도 항상 동일한 목록을 사용합니다.</p>
<p>이제 leader_list의 기본 값을 None으로 변경하고 결과를 확인해봅시다:</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">get_leaders</span>(element, leader_list=<span class="hljs-title class_">None</span>):
    <span class="hljs-keyword">if</span> leader_list is <span class="hljs-title class_">None</span>:
        leader_list = []
    leader_list.<span class="hljs-title function_">append</span>(element)
    <span class="hljs-keyword">return</span> leader_list


<span class="hljs-title function_">print</span>(<span class="hljs-title function_">get_leaders</span>(<span class="hljs-string">'Elon'</span>))
# [<span class="hljs-string">'Elon'</span>]
<span class="hljs-title function_">print</span>(<span class="hljs-title function_">get_leaders</span>(<span class="hljs-string">'Yang'</span>))
# [<span class="hljs-string">'Yang'</span>]
<span class="hljs-title function_">print</span>(<span class="hljs-title function_">get_leaders</span>(<span class="hljs-string">'Warren'</span>))
# [<span class="hljs-string">'Warren'</span>]
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>매번 함수 호출할 때마다 새로운 목록이 생성됩니다.</p>
<p>실제로 Python 함수에서 가변 기본 인수를 사용하는 것은 Python이 가변 및 불변 데이터 구조를 처리하는 방식으로 인해 안티 패턴으로 간주됩니다. 이 동작은 종종 예상치 못한 결과와 찾기 어려운 버그로 이어집니다.</p>
<h1>8. If-Else가 모든 곳에서 등장합니다</h1>
<p>Python 3.10 이전에는 때때로 많은 if-else 문을 작성해야 했습니다. 왜냐하면 Python은 아직 match-case 구문을 지원하지 않았기 때문입니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>파이썬 3.10 이후로 구조적 패턴 매칭 기술이 소개되면서 if-else 문을 반복적으로 작성하는 불편을 피할 수 있게 되었습니다:</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">handle_http_status</span>(status_code):
    match <span class="hljs-attr">status_code</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-number">200</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-string">"성공!"</span>
        <span class="hljs-keyword">case</span> <span class="hljs-number">400</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-string">"잘못된 요청"</span>
        <span class="hljs-keyword">case</span> <span class="hljs-number">401</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-string">"권한 없음"</span>
        <span class="hljs-keyword">case</span> <span class="hljs-number">404</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-string">"찾을 수 없음"</span>
        <span class="hljs-keyword">case</span> <span class="hljs-number">500</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-string">"내부 서버 오류"</span>


<span class="hljs-title function_">print</span>(<span class="hljs-title function_">handle_http_status</span>(<span class="hljs-number">200</span>))
# 성공!
<span class="hljs-title function_">print</span>(<span class="hljs-title function_">handle_http_status</span>(<span class="hljs-number">404</span>))
# 찾을 수 없음
<span class="hljs-title function_">print</span>(<span class="hljs-title function_">handle_http_status</span>(<span class="hljs-number">2077</span>))
# <span class="hljs-title class_">None</span>
</code></pre>
<p>위 프로그램에서 보듯이, match-case 구문을 사용하여 각각 다른 입력을 처리할 수 있습니다. 모든 경우에 if-else 문이 필요하지 않다는 것을 알 수 있습니다.</p>
<h1>9. C-스타일 문자열 포맷팅</h1>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>파이썬의 매우 오래된 버전에서는 문자열 포맷팅 연산이 C 프로그래밍 언어와 같았습니다:</p>
<pre><code class="hljs language-js">name = <span class="hljs-string">'Yang'</span>
<span class="hljs-title function_">print</span>(<span class="hljs-string">"Hi, %s"</span> % name)
# <span class="hljs-title class_">Hi</span>, <span class="hljs-title class_">Yang</span>
</code></pre>
<p>그러나 파이썬이 많이 발전함에 따라 이전 구문은 여전히 사용할 수 있지만, 그 낡은 면모를 보여주고 있습니다:</p>
<p>지금은 이 오래된 기술을 피하고 모든 문자열 포맷팅에 f-string 구문을 적용해야 합니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>name = 'Yang'
desc = 'amazing'
print(f"Hi, {name}! You are {desc}!")</p>
<h1>Hi, Yang! You are amazing!</h1>
<h1>결론</h1>
<p>어떤 프로그래밍 언어도 완벽하지 않습니다.</p>
<p>자바보다 오래된 파이썬은 불가피하게 몇 가지 나쁜 설계로 인해 안티 패턴을 유발합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>경험 많은 Python 개발자로서, 우리는 문제가 있는 곳을 파악하고 그것들을 피하는 것이 중요해요. 동시에, 최신 구문을 활용하기 위해 새로운 Python 버전의 업데이트를 주시하면 도움이 될 거예요.</p>
<p>읽어 주셔서 감사합니다. ❤️ 만약 마음에 드셨다면, 연락해 보아요:</p>
<ul>
<li>Linkedin</li>
<li>Medium</li>
</ul>
<p>제가 작성한 더 많은 Python 자습서들:</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"프로덕션에서 절대 사용하지 않을 9가지 Python 안티 패턴","description":"","date":"2024-07-14 20:45","slug":"2024-07-14-9PythonAntiPatternsThatIWillNeverApplyinProduction","content":"\n\n## 파이썬\n\n![Python Anti-Patterns](/TIL/assets/img/2024-07-14-9PythonAntiPatternsThatIWillNeverApplyinProduction_0.png)\n\n어떤 언어든, 오래된 만큼 반드시 몇 가지 안티-패턴 기능과 이해하기 어려운 구문이 있습니다.\n\n파이썬이 우아한 언어라고 하더라도 이 운명에서 벗어날 수 없습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n소프트웨어 개발자로서 우리가 할 수 있는 것은 지식을 최신 상태로 유지하고 오래된 또는 부적절한 기능을 사용하지 않는 것입니다.\n\n이 기사는 가독성, 보안 및 디버깅에 해로운 9가지 Python 안티 패턴에 대해 상기시킬 것입니다. 경험 많은 Python 엔지니어는 제품 개발 시 이러한 패턴을 적용해서는 안 됩니다.\n\n# 1. For-Else 구조\n\nPython에는 매우 특별한 구문인 for-else가 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nif-else가 아니라 for 루프 후에 \"else\"가 있다는 거야!\n\n```js\nleaders = [\"Elon\", \"Tim\", \"Warren\"]\n\nfor i in leaders:\n    if i == \"Yang\":\n        print(\"Yang is a leader!\")\n        break\nelse:\n    print(\"Yang을 찾을 수 없어요!\")\n\n# Yang을 찾을 수 없어요!\n```\n\n위의 코드에서 보듯이 leaders 리스트에는 Yang이 없지만 Yang 또한 지도자입니다. 따라서 for 루프에 break가 없어요.\n\n이 경우, for 루프 뒤에 있는 \"else\" 블록이 실행되었어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그 로직은 간단합니다. \"else\" 블록은 루프에 중단점이 없을 때만 실행됩니다.\n\n그러나 다른 프로그래밍 언어에서는 else 문을 이렇게 사용할 수 없기 때문에, 이 for-else 구조는 파이썬 원어민이 아닌 대부분의 동료들을 혼란스럽게 만들 수 있습니다.\n\n동료들이 파이썬 마스터라 하더라도, 이 기능이 100% 필요하지 않고, 사용하는 사람이 많지 않으므로, 제품에 적용하는 것은 전혀 좋은 생각이 아닙니다. 그렇지 않으면, 코드베이스의 가독성이 극도로 떨어질 수 있습니다.\n\n그렇다면, for-else 구조 없이 예시 코드를 다시 작성하는 방법은 무엇일까요?\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 마크다운 형식으로 변경해주세요:\n\n\nleaders = [\"Elon\", \"Tim\", \"Warren\"]\nfound_yang = False\n\nfor i in leaders:\n    if i == \"Yang\":\n        print(\"Yang is a leader!\")\n        found_yang = True\n        break\n\nif not found_yang:\n    print(\"Not found Yang!\")\n\n\n## 2. eval() 또는 exec() 함수\n\n처음 보면, eval() 함수의 힘을 활용하면 일부 기능을 구현하는 것이 더 쉬워 보입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, 다음 함수는 eval() 함수의 도움을 받아 한 줄의 코드로 기본 계산기를 구현합니다:\n\n```js\ndef calculator(a, b, op):\n    return eval(f'{a} {op} {b}')\n\nprint(calculator(2, 3, '+'))\n# 5\nprint(calculator(6, 5, '-'))\n# 1\nprint(calculator(7, 8, '*'))\n# 56\nprint(calculator(8, 2, '/'))\n# 4.0\n```\n\n깔끔하고 간결하죠?\n\n사이버 공격자들도 eval() 함수를 좋아합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그 이름에서 알 수 있듯이, eval() 함수는 Python 식을 평가하는 데 사용됩니다.\n\n그러나 입력이 시스템을 해킹하도록 특별히 설계된 경우, eval() 함수는 모든 악의의 근원이 될 수 있습니다.\n\n예를 들어, 누군가 이전의 계산기를 다음과 같은 방식으로 사용한다면, 쉽게 현재 위치의 폴더와 파일 목록을 가져올 수 있습니다:\n\n```js\ndef calculator(a, b, op):\n    return eval(f'{a} {op} {b}')\n\n\nprint(calculator(\"__import__('os').system('ls')\",'',''))\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음과 같이 입력을 변경해보는 건 어떨까요:\n\n```js\nprint(calculator(\"__import__('os').system('rm -rf *')\",'',''))\n```\n\n따라서, 제작 환경에서는 evel() 함수를 사용하지 않는 것이 가장 좋습니다.\n\nevel() 함수와 유사하게, exec()는 Python 프로그램 코드를 동적으로 실행하는 또 다른 내장 함수입니다. 보안 문제로 인해 이 역시 제작 환경에서 사용하지 않는 것이 좋습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 3. 깊게 중첩된 루프\n\n어떤 복잡한 경우에는 중첩된 루프를 사용할 수밖에 없는 것처럼 보입니다:\n\n```js\nlist_a = [1, 2020, 70]\nlist_b = [2, 4, 7, 2000]\nlist_c = [3, 70, 7]\n\nfor a in list_a:\n    for b in list_b:\n        for c in list_c:\n            if a + b + c == 2077:\n                print(a, b, c)\n# 70 2000 7\n```\n\n하지만 깊게 중첩된 루프는 읽기 어렵고 파이썬다운 방식이 아닙니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n나쁜 코딩에서 나오는 안티 패턴입니다. 파이썬은 이 문제를 해결하기 위한 내장 도구를 제공합니다:\n\n```python\nfrom itertools import product\n\nlist_a = [1, 2020, 70]\nlist_b = [2, 4, 7, 2000]\nlist_c = [3, 70, 7]\n\nfor a, b, c in product(list_a, list_b, list_c):\n    if a + b + c == 2077:\n        print(a, b, c)\n# 70 2000 7\n```\n\n위의 예시에서 보다시피, itertools.product() 함수의 도움을 받아 이전 프로그램은 중첩된 루프를 완전히 피할 수 있습니다. 이 함수는 입력 이터러블의 카테시안 곱을 얻기 위한 방법입니다.\n\n# 4. 와일드카드로 모두 가져오기(import)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n와일드카드 임포트(from module import *)는 이름 충돌과 코드 불명확성의 근본이 됩니다.\n\n이것은 모듈에서 모든 객체를 현재 네임스페이스로 가져오기 때문에 어디서 변수 또는 함수가 정의되었는지 추적하기 어렵습니다. 모듈에 의해 소개된 모든 이름을 기억하기 어려울 뿐만 아니라, 특히 대규모 타사 모듈의 경우 더욱 문제입니다.\n\n네임스페이스 오염을 피하기 위해, 우리가 명시적으로 필요한 것만 가져오는 것이 최선의 실천 방법입니다:\n\n```js\nfrom module import func_a, func_b\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 5. 멋진 한 줄 요약\n\n한 줄 요약은 프로그래밍의 재미난 부분을 보여줍니다. 재미로 작성하는 건 괜찮아요.\n\n하지만 제품용 코드에 넣는 건 재앙이 될 수 있습니다.\n\n이것은 퀵 정렬의 파이썬 한 줄 요약입니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n퀵정렬 = lambda l: 퀵정렬([i for i in l[1:] if i \u003c l[0]]) + [l[0]] + 퀵정렬([j for j in l[1:] if j \u003e= l[0]]) if l else []\n```\n\n이 코드는 잘 작동하지만 코드의 로직을 얼마나 빨리 이해할 수 있습니까?\n\n당신만큼 빨리 동료들도 이해할 수 있을까요?\n\n그리고 람다 함수는 많은 멋진 파이썬 한 줄짜리 코드의 기반입니다. 우리는 매우 간단한 함수에만 사용해야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 6. 깊은 상속 계층 구조와 복잡한 믹스인\n\n객체 지향 프로그래밍은 어떤 면에서는 두 각도로 양날의 검입니다.\n\n때로는 메서드의 목적을 이해하기 위해 매우 복잡한 상속 계층을 추적해야 할 수도 있습니다.\n\n게다가 Python은 믹스인을 지원하는데, 이는 객체를 이해하기 어렵게 만들 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n동료들이 편리하게 일할 수 있도록 상속 체인을 간소화하는 것을 고려해보세요.\n\n# 7. 변경 가능한 기본 인수\n\n파이썬은 값에 의한 호출(call-by-name)도 아니고 참조에 의한 호출(call-by-reference)도 아니며, 공유에 의한 호출(call-by-sharing)이다.\n\n이는 변경 가능한 기본 인수를 정의할 경우 혼란스러운 코드로 이어질 수 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ndef get_leaders(element, leader_list=[]):\n    leader_list.append(element)\n    return leader_list\n\n\nprint(get_leaders('Elon'))\n# ['Elon']\nprint(get_leaders('Yang'))\n# ['Elon', 'Yang']\nprint(get_leaders('Warren'))\n# ['Elon', 'Yang', 'Warren']\n```\n\n위의 함수는 함수를 3번 독립적으로 호출해도 항상 동일한 목록을 사용합니다.\n\n이제 leader_list의 기본 값을 None으로 변경하고 결과를 확인해봅시다:\n\n```js\ndef get_leaders(element, leader_list=None):\n    if leader_list is None:\n        leader_list = []\n    leader_list.append(element)\n    return leader_list\n\n\nprint(get_leaders('Elon'))\n# ['Elon']\nprint(get_leaders('Yang'))\n# ['Yang']\nprint(get_leaders('Warren'))\n# ['Warren']\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n매번 함수 호출할 때마다 새로운 목록이 생성됩니다.\n\n실제로 Python 함수에서 가변 기본 인수를 사용하는 것은 Python이 가변 및 불변 데이터 구조를 처리하는 방식으로 인해 안티 패턴으로 간주됩니다. 이 동작은 종종 예상치 못한 결과와 찾기 어려운 버그로 이어집니다.\n\n# 8. If-Else가 모든 곳에서 등장합니다\n\nPython 3.10 이전에는 때때로 많은 if-else 문을 작성해야 했습니다. 왜냐하면 Python은 아직 match-case 구문을 지원하지 않았기 때문입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬 3.10 이후로 구조적 패턴 매칭 기술이 소개되면서 if-else 문을 반복적으로 작성하는 불편을 피할 수 있게 되었습니다:\n\n```js\ndef handle_http_status(status_code):\n    match status_code:\n        case 200:\n            return \"성공!\"\n        case 400:\n            return \"잘못된 요청\"\n        case 401:\n            return \"권한 없음\"\n        case 404:\n            return \"찾을 수 없음\"\n        case 500:\n            return \"내부 서버 오류\"\n\n\nprint(handle_http_status(200))\n# 성공!\nprint(handle_http_status(404))\n# 찾을 수 없음\nprint(handle_http_status(2077))\n# None\n```\n\n위 프로그램에서 보듯이, match-case 구문을 사용하여 각각 다른 입력을 처리할 수 있습니다. 모든 경우에 if-else 문이 필요하지 않다는 것을 알 수 있습니다.\n\n# 9. C-스타일 문자열 포맷팅\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬의 매우 오래된 버전에서는 문자열 포맷팅 연산이 C 프로그래밍 언어와 같았습니다:\n\n```js\nname = 'Yang'\nprint(\"Hi, %s\" % name)\n# Hi, Yang\n```\n\n그러나 파이썬이 많이 발전함에 따라 이전 구문은 여전히 사용할 수 있지만, 그 낡은 면모를 보여주고 있습니다:\n\n지금은 이 오래된 기술을 피하고 모든 문자열 포맷팅에 f-string 구문을 적용해야 합니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\nname = 'Yang'\ndesc = 'amazing'\nprint(f\"Hi, {name}! You are {desc}!\")\n# Hi, Yang! You are amazing!\n\n\n# 결론\n\n어떤 프로그래밍 언어도 완벽하지 않습니다.\n\n자바보다 오래된 파이썬은 불가피하게 몇 가지 나쁜 설계로 인해 안티 패턴을 유발합니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n경험 많은 Python 개발자로서, 우리는 문제가 있는 곳을 파악하고 그것들을 피하는 것이 중요해요. 동시에, 최신 구문을 활용하기 위해 새로운 Python 버전의 업데이트를 주시하면 도움이 될 거예요.\n\n읽어 주셔서 감사합니다. ❤️ 만약 마음에 드셨다면, 연락해 보아요:\n\n- Linkedin\n- Medium\n\n제가 작성한 더 많은 Python 자습서들:","ogImage":{"url":"/TIL/assets/img/2024-07-14-9PythonAntiPatternsThatIWillNeverApplyinProduction_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-9PythonAntiPatternsThatIWillNeverApplyinProduction_0.png","tag":["Tech"],"readingTime":13},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e파이썬\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-14-9PythonAntiPatternsThatIWillNeverApplyinProduction_0.png\" alt=\"Python Anti-Patterns\"\u003e\u003c/p\u003e\n\u003cp\u003e어떤 언어든, 오래된 만큼 반드시 몇 가지 안티-패턴 기능과 이해하기 어려운 구문이 있습니다.\u003c/p\u003e\n\u003cp\u003e파이썬이 우아한 언어라고 하더라도 이 운명에서 벗어날 수 없습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e소프트웨어 개발자로서 우리가 할 수 있는 것은 지식을 최신 상태로 유지하고 오래된 또는 부적절한 기능을 사용하지 않는 것입니다.\u003c/p\u003e\n\u003cp\u003e이 기사는 가독성, 보안 및 디버깅에 해로운 9가지 Python 안티 패턴에 대해 상기시킬 것입니다. 경험 많은 Python 엔지니어는 제품 개발 시 이러한 패턴을 적용해서는 안 됩니다.\u003c/p\u003e\n\u003ch1\u003e1. For-Else 구조\u003c/h1\u003e\n\u003cp\u003ePython에는 매우 특별한 구문인 for-else가 있습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eif-else가 아니라 for 루프 후에 \"else\"가 있다는 거야!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eleaders = [\u003cspan class=\"hljs-string\"\u003e\"Elon\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"Tim\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"Warren\"\u003c/span\u003e]\n\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eleaders\u003c/span\u003e:\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e i == \u003cspan class=\"hljs-string\"\u003e\"Yang\"\u003c/span\u003e:\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Yang is a leader!\"\u003c/span\u003e)\n        \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003eelse\u003c/span\u003e:\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Yang을 찾을 수 없어요!\"\u003c/span\u003e)\n\n# \u003cspan class=\"hljs-title class_\"\u003eYang\u003c/span\u003e을 찾을 수 없어요!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위의 코드에서 보듯이 leaders 리스트에는 Yang이 없지만 Yang 또한 지도자입니다. 따라서 for 루프에 break가 없어요.\u003c/p\u003e\n\u003cp\u003e이 경우, for 루프 뒤에 있는 \"else\" 블록이 실행되었어요.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그 로직은 간단합니다. \"else\" 블록은 루프에 중단점이 없을 때만 실행됩니다.\u003c/p\u003e\n\u003cp\u003e그러나 다른 프로그래밍 언어에서는 else 문을 이렇게 사용할 수 없기 때문에, 이 for-else 구조는 파이썬 원어민이 아닌 대부분의 동료들을 혼란스럽게 만들 수 있습니다.\u003c/p\u003e\n\u003cp\u003e동료들이 파이썬 마스터라 하더라도, 이 기능이 100% 필요하지 않고, 사용하는 사람이 많지 않으므로, 제품에 적용하는 것은 전혀 좋은 생각이 아닙니다. 그렇지 않으면, 코드베이스의 가독성이 극도로 떨어질 수 있습니다.\u003c/p\u003e\n\u003cp\u003e그렇다면, for-else 구조 없이 예시 코드를 다시 작성하는 방법은 무엇일까요?\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e테이블 태그를 마크다운 형식으로 변경해주세요:\u003c/p\u003e\n\u003cp\u003eleaders = [\"Elon\", \"Tim\", \"Warren\"]\nfound_yang = False\u003c/p\u003e\n\u003cp\u003efor i in leaders:\nif i == \"Yang\":\nprint(\"Yang is a leader!\")\nfound_yang = True\nbreak\u003c/p\u003e\n\u003cp\u003eif not found_yang:\nprint(\"Not found Yang!\")\u003c/p\u003e\n\u003ch2\u003e2. eval() 또는 exec() 함수\u003c/h2\u003e\n\u003cp\u003e처음 보면, eval() 함수의 힘을 활용하면 일부 기능을 구현하는 것이 더 쉬워 보입니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e예를 들어, 다음 함수는 eval() 함수의 도움을 받아 한 줄의 코드로 기본 계산기를 구현합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003ecalculator\u003c/span\u003e(a, b, op):\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eeval\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e'{a} {op} {b}'\u003c/span\u003e)\n\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003ecalculator\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'+'\u003c/span\u003e))\n# \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003ecalculator\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'-'\u003c/span\u003e))\n# \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003ecalculator\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'*'\u003c/span\u003e))\n# \u003cspan class=\"hljs-number\"\u003e56\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003ecalculator\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'/'\u003c/span\u003e))\n# \u003cspan class=\"hljs-number\"\u003e4.0\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e깔끔하고 간결하죠?\u003c/p\u003e\n\u003cp\u003e사이버 공격자들도 eval() 함수를 좋아합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그 이름에서 알 수 있듯이, eval() 함수는 Python 식을 평가하는 데 사용됩니다.\u003c/p\u003e\n\u003cp\u003e그러나 입력이 시스템을 해킹하도록 특별히 설계된 경우, eval() 함수는 모든 악의의 근원이 될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 누군가 이전의 계산기를 다음과 같은 방식으로 사용한다면, 쉽게 현재 위치의 폴더와 파일 목록을 가져올 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003ecalculator\u003c/span\u003e(a, b, op):\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eeval\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e'{a} {op} {b}'\u003c/span\u003e)\n\n\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003ecalculator\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"__import__('os').system('ls')\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e))\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e다음과 같이 입력을 변경해보는 건 어떨까요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003ecalculator\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"__import__('os').system('rm -rf *')\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e따라서, 제작 환경에서는 evel() 함수를 사용하지 않는 것이 가장 좋습니다.\u003c/p\u003e\n\u003cp\u003eevel() 함수와 유사하게, exec()는 Python 프로그램 코드를 동적으로 실행하는 또 다른 내장 함수입니다. 보안 문제로 인해 이 역시 제작 환경에서 사용하지 않는 것이 좋습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e3. 깊게 중첩된 루프\u003c/h1\u003e\n\u003cp\u003e어떤 복잡한 경우에는 중첩된 루프를 사용할 수밖에 없는 것처럼 보입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003elist_a = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2020\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e70\u003c/span\u003e]\nlist_b = [\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2000\u003c/span\u003e]\nlist_c = [\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e70\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e]\n\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e a \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003elist_a\u003c/span\u003e:\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e b \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003elist_b\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e c \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003elist_c\u003c/span\u003e:\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e a + b + c == \u003cspan class=\"hljs-number\"\u003e2077\u003c/span\u003e:\n                \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(a, b, c)\n# \u003cspan class=\"hljs-number\"\u003e70\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e2000\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e하지만 깊게 중첩된 루프는 읽기 어렵고 파이썬다운 방식이 아닙니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e나쁜 코딩에서 나오는 안티 패턴입니다. 파이썬은 이 문제를 해결하기 위한 내장 도구를 제공합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e itertools \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e product\n\nlist_a = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2020\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e70\u003c/span\u003e]\nlist_b = [\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2000\u003c/span\u003e]\nlist_c = [\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e70\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e]\n\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e a, b, c \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e product(list_a, list_b, list_c):\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e a + b + c == \u003cspan class=\"hljs-number\"\u003e2077\u003c/span\u003e:\n        \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(a, b, c)\n\u003cspan class=\"hljs-comment\"\u003e# 70 2000 7\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위의 예시에서 보다시피, itertools.product() 함수의 도움을 받아 이전 프로그램은 중첩된 루프를 완전히 피할 수 있습니다. 이 함수는 입력 이터러블의 카테시안 곱을 얻기 위한 방법입니다.\u003c/p\u003e\n\u003ch1\u003e4. 와일드카드로 모두 가져오기(import)\u003c/h1\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e와일드카드 임포트(from module import *)는 이름 충돌과 코드 불명확성의 근본이 됩니다.\u003c/p\u003e\n\u003cp\u003e이것은 모듈에서 모든 객체를 현재 네임스페이스로 가져오기 때문에 어디서 변수 또는 함수가 정의되었는지 추적하기 어렵습니다. 모듈에 의해 소개된 모든 이름을 기억하기 어려울 뿐만 아니라, 특히 대규모 타사 모듈의 경우 더욱 문제입니다.\u003c/p\u003e\n\u003cp\u003e네임스페이스 오염을 피하기 위해, 우리가 명시적으로 필요한 것만 가져오는 것이 최선의 실천 방법입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e func_a, func_b\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e5. 멋진 한 줄 요약\u003c/h1\u003e\n\u003cp\u003e한 줄 요약은 프로그래밍의 재미난 부분을 보여줍니다. 재미로 작성하는 건 괜찮아요.\u003c/p\u003e\n\u003cp\u003e하지만 제품용 코드에 넣는 건 재앙이 될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이것은 퀵 정렬의 파이썬 한 줄 요약입니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e퀵정렬 = lambda \u003cspan class=\"hljs-attr\"\u003el\u003c/span\u003e: 퀵정렬([i \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e l[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e:] \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e i \u0026#x3C; l[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]]) + [l[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]] + 퀵정렬([j \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e j \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e l[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e:] \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e j \u003e= l[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]]) \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e l \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e []\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 코드는 잘 작동하지만 코드의 로직을 얼마나 빨리 이해할 수 있습니까?\u003c/p\u003e\n\u003cp\u003e당신만큼 빨리 동료들도 이해할 수 있을까요?\u003c/p\u003e\n\u003cp\u003e그리고 람다 함수는 많은 멋진 파이썬 한 줄짜리 코드의 기반입니다. 우리는 매우 간단한 함수에만 사용해야 합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e6. 깊은 상속 계층 구조와 복잡한 믹스인\u003c/h1\u003e\n\u003cp\u003e객체 지향 프로그래밍은 어떤 면에서는 두 각도로 양날의 검입니다.\u003c/p\u003e\n\u003cp\u003e때로는 메서드의 목적을 이해하기 위해 매우 복잡한 상속 계층을 추적해야 할 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e게다가 Python은 믹스인을 지원하는데, 이는 객체를 이해하기 어렵게 만들 수 있습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e동료들이 편리하게 일할 수 있도록 상속 체인을 간소화하는 것을 고려해보세요.\u003c/p\u003e\n\u003ch1\u003e7. 변경 가능한 기본 인수\u003c/h1\u003e\n\u003cp\u003e파이썬은 값에 의한 호출(call-by-name)도 아니고 참조에 의한 호출(call-by-reference)도 아니며, 공유에 의한 호출(call-by-sharing)이다.\u003c/p\u003e\n\u003cp\u003e이는 변경 가능한 기본 인수를 정의할 경우 혼란스러운 코드로 이어질 수 있습니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003eget_leaders\u003c/span\u003e(element, leader_list=[]):\n    leader_list.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(element)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e leader_list\n\n\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eget_leaders\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Elon'\u003c/span\u003e))\n# [\u003cspan class=\"hljs-string\"\u003e'Elon'\u003c/span\u003e]\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eget_leaders\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Yang'\u003c/span\u003e))\n# [\u003cspan class=\"hljs-string\"\u003e'Elon'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'Yang'\u003c/span\u003e]\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eget_leaders\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Warren'\u003c/span\u003e))\n# [\u003cspan class=\"hljs-string\"\u003e'Elon'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'Yang'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'Warren'\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위의 함수는 함수를 3번 독립적으로 호출해도 항상 동일한 목록을 사용합니다.\u003c/p\u003e\n\u003cp\u003e이제 leader_list의 기본 값을 None으로 변경하고 결과를 확인해봅시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003eget_leaders\u003c/span\u003e(element, leader_list=\u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e leader_list is \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e:\n        leader_list = []\n    leader_list.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(element)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e leader_list\n\n\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eget_leaders\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Elon'\u003c/span\u003e))\n# [\u003cspan class=\"hljs-string\"\u003e'Elon'\u003c/span\u003e]\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eget_leaders\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Yang'\u003c/span\u003e))\n# [\u003cspan class=\"hljs-string\"\u003e'Yang'\u003c/span\u003e]\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eget_leaders\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Warren'\u003c/span\u003e))\n# [\u003cspan class=\"hljs-string\"\u003e'Warren'\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e매번 함수 호출할 때마다 새로운 목록이 생성됩니다.\u003c/p\u003e\n\u003cp\u003e실제로 Python 함수에서 가변 기본 인수를 사용하는 것은 Python이 가변 및 불변 데이터 구조를 처리하는 방식으로 인해 안티 패턴으로 간주됩니다. 이 동작은 종종 예상치 못한 결과와 찾기 어려운 버그로 이어집니다.\u003c/p\u003e\n\u003ch1\u003e8. If-Else가 모든 곳에서 등장합니다\u003c/h1\u003e\n\u003cp\u003ePython 3.10 이전에는 때때로 많은 if-else 문을 작성해야 했습니다. 왜냐하면 Python은 아직 match-case 구문을 지원하지 않았기 때문입니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e파이썬 3.10 이후로 구조적 패턴 매칭 기술이 소개되면서 if-else 문을 반복적으로 작성하는 불편을 피할 수 있게 되었습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003ehandle_http_status\u003c/span\u003e(status_code):\n    match \u003cspan class=\"hljs-attr\"\u003estatus_code\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e:\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"성공!\"\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e400\u003c/span\u003e:\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"잘못된 요청\"\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e401\u003c/span\u003e:\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"권한 없음\"\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e404\u003c/span\u003e:\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"찾을 수 없음\"\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e:\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"내부 서버 오류\"\u003c/span\u003e\n\n\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003ehandle_http_status\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e))\n# 성공!\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003ehandle_http_status\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e404\u003c/span\u003e))\n# 찾을 수 없음\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003ehandle_http_status\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2077\u003c/span\u003e))\n# \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 프로그램에서 보듯이, match-case 구문을 사용하여 각각 다른 입력을 처리할 수 있습니다. 모든 경우에 if-else 문이 필요하지 않다는 것을 알 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e9. C-스타일 문자열 포맷팅\u003c/h1\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e파이썬의 매우 오래된 버전에서는 문자열 포맷팅 연산이 C 프로그래밍 언어와 같았습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ename = \u003cspan class=\"hljs-string\"\u003e'Yang'\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Hi, %s\"\u003c/span\u003e % name)\n# \u003cspan class=\"hljs-title class_\"\u003eHi\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eYang\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러나 파이썬이 많이 발전함에 따라 이전 구문은 여전히 사용할 수 있지만, 그 낡은 면모를 보여주고 있습니다:\u003c/p\u003e\n\u003cp\u003e지금은 이 오래된 기술을 피하고 모든 문자열 포맷팅에 f-string 구문을 적용해야 합니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003ename = 'Yang'\ndesc = 'amazing'\nprint(f\"Hi, {name}! You are {desc}!\")\u003c/p\u003e\n\u003ch1\u003eHi, Yang! You are amazing!\u003c/h1\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e어떤 프로그래밍 언어도 완벽하지 않습니다.\u003c/p\u003e\n\u003cp\u003e자바보다 오래된 파이썬은 불가피하게 몇 가지 나쁜 설계로 인해 안티 패턴을 유발합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e경험 많은 Python 개발자로서, 우리는 문제가 있는 곳을 파악하고 그것들을 피하는 것이 중요해요. 동시에, 최신 구문을 활용하기 위해 새로운 Python 버전의 업데이트를 주시하면 도움이 될 거예요.\u003c/p\u003e\n\u003cp\u003e읽어 주셔서 감사합니다. ❤️ 만약 마음에 드셨다면, 연락해 보아요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLinkedin\u003c/li\u003e\n\u003cli\u003eMedium\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e제가 작성한 더 많은 Python 자습서들:\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-14-9PythonAntiPatternsThatIWillNeverApplyinProduction"},"buildId":"M7pU9hOcx8u_ZIFMf95sd","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>