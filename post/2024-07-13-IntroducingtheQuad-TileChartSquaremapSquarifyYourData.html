<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>데이터 시각화 갓템, Quad-Tile Chart와 Squaremap 사용법 소개 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="데이터 시각화 갓템, Quad-Tile Chart와 Squaremap 사용법 소개 | TIL" data-gatsby-head="true"/><meta property="og:title" content="데이터 시각화 갓템, Quad-Tile Chart와 Squaremap 사용법 소개 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData" data-gatsby-head="true"/><meta name="twitter:title" content="데이터 시각화 갓템, Quad-Tile Chart와 Squaremap 사용법 소개 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-13 19:59" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-5ecfd58aae5a7e3d.js" defer=""></script><script src="/_next/static/xx51Gh_JNHDTBdDwrgykD/_buildManifest.js" defer=""></script><script src="/_next/static/xx51Gh_JNHDTBdDwrgykD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">데이터 시각화 갓템, Quad-Tile Chart와 Squaremap 사용법 소개</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="데이터 시각화 갓템, Quad-Tile Chart와 Squaremap 사용법 소개" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 13, 2024</span><span class="posts_reading_time__f7YPP">59<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_0.png" alt="2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_0"></p>
<h1>소개</h1>
<p>데이터 시각화에서 사용 가능한 캔버스의 크기와 모양은 항상 중요한 요소입니다. 이것은 공간을 절약하기 위한 수단으로 두 축 접근법을 사용하는 Crystal Bar Chart라는 차트를 최근 다른 기사에서 다룬 주제입니다.</p>
<p>이 기사에서는 값을 정사각형으로 시각화하고 볼록 다각형 또는 단순 오목 다각형 형태의 컨테이너를 가득 채우는 공간 절약 방법을 탐구하겠습니다. 또한 이 탐구 과정에 코드를 많이 활용해 보았으니, 다른 유용한 기술과 시각화 유형에 대한 재미있는 자습서로 제공될 수 있기를 희망합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 기사를 통해 달성하고자 하는 목표는 일반적이고 비표준적인 컨테이너 모양(아래 그림 참조)을 고려하고, 이와 유사한 모양의 값 집합을 제시하여 사용 가능한 공간을 최적화하고 직관적인 크기 비교를 제공하며 데이터를 사각형 모양으로 표현하는 것입니다!</p>
<p><img src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_1.png" alt="image"></p>
<p>새로운 축 없이 접근하기 전에, 결과를 측정할 좋은 기준을 찾을 수 있는 기존 축 기반 및 축 없는 방법에 대해 생각해 봅시다. 예를 들어, Wikipedia에서 제공하는 동물 중 상위 20마리의 최고 속도를 나타내는 정보를 활용하겠습니다.</p>
<h2>축 기반 데이터 시리즈 시각화</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>y-축이 항목의 값을 나타내는 경우, 정렬된 막대 차트와 경쟁하기 어려울 수 있어요. 먼저 그것을 플롯하고, 저의 vizmath 패키지를 사용하여 몇 가지 더 축 기반의 차트를 만들어 보겠습니다.</p>
<p>막대 차트</p>
<pre><code class="hljs language-js"># <span class="hljs-attr">https</span>:<span class="hljs-comment">//en.wikipedia.org/wiki/Fastest_animals (2024년 1월 26일 기준)</span>
# <span class="hljs-number">20</span>대 최고 빠른 동물 (최고속도, mph)

데이터 = {
    <span class="hljs-string">'id'</span> : [<span class="hljs-title function_">str</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">21</span>)],
    <span class="hljs-string">'speed'</span> : [<span class="hljs-number">242</span>,<span class="hljs-number">200</span>,<span class="hljs-number">105</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">95</span>,<span class="hljs-number">92.5</span>,<span class="hljs-number">88</span>,<span class="hljs-number">80</span>,<span class="hljs-number">79</span>,
        <span class="hljs-number">75</span>,<span class="hljs-number">67.85</span>,<span class="hljs-number">61.06</span>,<span class="hljs-number">60</span>,<span class="hljs-number">56</span>,<span class="hljs-number">55</span>,<span class="hljs-number">55</span>,<span class="hljs-number">55</span>,<span class="hljs-number">50</span>,<span class="hljs-number">50</span>]
}

# 막대 차트 (데이터는 이미 정렬되어 있음)
<span class="hljs-keyword">import</span> matplotlib.<span class="hljs-property">pyplot</span> <span class="hljs-keyword">as</span> plt

plt.<span class="hljs-title function_">figure</span>(figsize=(<span class="hljs-number">7</span>, <span class="hljs-number">1.5</span>))
막대 = plt.<span class="hljs-title function_">bar</span>(<span class="hljs-title function_">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">21</span>), 데이터[<span class="hljs-string">'speed'</span>], edgecolor=<span class="hljs-string">'black'</span>,
    color=<span class="hljs-string">'white'</span>, linewidth=<span class="hljs-number">1</span>)
plt.<span class="hljs-title function_">xticks</span>([])
plt.<span class="hljs-title function_">grid</span>(<span class="hljs-title class_">False</span>)
plt.<span class="hljs-title function_">show</span>()
</code></pre>
<img src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_2.png">
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>크리스털 막대 차트</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">from</span> vizmath.crystal_bar_chart <span class="hljs-keyword">import</span> crystals
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd

<span class="hljs-comment"># 데이터: 위를 참조하십시오</span>

df = pd.DataFrame(data)
cbc = crystals(df, <span class="hljs-string">'id'</span>, <span class="hljs-string">'speed'</span>, height_range=<span class="hljs-number">5</span>, width_override=<span class="hljs-number">5</span>,
    rotation=<span class="hljs-number">90</span>, offset=<span class="hljs-number">50</span>, bottom_up=<span class="hljs-literal">True</span>)
cbc.cbc_plot(legend=<span class="hljs-literal">False</span>, alternate_color=<span class="hljs-literal">True</span>, color=<span class="hljs-literal">False</span>)
</code></pre>
<p><img src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_3.png" alt="이미지"></p>
<p>비스웜 플롯</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> vizmath.<span class="hljs-property">beeswarm</span> <span class="hljs-keyword">import</span> swarm
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd

# 데이터: 위 참조

df = pd.<span class="hljs-title class_">DataFrame</span>(data)
diameter = <span class="hljs-number">5</span>
bs = <span class="hljs-title function_">swarm</span>(df, <span class="hljs-string">'id'</span>, <span class="hljs-string">'speed'</span>, <span class="hljs-title class_">None</span>, size_override=pi*(diameter/<span class="hljs-number">2</span>)**<span class="hljs-number">2</span>)
bs.<span class="hljs-title function_">beeswarm_plot</span>(color=<span class="hljs-title class_">False</span>)
</code></pre>
<img src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_4.png">
<p>각각의 메소드들은 값의 크기를 반영하는 모양과 위치를 제공하면서 데이터 집합의 밀도 프로필을 제공하는 독특한 방식을 제공합니다.</p>
<p>이제 같은 값 세트를 사용하여 상대적인 크기 비교에 중점을 둔 축 없는 예제로 넘어가며 일부 반응형 Bubble Chart를 그려 Quad-Tile Chart 알고리즘을 미리보겠습니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>축 없이 데이터 시각화</h2>
<p>축 없이 도메인을 표현하기 위해 한 수준의 트리맵(저의 Radial Treemap에 관심이 있는 경우 해당 문서를 확인해보세요!)을 포함하고, 이어서 Bubble 차트를 추가해 봅시다.</p>
<p>트리맵 (한 수준의 파이, 도넛, 직사각형)</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> vizmath.<span class="hljs-property">radial_treemap</span> <span class="hljs-keyword">import</span> rad_treemap <span class="hljs-keyword">as</span> rt
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd

# 데이터: 위의 데이터를 참조하세요

# 파이 트리맵
df = pd.<span class="hljs-title class_">DataFrame</span>(data)
o_rt = <span class="hljs-title function_">rt</span>(df, [<span class="hljs-string">'speed'</span>], <span class="hljs-string">'speed'</span>, r1=<span class="hljs-number">0</span>)
o_rt.<span class="hljs-title function_">plot_levels</span>()

# 도넛 트리맵
df = pd.<span class="hljs-title class_">DataFrame</span>(data)
o_rt = <span class="hljs-title function_">rt</span>(df, [<span class="hljs-string">'speed'</span>], <span class="hljs-string">'speed'</span>)
o_rt.<span class="hljs-title function_">plot_levels</span>()

# 트리맵
df = pd.<span class="hljs-title class_">DataFrame</span>(data)
o_rt = <span class="hljs-title function_">rt</span>(df, [<span class="hljs-string">'speed'</span>], <span class="hljs-string">'speed'</span>, r1=<span class="hljs-number">0</span>, r2=<span class="hljs-number">1</span>,
    a1=<span class="hljs-number">0</span>, a2=<span class="hljs-number">1</span>, rectangular=<span class="hljs-title class_">True</span>)
o_rt.<span class="hljs-title function_">plot_levels</span>()
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_5.png" alt="Bubble Chart (grid)"></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd

# <span class="hljs-attr">data</span>: 위에서 참조

df = pd.<span class="hljs-title class_">DataFrame</span>(data)

def <span class="hljs-title function_">grid_bubbles</span>(values, size_by=<span class="hljs-string">'area'</span>, rows=<span class="hljs-number">2</span>, cols=<span class="hljs-number">10</span>, buffer=<span class="hljs-number">0.1</span>):
    fig, ax = plt.<span class="hljs-title function_">subplots</span>(rows, cols, figsize=(<span class="hljs-number">7</span>, <span class="hljs-number">1.5</span>))
    sorted_values = np.<span class="hljs-title function_">sort</span>(values)[::-<span class="hljs-number">1</span>]
    <span class="hljs-keyword">if</span> size_by == <span class="hljs-string">'area'</span>:
        sizes = np.<span class="hljs-title function_">sqrt</span>(sorted_values) # 반지름 입력 고려
    elif size_by == <span class="hljs-string">'diameter'</span>:
        sizes = sorted_values # 반지름에 비례
    max_size = np.<span class="hljs-title function_">max</span>(sizes)
    b = max_size*buffer
    max_size += b
    index = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(rows):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(cols):
            # <span class="hljs-title class_">Matplotlib</span>의 <span class="hljs-title class_">Circle</span>을 위한 반지름 입력
            circle = plt.<span class="hljs-title class_">Circle</span>((<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>), sizes[index]/max_size/<span class="hljs-number">2</span>,
                color=<span class="hljs-string">'black'</span>, fill=<span class="hljs-title class_">False</span>, linewidth=<span class="hljs-number">2</span>)
            ax[i, j].<span class="hljs-title function_">add_artist</span>(circle)
            ax[i, j].<span class="hljs-title function_">set_xlim</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)
            ax[i, j].<span class="hljs-title function_">set_ylim</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)
            ax[i, j].<span class="hljs-title function_">axis</span>(<span class="hljs-string">'off'</span>)
            index += <span class="hljs-number">1</span>
    plt.<span class="hljs-title function_">tight_layout</span>()
    plt.<span class="hljs-title function_">show</span>()

<span class="hljs-title function_">grid_bubbles</span>(data[<span class="hljs-string">'speed'</span>], size_by=<span class="hljs-string">'area'</span>)
<span class="hljs-title function_">grid_bubbles</span>(data[<span class="hljs-string">'speed'</span>], size_by=<span class="hljs-string">'diameter'</span>)
</code></pre>
<p><img src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_6.png" alt="Bubble Chart (grid)"></p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>버블 차트 (내 새로운 Quad-Tile 차트 알고리즘을 사용하여 반 정렬)</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> vizmath.<span class="hljs-property">quadtile_chart</span> <span class="hljs-keyword">import</span> polyquadtile <span class="hljs-keyword">as</span> pq
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd

# 데이터: 위를 참조하세요

# 면적에 따라 크기 조정
df = pd.<span class="hljs-title class_">DataFrame</span>(data)
df[<span class="hljs-string">'speed'</span>] = df[<span class="hljs-string">'speed'</span>]/df[<span class="hljs-string">'speed'</span>].<span class="hljs-title function_">max</span>()*<span class="hljs-number">3.5</span>
o_pq = <span class="hljs-title function_">pq</span>(df,<span class="hljs-string">'id'</span>,<span class="hljs-string">'speed'</span>,buffer=<span class="hljs-number">0.0</span>, collapse=<span class="hljs-title class_">True</span>,
    constraints=[(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)], auto=<span class="hljs-title class_">False</span>)
o_pq.<span class="hljs-title function_">polyquadtile_plot</span>(show_constraints=<span class="hljs-title class_">True</span>, poly_color=<span class="hljs-string">'w'</span>,
    poly_line=<span class="hljs-string">'black'</span>, squares_off=<span class="hljs-title class_">True</span>, circles=<span class="hljs-title class_">True</span>)
<span class="hljs-title function_">print</span>(o_pq.<span class="hljs-property">multiplier</span>)

# 지름에 따라 크기 조정
df = pd.<span class="hljs-title class_">DataFrame</span>(data)
df[<span class="hljs-string">'speed'</span>] = df[<span class="hljs-string">'speed'</span>]**<span class="hljs-number">2</span> # 지름 비율에 맞게 조정
df[<span class="hljs-string">'speed'</span>] = df[<span class="hljs-string">'speed'</span>]/df[<span class="hljs-string">'speed'</span>].<span class="hljs-title function_">max</span>()*<span class="hljs-number">3.5</span>
o_pq = <span class="hljs-title function_">pq</span>(df,<span class="hljs-string">'id'</span>,<span class="hljs-string">'speed'</span>,buffer=<span class="hljs-number">0.0</span>, collapse=<span class="hljs-title class_">True</span>,
    constraints=[(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)], auto=<span class="hljs-title class_">False</span>)
o_pq.<span class="hljs-title function_">polyquadtile_plot</span>(show_constraints=<span class="hljs-title class_">True</span>, poly_color=<span class="hljs-string">'w'</span>,
    poly_line=<span class="hljs-string">'black'</span>, squares_off=<span class="hljs-title class_">True</span>, circles=<span class="hljs-title class_">True</span>)
</code></pre>
<p><img src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_7.png" alt="이미지"></p>
<p>이러한 방법들은 값이 어떤 크기인지 직접적인 참조를 제공하는 축이 없어서 위치 변경 기능이 작동합니다. 따라서 값의 모양, 크기 및 레이아웃이 데이터 인사이트를 수집하는 데 중요합니다. 값 표현 간의 공간을 보존하는 방식으로 이러한 차트를 유용하게 만드는 파라미터 조정이 중요합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>숫자 축 기반 차트의 경우 멀리 떨어져 있는 값 모양을 나란히 보여줄 수 있지만, 축 없는 차트를 사용하면 값 모양을 옆으로 보여줄 수 있어요. 데이터와 사용 사례에 따라, 축 없는 방법의 시각화 압축은 축 기반 방법보다 상당한 장점이 될 수 있어요.</p>
<p>위의 버블 차트에서는 면적 및 지름별 크기 설정도 포함했어요. 크기 설정 메커니즘은 종종 간과될 수 있지만, 두 결과 간의 차이는 상당할 수 있어요! 데이터의 성겁과 시각화의 내러티브 맥락에 따라, 시각화 도구에서 크기 설정이 무엇을 기반으로 하는지 항상 알고 있으면, 정보에 기반한 선택을 할 수 있어요.</p>
<p>기본 케이스 (경쟁사)</p>
<p>위의 예시를 리뷰하면 버블 차트가 사용 가능한 공간을 보존하면서 비슷한 형태의 값 세트를 적절히 크기에 맞게 표현하는 우리의 초기 목표를 이루는 경쟁자임을 알 수 있어요.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>포장된 Bubble Chart(컨테이너)는 결과를 측정하기 위한 경쟁 상대가 될 것입니다. 그러나 아쉽게도 내가 찾은 구현 (아래에 표시됨)은 원형 레이아웃만 나타내므로 다른 컨테이너 모양을 탐색할 때 완벽한 비교 사례가 되지 않을 것입니다.</p>
<pre><code class="hljs language-js"># circlify
<span class="hljs-keyword">import</span> circlify
circles_circlify = circlify.<span class="hljs-title function_">circlify</span>(data[<span class="hljs-string">'speed'</span>], show_enclosure=<span class="hljs-title class_">False</span>)
circles = [c <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> circles_circlify]
max_radius = <span class="hljs-title function_">max</span>(circle.<span class="hljs-property">r</span> <span class="hljs-keyword">for</span> circle <span class="hljs-keyword">in</span> circles)
xlim = <span class="hljs-title function_">max</span>(<span class="hljs-title function_">abs</span>(circle.<span class="hljs-property">x</span>) + max_radius <span class="hljs-keyword">for</span> circle <span class="hljs-keyword">in</span> circles)
ylim = <span class="hljs-title function_">max</span>(<span class="hljs-title function_">abs</span>(circle.<span class="hljs-property">y</span>) + max_radius <span class="hljs-keyword">for</span> circle <span class="hljs-keyword">in</span> circles)
limit = <span class="hljs-title function_">max</span>(xlim, ylim)
fig, axs = plt.<span class="hljs-title function_">subplots</span>(figsize=(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>))
axs.<span class="hljs-title function_">axis</span>(<span class="hljs-string">'off'</span>)
plt.<span class="hljs-title function_">xlim</span>(-limit, limit)
plt.<span class="hljs-title function_">ylim</span>(-limit, limit)
<span class="hljs-keyword">for</span> circle <span class="hljs-keyword">in</span> <span class="hljs-attr">circles</span>:
    axs.<span class="hljs-title function_">add_patch</span>(plt.<span class="hljs-title class_">Circle</span>((circle.<span class="hljs-property">x</span>, circle.<span class="hljs-property">y</span>), circle.<span class="hljs-property">r</span>,
        edgecolor=<span class="hljs-string">'black'</span>, facecolor=<span class="hljs-string">'white'</span>, linewidth=<span class="hljs-number">2</span>))
plt.<span class="hljs-title function_">show</span>()

# packcircles
<span class="hljs-keyword">import</span> packcircles
circles_packcircles = packcircles.<span class="hljs-title function_">pack</span>(data[<span class="hljs-string">'speed'</span>])
circles = [c <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> circles_packcircles]
# circles
max_radius = <span class="hljs-title function_">max</span>(radius <span class="hljs-keyword">for</span> (_, _, radius) <span class="hljs-keyword">in</span> circles)
xlim = <span class="hljs-title function_">max</span>(<span class="hljs-title function_">abs</span>(x) + max_radius <span class="hljs-keyword">for</span> (x, _, _) <span class="hljs-keyword">in</span> circles)
ylim = <span class="hljs-title function_">max</span>(<span class="hljs-title function_">abs</span>(y) + max_radius <span class="hljs-keyword">for</span> (_, y, _) <span class="hljs-keyword">in</span> circles)
limit = <span class="hljs-title function_">max</span>(xlim, ylim)
fig, axs = plt.<span class="hljs-title function_">subplots</span>(figsize=(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>))
axs.<span class="hljs-title function_">axis</span>(<span class="hljs-string">'off'</span>)
plt.<span class="hljs-title function_">xlim</span>(-limit, limit)
plt.<span class="hljs-title function_">ylim</span>(-limit, limit)
<span class="hljs-keyword">for</span> (x, y, radius) <span class="hljs-keyword">in</span> <span class="hljs-attr">circles</span>:
    axs.<span class="hljs-title function_">add_patch</span>(plt.<span class="hljs-title class_">Circle</span>((x, y), radius,
        edgecolor=<span class="hljs-string">'black'</span>, facecolor=<span class="hljs-string">'white'</span>, linewidth=<span class="hljs-number">2</span>))
plt.<span class="hljs-title function_">show</span>()

# <span class="hljs-title class_">Tableau</span> <span class="hljs-title class_">Public</span>:
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> os
df = pd.<span class="hljs-title class_">DataFrame</span>(data)
df.<span class="hljs-title function_">to_csv</span>(os.<span class="hljs-property">path</span>.<span class="hljs-title function_">dirname</span>(__file__) + <span class="hljs-string">'/circles.csv'</span>,
    encoding=<span class="hljs-string">'utf-8'</span>, index=<span class="hljs-title class_">False</span>)
# select packed bubbles -> <span class="hljs-title class_">Size</span> by [<span class="hljs-title class_">Speed</span>], [<span class="hljs-title class_">Id</span>] on <span class="hljs-title class_">Detail</span>
</code></pre>
<img src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_8.png">
<p>경쟁 상대를 선택했으니 이제 포장된 Bubble Chart가 홀로 서 있는지 또는 컨테이너 포장 목표를 충족하는 상대적 가치 비교를 위해 활용할 수 있는 다른 단순한 모양이 있는지 살펴보겠습니다. 이제 정사각형의 응용을 탐색해 보겠습니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>왜 Squarify를 사용해야 할까요?</h2>
<p>이미 패킹된 원들을 조사하는 무대를 마련했으니, 짧게 쉬어가며 질문을 해보는 게 좋을 것 같아요. 패킹된 원들이 존재하는데 왜 사각형에 관심을 가질까요?</p>
<p>데이터 시각화에서 이미 패킹된 원들이 널리 사용되고 있으므로 사람들은 원을 좋아하는 것으로 보입니다. 다양한 패킹된 버블 차트 구현은 다양한 프로그래밍 언어 및 소프트웨어에서 쉽게 찾을 수 있어요. 사실, Quad-Tile 차트를 만든 후 가장 먼저 한 일은 동그라미를 그리는 데 사용했어요 (소개 부분에 나와 있음). 그래서 동그라미의 매력은 실재해요!</p>
<p>하지만 사각형은 어떨까요? 다른 가능한 모양들과 비교했을 때 패킹된 사각형은 상대적으로 무해해 보이지만, 확실한 패킹된 사각형 차트 구현을 찾는 것은 어렵습니다. 왜 그럴까요...</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>간단한 비교를 하고 어떤 것을 발견해 봅시다:</p>
<p><img src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_9.png" alt="image"></p>
<p>위의 경우 1:2 비율을 사용하여 넓이나 길이를 비교하는 데 둥근 모양이나 사각형 모두 다른 것보다 직관성을 제공하지 않는 것으로 보입니다. 하지만 원은 더 부드럽고 사각형은 더 날카로운 것 같아요.</p>
<p>그렇다면, 나는 스퀘어리파이를 하는 이유가 다음과 같습니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>패킹된 사각형 구현은 존재하지 않는 것 같아서 시각적으로 얼마나 매력적인지 알기가 어렵습니다(패킹된 원의 대체물로). 따라서 조사할 가치가 있습니다.</li>
<li>파이썬의 사용 가능한 패킹된 원 구현물에서는 컨테이너를 활용할 수 있는 능력이 일반적으로 부족합니다(모두 원의 수가 증가함에 따라 원형 레이아웃만 제공하는 것으로 보입니다).</li>
<li>사각형의 단순성은 알고리즘을 통해 사각형을 채우려고 시도하면 수학적 연산이 직관적일 것으로 보입니다. 따라서 빠른 개념 증명이 가능할 수도 있습니다.</li>
</ul>
<p>스퀘어화를 추구하는 동기를 제시했으니, 이제 사각형 패킹 노력의 핵심 구성 요소인 패킹을 살펴보고, 사각형이 원에 어떻게 대응하는지 확인해봅시다.</p>
<h1>모양 패킹 &#x26; 컨테이너 패킹</h1>
<h2>타일링과 함께</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>수사 목적으로 명백한 것을 언급할 가치가 있습니다. 사각형은 가장을 가지고 있지만 원은 그렇지 않습니다. 이 특성은 유사한 크기의 사각형들을 테셀레이션할 수 있게 해주어, 패킹이라는 유용한 개념이 될 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> matplotlib.<span class="hljs-property">pyplot</span> <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">import</span> matplotlib.<span class="hljs-property">patches</span> <span class="hljs-keyword">as</span> patches

# 도형과 공간을 사용하여 다이아몬드 테셀레이션 모의실험을 해봅시다.
def <span class="hljs-title function_">diamond_tessellation</span>(rows, cols):
    fig, ax = plt.<span class="hljs-title function_">subplots</span>()
    ax.<span class="hljs-title function_">set_aspect</span>(<span class="hljs-string">'equal'</span>, adjustable=<span class="hljs-string">'box'</span>)
    plt.<span class="hljs-title function_">axis</span>(<span class="hljs-string">'off'</span>)
    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(rows):
        <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(cols):
            diamond = patches.<span class="hljs-title class_">Polygon</span>([
                (col + <span class="hljs-number">0.5</span>, row), 
                (col + <span class="hljs-number">1</span>, row + <span class="hljs-number">0.5</span>), 
                (col + <span class="hljs-number">0.5</span>, row + <span class="hljs-number">1</span>), 
                (col, row + <span class="hljs-number">0.5</span>)
                ], edgecolor=<span class="hljs-string">'grey'</span>, facecolor=<span class="hljs-string">'whitesmoke'</span>)
            ax.<span class="hljs-title function_">add_patch</span>(diamond)
    ax.<span class="hljs-title function_">set_xlim</span>(<span class="hljs-number">0</span>, cols)
    ax.<span class="hljs-title function_">set_ylim</span>(<span class="hljs-number">0</span>, rows)
    plt.<span class="hljs-title function_">show</span>()

<span class="hljs-title function_">diamond_tessellation</span>(<span class="hljs-number">2</span>, <span class="hljs-number">9</span>)
</code></pre>
<img src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_10.png">
<p>유감스럽게도, 테셀레이션은 데이터셋의 값이 동일하거나 편리한 비율을 가지는 것으로 가정하는 것이 현실적이지 않기 때문에 일반적인 해결책은 아닙니다. 그러나 간격이 없는 가장의 개념은 원보다 잠재적인 이점으로 더 탐구할 가치가 있습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>최적화로</h2>
<p>최적화 방법은 두 개의 모양을 비교하는 메커니즘으로 다음 단계로 가치 있는 것처럼 보입니다. 그래서 원과 정사각형 사이에 가능한 균일하게 적용할 수 있는 간단한 목적 함수에 집중하여 결과를 검토해 봅시다.</p>
<p>먼저, 목적 함수의 요소를 식별해야 합니다. 우리는 모양의 중첩을 방지하는 메커니즘과 밀접하게 패킹하려는 반대 힘이 필요합니다. 각각을 자세히 살펴보겠습니다.</p>
<ul>
<li>중첩 방지 (밀어내기) - 중첩을 방지하기 위해 모양들의 총 중첩 영역을 고려하고, 다른 모양에 완전히 포함되는 모양에 대해 추가 벌칙을 부과하여 작은 모양의 중첩 방지를 촉진합니다.</li>
<li>패킹 촉진 (가까이 끌어모으기) - 패킹을 촉진하기 위해 모양을 특정 관심 지점으로 끌어당기는 것을 보상할 것입니다.</li>
</ul>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>지금은 컨테이너를 무시하고 도형 패킹에 초점을 맞춰 각 도형의 기하학적 특징을 살펴봅시다. 이제 식별된 재료로 구현할 함수를 설정해 봅시다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> shapely.<span class="hljs-property">geometry</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">Point</span>, <span class="hljs-title class_">Polygon</span>
<span class="hljs-keyword">from</span> shapely.<span class="hljs-property">ops</span> <span class="hljs-keyword">import</span> unary_union

# 셰이프의 중심에서 관심 지점까지의 거리를 더하여 당김 힘을 설정합시다
def <span class="hljs-title function_">calc_distance_from_point</span>(shapes, shape_type, origin):
    penalty = <span class="hljs-number">0</span>
    ref_point = <span class="hljs-title class_">Point</span>(origin)
    <span class="hljs-keyword">if</span> shape_type == <span class="hljs-string">'circle'</span>:
        <span class="hljs-keyword">for</span> x, y, _ <span class="hljs-keyword">in</span> <span class="hljs-attr">shapes</span>:
            centroid = <span class="hljs-title class_">Point</span>(x, y)
            penalty += centroid.<span class="hljs-title function_">distance</span>(ref_point)
    elif shape_type == <span class="hljs-string">'square'</span>:
        <span class="hljs-keyword">for</span> x, y, side <span class="hljs-keyword">in</span> <span class="hljs-attr">shapes</span>:
            centroid = <span class="hljs-title class_">Polygon</span>([(x, y), (x + side, y),
                (x + side, y + side), (x, y + side)]).<span class="hljs-property">centroid</span>
            penalty += centroid.<span class="hljs-title function_">distance</span>(ref_point)
    <span class="hljs-keyword">return</span> penalty

# 이제 첫 번째 당김 힘을 설정하여 한 도형이 다른 도형 안에 포함되어 있는지 여부를 파악하고 발생 횟수를 더합시다
def <span class="hljs-title function_">calc_containment</span>(shapes, shape_type):
    penalty = <span class="hljs-number">0</span>
    shapely_shapes = []
    <span class="hljs-keyword">if</span> shape_type == <span class="hljs-string">'circle'</span>:
        shapely_shapes = [<span class="hljs-title class_">Point</span>(x, y).<span class="hljs-title function_">buffer</span>(r) 
            <span class="hljs-keyword">for</span> x, y, r <span class="hljs-keyword">in</span> shapes]
    elif shape_type == <span class="hljs-string">'square'</span>:
        shapely_shapes = [<span class="hljs-title class_">Polygon</span>([(x, y), (x + side, y),
            (x + side, y + side), (x, y + side)]) 
            <span class="hljs-keyword">for</span> x, y, side <span class="hljs-keyword">in</span> shapes]
    <span class="hljs-keyword">for</span> i, shape1 <span class="hljs-keyword">in</span> <span class="hljs-title function_">enumerate</span>(shapely_shapes):
        <span class="hljs-keyword">for</span> j, shape2 <span class="hljs-keyword">in</span> <span class="hljs-title function_">enumerate</span>(shapely_shapes):
            <span class="hljs-keyword">if</span> i != j and shape1.<span class="hljs-title function_">contains</span>(shape2):
                penalty += <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> penalty

# 당김 힘을 완성하기 위해 전체 도형 중첩 영역을 계산합시다
def <span class="hljs-title function_">calc_overlap_area</span>(shapes, shape_type):
    <span class="hljs-keyword">if</span> shape_type == <span class="hljs-string">'circle'</span>:
        shapely_shapes = [<span class="hljs-title class_">Point</span>(s[<span class="hljs-number">0</span>], s[<span class="hljs-number">1</span>]).<span class="hljs-title function_">buffer</span>(s[<span class="hljs-number">2</span>]) 
            <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> shapes]
    elif shape_type == <span class="hljs-string">'square'</span>:
        shapely_shapes = [<span class="hljs-title class_">Polygon</span>([(s[<span class="hljs-number">0</span>], s[<span class="hljs-number">1</span>]), (s[<span class="hljs-number">0</span>] + s[<span class="hljs-number">2</span>], s[<span class="hljs-number">1</span>]), 
            (s[<span class="hljs-number">0</span>] + s[<span class="hljs-number">2</span>], s[<span class="hljs-number">1</span>] + s[<span class="hljs-number">2</span>]), (s[<span class="hljs-number">0</span>], s[<span class="hljs-number">1</span>] + s[<span class="hljs-number">2</span>])]) 
            <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> shapes]
    merged_area = <span class="hljs-title function_">unary_union</span>(shapely_shapes).<span class="hljs-property">area</span>
    individual_areas = <span class="hljs-title function_">sum</span>(shape.<span class="hljs-property">area</span> <span class="hljs-keyword">for</span> shape <span class="hljs-keyword">in</span> shapely_shapes)
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">abs</span>(individual_areas - merged_area)

# 마지막으로, 힘을 종합하여 목적 함수로 만들어봅시다
def <span class="hljs-title function_">objective_function</span>(variables, shapes, shape_type, 
    origin=(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>), prevent_overlap_factor=<span class="hljs-number">2</span>):
    <span class="hljs-keyword">for</span> i, shape <span class="hljs-keyword">in</span> <span class="hljs-title function_">enumerate</span>(shapes):
        shapes[i] = (variables[i*<span class="hljs-number">2</span>], variables[i*<span class="hljs-number">2</span> + <span class="hljs-number">1</span>], shape[<span class="hljs-number">2</span>])
    overlap_area = <span class="hljs-title function_">calc_overlap_area</span>(shapes, shape_type)
    contained = <span class="hljs-title function_">calc_containment</span>(shapes, shape_type)
    sum_distance = <span class="hljs-title function_">calc_distance_from_point</span>(shapes, shape_type, origin)
    <span class="hljs-keyword">return</span> overlap_area * prevent_overlap_factor * (<span class="hljs-number">1</span> + contained) + sum_distance
</code></pre>
<p>목적 함수에서는 도형의 겹치는 영역을 포함하는 모양의 수와 곱하여 당김 패널티를 집중시키기로 선택했습니다. 그리고 당김 정도를 조절하는 'prevent_overlap_factor' 가중치를 추가했습니다.</p>
<p>이제 목적 함수가 준비되었으니, 이전의 예제 데이터를 사용하여 원과 사각형 패킹 최적화 루틴을 설정해 봅시다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"># 이전 예시 데이터:
data = {
    <span class="hljs-string">'id'</span> : [<span class="hljs-title function_">str</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">21</span>)],
    <span class="hljs-string">'speed'</span> : [<span class="hljs-number">242</span>,<span class="hljs-number">200</span>,<span class="hljs-number">105</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">95</span>,<span class="hljs-number">92.5</span>,<span class="hljs-number">88</span>,<span class="hljs-number">80</span>,<span class="hljs-number">79</span>,
        <span class="hljs-number">75</span>,<span class="hljs-number">67.85</span>,<span class="hljs-number">61.06</span>,<span class="hljs-number">60</span>,<span class="hljs-number">56</span>,<span class="hljs-number">55</span>,<span class="hljs-number">55</span>,<span class="hljs-number">55</span>,<span class="hljs-number">50</span>,<span class="hljs-number">50</span>]
}

# 원하는 크기 창(<span class="hljs-title class_">Window</span>) (계수)와 모양의 반복 가능한 랜덤 위치를 위한 시드를 설정해봅시다.

계수 = <span class="hljs-number">10</span>
시드 = <span class="hljs-number">123</span>

최대속도 = np.<span class="hljs-title function_">max</span>(data[<span class="hljs-string">'speed'</span>])
np.<span class="hljs-property">random</span>.<span class="hljs-title function_">seed</span>(시드)

모양들 = [(np.<span class="hljs-property">random</span>.<span class="hljs-title function_">uniform</span>(<span class="hljs-number">0</span>, 계수*<span class="hljs-number">1.5</span>),
    np.<span class="hljs-property">random</span>.<span class="hljs-title function_">uniform</span>(<span class="hljs-number">0</span>, 계수*<span class="hljs-number">1.5</span>),
    v/최대속도*계수) <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> data[<span class="hljs-string">'speed'</span>]]
</code></pre>
<p>이제, 원과 사각형의 입력을 분리하고 최적화 메서드에 전달할 경계를 추가해봅시다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> copy
<span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sqrt

# 각 모양에 대해 최적화하기 위해 복사본을 만듭시다.
원들 = copy.<span class="hljs-title function_">deepcopy</span>(모양들)
사각형들 = copy.<span class="hljs-title function_">deepcopy</span>(모양들)

# 위치를 최적화하기 위해 좌표를 평면으로 펼쳐봅시다
초기_위치 = [val <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> 모양들 <span class="hljs-keyword">for</span> val <span class="hljs-keyword">in</span> s[:<span class="hljs-number">2</span>]]

# 이제 각 모양의 경계를 계산하여 최적화 함수에 전달합시다
def <span class="hljs-title function_">calc_bounds</span>(모양들, 모양_유형):
    총_면적 = <span class="hljs-number">0</span>
    <span class="hljs-keyword">if</span> 모양_유형 == <span class="hljs-string">'원'</span>:
        총_면적 = <span class="hljs-title function_">sum</span>(np.<span class="hljs-property">pi</span> * (r**<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> _, _, r <span class="hljs-keyword">in</span> 모양들)
    elif 모양_유형 == <span class="hljs-string">'사각형'</span>:
        총_면적 = <span class="hljs-title function_">sum</span>(side**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> _, _, side <span class="hljs-keyword">in</span> 모양들)
    추정된_한변의_길이 = <span class="hljs-title function_">sqrt</span>(총_면적)
    패딩 = 추정된_한변의_길이 / <span class="hljs-number">2</span>
    하한 = <span class="hljs-number">0</span> - 패딩
    상한 = 추정된_한변의_길이 + 패딩
    <span class="hljs-keyword">return</span> (하한, 상한)

# 원과 사각형에 대한 경계 계산
원의_경계 = <span class="hljs-title function_">calc_bounds</span>(원들, <span class="hljs-string">'원'</span>)
사각형의_경계 = <span class="hljs-title function_">calc_bounds</span>(사각형들, <span class="hljs-string">'사각형'</span>)

# 각 모양에 경계를 적용하여 최적화하기
원_경계들 = [(원의_경계[<span class="hljs-number">0</span>], 원의_경계[<span class="hljs-number">1</span>]) 
    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-title function_">len</span>(초기_위치))]
사각형_경계들 = [(사각형의_경계[<span class="hljs-number">0</span>], 사각형의_경계[<span class="hljs-number">1</span>])
    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-title function_">len</span>(초기_위치))]

# 풀 힘을 위한 접힘점을 설정하기 위해 경계를 사용
원의_접힘점 = (원의_경계[<span class="hljs-number">1</span>]-원의_경계[<span class="hljs-number">0</span>])/<span class="hljs-number">2</span>+원의_경계[<span class="hljs-number">0</span>]
사각형의_접힘점 = (사각형의_경계[<span class="hljs-number">1</span>]-사각형의_경계[<span class="hljs-number">0</span>])/<span class="hljs-number">2</span>+사각형의_경계[<span class="hljs-number">0</span>]
원의_접힘점들 = (원의_접힘점, 원의_접힘점)
사각형의_접힘점들 = (사각형의_접힘점, 사각형의_접힘점)
</code></pre>
<p>마지막으로, 결과를 시각화하기 위한 플로팅 함수를 설정하고 각 모양에 대해 최적화를 실행해보겠습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> matplotlib.<span class="hljs-property">pyplot</span> <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">import</span> matplotlib.<span class="hljs-property">patches</span> <span class="hljs-keyword">as</span> patches
<span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> inf
<span class="hljs-keyword">from</span> scipy.<span class="hljs-property">optimize</span> <span class="hljs-keyword">import</span> minimize

# 결과를 확인할 수 있는 plotting 함수를 만들어봅시다.
def <span class="hljs-title function_">plot_shapes</span>(shapes, shape_type):
    fig, ax = plt.<span class="hljs-title function_">subplots</span>()
    min_x, min_y, max_x, max_y = <span class="hljs-number">0.</span>,<span class="hljs-number">0.</span>,<span class="hljs-number">0.</span>,<span class="hljs-number">0.</span>
    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-attr">shapes</span>:
        <span class="hljs-keyword">if</span> shape_type == <span class="hljs-string">'circle'</span>:
            circle = patches.<span class="hljs-title class_">Circle</span>((s[<span class="hljs-number">0</span>], s[<span class="hljs-number">1</span>]), s[<span class="hljs-number">2</span>],
                facecolor=<span class="hljs-string">'lightgrey'</span>, edgecolor=<span class="hljs-string">'black'</span>)
            ax.<span class="hljs-title function_">add_patch</span>(circle)
            min_x = <span class="hljs-title function_">min</span>(min_x, s[<span class="hljs-number">0</span>] - s[<span class="hljs-number">2</span>])
            min_y = <span class="hljs-title function_">min</span>(min_y, s[<span class="hljs-number">1</span>] - s[<span class="hljs-number">2</span>])
            max_x = <span class="hljs-title function_">max</span>(max_x, s[<span class="hljs-number">0</span>] + s[<span class="hljs-number">2</span>])
            max_y = <span class="hljs-title function_">max</span>(max_y, s[<span class="hljs-number">1</span>] + s[<span class="hljs-number">2</span>])
        elif shape_type == <span class="hljs-string">'square'</span>:
            square = patches.<span class="hljs-title class_">Rectangle</span>((s[<span class="hljs-number">0</span>], s[<span class="hljs-number">1</span>]), s[<span class="hljs-number">2</span>], s[<span class="hljs-number">2</span>],
                facecolor=<span class="hljs-string">'lightgrey'</span>, edgecolor=<span class="hljs-string">'black'</span>)
            ax.<span class="hljs-title function_">add_patch</span>(square)
            min_x = <span class="hljs-title function_">min</span>(min_x, s[<span class="hljs-number">0</span>])
            min_y = <span class="hljs-title function_">min</span>(min_y, s[<span class="hljs-number">1</span>])
            max_x = <span class="hljs-title function_">max</span>(max_x, s[<span class="hljs-number">0</span>] + s[<span class="hljs-number">2</span>])
            max_y = <span class="hljs-title function_">max</span>(max_y, s[<span class="hljs-number">1</span>] + s[<span class="hljs-number">2</span>])
    padding = <span class="hljs-number">1</span>
    ax.<span class="hljs-title function_">set_xlim</span>(min_x - padding, max_x + padding)
    ax.<span class="hljs-title function_">set_ylim</span>(min_y - padding, max_y + padding)
    ax.<span class="hljs-title function_">set_aspect</span>(<span class="hljs-string">'equal'</span>, <span class="hljs-string">'box'</span>)
    plt.<span class="hljs-title function_">show</span>()

# 마지막으로 반복을 모니터링하는 콜백 함수를 설정해봅시다.
def <span class="hljs-title function_">callback</span>(i):
    <span class="hljs-variable language_">global</span> iteration
    iteration += <span class="hljs-number">1</span>
    <span class="hljs-title function_">print</span>(f<span class="hljs-string">'반복 {iteration}'</span>)

# 원 최적화 실행:
iteration = <span class="hljs-number">0</span>
optimized_circles = <span class="hljs-title function_">minimize</span>(objective_function, initial_positions,
    args=(circles, <span class="hljs-string">'circle'</span>, origin_circles), method=<span class="hljs-string">'L-BFGS-B'</span>,
    bounds=bounds_circles, callback=callback,
    options={<span class="hljs-string">'maxiter'</span>: <span class="hljs-number">300</span>, <span class="hljs-string">'maxfun'</span>: inf, <span class="hljs-string">'ftol'</span>: <span class="hljs-number">0</span>, <span class="hljs-string">'gtol'</span>: <span class="hljs-number">0</span>})
packed_circles = [(optimized_circles.<span class="hljs-property">x</span>[i*<span class="hljs-number">2</span>],
    optimized_circles.<span class="hljs-property">x</span>[i*<span class="hljs-number">2</span> + <span class="hljs-number">1</span>], circles[i][<span class="hljs-number">2</span>])
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-title function_">len</span>(circles))]
# <span class="hljs-title function_">plot_shapes</span>(shapes, <span class="hljs-string">'circle'</span>) # 초기 위치를 보려면 주석 해제
<span class="hljs-title function_">plot_shapes</span>(packed_circles, <span class="hljs-string">'circle'</span>)

# 사각형 최적화 실행:
iteration = <span class="hljs-number">0</span>
optimized_squares = <span class="hljs-title function_">minimize</span>(objective_function, initial_positions,
    args=(squares, <span class="hljs-string">'square'</span>, origin_squares), method=<span class="hljs-string">'L-BFGS-B'</span>,
    bounds=bounds_squares, callback=callback,
    options={<span class="hljs-string">'maxiter'</span>: <span class="hljs-number">300</span>, <span class="hljs-string">'maxfun'</span>: inf, <span class="hljs-string">'ftol'</span>: <span class="hljs-number">0</span>, <span class="hljs-string">'gtol'</span>: <span class="hljs-number">0</span>})
packed_squares = [(optimized_squares.<span class="hljs-property">x</span>[i*<span class="hljs-number">2</span>],
    optimized_squares.<span class="hljs-property">x</span>[i*<span class="hljs-number">2</span> + <span class="hljs-number">1</span>], squares[i][<span class="hljs-number">2</span>])
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-title function_">len</span>(squares))]
# <span class="hljs-title function_">plot_shapes</span>(shapes, <span class="hljs-string">'square'</span>) # 초기 위치를 보려면 주석 해제
<span class="hljs-title function_">plot_shapes</span>(packed_squares, <span class="hljs-string">'square'</span>)
</code></pre>
<p>위 코드에서는 'L-BFGS-B' 메서드를 선택하여 scipy의 'minimize' 함수에서 반복 횟수를 300으로 설정했습니다. 초기 위치를 제어하는 난수 시드는 결과에 영향을 미칠 수 있으므로 두 모양에 대해 각각 3가지 다른 시드를 살펴봅시다.</p>
<img src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_11.png">
<p>각 테스트 케이스를 생성하는 데 랩톱에서 약 5분이 걸렸으므로, 이 방법의 시간 요구 사항은 고려해야 할 불안정한 요소입니다. 이미 긴 대기 시간 때문에 컨테이너 중첩 비용을 목적 함수에 추가하여 컨테이너 패킹 통찰을 검토하는 것은 현재 필요하지 않은 것으로 보입니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>지면 배치 관련해서 원들이 더 조밀하게 배열되어 있는 것 같습니다. 이것이 데이터 시각화에서 패킹된 원이 패킹된 정사각형보다 흔한 이유를 설명하는 첫 번째 증거가 될 수 있습니다.</p>
<p>하지만 포기하기 전에, 정사각형에 맞춤화된 알고리즘을 사용한 최종 평가로 넘어가 봅시다!</p>
<h2>알고리즘을 통해</h2>
<p>위의 실험에서 얻은 주요 결론은:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>일반 최적화 구현을 사용하여 단순 목적 함수에 따라 패킹된 모양을 생성하는 것은 어느 정도 작동하는 것 같아요.</li>
<li>그러나 이것은 정말 느리고 대규모 데이터셋을 처리하기에 부적합하죠.</li>
<li>원형 배열들이 (적어도 컨테이너 패킹 없이는) 사각형 배열보다 더 융합되어 보였어요.</li>
</ul>
<p>우리는 대규모 데이터셋에서 성능이 우수하며 더 매력적인 사각형 배열을 생성할 수 있고, 컨테이너 패킹을 구현할 수 있는 특수화된 알고리즘이 필요하다는 것이 분명해요. 이 방식을 일반적인 최적화 프레임워크와 구분짓기 위해 사각형의 특정 특성을 활용하고, 포장 기회를 탐색할 필요가 있어요.</p>
<p>우리가 활용할 수 있는 사각형의 몇 가지 기하학적 요소를 나열하여 시작해봐요:</p>
<ul>
<li>형태: 네 개의 직각을 감싸고 있는 같은 길이의 네 변을 가지며, 화면을 기준으로 회전할 수 있어 다른 외형이 될 수 있는</li>
<li>패킹: 간격 없이 사각형 사이에 이웃할 수 있는 능력</li>
<li>배치: 각 사각형의 각 변은 4개의 가능한 꼭지점 중 하나에서 시작하여 이웃할 사각형에게 이웃할 수 있는 평면적인 2차원 공간을 무한대로 제공함</li>
</ul>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>다음에는 패킹된 사각형이 패킹된 원과 어떻게 경쟁할 수 있는지 이해하기 위해 Quad-Tile 차트라는 새로운 시각화 기술에 사용되는 알고리즘을 설명할 것입니다.</p>
<h2>Quad-Tile 차트</h2>
<h3>영감</h3>
<p>몇 년 전 어떤 사람이 패킹된 버블 차트는 대부분 쓸모없다고 말했습니다. 무슨 이유에서인지 그 말이 나에게 영감을 주어 패킹된 사각형 차트를 만들게 되었습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>첫 번째 버전을 개발하고 Tableau Public 시각화와 몇 가지 다른 기술과 함께 구체화된 결과물을 시험해 보았어요. 여기에는 18개의 사각형을 포함하는 Voronoi Treemaps가 있는 (v1) Quad-Tile Chart가 표시된 발췌본이 있어요. (Voronoi Treemaps는 D3.js를 사용하여 계산되었어요).</p>
<p><img src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_12.png" alt="Quad-Tile Chart"></p>
<p>아래에서는 이 알고리즘에 대해 설명하고, 몇 일 전에 다시 시작했을 때 최종적으로 채택한 방식을 설명할게요.</p>
<h2>(초기) 알고리즘 v1</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>내 초기 접근 방식인 2022년 초에는 컨테이너를 고려하지 않았습니다. 가장 큰 정사각형부터 시작하여 중앙에 배치한 후 모든 정사각형이 중심 정사각형 주변에 감싸지도록 연속적으로 나열하려고 노력했습니다. 가장 작은 정사각형은 가장 중심부터 먼 위치에 배치되었습니다.</p>
<p>마디 있는 정사각형 배열에 관해 스케치한 후에 나에게 온 개념 중에는 다음과 같은 것들이 있습니다:</p>
<ul>
<li>사분면 - 조사한 결과, 정사각형은 연속적인 사각형들을 분산하기 위한 4개의 오프셋 평면을 제공합니다.</li>
<li>자기 조직화 정사각형 배치 - 한 평면의 잠재적 너비와 오프셋 평면의 차지된 높이를 연관시킴으로써 자기 조직화를 가능케하도록 하며, 이는 공유 경계(분할된 세그먼트로 실행됨)를 구현함으로써 이루어집니다.</li>
<li>측면 전환 - 크기에 따라 정사각형들을 고르게 분산하기 위해, 원하는 순서로 하나를 배치한 후 측면을 전환합니다. (나는 기본적으로 윗쪽-오른쪽-아래쪽-왼쪽으로 전환했습니다.)</li>
<li>사용자 정의 - 이 방법은 값 정렬을 배제하지만, 일련의 규칙에 따라 다음 측면을 선택할 수 있는 기능을 구현할 수 있는 능력을 제공합니다.</li>
</ul>
<img src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_13.png">
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>v1 알고리즘은 다음과 같아요:</p>
<ul>
<li>먼저 양수 값들로 이루어진 집합부터 내림차순으로 정렬해요. 예를 들어, 9.4, 7.4, 1.5, 0.2</li>
<li>값을 패딩하기 위해 각 사각형 주변의 공간을 추가한 후 (예를 들어 0.5)</li>
<li>첫번째 (가장 큰) 사각형을 설정하고, 중앙 사각형 주변의 각 사분면을 위한 세그먼트 저장 메커니즘을 생성해요.</li>
<li>초기 세그먼트를 중앙 사각형의 변으로 설정하고, 각 사분면에 하나씩 배정해요.</li>
<li>옆면 순서 (기본값은 위, 오른쪽, 아래, 왼쪽)가 주어지면, 각 면을 반복하면서 작은 사각형을 배치해요. 각 사분면의 첫 번째 사각형은 해당 사분면 평면의 원점과 정렬되어, 해당 사분면의 초기 세그먼트 시작 위치에서 시작해요.</li>
<li>위쪽 면에 사각형을 배치하려면 (정렬 및 배치 요구 사항을 고려하여), 세그먼트를 가장 짧은 y값별로 정렬하고 가장 긴 길이를 가지는 세그먼트에서, 사각형의 너비 ≤ 세그먼트 길이인 첫 번째 세그먼트에 사각형을 배치해요.</li>
<li>사각형을 배치하면, 해당 사각형이 차지한 공간을 세그먼트에서 조절하여 세그먼트의 시작 위치 및 길이를 조정하고, 새로운 세그먼트를 만들어요.</li>
<li>배치된 사각형의 시작 위치가 사분면 평면의 오프셋 경계와 정렬되면 (중앙 사각형의 축에 수직인 경계), 중앙 사각형 주변의 자기 조직화 성장을 가능하게 하기 위해 영향을 받는 세그먼트의 세그먼트 길이를 연장해요.</li>
<li>원하는 스택 구성을 위해 필요한 측 선택 메커니즘을 구현해요.</li>
<li>사각형을 버퍼로 다시 원래 크기로 바꾸고, 원하는 회전으로 사각형을 회전시켜요 (기본값은 45도).</li>
</ul>
<p>아래 다이어그램은 세그먼트 기반 접근 방법을 보여줘요. 각 세그먼트는 다음과 같이 될 거에요:</p>
<ul>
<li>원래 위치에서 한 방향으로 효과적으로 이동시켜져요 (사각형의 너비가 세그먼트 길이와 같은 경우)</li>
<li>두 섹션으로 분할돼요 (하나는 배치된 사각형의 너비를 따르고, 다른 하나는 시작 위치와 길이가 변경된 원래 세그먼트일거에요).</li>
</ul>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<img src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_14.png">
<p>재미로, 몇 가지 측면 선택 옵션을 구현했는데 'constraints' 입력란은 다각형을 받아들이고 외곽을 벗어나면 측면을 전환하려고 시도하여 다각형과 겹치는 특정 영역에서의 성장을 촉진합니다.</p>
<img src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_15.png">
<p>이것이 제 두 번째 영감으로 이어집니다. Quad-Tile Chart v1을 내 vizmath 패키지에 통합할 때 다각형 입력과 더 많은 작업을 할 수 있는지 생각하기 시작했습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>일부 실험 끝에, 주어진 다각형 내에 꼭지점이 깔끔하게 맞는 완전히 기능적인 컨테이너 패킹 구현이 재미있을 것이라고 결정하고 처음부터 알고리즘을 완전히 개편해보기로 했습니다! 다음에 해당하는 알고리즘을 확인해 봅시다: Quad-Tile Chart v2</p>
<h2>(최종) 알고리즘 v2</h2>
<p>이 알고리즘의 두 번째 버전은 v1의 일부 핵심 요소를 확장하고 쿼드런트-세그먼트 접근 방식을 유사하게 사용하면서 몇 가지 수정 사항과 컨테이너 패킹을 수용하기 위한 몇 가지 새로운 기능을 추가합니다.</p>
<p>v2에 대한 주요 세부 내용은 다음과 같습니다. 특별한 점을 확인해 보세요:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>Bridge Segments(컨테이너 채우기)</li>
<li>Backward Segment Extension(‘축소’ 옵션)</li>
<li>Value Multiplier Bisection Optimization(컨테이너 패킹)</li>
</ul>
<p><img src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_16.png" alt="image"></p>
<p>다음은 v2 알고리즘입니다:</p>
<ul>
<li>단계 1~5는 v1과 동일하지만 2가지 세그먼트 속성(세그먼트 높이 및 세그먼트가 활성화되어 있는지), 3가지 사분면 레벨 속성(최소 바닥과 천장 및 해당 사분면 전체가 방을 다 쓴 것인지) 및 배치된 사각형에 대한 속성(왼쪽 아래 모서리 좌표 및 너비)가 추가됩니다.</li>
<li>이터레이터(처음에 0으로 설정)가 놓여야 하는 사각형 수보다 작을 동안 다음 절차가 수행됩니다:</li>
<li>마지막 바닥 세그먼트(LFS)를 찾습니다: max(segments: 'y=floor', sort: 'x')</li>
<li>정렬된 세그먼트 목록을 만듭니다: (segments: 'is active', sort: 'height, x')</li>
<li>정렬된 세그먼트를 루프합니다(아래에서 '세그먼트' 및 루프 반복 '세그먼트'로 참조됨) 및 진행합니다.</li>
<li>만약 사각형의 모퉁이가 다각형 내에 있고 사각형의 '너비'와 '높이'가 세그먼트의 '너비'와 '높이'에 맞는다면 사각형은 배치됩니다. 그렇지 않으면 세그먼트를 '비활성화'로 설정합니다.</li>
<li>세그먼트의 'y' 값이 사분면의 '바닥'과 같다면 사각형의 '너비'를 추가하여 '바닥'을 업데이트합니다.</li>
<li>사각형이 배치되면 사각형의 너비와 세그먼트 길이에 따라 현재 세그먼트를 대체할 1개 또는 2개의 새 세그먼트를 생성합니다.</li>
<li>축소가 활성화된 경우 다음 절차가 수행됩니다:</li>
<li>세그먼트를 새로 생성된 세그먼트 중 가장 왼쪽으로 설정(NLS).</li>
<li>확장할 세그먼트를 찾습니다: max(segments: 'x + 길이 = NLS.x', 'y = NLS.y', sort: 'x')</li>
<li>확장할 세그먼트가 존재하는 경우, NLS 길이를 추가하고 NLS를 제거합니다.</li>
<li>그렇지 않은 경우, 왼쪽 사각형(LS)을 찾습니다: max(squares: 'x+w≤NLS.x', 'y≤NLS.y', 'y+x≥NLS.y', sort: 'x')</li>
<li>왼쪽 사각형(LS)이 존재하면 LS.x + LS.w ≤ NLS.x를 확인하여 갭이 있는지 확인합니다.</li>
<li>그렇다면, 커버된 세그먼트(CS)를 확인합니다: max(segments: 'y=LS.y', 'x`NLS.x', sort: 'x')</li>
<li>커버된 세그먼트가 존재하는 경우, 세그먼트 높이를 사각형 너비와 동일하게 설정하고 병합 세그먼트를 확인합니다: max(segments: 'x+길이+CS.length = NLS.x', 'y=NLS.y', sort: x)</li>
<li>병합 세그먼트가 존재하는 경우, 사각형 너비와 CS.length를 추가하여 길이를 확장합니다.</li>
<li>그렇지 않은 경우, LS.x + LS.w ≤ NLS.x - 사각형 너비라면 NLS.x = LS.x+LS.w 및 NLS.길이 = CS.length으로 NLS를 조정합니다.</li>
<li>세그먼트가 LFS와 같고 배치되지 않았으며 사분면의 바닥이 천장과 다른 경우 다리 세그먼트를 생성합니다. 다음 절차를 따릅니다:</li>
<li>LFS.높이 및 사분면 바닥을 사분면 천장으로 업데이트합니다.</li>
<li>천장 세그먼트(CS)가 천장에서 존재하는지 확인합니다: max(segments: 'y=ceiling', sort: x)</li>
<li>존재하는 경우, 그 길이를 다각형 경계까지 확장합니다.</li>
<li>그렇지 않은 경우, (세그먼트.x, 천장)에 새 세그먼트를 생성하고 해당 지점과 다각형 경계 사이의 거리로 길이를 설정합니다.</li>
<li>마지막으로, 모든 세그먼트를 '활성화'로 설정하고 루프를 종료합니다.</li>
<li>그렇지 않은 경우, 사각형이 배치되면 사각형을 사각형 목록에 추가하고 해당 속성을 설정하고 사분면을 '방이있음'으로 설정하고 세그먼트가 마지막 세그먼트인 경우 모든 세그먼트를 '활성화'로 설정하고 이터레이터를 1 증가시키고 다음 측면을 설정하고 루프를 종료합니다.</li>
<li>그렇지 않은 경우, 마지막 세그먼트에 도달하면 가능한 경우 더 많은 다리 세그먼트를 추가하려 시도합니다. 다음 절차를 따릅니다:</li>
<li>다리 사각형(BS)을 확인합니다: 첫번째(squares: 'x+w=LFS.x', 'y=LFS.y')</li>
<li>있으면, LFS.높이 = BS.x로 설정하고 사분면 바닥을 BS.w만큼 증가시키고 사분면 천장을 바닥으로 설정합니다.</li>
<li>다리 사각형 세그먼트를 확인합니다: max(segments: 'y=floor', sort: x)</li>
<li>하나가 존재한다면, 그 길이를 다각형 경계까지 확장합니다.</li>
<li>그렇지 않은 경우, (BS.x+BS.w, 바닥)에 새 세그먼트를 생성하고 해당 지점과 다각형 경계 사이의 거리로 길이를 설정합니다.</li>
<li>마지막으로, 모든 세그먼트를 '활성화'로 설정하고 루프를 종료합니다.</li>
<li>BS를 찾지 못한 경우, 사분면을 '방이없음'으로 설정하고 모든 세그먼트를 '활성화'로 설정하고 다음 측면을 설정하고 모든 사분면이 방이없으면 이터레이터를 놓여야 하는 사각형 수로 설정(사실상 외부 while 루프를 종료합니다).</li>
<li>v1의 단계 10을 반복하며 각 사분면을 올바른 방향으로 회전합니다.</li>
<li>자동 배열 옵션이 선택된 경우(컨테이너 패킹), 변환된 값들</li>
</ul>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>v2 알고리즘은 컨테이너 패킹을 맞추기 위해 훨씬 더 많은 작업을 필요로했기 때문에 v1 알고리즘의 간단함에 비해 더 많은 노력이 필요했습니다. 하지만 정말 그만한 가치가 있었어요! v2에서 몇 가지 레이아웃 예제를 살펴봅시다.</p>
<p><img src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_17.png" alt="이미지"></p>
<p>위의 원 형태의 외곽선은 '축소' 기능을 사용하여 참조용으로 포함했습니다. v2의 이론적 한계는 아마도 자기 자신을 내부로 돌리는 다각형들일 것입니다 (이는 사분면의 타일링 평면에서 고유 다각형 갭을 처리하기 위한 향상된 세그먼트 논리가 필요할 것입니다).</p>
<p>다음으로, Python에서 Quad-Tile 차트를 구축하는 방법을 살펴보겠습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>파이썬 구현</h2>
<p>저는 제 Quad-Tile Chart 알고리즘 v1 및 v2를 파이썬에서 사용할 수 있도록 vizmath 패키지를 통해 구현했습니다. PyPI에서 제공됩니다. 소개에서 시작하는 초기 예제를 사용하여 몇 가지 추가 옵션을 살펴보고 입력 및 출력을 설명하겠습니다. 먼저 v1로 시작합니다:</p>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Quad</span>-<span class="hljs-title class_">Tile</span> <span class="hljs-title class_">Chart</span> v1
# pip install vizmath==<span class="hljs-number">0.0</span><span class="hljs-number">.22</span>
<span class="hljs-keyword">from</span> vizmath.<span class="hljs-property">quadtile_chart</span> <span class="hljs-keyword">import</span> quadtile <span class="hljs-keyword">as</span> qt
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd

data = {
    <span class="hljs-string">'id'</span> : [<span class="hljs-title function_">str</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">21</span>)],
    <span class="hljs-string">'speed'</span> : [<span class="hljs-number">242</span>,<span class="hljs-number">200</span>,<span class="hljs-number">105</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">95</span>,<span class="hljs-number">92.5</span>,<span class="hljs-number">88</span>,<span class="hljs-number">80</span>,<span class="hljs-number">79</span>,
        <span class="hljs-number">75</span>,<span class="hljs-number">67.85</span>,<span class="hljs-number">61.06</span>,<span class="hljs-number">60</span>,<span class="hljs-number">56</span>,<span class="hljs-number">55</span>,<span class="hljs-number">55</span>,<span class="hljs-number">55</span>,<span class="hljs-number">50</span>,<span class="hljs-number">50</span>]
}
df = pd.<span class="hljs-title class_">DataFrame</span>(data)

# 쿼드타일 객체 생성
#   > <span class="hljs-attr">df</span>: 데이터와 id 필드가 있는 <span class="hljs-title class_">DataFrame</span>
#   > <span class="hljs-attr">id_field</span>: 필수 식별자 필드 (더미값 사용 가능)
#   > <span class="hljs-attr">value_field</span>: 필수 값 열
#   > <span class="hljs-attr">xo</span>: x축 기준점
#   > <span class="hljs-attr">yo</span>: y축 기준점
#   > <span class="hljs-attr">packing</span>: 패킹 방법 (<span class="hljs-string">'auto'</span>,<span class="hljs-string">'inc'</span>,<span class="hljs-string">'num'</span>,<span class="hljs-string">'max'</span>,<span class="hljs-string">'min'</span>)
#   > <span class="hljs-attr">overflow</span>: <span class="hljs-string">'num'</span>, <span class="hljs-string">'max'</span>, <span class="hljs-string">'min'</span> 패킹을 위한 정수 임계값
#   > <span class="hljs-attr">buffer</span>: 사각형 크기에 추가 값
#   > <span class="hljs-attr">rotate</span>: 차트 회전 각도
#   > <span class="hljs-attr">constraints</span>: 둘레 내부 성장을 촉진하는 다각형
#   > <span class="hljs-attr">size_by</span>: <span class="hljs-string">'area'</span> 또는 <span class="hljs-string">'width'</span>
#   > <span class="hljs-attr">poly_sort</span>: 다각형 정점 정렬 활성화/비활성화 (참, 거짓)
qt_o_area = <span class="hljs-title function_">qt</span>(df,<span class="hljs-string">'id'</span>,<span class="hljs-string">'speed'</span>, size_by=<span class="hljs-string">'area'</span>, buffer=<span class="hljs-number">0</span>)
qt_o_width = <span class="hljs-title function_">qt</span>(df,<span class="hljs-string">'id'</span>,<span class="hljs-string">'speed'</span>, size_by=<span class="hljs-string">'width'</span>, buffer=<span class="hljs-number">0</span>)

# 차트 그리기 (면적 및 너비에 따라 크기 조절)
qt_o_area.<span class="hljs-title function_">quadtile_plot</span>(color=<span class="hljs-string">'quad'</span>, cw=<span class="hljs-number">0.75</span>, opacity=<span class="hljs-number">.9</span>)
qt_o_width.<span class="hljs-title function_">quadtile_plot</span>(color=<span class="hljs-string">'quad'</span>, cw=<span class="hljs-number">0.75</span>, opacity=<span class="hljs-number">.9</span>)
</code></pre>
<img src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_18.png">
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이제 v2를 사용해 봅시다:</p>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Quad</span>-<span class="hljs-title class_">Tile</span> <span class="hljs-title class_">Chart</span> v2
# pip install vizmath==<span class="hljs-number">0.0</span><span class="hljs-number">.22</span>
<span class="hljs-keyword">from</span> vizmath.<span class="hljs-property">quadtile_chart</span> <span class="hljs-keyword">import</span> polyquadtile <span class="hljs-keyword">as</span> pqt
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd

data = {
    <span class="hljs-string">'id'</span>: [<span class="hljs-title function_">str</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">21</span>)],
    <span class="hljs-string">'speed'</span>: [<span class="hljs-number">242</span>, <span class="hljs-number">200</span>, <span class="hljs-number">105</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">95</span>, <span class="hljs-number">92.5</span>, <span class="hljs-number">88</span>, <span class="hljs-number">80</span>, <span class="hljs-number">79</span>, <span class="hljs-number">75</span>, <span class="hljs-number">67.85</span>, <span class="hljs-number">61.06</span>, <span class="hljs-number">60</span>, <span class="hljs-number">56</span>, <span class="hljs-number">55</span>, <span class="hljs-number">55</span>, <span class="hljs-number">55</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>]
}
df = pd.<span class="hljs-title class_">DataFrame</span>(data)

# 쿼드타일 객체 생성
#   > <span class="hljs-attr">df</span>: 데이터를 포함하고 있는 <span class="hljs-title class_">DataFrame</span>, 숫자형 데이터 컬럼과 id 필드를 가져야 함
#   > <span class="hljs-attr">id_field</span>: 필수 식별자 필드 (더미 값 사용 가능)
#   > <span class="hljs-attr">value_field</span>: 필수 값 컬럼
#   > <span class="hljs-attr">xo</span>: x축 원점
#   > <span class="hljs-attr">yo</span>: y축 원점
#   > <span class="hljs-attr">buffer</span>: 사각형 크기를 조절하는 보정값
#   > <span class="hljs-attr">rotate</span>: 차트 회전 각도
#   > <span class="hljs-attr">sides</span>: 포함시킬 변 선택 (<span class="hljs-string">'top'</span>, <span class="hljs-string">'right'</span>, <span class="hljs-string">'bottom'</span>, <span class="hljs-string">'left'</span>)
#   > <span class="hljs-attr">collapse</span>: 축소/확대 설정 (<span class="hljs-title class_">True</span>, <span class="hljs-title class_">False</span>)
#   > <span class="hljs-attr">constraints</span>: 패킹할 다각형 컨테이너
#   > <span class="hljs-attr">xc</span>: x축 컨테이너 오프셋 값
#   > <span class="hljs-attr">yc</span>: y축 컨테이너 오프셋 값
#   > <span class="hljs-attr">size_by</span>: <span class="hljs-string">'area'</span> 또는 <span class="hljs-string">'width'</span>
#   > <span class="hljs-attr">auto</span>: 자동 패킹 활성화/비활성화 (<span class="hljs-title class_">True</span>, <span class="hljs-title class_">False</span>)
#   > <span class="hljs-attr">auto_max_iter</span>: 자동 패킹 반복 횟수
#   > <span class="hljs-attr">auto_min_val</span>: 자동 패킹 최소 배수
#   > <span class="hljs-attr">auto_max_val</span>: 자동 패킹 최대 배수
#   > <span class="hljs-attr">poly_sort</span>: 다각형 꼭지점 정렬 활성화/비활성화 (<span class="hljs-title class_">True</span>, <span class="hljs-title class_">False</span>)
pqt_o_area = <span class="hljs-title function_">pqt</span>(df, <span class="hljs-string">'id'</span>, <span class="hljs-string">'speed'</span>, size_by=<span class="hljs-string">'area'</span>, buffer=<span class="hljs-number">0</span>)
pqt_o_width = <span class="hljs-title function_">pqt</span>(df, <span class="hljs-string">'id'</span>, <span class="hljs-string">'speed'</span>, size_by=<span class="hljs-string">'width'</span>, buffer=<span class="hljs-number">0</span>)

# 차트 그리기 (면적 및 폭에 따라 사이즈가 지정된 차트)
pqt_o_area.<span class="hljs-title function_">polyquadtile_plot</span>(color=<span class="hljs-string">'quad'</span>, cw=<span class="hljs-number">0.75</span>, opacity=<span class="hljs-number">0.9</span>)
pqt_o_width.<span class="hljs-title function_">polyquadtile_plot</span>(color=<span class="hljs-string">'quad'</span>, cw=<span class="hljs-number">0.75</span>, opacity=<span class="hljs-number">0.9</span>)
</code></pre>
<img src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_19.png">
<p>이제 v1 및 v2의 랜덤 초기화 옵션을 포함한 몇 가지 추가 옵션을 조사해 봅시다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"># <span class="hljs-number">1000</span>개의 임의 크기 사각형을 테스트해봅시다:
<span class="hljs-keyword">from</span> vizmath.<span class="hljs-property">quadtile_chart</span> <span class="hljs-keyword">import</span> quadtile <span class="hljs-keyword">as</span> qt
<span class="hljs-keyword">from</span> vizmath.<span class="hljs-property">quadtile_chart</span> <span class="hljs-keyword">import</span> polyquadtile <span class="hljs-keyword">as</span> pqt

# 상단 좌측에 회전된 <span class="hljs-title class_">Quad</span>-<span class="hljs-title class_">Tile</span> <span class="hljs-title class_">Chart</span> v1
qt_o1 = qt.<span class="hljs-title function_">random_quadtile</span>(<span class="hljs-number">1000</span>, rotate=<span class="hljs-number">45</span>)
qt_o1.<span class="hljs-title function_">quadtile_plot</span>(color=<span class="hljs-string">'quad'</span>, cw=<span class="hljs-number">0.75</span>, opacity=<span class="hljs-number">.9</span>)

# 상단 우측에 비회전 <span class="hljs-title class_">Quad</span>-<span class="hljs-title class_">Tile</span> <span class="hljs-title class_">Chart</span> v1
qt_o2 = qt.<span class="hljs-title function_">random_quadtile</span>(<span class="hljs-number">1000</span>, rotate=<span class="hljs-number">0</span>)
qt_o2.<span class="hljs-title function_">quadtile_plot</span>(color=<span class="hljs-string">'quad'</span>, cw=<span class="hljs-number">0.75</span>, opacity=<span class="hljs-number">.9</span>)

# 하단 좌측에 정사각형 컨테이너를 사용한 <span class="hljs-title class_">Quad</span>-<span class="hljs-title class_">Tile</span> <span class="hljs-title class_">Chart</span> v2
poly = [(-<span class="hljs-number">10</span>,-<span class="hljs-number">10</span>),(-<span class="hljs-number">10</span>,<span class="hljs-number">10</span>),(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>),(<span class="hljs-number">10</span>,-<span class="hljs-number">10</span>)] # 다각형 컨테이너
pqt_o1 = pqt.<span class="hljs-title function_">random_polyquadtile</span>(<span class="hljs-number">1000</span>, constraints=poly, buffer=<span class="hljs-number">0</span>)
pqt_o1.<span class="hljs-title function_">polyquadtile_plot</span>(color=<span class="hljs-string">'quad'</span>, cw=<span class="hljs-number">0.75</span>, opacity=<span class="hljs-number">.9</span>)

# 중앙에 가로 세로 비율이 <span class="hljs-number">1</span>:<span class="hljs-number">1</span>인 <span class="hljs-title class_">Quad</span>-<span class="hljs-title class_">Tile</span> <span class="hljs-title class_">Chart</span> v2
pqt_o2 = pqt.<span class="hljs-title function_">random_polyquadtile</span>(<span class="hljs-number">1000</span>, constraints=[(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)], buffer=<span class="hljs-number">0</span>)
pqt_o2.<span class="hljs-title function_">polyquadtile_plot</span>(color=<span class="hljs-string">'quad'</span>, cw=<span class="hljs-number">0.75</span>, opacity=<span class="hljs-number">.9</span>)

# 하단 우측에 가로 세로 비율이 <span class="hljs-number">1</span>:<span class="hljs-number">1</span>인 <span class="hljs-title class_">Quad</span>-<span class="hljs-title class_">Tile</span> <span class="hljs-title class_">Chart</span> v2
pqt_o3 = pqt.<span class="hljs-title function_">random_polyquadtile</span>(<span class="hljs-number">1000</span>, constraints=[(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)],
    buffer=<span class="hljs-number">0</span>, rotate=<span class="hljs-number">0</span>)
pqt_o3.<span class="hljs-title function_">polyquadtile_plot</span>(color=<span class="hljs-string">'quad'</span>, cw=<span class="hljs-number">0.75</span>, opacity=<span class="hljs-number">.9</span>, circles=<span class="hljs-title class_">False</span>)
</code></pre>
<img src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_20.png">
<p>위 내용은 각 버전 간 배치 방법의 미묘한 차이를 보여줍니다 (v1은 y값이 가장 낮고 가장 긴 길이로 선택된 세그먼트, v2는 계단식 접근 방식). 또한 v2에 대한 무작위 초기화는 무작위 볼록 다각형을 생성할 것입니다 — 무엇이 나올지 아무도 모릅니다!</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> vizmath.<span class="hljs-property">quadtile_chart</span> <span class="hljs-keyword">import</span> polyquadtile <span class="hljs-keyword">as</span> pqt

pqt_o = pqt.<span class="hljs-title function_">random_polyquadtile</span>(<span class="hljs-number">100</span>, collapse=<span class="hljs-title class_">True</span>)
pqt_o.<span class="hljs-title function_">polyquadtile_plot</span>(color=<span class="hljs-string">'quad'</span>, cw=<span class="hljs-number">0.75</span>, opacity=<span class="hljs-number">.9</span>, circles=<span class="hljs-title class_">True</span>,
    show_constraints=<span class="hljs-title class_">True</span>)

# 계속해서 무작위 크기 사각형을 사용한 무작위 컨테이너 실행
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<img src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_21.png">
<p>그리고 끝으로, 우리는 중심점을 사용하여 부모 사각형의 경계 상자 크기에 맞는 모든 모양으로 플롯할 수 있음을 기억하세요. 원형 차트의 경우에는 반소형 Bubble Chart만 플로팅한다는 소개를 참조하세요!</p>
<p>이제 Quad-Tile Chart 알고리즘으로 생성된 사분면 다각형과 사분면 중심점 출력을 검토해 봅시다.</p>
<p>사분면 다각형 출력:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>item — ‘id’ 입력 필드로 지정된 수신 식별자</li>
<li>a — 사각형의 상대적 면적 (버퍼는 포함되지 않음)</li>
<li>w — 할당된 공간의 너비: 사각형의 너비 + 버퍼*2</li>
<li>x, y — 레이아웃 내의 점에 대한 직교 좌표</li>
<li>path — 폴리곤을 둘러싼 경로를 나타내는 정수 순서 집합으로, Crystal Bar Chart의 각 크리스탈 ID 및 면에 대해 각각의 (x, y) 점과 함께 사용됨: 1부터 N까지</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> vizmath.<span class="hljs-property">quadtile_chart</span> <span class="hljs-keyword">import</span> polyquadtile <span class="hljs-keyword">as</span> pqt
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd

# 컨테이너에 맞게 크기 조정 없이 초기 예제 데이터 사용:
data = {
    <span class="hljs-string">'id'</span> : [<span class="hljs-title function_">str</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">21</span>)],
    <span class="hljs-string">'speed'</span> : [<span class="hljs-number">242</span>,<span class="hljs-number">200</span>,<span class="hljs-number">105</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">95</span>,<span class="hljs-number">92.5</span>,<span class="hljs-number">88</span>,<span class="hljs-number">80</span>,<span class="hljs-number">79</span>,<span class="hljs-number">75</span>,<span class="hljs-number">67.85</span>,<span class="hljs-number">61.06</span>,<span class="hljs-number">60</span>,<span class="hljs-number">56</span>,<span class="hljs-number">55</span>,<span class="hljs-number">55</span>,<span class="hljs-number">55</span>,<span class="hljs-number">50</span>,<span class="hljs-number">50</span>]
}
poly = [(-<span class="hljs-number">1000</span>,-<span class="hljs-number">1000</span>),(-<span class="hljs-number">1000</span>,<span class="hljs-number">1000</span>),(<span class="hljs-number">1000</span>,<span class="hljs-number">1000</span>),(<span class="hljs-number">1000</span>,-<span class="hljs-number">1000</span>)] # 설명 예제 출력을 위한 충분히 큰 컨테이너
df = pd.<span class="hljs-title class_">DataFrame</span>(data)
o_pq1 = <span class="hljs-title function_">pqt</span>(df,<span class="hljs-string">'id'</span>,<span class="hljs-string">'speed'</span>,buffer=<span class="hljs-number">5.0</span>, collapse=<span class="hljs-title class_">True</span>, constraints=poly, auto=<span class="hljs-title class_">False</span>)
o_pq2 = <span class="hljs-title function_">pqt</span>(df,<span class="hljs-string">'id'</span>,<span class="hljs-string">'speed'</span>,buffer=<span class="hljs-number">5.0</span>, collapse=<span class="hljs-title class_">True</span>, constraints=poly, auto=<span class="hljs-title class_">False</span>, size_by=<span class="hljs-string">'width'</span>)

# 면적에 따라 크기 조정:
o_pq1.<span class="hljs-property">o_polyquadtile_chart</span>.<span class="hljs-property">df</span>[[<span class="hljs-string">'id'</span>,<span class="hljs-string">'item'</span>,<span class="hljs-string">'a'</span>,<span class="hljs-string">'w'</span>,<span class="hljs-string">'x'</span>,<span class="hljs-string">'y'</span>,<span class="hljs-string">'path'</span>]].<span class="hljs-title function_">head</span>()
# 너비에 따라 크기 조정:
o_pq2.<span class="hljs-property">o_polyquadtile_chart</span>.<span class="hljs-property">df</span>[[<span class="hljs-string">'id'</span>,<span class="hljs-string">'item'</span>,<span class="hljs-string">'a'</span>,<span class="hljs-string">'w'</span>,<span class="hljs-string">'x'</span>,<span class="hljs-string">'y'</span>,<span class="hljs-string">'path'</span>]].<span class="hljs-title function_">head</span>()
</code></pre>
<img src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_22.png">
<p>사각형 중심점은 'id' 대신 'item'으로 동일한 속성으로 추출될 수도 있습니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>넓이 별 크기:</h1>
<p>o_pq1.o_polysquares.df[['id','a','w','x','y']].head()</p>
<h1>너비 별 크기:</h1>
<p>o_pq2.o_polysquares.df[['id','a','w','x','y']].head()</p>
<p><img src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_23.png" alt="이미지"></p>
<p>이제 Quad-Tile 차트로 무엇을 더 할 수 있는지 알아봅시다.</p>
<h2>확장성</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>캔버스 레이아웃을 활용하는 원래의 목표를 표준 및 비표준 컨테이너와 함께 다시 살펴보겠습니다. 볼록 다각형과 간단한 오목 다각형을 수용할 수 있는 방법을 보여드렸고, 이제는 소개에서 소개된 레이아웃을 채워봤습니다. 각각 100개의 정사각형이 들어가는 컨테이너에 대해 다양한 회전을 적용했습니다.</p>
<p><img src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_24.png" alt="image"></p>
<p>가장 일반적인 캔버스 레이아웃은 직사각형 컨테이너일 것이므로, 원하는 종횡비를 간단하게 전달하는 것이 유용합니다. 다음은 너비를 다양하게 조절한 예시입니다 (높이 조절 방법도 동일합니다):</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> vizmath.<span class="hljs-property">quadtile_chart</span> <span class="hljs-keyword">import</span> polyquadtile <span class="hljs-keyword">as</span> pqt

aspect_ratio = (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) #(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>) (<span class="hljs-number">3</span>,<span class="hljs-number">1</span>) (<span class="hljs-number">4</span>,<span class="hljs-number">1</span>)
pqt_o = pqt.<span class="hljs-title function_">random_polyquadtile</span>(<span class="hljs-number">100</span>, constraints=[aspect_ratio], 
    rotate=<span class="hljs-number">45</span>, collapse=<span class="hljs-title class_">True</span>, buffer=<span class="hljs-number">.02</span>)
pqt_o.<span class="hljs-title function_">polyquadtile_plot</span>(color=<span class="hljs-string">'quad'</span>, cw=<span class="hljs-number">0.75</span>, opacity=<span class="hljs-number">.9</span>)
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_25.png" alt="이미지"></p>
<p>Extensibility의 또 다른 흥미로운 측면은 계층적 데이터를 포함하는 것입니다. 기존 방법의 일부 단점은 다음과 같습니다:</p>
<ul>
<li>중첩된 원은 레벨별로 정확한 상대적인 면적을 유지할 수 없습니다. 이를 위해 중첩된 Radial이나 Voronoi Treemaps가 필요합니다.</li>
<li>Treemaps는 상위 레벨에서 불규칙한 차원을 가질 가능성이 있습니다. (사각형, 원형, 또는 Voronoi일 경우)</li>
</ul>
<p>Quad-Tile Chart는 계층의 상위 수준을 유사한 모양으로 캡처하여 초기 크기 비교를 제공함으로써 두 번째 문제를 우아하게 처리할 수 있습니다.🌟</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>첫 번째 문제에 대해 말씀드리면, 중첩된 Quad-Tile Charts는 중첩된 패킹된 원(타일 섹션에서 언급된대로)과 동일한 단점을 가지고 있지만, 전통적인 직사각형 Treemaps(또는 Voronoi Treemaps)으로 나무 전체에 대한 정확한 면적을 유지하는 대안을 제공합니다. 중첩된 직사각형 Treemaps은 부모 정사각형의 변을 사용하여 보다 직관적인 자식 직사각형 비교를 할 수 있어 원하는 경우가 있습니다.</p>
<p>다음 단계의 직사각형 Treemaps에 대한 예시 몇 가지를 함께 공유드리겠습니다. 상위 수준에 정사각형을 포함한 Quad-Tile Chart에 중첩된 이들을 제가 “Squaremaps”라고 부르겠습니다!</p>
<p><img src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_26.png" alt="Squaremaps"></p>
<p>제가 vizmath에서 Squaremaps에 대한 구현을 다음과 같이 작성했습니다(그리고 필요 시 계층적 데이터를 동적으로 생성하는 기능도 추가했습니다!):</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">from</span> vizmath.<span class="hljs-property">quadtile_chart</span> <span class="hljs-keyword">import</span> squaremap <span class="hljs-keyword">as</span> sm

# 랜덤한 스퀘어 맵 생성
o_sm1 = sm.<span class="hljs-title function_">random_squaremap</span>(num_levels=<span class="hljs-number">3</span>, items_range=(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>), 
    value_range=(<span class="hljs-number">1</span>,<span class="hljs-number">1000</span>), sig=<span class="hljs-number">0.8</span>)
o_sm1.<span class="hljs-property">o_squaremap</span>.<span class="hljs-title function_">plot_levels</span>(level=<span class="hljs-number">3</span>, fill=<span class="hljs-string">'w'</span>)

# 계층적 데이터를 사용하여 스퀘어 맵 생성
data = [
    [<span class="hljs-string">'a1'</span>, <span class="hljs-string">'b1'</span>, <span class="hljs-string">'c1'</span>, <span class="hljs-number">9.3</span>],
    [<span class="hljs-string">'a1'</span>, <span class="hljs-string">'b1'</span>, <span class="hljs-string">'c2'</span>, <span class="hljs-number">6.7</span>],
    [<span class="hljs-string">'a1'</span>, <span class="hljs-string">'b1'</span>, <span class="hljs-string">'c3'</span>, <span class="hljs-number">2.4</span>],
    [<span class="hljs-string">'a1'</span>, <span class="hljs-string">'b2'</span>, <span class="hljs-string">'c1'</span>, <span class="hljs-number">4.5</span>],
    [<span class="hljs-string">'a1'</span>, <span class="hljs-string">'b2'</span>, <span class="hljs-string">'c2'</span>, <span class="hljs-number">3.1</span>],

    [<span class="hljs-string">'a2'</span>, <span class="hljs-string">'b1'</span>, <span class="hljs-string">'c1'</span>, <span class="hljs-number">5.9</span>],
    [<span class="hljs-string">'a2'</span>, <span class="hljs-string">'b1'</span>, <span class="hljs-string">'c2'</span>, <span class="hljs-number">32.3</span>],
    [<span class="hljs-string">'a2'</span>, <span class="hljs-string">'b1'</span>, <span class="hljs-string">'c3'</span>, <span class="hljs-number">12.3</span>],
    [<span class="hljs-string">'a2'</span>, <span class="hljs-string">'b1'</span>, <span class="hljs-string">'c4'</span>, <span class="hljs-number">2.3</span>],
    [<span class="hljs-string">'a2'</span>, <span class="hljs-string">'b2'</span>, <span class="hljs-string">'c1'</span>, <span class="hljs-number">9.1</span>],
    [<span class="hljs-string">'a2'</span>, <span class="hljs-string">'b2'</span>, <span class="hljs-string">'c2'</span>, <span class="hljs-number">17.3</span>],
    [<span class="hljs-string">'a2'</span>, <span class="hljs-string">'b2'</span>, <span class="hljs-string">'c3'</span>, <span class="hljs-number">6.7</span>],
    [<span class="hljs-string">'a2'</span>, <span class="hljs-string">'b2'</span>, <span class="hljs-string">'c4'</span>, <span class="hljs-number">4.4</span>],
    [<span class="hljs-string">'a2'</span>, <span class="hljs-string">'b2'</span>, <span class="hljs-string">'c5'</span>, <span class="hljs-number">11.3</span>],

    [<span class="hljs-string">'a3'</span>, <span class="hljs-string">'b1'</span>, <span class="hljs-string">'c1'</span>, <span class="hljs-number">7.5</span>],
    [<span class="hljs-string">'a3'</span>, <span class="hljs-string">'b1'</span>, <span class="hljs-string">'c2'</span>, <span class="hljs-number">9.5</span>],
    [<span class="hljs-string">'a3'</span>, <span class="hljs-string">'b2'</span>, <span class="hljs-string">'c3'</span>, <span class="hljs-number">17.1</span>],

    [<span class="hljs-string">'a4'</span>, <span class="hljs-string">'b2'</span>, <span class="hljs-string">'c1'</span>, <span class="hljs-number">5.1</span>],
    [<span class="hljs-string">'a4'</span>, <span class="hljs-string">'b2'</span>, <span class="hljs-string">'c2'</span>, <span class="hljs-number">2.1</span>],
    [<span class="hljs-string">'a4'</span>, <span class="hljs-string">'b2'</span>, <span class="hljs-string">'c3'</span>, <span class="hljs-number">11.1</span>],
    [<span class="hljs-string">'a4'</span>, <span class="hljs-string">'b2'</span>, <span class="hljs-string">'c4'</span>, <span class="hljs-number">1.5</span>]]
df = pd.<span class="hljs-title class_">DataFrame</span>(data, columns = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'value'</span>])
o_sm2 = <span class="hljs-title function_">sm</span>(df, [<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>], <span class="hljs-string">'value'</span>, constraints=[(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)], buffer=<span class="hljs-number">.2</span>)
o_sm2.<span class="hljs-property">o_squaremap</span>.<span class="hljs-title function_">plot_levels</span>(level=<span class="hljs-number">3</span>, fill=<span class="hljs-string">'w'</span>)
</code></pre>
<img src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_27.png">
<h2>Tableau Public Implementation</h2>
<p>파이썬에서 Quad-Tile Chart를 소개했으며 계층적 확장에 대한 Squaremap을 포함하였습니다. 이어서 Tableau Public (v 2023.3.1)에서 양쪽 모두를 구현하는 방법을 보여드리겠습니다! 우선 간단한 Squaremap 구현부터 시작하여 대화형으로 만드는 더 체계적인 Quad-Tile Chart 구축으로 넘어가보겠습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Tableau Public에서 Squaremap 구현</p>
<p>더 자세한 안내를 위해서는, 저의 Radial Treemaps에 관한 글이 있습니다. 해당 글은 상호작용 가능한 계층을 만드는 방법에 대해 더 상세히 안내하며, 이를 위해 Squaremap과 동일한 그림 출력을 사용합니다! 지금은 임의의 입력을 생성하고 단순한 Tableau 예제에 대비한 그림 출력 데이터를 준비해보겠습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> vizmath.<span class="hljs-property">quadtile_chart</span> <span class="hljs-keyword">import</span> squaremap <span class="hljs-keyword">as</span> sm

# 임의의 계층 데이터 생성 및 <span class="hljs-title class_">Squaremap</span> 작성
o_sm = sm.<span class="hljs-title function_">random_squaremap</span>(num_levels=<span class="hljs-number">3</span>, num_top_level_items=<span class="hljs-number">120</span>,
    items_range=(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>), value_range=(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>), sig=<span class="hljs-number">0.75</span>, 
    collapse=<span class="hljs-title class_">True</span>, buffer=<span class="hljs-number">0.05</span>)
# 초기 플롯 검토
o_sm.<span class="hljs-property">o_squaremap</span>.<span class="hljs-title function_">plot_level</span>(level=<span class="hljs-number">3</span>)
# 출력의 미리보기 (그림 데이터)
o_sm.<span class="hljs-property">o_squaremap</span>.<span class="hljs-property">df_rad_treemap</span>.<span class="hljs-title function_">head</span>(<span class="hljs-number">10</span>)
# 데이터로 그림 객체 설정
o_sm.<span class="hljs-property">o_squaremap</span>.<span class="hljs-property">o_rad_treemap</span>.<span class="hljs-property">df</span> = o_sm.<span class="hljs-property">o_squaremap</span>.<span class="hljs-property">df_rad_treemap</span>
# <span class="hljs-title class_">Tableau</span>에서 지도 레이어를 활용하기 위한 데이터 재조정
o_sm.<span class="hljs-property">o_squaremap</span>.<span class="hljs-property">o_rad_treemap</span>.<span class="hljs-title function_">dataframe_rescale</span>(
    xmin=-<span class="hljs-number">5</span>, xmax=<span class="hljs-number">5</span>, ymin=-<span class="hljs-number">5</span>, ymax=<span class="hljs-number">5</span>)
# 데이터를 csv로 작성
o_sm.<span class="hljs-property">o_squaremap</span>.<span class="hljs-property">o_rad_treemap</span>.<span class="hljs-title function_">dataframe_to_csv</span>(<span class="hljs-string">'squaremap'</span>)
</code></pre>
<img src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_28.png">
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>테이블 태그를 Markdown 형식으로 변경해주세요.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>[Group]을 Marks 아래 Detail로 드래그하세요.</li>
<li>Marks 드롭다운 메뉴에서 Polygon을 선택하세요 (이 시점에서 이상하게 보인다고 걱정하지 마세요).</li>
<li>[Path]를 Marks 아래 Path로 드래그하고 현재 SUM(Path)인 항목을 우클릭하여 Dimension으로 선택하세요.</li>
<li>[Value]를 Color로 드래그하고 Dimension으로 변환하는 작업을 반복하세요.</li>
<li>Color 아래에서 "색상 편집..."을 선택하고 다음 옵션으로 구성하세요: '반전, 고급: (시작: 0, 끝: 10)'</li>
</ul>
<p>이제 더 재미를 위해 더 한 개의 레이어를 추가하여 색상을 변경해 봅시다:</p>
<ul>
<li>[Treemap]을 지도 영역으로 드래그하면 팝업이 나타납니다: Marks 레이어 추가 - 이를 클릭하여 새로운 지도 레이어를 생성하세요.</li>
<li>위의 단계를 반복하되 이제 [Side]를 Color로 사용하세요.</li>
<li>Color 아래에서 검은 테두리를 선택하고 투명도를 15%로 설정하세요.</li>
</ul>
<p>이제 아래와 유사한 차트가 나타날 것입니다 (입력의 무작위성으로 인해 고유한 것이 될 것입니다!). 이제 [Level]로 필터링하거나 필요에 맞는 상호 작용을 설정할 수 있습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_29.png" alt="image"></p>
<p>이 Squaremap 구현이 당신의 계층적 데이터를 더 자세히 탐색하는 데 유용한 시작점이 되길 바랍니다!</p>
<p>Tableau Public에서 Quad-Tile Chart 구현</p>
<p>이제 더 자세한 Quad-Tile Chart 구현에 초점을 맞추고 Tableau Public에서 상호작용형 시각화를 만들어 보겠습니다. 강 체계에 대한 위키피디아 데이터 일부로 시작해서 파일에 저장해보죠.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd

# 위키백과에서 (<span class="hljs-number">2024</span>년 <span class="hljs-number">1</span>월 <span class="hljs-number">26</span>일 기준) 상위 <span class="hljs-number">50</span>개의 강 시스템 목록
# <span class="hljs-attr">https</span>:<span class="hljs-comment">//en.wikipedia.org/wiki/List_of_river_systems_by_length</span>
data = {
    <span class="hljs-string">'강'</span> : [<span class="hljs-title function_">str</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">51</span>)],
    <span class="hljs-string">'길이_km'</span> : [
        <span class="hljs-number">6650</span>,<span class="hljs-number">6400</span>,<span class="hljs-number">6300</span>,<span class="hljs-number">6275</span>,<span class="hljs-number">5539</span>,<span class="hljs-number">5464</span>,<span class="hljs-number">5410</span>,<span class="hljs-number">4880</span>,<span class="hljs-number">4700</span>,<span class="hljs-number">4444</span>,<span class="hljs-number">4400</span>,<span class="hljs-number">4350</span>,<span class="hljs-number">4241</span>,
        <span class="hljs-number">4200</span>,<span class="hljs-number">3969</span>,<span class="hljs-number">3672</span>,<span class="hljs-number">3650</span>,<span class="hljs-number">3645</span>,<span class="hljs-number">3610</span>,<span class="hljs-number">3596</span>,<span class="hljs-number">3380</span>,<span class="hljs-number">3211</span>,<span class="hljs-number">3185</span>,<span class="hljs-number">3180</span>,<span class="hljs-number">3078</span>,<span class="hljs-number">3060</span>,
        <span class="hljs-number">3058</span>,<span class="hljs-number">3057</span>,<span class="hljs-number">2989</span>,<span class="hljs-number">2888</span>,<span class="hljs-number">2809</span>,<span class="hljs-number">2740</span>,<span class="hljs-number">2720</span>,<span class="hljs-number">2704</span>,<span class="hljs-number">2620</span>,<span class="hljs-number">2615</span>,<span class="hljs-number">2570</span>,<span class="hljs-number">2549</span>,<span class="hljs-number">2513</span>,
        <span class="hljs-number">2500</span>,<span class="hljs-number">2490</span>,<span class="hljs-number">2450</span>,<span class="hljs-number">2428</span>,<span class="hljs-number">2410</span>,<span class="hljs-number">2348</span>,<span class="hljs-number">2333</span>,<span class="hljs-number">2292</span>,<span class="hljs-number">2287</span>,<span class="hljs-number">2273</span>,<span class="hljs-number">2270</span>],
    <span class="hljs-string">'길이_m'</span> : [
        <span class="hljs-number">4130</span>,<span class="hljs-number">3976</span>,<span class="hljs-number">3917</span>,<span class="hljs-number">3902</span>,<span class="hljs-number">3445</span>,<span class="hljs-number">3395</span>,<span class="hljs-number">3364</span>,<span class="hljs-number">3030</span>,<span class="hljs-number">2922</span>,<span class="hljs-number">2763</span>,<span class="hljs-number">2736</span>,<span class="hljs-number">2705</span>,<span class="hljs-number">2637</span>,
        <span class="hljs-number">2611</span>,<span class="hljs-number">2466</span>,<span class="hljs-number">2282</span>,<span class="hljs-number">2270</span>,<span class="hljs-number">2266</span>,<span class="hljs-number">2250</span>,<span class="hljs-number">2236</span>,<span class="hljs-number">2100</span>,<span class="hljs-number">1995</span>,<span class="hljs-number">1980</span>,<span class="hljs-number">1976</span>,<span class="hljs-number">1913</span>,<span class="hljs-number">1901</span>,
        <span class="hljs-number">1900</span>,<span class="hljs-number">1900</span>,<span class="hljs-number">1857</span>,<span class="hljs-number">1795</span>,<span class="hljs-number">1745.8</span>,<span class="hljs-number">1703</span>,<span class="hljs-number">1700</span>,<span class="hljs-number">1690</span>,<span class="hljs-number">1628</span>,<span class="hljs-number">1625</span>,<span class="hljs-number">1597</span>,<span class="hljs-number">1584</span>,
        <span class="hljs-number">1562</span>,<span class="hljs-number">1553</span>,<span class="hljs-number">1547</span>,<span class="hljs-number">1522</span>,<span class="hljs-number">1509</span>,<span class="hljs-number">1498</span>,<span class="hljs-number">1459</span>,<span class="hljs-number">1450</span>,<span class="hljs-number">1424</span>,<span class="hljs-number">1421</span>,<span class="hljs-number">1412</span>,<span class="hljs-number">1410</span>],
    <span class="hljs-string">'배수지역_km2'</span> : [
        <span class="hljs-number">3254555</span>,<span class="hljs-number">7000000</span>,<span class="hljs-number">1800000</span>,<span class="hljs-number">2980000</span>,<span class="hljs-number">2580000</span>,<span class="hljs-number">745000</span>,<span class="hljs-number">2990000</span>,<span class="hljs-number">2582672</span>,
        <span class="hljs-number">3680000</span>,<span class="hljs-number">1855000</span>,<span class="hljs-number">2490000</span>,<span class="hljs-number">810000</span>,<span class="hljs-number">1790000</span>,<span class="hljs-number">2090000</span>,<span class="hljs-number">712035</span>,<span class="hljs-number">1061000</span>,
        <span class="hljs-number">950000</span>,<span class="hljs-number">1380000</span>,<span class="hljs-number">960000</span>,<span class="hljs-number">884000</span>,<span class="hljs-number">1485200</span>,<span class="hljs-number">63166</span>,<span class="hljs-number">850000</span>,<span class="hljs-number">610000</span>,<span class="hljs-number">219000</span>,
        <span class="hljs-number">324000</span>,<span class="hljs-number">1030000</span>,<span class="hljs-number">570000</span>,<span class="hljs-number">473000</span>,<span class="hljs-number">817000</span>,<span class="hljs-number">404200</span>,<span class="hljs-number">1330000</span>,<span class="hljs-number">454000</span>,<span class="hljs-number">1024000</span>,
        <span class="hljs-number">534739</span>,<span class="hljs-number">242259</span>,<span class="hljs-number">1093000</span>,<span class="hljs-number">900000</span>,<span class="hljs-number">644000</span>,<span class="hljs-number">270000</span>,<span class="hljs-number">1547</span>,<span class="hljs-number">1522</span>,<span class="hljs-number">1509</span>,<span class="hljs-number">1498</span>,
        <span class="hljs-number">1459</span>,<span class="hljs-number">1450</span>,<span class="hljs-number">1424</span>,<span class="hljs-number">1421</span>,<span class="hljs-number">1412</span>,<span class="hljs-number">1410</span>],
    <span class="hljs-string">'평균유출량_m3_s'</span> : [
        <span class="hljs-number">2800</span>,<span class="hljs-number">209000</span>,<span class="hljs-number">30166</span>,<span class="hljs-number">16792</span>,<span class="hljs-number">18050</span>,<span class="hljs-number">2571</span>,<span class="hljs-number">12475</span>,<span class="hljs-number">22000</span>,<span class="hljs-number">41800</span>,<span class="hljs-number">11400</span>,<span class="hljs-number">15500</span>,
        <span class="hljs-number">16000</span>,<span class="hljs-number">10300</span>,<span class="hljs-number">5589</span>,<span class="hljs-number">19800</span>,<span class="hljs-number">767</span>,<span class="hljs-number">13598</span>,<span class="hljs-number">8080</span>,<span class="hljs-number">7160</span>,<span class="hljs-number">856</span>,<span class="hljs-number">31200</span>,<span class="hljs-number">8400</span>,<span class="hljs-number">6210</span>,
        <span class="hljs-number">3300</span>,<span class="hljs-number">703</span>,<span class="hljs-number">3153</span>,<span class="hljs-number">10100</span>,<span class="hljs-number">82</span>,<span class="hljs-number">3600</span>,<span class="hljs-number">7130</span>,<span class="hljs-number">13000</span>,<span class="hljs-number">4880</span>,<span class="hljs-number">1480</span>,<span class="hljs-number">12037</span>,<span class="hljs-number">1400</span>,<span class="hljs-number">6000</span>,
        <span class="hljs-number">2575</span>,<span class="hljs-number">4300</span>,<span class="hljs-number">3800</span>,<span class="hljs-number">270000</span>,<span class="hljs-number">1547</span>,<span class="hljs-number">1522</span>,<span class="hljs-number">1509</span>,<span class="hljs-number">1498</span>,<span class="hljs-number">1459</span>,<span class="hljs-number">1450</span>,<span class="hljs-number">1424</span>,<span class="hljs-number">1421</span>,
        <span class="hljs-number">1412</span>,<span class="hljs-number">1410</span>],
    <span class="hljs-string">'방출지'</span> : [
        <span class="hljs-string">'지중해'</span>,<span class="hljs-string">'대서양'</span>,<span class="hljs-string">'동해'</span>,<span class="hljs-string">'멕시코만'</span>,
        <span class="hljs-string">'카라해'</span>,<span class="hljs-string">'보해'</span>,<span class="hljs-string">'오블만'</span>,<span class="hljs-string">'리오데라플라타'</span>,
        <span class="hljs-string">'대서양'</span>,<span class="hljs-string">'오호츠크해'</span>,<span class="hljs-string">'랩테프해'</span>,<span class="hljs-string">'남중국해'</span>,
        <span class="hljs-string">'보퍼트해'</span>,<span class="hljs-string">'기니만'</span>,<span class="hljs-string">'간지스'</span>,<span class="hljs-string">'남쪽의해'</span>,
        <span class="hljs-string">'대서양(마라조 만), 아마존 델타'</span>,<span class="hljs-string">'카스피해'</span>,
        <span class="hljs-string">'아라비아해'</span>,<span class="hljs-string">'페르시아만'</span>,<span class="hljs-string">'아마존'</span>,<span class="hljs-string">'아마존'</span>,<span class="hljs-string">'베링해'</span>,
        <span class="hljs-string">'대서양'</span>,<span class="hljs-string">'아랄해'</span>,<span class="hljs-string">'안다만해'</span>,<span class="hljs-string">'세인트로렌스만'</span>,
        <span class="hljs-string">'멕시코만'</span>,<span class="hljs-string">'예니세이강'</span>,<span class="hljs-string">'흑해'</span>,<span class="hljs-string">'안다만해'</span>,
        <span class="hljs-string">'모잠비크해협'</span>,<span class="hljs-string">'레나강'</span>,<span class="hljs-string">'벵갈만'</span>,<span class="hljs-string">'아랄해'</span>,<span class="hljs-string">'아마존'</span>,
        <span class="hljs-string">'헛슨만'</span>,<span class="hljs-string">'파라나강'</span>,<span class="hljs-string">'동시베리아해'</span>,<span class="hljs-string">'파라과이강'</span>,<span class="hljs-string">'옵강'</span>,<span class="hljs-string">'이르티시강'</span>,
        <span class="hljs-string">'카스피해'</span>,<span class="hljs-string">'아마존'</span>,<span class="hljs-string">'미시시피강'</span>,<span class="hljs-string">'캘리포니아만'</span>,
        <span class="hljs-string">'랩테프해'</span>,<span class="hljs-string">'흑해'</span>,<span class="hljs-string">'레나강'</span>,<span class="hljs-string">'콩고'</span>],
    <span class="hljs-string">'이름'</span>: [
        <span class="hljs-string">'나일–화이트나일–카게라–냐바롱고–모고고–루카라라'</span>,
        <span class="hljs-string">'아마존–우카야리–탐보–에네–만타롤'</span>,
        <span class="hljs-string">'창강–금샤강–통티안강–당쿠강 (장강)'</span>,
        <span class="hljs-string">'미시시피–미주리–제퍼슨–비버헤드–레드락–헬로링'</span>,
        <span class="hljs-string">'예니세이강–앙가라강–셀렝가강–이더'</span>,<span class="hljs-string">'황허강'</span>,
        <span class="hljs-string">'오블강–이르티시강'</span>,<span class="hljs-string">'리오데라플라타–파라나강–리오그란데'</span>,
        <span class="hljs-string">'콩고강–잠베시 (자이료)'</span>,
        <span class="hljs-string">'두문강–아르군강–헤를런 (흑룽강)'</span>,<span class="hljs-string">'레나강'</span>,<span class="hljs-string">'메콩 (랑창강)'</span>,
        <span class="hljs-string">'맥케너지강–스레이브강–피스강–핀레이'</span>,<span class="hljs-string">'니제르강'</span>,<span class="hljs-string">'브라마푸트라–얀룽창포'</span>,
        <span class="hljs-string">'머리–달링–컬고아–발론–콘다믄'</span>,<span class="hljs-string">'토칸찐스–아라구아이아'</span>,
        <span class="hljs-string">'볼가'</span>,<span class="hljs-string">'인다스–생거 장보'</span>,<span class="hljs-string">'샤트알아랍–유프라테스–무랏'</span>,
        <span class="hljs-string">'마데이라–마모레–그랜데–케인–로차'</span>,<span class="hljs-string">'푸르스'</span>,<span class="hljs-string">'유곤'</span>,<span class="hljs-string">'상프란시스코'</span>,
        <span class="hljs-string">'시르다리야–나린'</span>,<span class="hljs-string">'살윈 (누강)'</span>,
        <span class="hljs-string">'세인트로렌스–나이아가라–디트로이트–세인트클레어–세인트\
        메리스–세인트루이스–노스 (그레이트레이크스)'</span>,<span class="hljs-string">'리오그란데'</span>,<span class="hljs-string">'하횡강'</span>,
        f<span class="hljs-string">"도나우–브렉','두네르','두롱강–납마이강–둘롱강–케라올올루–가다쿠"</span>,
        <span class="hljs-string">'잠베지 (잠베지)'</span>,<span class="hljs-string">'빌류이'</span>,<span class="hljs-string">'간지스–후글리–팜다 (강가)'</span>,
        <span class="hljs-string">'아무다리아–판즈'</span>,<span class="hljs-string">'자푸라 (까퀘타)'</span>,<span class="hljs-string">'넬슨–사스카추완'</span>,
        <span class="hljs-string">'파라과이 (리오파라과이)'</span>,<span class="hljs-string">'콜룸마'</span>,<span class="hljs-string">'필코마요'</span>,<span class="hljs-string">'상횡강–카툰'</span>,
        <span class="hljs-string">'이심'</span>,<span class="hljs-string">'우랄'</span>,<span class="hljs-string">'주루아'</span>,<span class="hljs-string">'아칸소어스'</span>,<span class="hljs-string">'콜로라도 (미 서부)'</span>,
        <span class="hljs-string">'올레니오크'</span>,<span class="hljs-string">'드니프르'</span>,<span class="hljs-string">'알단'</span>,<span class="hljs-string">'우방기–우엘'</span>]
}

df = pd.<span class="hljs-title class_">DataFrame</span>(data)
df.<span class="hljs-title function_">to_csv</span>(<span class="hljs-string">'강_시스템.csv'</span>)
</code></pre>
<p>길이 (</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이것은 좋아 보이네요. Tableau에서 지도 레이어를 활용하기 위해 차트 다각형 및 중심점의 출력 데이터를 저장해봅시다. 나중에 사용할 삼각형의 좌표도 출력하여 나준합니다.</p>
<pre><code class="hljs language-js"># 출력 파일 (<span class="hljs-title class_">Tableau</span>에서 지도 레이어를 활용하기 위해 데이터 재조정)

# <span class="hljs-title class_">Quad</span>-<span class="hljs-title class_">Tile</span> 차트 다각형 출력
o_pqt.<span class="hljs-property">o_polyquadtile_chart</span>.<span class="hljs-title function_">dataframe_rescale</span>(-<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,-<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)
o_pqt.<span class="hljs-property">o_polyquadtile_chart</span>.<span class="hljs-property">df</span> = pd.<span class="hljs-title function_">merge</span>(
    o_pqt.<span class="hljs-property">o_polyquadtile_chart</span>.<span class="hljs-property">df</span>, df, left_on=<span class="hljs-string">'item'</span>, right_on=<span class="hljs-string">'river'</span>)
o_pqt.<span class="hljs-property">o_polyquadtile_chart</span>.<span class="hljs-property">df</span> = o_pqt.<span class="hljs-property">o_polyquadtile_chart</span>.<span class="hljs-property">df</span>[
    [<span class="hljs-string">'river'</span>,<span class="hljs-string">'side'</span>,<span class="hljs-string">'x'</span>,<span class="hljs-string">'y'</span>,<span class="hljs-string">'path'</span>,<span class="hljs-string">'length_km'</span>,<span class="hljs-string">'length_m'</span>,
    <span class="hljs-string">'drainage_area_km2'</span>,<span class="hljs-string">'average_discharge_m3_s'</span>,<span class="hljs-string">'outflow'</span>,<span class="hljs-string">'name'</span>]]
o_pqt.<span class="hljs-property">o_polyquadtile_chart</span>.<span class="hljs-title function_">dataframe_to_csv</span>(<span class="hljs-string">'quadtile'</span>)

# <span class="hljs-title class_">Quad</span>-<span class="hljs-title class_">Tile</span> 차트 중심점 출력
o_pqt.<span class="hljs-property">o_polysquares</span>.<span class="hljs-title function_">dataframe_rescale</span>(-<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,-<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)
o_pqt.<span class="hljs-property">o_polysquares</span>.<span class="hljs-property">df</span> = pd.<span class="hljs-title function_">merge</span>(
    o_pqt.<span class="hljs-property">o_polysquares</span>.<span class="hljs-property">df</span>, df, left_on=<span class="hljs-string">'id'</span>, right_on=<span class="hljs-string">'river'</span>)
o_pqt.<span class="hljs-property">o_polysquares</span>.<span class="hljs-property">df</span> = o_pqt.<span class="hljs-property">o_polysquares</span>.<span class="hljs-property">df</span>[
    [<span class="hljs-string">'river'</span>,<span class="hljs-string">'side'</span>,<span class="hljs-string">'x'</span>,<span class="hljs-string">'y'</span>,<span class="hljs-string">'length_km'</span>,<span class="hljs-string">'length_m'</span>,
    <span class="hljs-string">'drainage_area_km2'</span>,<span class="hljs-string">'average_discharge_m3_s'</span>,<span class="hljs-string">'outflow'</span>,<span class="hljs-string">'name'</span>]]
o_pqt.<span class="hljs-property">o_polysquares</span>.<span class="hljs-title function_">dataframe_to_csv</span>(<span class="hljs-string">'quadtile_centroids'</span>)

# 삼각형 컨테이너 좌표
poly = o_pqt.<span class="hljs-property">constraints</span>
rs_poly_yx = [(vf.<span class="hljs-title function_">rescale</span>(y, -<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>),
    vf.<span class="hljs-title function_">rescale</span>(x, -<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)) <span class="hljs-keyword">for</span> x,y <span class="hljs-keyword">in</span> poly]
<span class="hljs-title function_">print</span>(rs_poly_yx)
# 결과:
# [(-<span class="hljs-number">0.691813852924281</span>, -<span class="hljs-number">0.9166666666666669</span>), 
# (<span class="hljs-number">0.8615194804090525</span>, <span class="hljs-number">0.0</span>), 
# (-<span class="hljs-number">0.691813852924281</span>, <span class="hljs-number">0.9166666666666667</span>)]
</code></pre>
<p>마지막으로, 상호 작용을 더 활성화하기 위해 범례를 생성해봅시다.</p>
<pre><code class="hljs language-js">#%% 범례 플롯
df_legend = df.<span class="hljs-title function_">groupby</span>(<span class="hljs-string">'outflow'</span>)[<span class="hljs-string">'name'</span>].<span class="hljs-title function_">count</span>().<span class="hljs-title function_">reset_index</span>()
o_pqt_legend = <span class="hljs-title function_">pqt</span>(df_legend,<span class="hljs-string">'outflow'</span>,<span class="hljs-string">'name'</span>, 
    constraints=[(<span class="hljs-number">4</span>,<span class="hljs-number">1</span>)], collapse=<span class="hljs-title class_">True</span>,
    rotate=<span class="hljs-number">45</span>, buffer=<span class="hljs-number">.1</span>, size_by=<span class="hljs-string">'width'</span>, sides=[<span class="hljs-string">'top'</span>,<span class="hljs-string">'right'</span>])
o_pqt_legend.<span class="hljs-title function_">polyquadtile_plot</span>(show_constraints=<span class="hljs-title class_">True</span>)

#%% 범례 데이터
o_pqt_legend.<span class="hljs-property">o_polyquadtile_chart</span>.<span class="hljs-title function_">dataframe_rescale</span>(-<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,-<span class="hljs-number">4</span>,<span class="hljs-number">4</span>)
o_pqt_legend.<span class="hljs-property">o_polyquadtile_chart</span>.<span class="hljs-property">df</span> = pd.<span class="hljs-title function_">merge</span>(
    o_pqt_legend.<span class="hljs-property">o_polyquadtile_chart</span>.<span class="hljs-property">df</span>, df_legend, 
    left_on=<span class="hljs-string">'item'</span>, right_on=<span class="hljs-string">'outflow'</span>)
o_pqt_legend.<span class="hljs-property">o_polyquadtile_chart</span>.<span class="hljs-property">df</span> = o_pqt_legend.<span class="hljs-property">o_polyquadtile_chart</span>.<span class="hljs-property">df</span>[
    [<span class="hljs-string">'outflow'</span>,<span class="hljs-string">'side'</span>,<span class="hljs-string">'x'</span>,<span class="hljs-string">'y'</span>,<span class="hljs-string">'path'</span>,<span class="hljs-string">'name'</span>]]
o_pqt_legend.<span class="hljs-property">o_polyquadtile_chart</span>.<span class="hljs-title function_">dataframe_to_csv</span>(<span class="hljs-string">'quadtile_legend'</span>)
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_31.png" alt="그림"></p>
<p>이제 Tableau를 준비했으니, 다음 3개 파일을 모두 가져오기 위해 텍스트 파일 옵션을 사용하여 시작해보겠습니다. Sheet 1로 이동한 다음, 상단 왼쪽 데이터 탭에서 쿼드타일 데이터 소스를 선택하고 다음과 같은 계산 열을 생성하세요:</p>
<p>먼저 맵 영역에서 마우스를 오른쪽 클릭하여 배경 레이어를 선택하고 다음 옵션을 조정해보세요:</p>
<ul>
<li>모든 배경 맵 레이어 (베이스, 랜드 커버 등)을 선택 해제하세요.</li>
<li>이제 맵 영역에서 마우스를 오른쪽 클릭하고 맵 옵션을 선택한 다음, 패널에서 모든 옵션을 선택 해제하세요.</li>
</ul>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>배경 레이어를 닫고 다음 단계를 계속해 보세요:</p>
<ul>
<li>[Side]를 Marks 하위에 Detail로 드래그합니다.</li>
<li>Marks 드롭다운 메뉴에서 Polygon을 선택합니다.</li>
<li>Color 하위에서 검은색 테두리 색상을 선택하고 불투명도를 40%로 조절한 다음 색상을 연한 파랑색으로 설정합니다.</li>
</ul>
<p>다음으로, 사각형에 대한 윤곽선 레이어를 추가해 봅시다:</p>
<ul>
<li>[Squares]를 맵 영역으로 드래그하면 팝업이 나타납니다: Marks 레이어 추가 - 이를 클릭하여 새 맵 레이어를 만듭니다.</li>
<li>팝업 메뉴에서 드롭다운 메뉴를 통해 필드를 'Outlines'로 이름을 변경합니다.</li>
<li>[River]를 이 새로운 맵 레이어의 Marks 하위 Detail로 드래그합니다.</li>
<li>Marks 드롭다운 메뉴에서 Line을 선택합니다 (이 시점에서 이상하게 보인다 해도 걱정하지 마세요).</li>
<li>[Path]를 Marks 하위 Path로 드래그하고 차원으로 변환하는 프로세스를 반복합니다.</li>
</ul>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>메인 스퀘어 레이어에 대해 Marks 드롭다운 메뉴에서 Polygon을 선택하여 새 레이어에 대해 위 과정을 반복하고, [Drainage Area Km2]로 색을 입힙니다. '시작: 0, 끝: 3,000,000'으로 설정해주세요.</p>
<p>마지막으로, 데이터 탭에서 quadtile_centroids를 선택하여 중심점을 사용하는 레이어를 추가하고, 다음과 같은 계산된 열을 추가해주세요:</p>
<p>Tableau에서 올바른 크기 조정을 위해 길이를 제곱한 것을 알 수 있습니다. 이를 다음 단계에서 사용할 것입니다:</p>
<ul>
<li>[Centroids]를 지도 영역으로 드래그하면 팝업이 표시됩니다: Marks 레이어 추가 - 피말을 해당 위치에 드래그하여 새 지도 레이어를 생성합니다.</li>
<li>이 새 지도 레이어에서 Marks 아래 Detail로 [River]를 드래그합니다.</li>
<li>Marks 드롭다운 메뉴에서 Circle을 선택합니다.</li>
<li>[Size]를 Marks 아래 Size로 드래그하고 이를 차원으로 변환하는 과정과 크기 틱을 두 번째 해시로 설정합니다.</li>
<li>[Average Discharge M3 S]를 Color로 드래그하고 하얀 테두리를 추가하고 '시작: 0, 끝: 50,000'으로 설정해주세요.</li>
</ul>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>오른쪽 하단에 널 경고 표시가 나타납니다. 이를 마우스 오른쪽 단추로 클릭하고 숨김 표시를 선택할 수 있습니다. 이 시점에서 상호작용 및 레이블을 나중에 구현하기 위해 아래에 표시된 몇 가지 다른 세부 정보와 속성을 추가한 것처럼 보일 것입니다:</p>
<p><img src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_32.png" alt="image"></p>
<p>이제 대시보드의 소스 자료를 완성하기 위해 세 개의 시트를 추가해 보겠습니다. 설정을 위해 이미지를 참조하십시오.</p>
<ul>
<li>"Bars" - quadtile_centroids 데이터 소스를 사용します.</li>
</ul>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_33.png" alt="이미지"></p>
<ul>
<li>“범례” - quadtile_legend 데이터 소스 사용</li>
</ul>
<p><img src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_34.png" alt="이미지"></p>
<ul>
<li>“강” - quadtile_centroids 데이터 소스 사용, [이름]을 '정렬 기준: 필드, 정렬 순서: 내림차순, 필드 이름: [길이 Km], 집계: 최대값'으로 정렬 ('이름' 항목을 오른쪽 클릭하여 정렬... 선택)</li>
</ul>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<img src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_35.png">
<p>마지막 단계로, 이제 4개의 시트를 대시보드에 정리하고 대시보드 <code>동작</code> 아래의 상단 메뉴에서 몇 가지 동작을 설정해보겠습니다. 대시보드 <code>동작</code> 아래의 추가 동작 드롭다운을 클릭하고 <code>하이라이트</code>를 선택합니다. 대상 하이라이트에서 <code>선택한 필드</code>를 선택하고 [Outflow]과 [River] 필드를 선택합니다 ([Outflow]가 상기 시트에 세부사항으로 추가되었는지 확인). 마지막으로 오른쪽 상단의 <code>실행 동작</code> 아래에서 <code>가리키기</code> 옵션을 선택합니다.</p>
<p>마지막 동작으로 추가 동작 드롭다운을 클릭하고 다음 옵션을 사용하여 필터를 선택합니다: '소스 시트: 범례, 대상 시트: 강, 선택한 필드: Outflow <code>quadtile_centroids</code> Outflow, 실행 동작: 선택시 실행, 선택 해제 시 모든 값 제외'. 이제 대시보드는 모든 시트에서 요청시 하이라이트를 표시하고 범례 시트에서 선택된 값에 대해 필터를 제외할 것입니다!</p>
<img src="https://miro.medium.com/v2/resize:fit:1200/1*4CSKItCTjLiMaB7s09zolQ.gif">
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>결론</h2>
<p>이 글에서 우리는 정방형이 원에 비해 채워진 도형 시각화에서 어떻게 성능을 발휘할 수 있는지 알아보기 위한 여정을 떠났습니다. 저희는 정방형의 적용을 테스트하기 위해 고수준 비교를 위한 최적화 프레임워크를 구현했고, 결국 정방형의 잠재력을 최대한 활용하기 위해 사용자 정의 알고리즘을 활용하기로 결정했습니다.</p>
<p>저는 "쿼드-타일 차트"라고 명명한 것에 대한 상세한 안내서를 제공합니다. 이 차트는 값 세트를 시각화하는 데 사용되며, 또한 값 ​​계층 구조를 시각화하거나 시각화 캔버스의 사용 가능한 공간을 고려해 원하는 다각형 컨테이너 내에 정방형을 패킹하는 기능을 제공하는 "스퀘어맵"으로 확장됩니다.</p>
<p>현재 데이터 시각화 공간에서 사용되는 주요 원 패킹 구현과는 다르게 다각형 컨테이너는 주요 장점으로 작용하며, Squaremap을 통해 계층 데이터는 새로운 집을 찾을 수 있습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>가능하면, Quad-Tile Chart의 사각형 배열은 시각적으로 매력적으로 보입니다 (원과 경쟁하기 위해 필수적입니다!) 그리고 사각형은 원의 중심에 배치된 원들과 서로 바꿔 쓸 수 있습니다 (반응형인 Bubble Chart를 위해) 이것은 데이터를 사각형으로 구성하는 경향을 정당화하기 위한 우리의 노력의 승리로 결론내릴 수 있습니다.</p>
<p>각종 데이터 시리즈와 계층이 모든 코너를 도발하고 있을 때, 여러분이 이러한 시각화 기술을 데이터 탐색 여정에서 유용한 도구로 활용하길 바랍니다!</p>
<h2>참고 자료</h2>
<p>본 문서에 포함된 모든 이미지는 별도로 명시하지 않은 한 저자가 제작했습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>[1] 위키백과 (CC BY-SA), “최고의 빠른 동물” (기준일: 2024년 1월 26일)</p>
<p>[2] 위키백과 (CC BY-SA), “길이별 강 시스템 목록” (기준일: 2024년 1월 26일)</p>
<p>관련 기사</p>
<ul>
<li>복잡한 집합 관계를 시각화하는 Multi-Chord Diagram 소개</li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"데이터 시각화 갓템, Quad-Tile Chart와 Squaremap 사용법 소개","description":"","date":"2024-07-13 19:59","slug":"2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData","content":"\n\n![2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_0](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_0.png)\n\n# 소개\n\n데이터 시각화에서 사용 가능한 캔버스의 크기와 모양은 항상 중요한 요소입니다. 이것은 공간을 절약하기 위한 수단으로 두 축 접근법을 사용하는 Crystal Bar Chart라는 차트를 최근 다른 기사에서 다룬 주제입니다.\n\n이 기사에서는 값을 정사각형으로 시각화하고 볼록 다각형 또는 단순 오목 다각형 형태의 컨테이너를 가득 채우는 공간 절약 방법을 탐구하겠습니다. 또한 이 탐구 과정에 코드를 많이 활용해 보았으니, 다른 유용한 기술과 시각화 유형에 대한 재미있는 자습서로 제공될 수 있기를 희망합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기사를 통해 달성하고자 하는 목표는 일반적이고 비표준적인 컨테이너 모양(아래 그림 참조)을 고려하고, 이와 유사한 모양의 값 집합을 제시하여 사용 가능한 공간을 최적화하고 직관적인 크기 비교를 제공하며 데이터를 사각형 모양으로 표현하는 것입니다!\n\n![image](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_1.png)\n\n새로운 축 없이 접근하기 전에, 결과를 측정할 좋은 기준을 찾을 수 있는 기존 축 기반 및 축 없는 방법에 대해 생각해 봅시다. 예를 들어, Wikipedia에서 제공하는 동물 중 상위 20마리의 최고 속도를 나타내는 정보를 활용하겠습니다. \n\n## 축 기반 데이터 시리즈 시각화\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ny-축이 항목의 값을 나타내는 경우, 정렬된 막대 차트와 경쟁하기 어려울 수 있어요. 먼저 그것을 플롯하고, 저의 vizmath 패키지를 사용하여 몇 가지 더 축 기반의 차트를 만들어 보겠습니다.\n\n막대 차트\n\n```js\n# https://en.wikipedia.org/wiki/Fastest_animals (2024년 1월 26일 기준)\n# 20대 최고 빠른 동물 (최고속도, mph)\n\n데이터 = {\n    'id' : [str(i) for i in range(1, 21)],\n    'speed' : [242,200,105,100,100,95,92.5,88,80,79,\n        75,67.85,61.06,60,56,55,55,55,50,50]\n}\n\n# 막대 차트 (데이터는 이미 정렬되어 있음)\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(7, 1.5))\n막대 = plt.bar(range(1, 21), 데이터['speed'], edgecolor='black',\n    color='white', linewidth=1)\nplt.xticks([])\nplt.grid(False)\nplt.show()\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_2.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n크리스털 막대 차트\n\n```python\nfrom vizmath.crystal_bar_chart import crystals\nimport pandas as pd\n\n# 데이터: 위를 참조하십시오\n\ndf = pd.DataFrame(data)\ncbc = crystals(df, 'id', 'speed', height_range=5, width_override=5,\n    rotation=90, offset=50, bottom_up=True)\ncbc.cbc_plot(legend=False, alternate_color=True, color=False)\n```\n\n![이미지](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_3.png)\n\n비스웜 플롯\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfrom vizmath.beeswarm import swarm\nimport pandas as pd\n\n# 데이터: 위 참조\n\ndf = pd.DataFrame(data)\ndiameter = 5\nbs = swarm(df, 'id', 'speed', None, size_override=pi*(diameter/2)**2)\nbs.beeswarm_plot(color=False)\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_4.png\" /\u003e\n\n각각의 메소드들은 값의 크기를 반영하는 모양과 위치를 제공하면서 데이터 집합의 밀도 프로필을 제공하는 독특한 방식을 제공합니다.\n\n이제 같은 값 세트를 사용하여 상대적인 크기 비교에 중점을 둔 축 없는 예제로 넘어가며 일부 반응형 Bubble Chart를 그려 Quad-Tile Chart 알고리즘을 미리보겠습니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 축 없이 데이터 시각화\n\n축 없이 도메인을 표현하기 위해 한 수준의 트리맵(저의 Radial Treemap에 관심이 있는 경우 해당 문서를 확인해보세요!)을 포함하고, 이어서 Bubble 차트를 추가해 봅시다.\n\n트리맵 (한 수준의 파이, 도넛, 직사각형)\n\n```js\nfrom vizmath.radial_treemap import rad_treemap as rt\nimport pandas as pd\n\n# 데이터: 위의 데이터를 참조하세요\n\n# 파이 트리맵\ndf = pd.DataFrame(data)\no_rt = rt(df, ['speed'], 'speed', r1=0)\no_rt.plot_levels()\n\n# 도넛 트리맵\ndf = pd.DataFrame(data)\no_rt = rt(df, ['speed'], 'speed')\no_rt.plot_levels()\n\n# 트리맵\ndf = pd.DataFrame(data)\no_rt = rt(df, ['speed'], 'speed', r1=0, r2=1,\n    a1=0, a2=1, rectangular=True)\no_rt.plot_levels()\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Bubble Chart (grid)](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_5.png)\n\n```js\nimport numpy as np\nimport pandas as pd\n\n# data: 위에서 참조\n\ndf = pd.DataFrame(data)\n\ndef grid_bubbles(values, size_by='area', rows=2, cols=10, buffer=0.1):\n    fig, ax = plt.subplots(rows, cols, figsize=(7, 1.5))\n    sorted_values = np.sort(values)[::-1]\n    if size_by == 'area':\n        sizes = np.sqrt(sorted_values) # 반지름 입력 고려\n    elif size_by == 'diameter':\n        sizes = sorted_values # 반지름에 비례\n    max_size = np.max(sizes)\n    b = max_size*buffer\n    max_size += b\n    index = 0\n    for i in range(rows):\n        for j in range(cols):\n            # Matplotlib의 Circle을 위한 반지름 입력\n            circle = plt.Circle((0.5, 0.5), sizes[index]/max_size/2,\n                color='black', fill=False, linewidth=2)\n            ax[i, j].add_artist(circle)\n            ax[i, j].set_xlim(0, 1)\n            ax[i, j].set_ylim(0, 1)\n            ax[i, j].axis('off')\n            index += 1\n    plt.tight_layout()\n    plt.show()\n\ngrid_bubbles(data['speed'], size_by='area')\ngrid_bubbles(data['speed'], size_by='diameter')\n```\n\n![Bubble Chart (grid)](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_6.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n버블 차트 (내 새로운 Quad-Tile 차트 알고리즘을 사용하여 반 정렬)\n\n```js\nfrom vizmath.quadtile_chart import polyquadtile as pq\nimport pandas as pd\n\n# 데이터: 위를 참조하세요\n\n# 면적에 따라 크기 조정\ndf = pd.DataFrame(data)\ndf['speed'] = df['speed']/df['speed'].max()*3.5\no_pq = pq(df,'id','speed',buffer=0.0, collapse=True,\n    constraints=[(2,1)], auto=False)\no_pq.polyquadtile_plot(show_constraints=True, poly_color='w',\n    poly_line='black', squares_off=True, circles=True)\nprint(o_pq.multiplier)\n\n# 지름에 따라 크기 조정\ndf = pd.DataFrame(data)\ndf['speed'] = df['speed']**2 # 지름 비율에 맞게 조정\ndf['speed'] = df['speed']/df['speed'].max()*3.5\no_pq = pq(df,'id','speed',buffer=0.0, collapse=True,\n    constraints=[(2,1)], auto=False)\no_pq.polyquadtile_plot(show_constraints=True, poly_color='w',\n    poly_line='black', squares_off=True, circles=True)\n```\n\n![이미지](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_7.png)\n\n이러한 방법들은 값이 어떤 크기인지 직접적인 참조를 제공하는 축이 없어서 위치 변경 기능이 작동합니다. 따라서 값의 모양, 크기 및 레이아웃이 데이터 인사이트를 수집하는 데 중요합니다. 값 표현 간의 공간을 보존하는 방식으로 이러한 차트를 유용하게 만드는 파라미터 조정이 중요합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n숫자 축 기반 차트의 경우 멀리 떨어져 있는 값 모양을 나란히 보여줄 수 있지만, 축 없는 차트를 사용하면 값 모양을 옆으로 보여줄 수 있어요. 데이터와 사용 사례에 따라, 축 없는 방법의 시각화 압축은 축 기반 방법보다 상당한 장점이 될 수 있어요.\n\n위의 버블 차트에서는 면적 및 지름별 크기 설정도 포함했어요. 크기 설정 메커니즘은 종종 간과될 수 있지만, 두 결과 간의 차이는 상당할 수 있어요! 데이터의 성겁과 시각화의 내러티브 맥락에 따라, 시각화 도구에서 크기 설정이 무엇을 기반으로 하는지 항상 알고 있으면, 정보에 기반한 선택을 할 수 있어요.\n\n기본 케이스 (경쟁사)\n\n위의 예시를 리뷰하면 버블 차트가 사용 가능한 공간을 보존하면서 비슷한 형태의 값 세트를 적절히 크기에 맞게 표현하는 우리의 초기 목표를 이루는 경쟁자임을 알 수 있어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n포장된 Bubble Chart(컨테이너)는 결과를 측정하기 위한 경쟁 상대가 될 것입니다. 그러나 아쉽게도 내가 찾은 구현 (아래에 표시됨)은 원형 레이아웃만 나타내므로 다른 컨테이너 모양을 탐색할 때 완벽한 비교 사례가 되지 않을 것입니다.\n\n```js\n# circlify\nimport circlify\ncircles_circlify = circlify.circlify(data['speed'], show_enclosure=False)\ncircles = [c for c in circles_circlify]\nmax_radius = max(circle.r for circle in circles)\nxlim = max(abs(circle.x) + max_radius for circle in circles)\nylim = max(abs(circle.y) + max_radius for circle in circles)\nlimit = max(xlim, ylim)\nfig, axs = plt.subplots(figsize=(8, 8))\naxs.axis('off')\nplt.xlim(-limit, limit)\nplt.ylim(-limit, limit)\nfor circle in circles:\n    axs.add_patch(plt.Circle((circle.x, circle.y), circle.r,\n        edgecolor='black', facecolor='white', linewidth=2))\nplt.show()\n\n# packcircles\nimport packcircles\ncircles_packcircles = packcircles.pack(data['speed'])\ncircles = [c for c in circles_packcircles]\n# circles\nmax_radius = max(radius for (_, _, radius) in circles)\nxlim = max(abs(x) + max_radius for (x, _, _) in circles)\nylim = max(abs(y) + max_radius for (_, y, _) in circles)\nlimit = max(xlim, ylim)\nfig, axs = plt.subplots(figsize=(8, 8))\naxs.axis('off')\nplt.xlim(-limit, limit)\nplt.ylim(-limit, limit)\nfor (x, y, radius) in circles:\n    axs.add_patch(plt.Circle((x, y), radius,\n        edgecolor='black', facecolor='white', linewidth=2))\nplt.show()\n\n# Tableau Public:\nimport pandas as pd\nimport os\ndf = pd.DataFrame(data)\ndf.to_csv(os.path.dirname(__file__) + '/circles.csv',\n    encoding='utf-8', index=False)\n# select packed bubbles -\u003e Size by [Speed], [Id] on Detail\r\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_8.png\" /\u003e\n\n경쟁 상대를 선택했으니 이제 포장된 Bubble Chart가 홀로 서 있는지 또는 컨테이너 포장 목표를 충족하는 상대적 가치 비교를 위해 활용할 수 있는 다른 단순한 모양이 있는지 살펴보겠습니다. 이제 정사각형의 응용을 탐색해 보겠습니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 왜 Squarify를 사용해야 할까요?\n\n이미 패킹된 원들을 조사하는 무대를 마련했으니, 짧게 쉬어가며 질문을 해보는 게 좋을 것 같아요. 패킹된 원들이 존재하는데 왜 사각형에 관심을 가질까요?\n\n데이터 시각화에서 이미 패킹된 원들이 널리 사용되고 있으므로 사람들은 원을 좋아하는 것으로 보입니다. 다양한 패킹된 버블 차트 구현은 다양한 프로그래밍 언어 및 소프트웨어에서 쉽게 찾을 수 있어요. 사실, Quad-Tile 차트를 만든 후 가장 먼저 한 일은 동그라미를 그리는 데 사용했어요 (소개 부분에 나와 있음). 그래서 동그라미의 매력은 실재해요!\n\n하지만 사각형은 어떨까요? 다른 가능한 모양들과 비교했을 때 패킹된 사각형은 상대적으로 무해해 보이지만, 확실한 패킹된 사각형 차트 구현을 찾는 것은 어렵습니다. 왜 그럴까요...\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n간단한 비교를 하고 어떤 것을 발견해 봅시다:\n\n![image](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_9.png)\n\n위의 경우 1:2 비율을 사용하여 넓이나 길이를 비교하는 데 둥근 모양이나 사각형 모두 다른 것보다 직관성을 제공하지 않는 것으로 보입니다. 하지만 원은 더 부드럽고 사각형은 더 날카로운 것 같아요.\n\n그렇다면, 나는 스퀘어리파이를 하는 이유가 다음과 같습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 패킹된 사각형 구현은 존재하지 않는 것 같아서 시각적으로 얼마나 매력적인지 알기가 어렵습니다(패킹된 원의 대체물로). 따라서 조사할 가치가 있습니다.\n- 파이썬의 사용 가능한 패킹된 원 구현물에서는 컨테이너를 활용할 수 있는 능력이 일반적으로 부족합니다(모두 원의 수가 증가함에 따라 원형 레이아웃만 제공하는 것으로 보입니다).\n- 사각형의 단순성은 알고리즘을 통해 사각형을 채우려고 시도하면 수학적 연산이 직관적일 것으로 보입니다. 따라서 빠른 개념 증명이 가능할 수도 있습니다.\n\n스퀘어화를 추구하는 동기를 제시했으니, 이제 사각형 패킹 노력의 핵심 구성 요소인 패킹을 살펴보고, 사각형이 원에 어떻게 대응하는지 확인해봅시다.\n\n# 모양 패킹 \u0026 컨테이너 패킹\n\n## 타일링과 함께\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n수사 목적으로 명백한 것을 언급할 가치가 있습니다. 사각형은 가장을 가지고 있지만 원은 그렇지 않습니다. 이 특성은 유사한 크기의 사각형들을 테셀레이션할 수 있게 해주어, 패킹이라는 유용한 개념이 될 수 있습니다.\n\n```js\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\n\n# 도형과 공간을 사용하여 다이아몬드 테셀레이션 모의실험을 해봅시다.\ndef diamond_tessellation(rows, cols):\n    fig, ax = plt.subplots()\n    ax.set_aspect('equal', adjustable='box')\n    plt.axis('off')\n    for row in range(rows):\n        for col in range(cols):\n            diamond = patches.Polygon([\n                (col + 0.5, row), \n                (col + 1, row + 0.5), \n                (col + 0.5, row + 1), \n                (col, row + 0.5)\n                ], edgecolor='grey', facecolor='whitesmoke')\n            ax.add_patch(diamond)\n    ax.set_xlim(0, cols)\n    ax.set_ylim(0, rows)\n    plt.show()\n\ndiamond_tessellation(2, 9)\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_10.png\" /\u003e\n\n유감스럽게도, 테셀레이션은 데이터셋의 값이 동일하거나 편리한 비율을 가지는 것으로 가정하는 것이 현실적이지 않기 때문에 일반적인 해결책은 아닙니다. 그러나 간격이 없는 가장의 개념은 원보다 잠재적인 이점으로 더 탐구할 가치가 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 최적화로\n\n최적화 방법은 두 개의 모양을 비교하는 메커니즘으로 다음 단계로 가치 있는 것처럼 보입니다. 그래서 원과 정사각형 사이에 가능한 균일하게 적용할 수 있는 간단한 목적 함수에 집중하여 결과를 검토해 봅시다.\n\n먼저, 목적 함수의 요소를 식별해야 합니다. 우리는 모양의 중첩을 방지하는 메커니즘과 밀접하게 패킹하려는 반대 힘이 필요합니다. 각각을 자세히 살펴보겠습니다.\n\n- 중첩 방지 (밀어내기) - 중첩을 방지하기 위해 모양들의 총 중첩 영역을 고려하고, 다른 모양에 완전히 포함되는 모양에 대해 추가 벌칙을 부과하여 작은 모양의 중첩 방지를 촉진합니다.\n- 패킹 촉진 (가까이 끌어모으기) - 패킹을 촉진하기 위해 모양을 특정 관심 지점으로 끌어당기는 것을 보상할 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금은 컨테이너를 무시하고 도형 패킹에 초점을 맞춰 각 도형의 기하학적 특징을 살펴봅시다. 이제 식별된 재료로 구현할 함수를 설정해 봅시다.\n\n```js\nfrom shapely.geometry import Point, Polygon\nfrom shapely.ops import unary_union\n\n# 셰이프의 중심에서 관심 지점까지의 거리를 더하여 당김 힘을 설정합시다\ndef calc_distance_from_point(shapes, shape_type, origin):\n    penalty = 0\n    ref_point = Point(origin)\n    if shape_type == 'circle':\n        for x, y, _ in shapes:\n            centroid = Point(x, y)\n            penalty += centroid.distance(ref_point)\n    elif shape_type == 'square':\n        for x, y, side in shapes:\n            centroid = Polygon([(x, y), (x + side, y),\n                (x + side, y + side), (x, y + side)]).centroid\n            penalty += centroid.distance(ref_point)\n    return penalty\n\n# 이제 첫 번째 당김 힘을 설정하여 한 도형이 다른 도형 안에 포함되어 있는지 여부를 파악하고 발생 횟수를 더합시다\ndef calc_containment(shapes, shape_type):\n    penalty = 0\n    shapely_shapes = []\n    if shape_type == 'circle':\n        shapely_shapes = [Point(x, y).buffer(r) \n            for x, y, r in shapes]\n    elif shape_type == 'square':\n        shapely_shapes = [Polygon([(x, y), (x + side, y),\n            (x + side, y + side), (x, y + side)]) \n            for x, y, side in shapes]\n    for i, shape1 in enumerate(shapely_shapes):\n        for j, shape2 in enumerate(shapely_shapes):\n            if i != j and shape1.contains(shape2):\n                penalty += 1\n    return penalty\n\n# 당김 힘을 완성하기 위해 전체 도형 중첩 영역을 계산합시다\ndef calc_overlap_area(shapes, shape_type):\n    if shape_type == 'circle':\n        shapely_shapes = [Point(s[0], s[1]).buffer(s[2]) \n            for s in shapes]\n    elif shape_type == 'square':\n        shapely_shapes = [Polygon([(s[0], s[1]), (s[0] + s[2], s[1]), \n            (s[0] + s[2], s[1] + s[2]), (s[0], s[1] + s[2])]) \n            for s in shapes]\n    merged_area = unary_union(shapely_shapes).area\n    individual_areas = sum(shape.area for shape in shapely_shapes)\n    return abs(individual_areas - merged_area)\n\n# 마지막으로, 힘을 종합하여 목적 함수로 만들어봅시다\ndef objective_function(variables, shapes, shape_type, \n    origin=(0,0), prevent_overlap_factor=2):\n    for i, shape in enumerate(shapes):\n        shapes[i] = (variables[i*2], variables[i*2 + 1], shape[2])\n    overlap_area = calc_overlap_area(shapes, shape_type)\n    contained = calc_containment(shapes, shape_type)\n    sum_distance = calc_distance_from_point(shapes, shape_type, origin)\n    return overlap_area * prevent_overlap_factor * (1 + contained) + sum_distance\n```\n\n목적 함수에서는 도형의 겹치는 영역을 포함하는 모양의 수와 곱하여 당김 패널티를 집중시키기로 선택했습니다. 그리고 당김 정도를 조절하는 'prevent_overlap_factor' 가중치를 추가했습니다.\n\n이제 목적 함수가 준비되었으니, 이전의 예제 데이터를 사용하여 원과 사각형 패킹 최적화 루틴을 설정해 봅시다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\r\n# 이전 예시 데이터:\r\ndata = {\r\n    'id' : [str(i) for i in range(1, 21)],\r\n    'speed' : [242,200,105,100,100,95,92.5,88,80,79,\r\n        75,67.85,61.06,60,56,55,55,55,50,50]\r\n}\r\n\r\n# 원하는 크기 창(Window) (계수)와 모양의 반복 가능한 랜덤 위치를 위한 시드를 설정해봅시다.\r\n\r\n계수 = 10\r\n시드 = 123\r\n\r\n최대속도 = np.max(data['speed'])\r\nnp.random.seed(시드)\r\n\r\n모양들 = [(np.random.uniform(0, 계수*1.5),\r\n    np.random.uniform(0, 계수*1.5),\r\n    v/최대속도*계수) for v in data['speed']]\r\n```\r\n\r\n이제, 원과 사각형의 입력을 분리하고 최적화 메서드에 전달할 경계를 추가해봅시다.\r\n\r\n```js\r\nimport numpy as np\r\nimport copy\r\nfrom math import sqrt\r\n\r\n# 각 모양에 대해 최적화하기 위해 복사본을 만듭시다.\r\n원들 = copy.deepcopy(모양들)\r\n사각형들 = copy.deepcopy(모양들)\r\n\r\n# 위치를 최적화하기 위해 좌표를 평면으로 펼쳐봅시다\r\n초기_위치 = [val for s in 모양들 for val in s[:2]]\r\n\r\n# 이제 각 모양의 경계를 계산하여 최적화 함수에 전달합시다\r\ndef calc_bounds(모양들, 모양_유형):\r\n    총_면적 = 0\r\n    if 모양_유형 == '원':\r\n        총_면적 = sum(np.pi * (r**2) for _, _, r in 모양들)\r\n    elif 모양_유형 == '사각형':\r\n        총_면적 = sum(side**2 for _, _, side in 모양들)\r\n    추정된_한변의_길이 = sqrt(총_면적)\r\n    패딩 = 추정된_한변의_길이 / 2\r\n    하한 = 0 - 패딩\r\n    상한 = 추정된_한변의_길이 + 패딩\r\n    return (하한, 상한)\r\n\r\n# 원과 사각형에 대한 경계 계산\r\n원의_경계 = calc_bounds(원들, '원')\r\n사각형의_경계 = calc_bounds(사각형들, '사각형')\r\n\r\n# 각 모양에 경계를 적용하여 최적화하기\r\n원_경계들 = [(원의_경계[0], 원의_경계[1]) \r\n    for _ in range(len(초기_위치))]\r\n사각형_경계들 = [(사각형의_경계[0], 사각형의_경계[1])\r\n    for _ in range(len(초기_위치))]\r\n\r\n# 풀 힘을 위한 접힘점을 설정하기 위해 경계를 사용\r\n원의_접힘점 = (원의_경계[1]-원의_경계[0])/2+원의_경계[0]\r\n사각형의_접힘점 = (사각형의_경계[1]-사각형의_경계[0])/2+사각형의_경계[0]\r\n원의_접힘점들 = (원의_접힘점, 원의_접힘점)\r\n사각형의_접힘점들 = (사각형의_접힘점, 사각형의_접힘점)\r\n```\r\n\r\n마지막으로, 결과를 시각화하기 위한 플로팅 함수를 설정하고 각 모양에 대해 최적화를 실행해보겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nfrom math import inf\nfrom scipy.optimize import minimize\n\n# 결과를 확인할 수 있는 plotting 함수를 만들어봅시다.\ndef plot_shapes(shapes, shape_type):\n    fig, ax = plt.subplots()\n    min_x, min_y, max_x, max_y = 0.,0.,0.,0.\n    for s in shapes:\n        if shape_type == 'circle':\n            circle = patches.Circle((s[0], s[1]), s[2],\n                facecolor='lightgrey', edgecolor='black')\n            ax.add_patch(circle)\n            min_x = min(min_x, s[0] - s[2])\n            min_y = min(min_y, s[1] - s[2])\n            max_x = max(max_x, s[0] + s[2])\n            max_y = max(max_y, s[1] + s[2])\n        elif shape_type == 'square':\n            square = patches.Rectangle((s[0], s[1]), s[2], s[2],\n                facecolor='lightgrey', edgecolor='black')\n            ax.add_patch(square)\n            min_x = min(min_x, s[0])\n            min_y = min(min_y, s[1])\n            max_x = max(max_x, s[0] + s[2])\n            max_y = max(max_y, s[1] + s[2])\n    padding = 1\n    ax.set_xlim(min_x - padding, max_x + padding)\n    ax.set_ylim(min_y - padding, max_y + padding)\n    ax.set_aspect('equal', 'box')\n    plt.show()\n\n# 마지막으로 반복을 모니터링하는 콜백 함수를 설정해봅시다.\ndef callback(i):\n    global iteration\n    iteration += 1\n    print(f'반복 {iteration}')\n\n# 원 최적화 실행:\niteration = 0\noptimized_circles = minimize(objective_function, initial_positions,\n    args=(circles, 'circle', origin_circles), method='L-BFGS-B',\n    bounds=bounds_circles, callback=callback,\n    options={'maxiter': 300, 'maxfun': inf, 'ftol': 0, 'gtol': 0})\npacked_circles = [(optimized_circles.x[i*2],\n    optimized_circles.x[i*2 + 1], circles[i][2])\n    for i in range(len(circles))]\n# plot_shapes(shapes, 'circle') # 초기 위치를 보려면 주석 해제\nplot_shapes(packed_circles, 'circle')\n\n# 사각형 최적화 실행:\niteration = 0\noptimized_squares = minimize(objective_function, initial_positions,\n    args=(squares, 'square', origin_squares), method='L-BFGS-B',\n    bounds=bounds_squares, callback=callback,\n    options={'maxiter': 300, 'maxfun': inf, 'ftol': 0, 'gtol': 0})\npacked_squares = [(optimized_squares.x[i*2],\n    optimized_squares.x[i*2 + 1], squares[i][2])\n    for i in range(len(squares))]\n# plot_shapes(shapes, 'square') # 초기 위치를 보려면 주석 해제\nplot_shapes(packed_squares, 'square')\r\n```\n\n위 코드에서는 'L-BFGS-B' 메서드를 선택하여 scipy의 'minimize' 함수에서 반복 횟수를 300으로 설정했습니다. 초기 위치를 제어하는 난수 시드는 결과에 영향을 미칠 수 있으므로 두 모양에 대해 각각 3가지 다른 시드를 살펴봅시다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_11.png\" /\u003e\n\n각 테스트 케이스를 생성하는 데 랩톱에서 약 5분이 걸렸으므로, 이 방법의 시간 요구 사항은 고려해야 할 불안정한 요소입니다. 이미 긴 대기 시간 때문에 컨테이너 중첩 비용을 목적 함수에 추가하여 컨테이너 패킹 통찰을 검토하는 것은 현재 필요하지 않은 것으로 보입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지면 배치 관련해서 원들이 더 조밀하게 배열되어 있는 것 같습니다. 이것이 데이터 시각화에서 패킹된 원이 패킹된 정사각형보다 흔한 이유를 설명하는 첫 번째 증거가 될 수 있습니다.\n\n하지만 포기하기 전에, 정사각형에 맞춤화된 알고리즘을 사용한 최종 평가로 넘어가 봅시다!\n\n## 알고리즘을 통해\n\n위의 실험에서 얻은 주요 결론은:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 일반 최적화 구현을 사용하여 단순 목적 함수에 따라 패킹된 모양을 생성하는 것은 어느 정도 작동하는 것 같아요.\n- 그러나 이것은 정말 느리고 대규모 데이터셋을 처리하기에 부적합하죠.\n- 원형 배열들이 (적어도 컨테이너 패킹 없이는) 사각형 배열보다 더 융합되어 보였어요.\n\n우리는 대규모 데이터셋에서 성능이 우수하며 더 매력적인 사각형 배열을 생성할 수 있고, 컨테이너 패킹을 구현할 수 있는 특수화된 알고리즘이 필요하다는 것이 분명해요. 이 방식을 일반적인 최적화 프레임워크와 구분짓기 위해 사각형의 특정 특성을 활용하고, 포장 기회를 탐색할 필요가 있어요.\n\n우리가 활용할 수 있는 사각형의 몇 가지 기하학적 요소를 나열하여 시작해봐요:\n\n- 형태: 네 개의 직각을 감싸고 있는 같은 길이의 네 변을 가지며, 화면을 기준으로 회전할 수 있어 다른 외형이 될 수 있는\n- 패킹: 간격 없이 사각형 사이에 이웃할 수 있는 능력\n- 배치: 각 사각형의 각 변은 4개의 가능한 꼭지점 중 하나에서 시작하여 이웃할 사각형에게 이웃할 수 있는 평면적인 2차원 공간을 무한대로 제공함\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음에는 패킹된 사각형이 패킹된 원과 어떻게 경쟁할 수 있는지 이해하기 위해 Quad-Tile 차트라는 새로운 시각화 기술에 사용되는 알고리즘을 설명할 것입니다.\n\n## Quad-Tile 차트\n\n### 영감\n\n몇 년 전 어떤 사람이 패킹된 버블 차트는 대부분 쓸모없다고 말했습니다. 무슨 이유에서인지 그 말이 나에게 영감을 주어 패킹된 사각형 차트를 만들게 되었습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n첫 번째 버전을 개발하고 Tableau Public 시각화와 몇 가지 다른 기술과 함께 구체화된 결과물을 시험해 보았어요. 여기에는 18개의 사각형을 포함하는 Voronoi Treemaps가 있는 (v1) Quad-Tile Chart가 표시된 발췌본이 있어요. (Voronoi Treemaps는 D3.js를 사용하여 계산되었어요).\n\n![Quad-Tile Chart](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_12.png)\n\n아래에서는 이 알고리즘에 대해 설명하고, 몇 일 전에 다시 시작했을 때 최종적으로 채택한 방식을 설명할게요.\n\n## (초기) 알고리즘 v1\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n내 초기 접근 방식인 2022년 초에는 컨테이너를 고려하지 않았습니다. 가장 큰 정사각형부터 시작하여 중앙에 배치한 후 모든 정사각형이 중심 정사각형 주변에 감싸지도록 연속적으로 나열하려고 노력했습니다. 가장 작은 정사각형은 가장 중심부터 먼 위치에 배치되었습니다.\n\n마디 있는 정사각형 배열에 관해 스케치한 후에 나에게 온 개념 중에는 다음과 같은 것들이 있습니다:\n\n- 사분면 - 조사한 결과, 정사각형은 연속적인 사각형들을 분산하기 위한 4개의 오프셋 평면을 제공합니다.\n- 자기 조직화 정사각형 배치 - 한 평면의 잠재적 너비와 오프셋 평면의 차지된 높이를 연관시킴으로써 자기 조직화를 가능케하도록 하며, 이는 공유 경계(분할된 세그먼트로 실행됨)를 구현함으로써 이루어집니다.\n- 측면 전환 - 크기에 따라 정사각형들을 고르게 분산하기 위해, 원하는 순서로 하나를 배치한 후 측면을 전환합니다. (나는 기본적으로 윗쪽-오른쪽-아래쪽-왼쪽으로 전환했습니다.)\n- 사용자 정의 - 이 방법은 값 정렬을 배제하지만, 일련의 규칙에 따라 다음 측면을 선택할 수 있는 기능을 구현할 수 있는 능력을 제공합니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_13.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nv1 알고리즘은 다음과 같아요:\n- 먼저 양수 값들로 이루어진 집합부터 내림차순으로 정렬해요. 예를 들어, 9.4, 7.4, 1.5, 0.2\n- 값을 패딩하기 위해 각 사각형 주변의 공간을 추가한 후 (예를 들어 0.5)\n- 첫번째 (가장 큰) 사각형을 설정하고, 중앙 사각형 주변의 각 사분면을 위한 세그먼트 저장 메커니즘을 생성해요.\n- 초기 세그먼트를 중앙 사각형의 변으로 설정하고, 각 사분면에 하나씩 배정해요.\n- 옆면 순서 (기본값은 위, 오른쪽, 아래, 왼쪽)가 주어지면, 각 면을 반복하면서 작은 사각형을 배치해요. 각 사분면의 첫 번째 사각형은 해당 사분면 평면의 원점과 정렬되어, 해당 사분면의 초기 세그먼트 시작 위치에서 시작해요.\n- 위쪽 면에 사각형을 배치하려면 (정렬 및 배치 요구 사항을 고려하여), 세그먼트를 가장 짧은 y값별로 정렬하고 가장 긴 길이를 가지는 세그먼트에서, 사각형의 너비 ≤ 세그먼트 길이인 첫 번째 세그먼트에 사각형을 배치해요.\n- 사각형을 배치하면, 해당 사각형이 차지한 공간을 세그먼트에서 조절하여 세그먼트의 시작 위치 및 길이를 조정하고, 새로운 세그먼트를 만들어요.\n- 배치된 사각형의 시작 위치가 사분면 평면의 오프셋 경계와 정렬되면 (중앙 사각형의 축에 수직인 경계), 중앙 사각형 주변의 자기 조직화 성장을 가능하게 하기 위해 영향을 받는 세그먼트의 세그먼트 길이를 연장해요.\n- 원하는 스택 구성을 위해 필요한 측 선택 메커니즘을 구현해요.\n- 사각형을 버퍼로 다시 원래 크기로 바꾸고, 원하는 회전으로 사각형을 회전시켜요 (기본값은 45도).\n\n아래 다이어그램은 세그먼트 기반 접근 방법을 보여줘요. 각 세그먼트는 다음과 같이 될 거에요:\n- 원래 위치에서 한 방향으로 효과적으로 이동시켜져요 (사각형의 너비가 세그먼트 길이와 같은 경우)\n- 두 섹션으로 분할돼요 (하나는 배치된 사각형의 너비를 따르고, 다른 하나는 시작 위치와 길이가 변경된 원래 세그먼트일거에요).\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_14.png\" /\u003e\n\n재미로, 몇 가지 측면 선택 옵션을 구현했는데 'constraints' 입력란은 다각형을 받아들이고 외곽을 벗어나면 측면을 전환하려고 시도하여 다각형과 겹치는 특정 영역에서의 성장을 촉진합니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_15.png\" /\u003e\n\n이것이 제 두 번째 영감으로 이어집니다. Quad-Tile Chart v1을 내 vizmath 패키지에 통합할 때 다각형 입력과 더 많은 작업을 할 수 있는지 생각하기 시작했습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일부 실험 끝에, 주어진 다각형 내에 꼭지점이 깔끔하게 맞는 완전히 기능적인 컨테이너 패킹 구현이 재미있을 것이라고 결정하고 처음부터 알고리즘을 완전히 개편해보기로 했습니다! 다음에 해당하는 알고리즘을 확인해 봅시다: Quad-Tile Chart v2\n\n## (최종) 알고리즘 v2\n\n이 알고리즘의 두 번째 버전은 v1의 일부 핵심 요소를 확장하고 쿼드런트-세그먼트 접근 방식을 유사하게 사용하면서 몇 가지 수정 사항과 컨테이너 패킹을 수용하기 위한 몇 가지 새로운 기능을 추가합니다.\n\nv2에 대한 주요 세부 내용은 다음과 같습니다. 특별한 점을 확인해 보세요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Bridge Segments(컨테이너 채우기)\n- Backward Segment Extension(‘축소’ 옵션)\n- Value Multiplier Bisection Optimization(컨테이너 패킹)\n\n![image](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_16.png)\n\n다음은 v2 알고리즘입니다:\n\n- 단계 1~5는 v1과 동일하지만 2가지 세그먼트 속성(세그먼트 높이 및 세그먼트가 활성화되어 있는지), 3가지 사분면 레벨 속성(최소 바닥과 천장 및 해당 사분면 전체가 방을 다 쓴 것인지) 및 배치된 사각형에 대한 속성(왼쪽 아래 모서리 좌표 및 너비)가 추가됩니다.\n- 이터레이터(처음에 0으로 설정)가 놓여야 하는 사각형 수보다 작을 동안 다음 절차가 수행됩니다:\n- 마지막 바닥 세그먼트(LFS)를 찾습니다: max(segments: 'y=floor', sort: 'x')\n- 정렬된 세그먼트 목록을 만듭니다: (segments: 'is active', sort: 'height, x')\n- 정렬된 세그먼트를 루프합니다(아래에서 '세그먼트' 및 루프 반복 '세그먼트'로 참조됨) 및 진행합니다.\n- 만약 사각형의 모퉁이가 다각형 내에 있고 사각형의 '너비'와 '높이'가 세그먼트의 '너비'와 '높이'에 맞는다면 사각형은 배치됩니다. 그렇지 않으면 세그먼트를 '비활성화'로 설정합니다.\n- 세그먼트의 'y' 값이 사분면의 '바닥'과 같다면 사각형의 '너비'를 추가하여 '바닥'을 업데이트합니다.\n- 사각형이 배치되면 사각형의 너비와 세그먼트 길이에 따라 현재 세그먼트를 대체할 1개 또는 2개의 새 세그먼트를 생성합니다.\n- 축소가 활성화된 경우 다음 절차가 수행됩니다:\n- 세그먼트를 새로 생성된 세그먼트 중 가장 왼쪽으로 설정(NLS).\n- 확장할 세그먼트를 찾습니다: max(segments: 'x + 길이 = NLS.x', 'y = NLS.y', sort: 'x')\n- 확장할 세그먼트가 존재하는 경우, NLS 길이를 추가하고 NLS를 제거합니다.\n- 그렇지 않은 경우, 왼쪽 사각형(LS)을 찾습니다: max(squares: 'x+w≤NLS.x', 'y≤NLS.y', 'y+x≥NLS.y', sort: 'x')\n- 왼쪽 사각형(LS)이 존재하면 LS.x + LS.w ≤ NLS.x를 확인하여 갭이 있는지 확인합니다.\n- 그렇다면, 커버된 세그먼트(CS)를 확인합니다: max(segments: 'y=LS.y', 'x`NLS.x', sort: 'x')\n- 커버된 세그먼트가 존재하는 경우, 세그먼트 높이를 사각형 너비와 동일하게 설정하고 병합 세그먼트를 확인합니다: max(segments: 'x+길이+CS.length = NLS.x', 'y=NLS.y', sort: x)\n- 병합 세그먼트가 존재하는 경우, 사각형 너비와 CS.length를 추가하여 길이를 확장합니다.\n- 그렇지 않은 경우, LS.x + LS.w ≤ NLS.x - 사각형 너비라면 NLS.x = LS.x+LS.w 및 NLS.길이 = CS.length으로 NLS를 조정합니다.\n- 세그먼트가 LFS와 같고 배치되지 않았으며 사분면의 바닥이 천장과 다른 경우 다리 세그먼트를 생성합니다. 다음 절차를 따릅니다:\n- LFS.높이 및 사분면 바닥을 사분면 천장으로 업데이트합니다.\n- 천장 세그먼트(CS)가 천장에서 존재하는지 확인합니다: max(segments: 'y=ceiling', sort: x)\n- 존재하는 경우, 그 길이를 다각형 경계까지 확장합니다.\n- 그렇지 않은 경우, (세그먼트.x, 천장)에 새 세그먼트를 생성하고 해당 지점과 다각형 경계 사이의 거리로 길이를 설정합니다.\n- 마지막으로, 모든 세그먼트를 '활성화'로 설정하고 루프를 종료합니다.\n- 그렇지 않은 경우, 사각형이 배치되면 사각형을 사각형 목록에 추가하고 해당 속성을 설정하고 사분면을 '방이있음'으로 설정하고 세그먼트가 마지막 세그먼트인 경우 모든 세그먼트를 '활성화'로 설정하고 이터레이터를 1 증가시키고 다음 측면을 설정하고 루프를 종료합니다.\n- 그렇지 않은 경우, 마지막 세그먼트에 도달하면 가능한 경우 더 많은 다리 세그먼트를 추가하려 시도합니다. 다음 절차를 따릅니다:\n- 다리 사각형(BS)을 확인합니다: 첫번째(squares: 'x+w=LFS.x', 'y=LFS.y')\n- 있으면, LFS.높이 = BS.x로 설정하고 사분면 바닥을 BS.w만큼 증가시키고 사분면 천장을 바닥으로 설정합니다.\n- 다리 사각형 세그먼트를 확인합니다: max(segments: 'y=floor', sort: x)\n- 하나가 존재한다면, 그 길이를 다각형 경계까지 확장합니다.\n- 그렇지 않은 경우, (BS.x+BS.w, 바닥)에 새 세그먼트를 생성하고 해당 지점과 다각형 경계 사이의 거리로 길이를 설정합니다.\n- 마지막으로, 모든 세그먼트를 '활성화'로 설정하고 루프를 종료합니다.\n- BS를 찾지 못한 경우, 사분면을 '방이없음'으로 설정하고 모든 세그먼트를 '활성화'로 설정하고 다음 측면을 설정하고 모든 사분면이 방이없으면 이터레이터를 놓여야 하는 사각형 수로 설정(사실상 외부 while 루프를 종료합니다).\n- v1의 단계 10을 반복하며 각 사분면을 올바른 방향으로 회전합니다.\n- 자동 배열 옵션이 선택된 경우(컨테이너 패킹), 변환된 값들\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nv2 알고리즘은 컨테이너 패킹을 맞추기 위해 훨씬 더 많은 작업을 필요로했기 때문에 v1 알고리즘의 간단함에 비해 더 많은 노력이 필요했습니다. 하지만 정말 그만한 가치가 있었어요! v2에서 몇 가지 레이아웃 예제를 살펴봅시다.\n\n![이미지](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_17.png)\n\n위의 원 형태의 외곽선은 '축소' 기능을 사용하여 참조용으로 포함했습니다. v2의 이론적 한계는 아마도 자기 자신을 내부로 돌리는 다각형들일 것입니다 (이는 사분면의 타일링 평면에서 고유 다각형 갭을 처리하기 위한 향상된 세그먼트 논리가 필요할 것입니다).\n\n다음으로, Python에서 Quad-Tile 차트를 구축하는 방법을 살펴보겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 파이썬 구현\n\n저는 제 Quad-Tile Chart 알고리즘 v1 및 v2를 파이썬에서 사용할 수 있도록 vizmath 패키지를 통해 구현했습니다. PyPI에서 제공됩니다. 소개에서 시작하는 초기 예제를 사용하여 몇 가지 추가 옵션을 살펴보고 입력 및 출력을 설명하겠습니다. 먼저 v1로 시작합니다:\n\n```js\n# Quad-Tile Chart v1\n# pip install vizmath==0.0.22\nfrom vizmath.quadtile_chart import quadtile as qt\nimport pandas as pd\n\ndata = {\n    'id' : [str(i) for i in range(1, 21)],\n    'speed' : [242,200,105,100,100,95,92.5,88,80,79,\n        75,67.85,61.06,60,56,55,55,55,50,50]\n}\ndf = pd.DataFrame(data)\n\n# 쿼드타일 객체 생성\n#   \u003e df: 데이터와 id 필드가 있는 DataFrame\n#   \u003e id_field: 필수 식별자 필드 (더미값 사용 가능)\n#   \u003e value_field: 필수 값 열\n#   \u003e xo: x축 기준점\n#   \u003e yo: y축 기준점\n#   \u003e packing: 패킹 방법 ('auto','inc','num','max','min')\n#   \u003e overflow: 'num', 'max', 'min' 패킹을 위한 정수 임계값\n#   \u003e buffer: 사각형 크기에 추가 값\n#   \u003e rotate: 차트 회전 각도\n#   \u003e constraints: 둘레 내부 성장을 촉진하는 다각형\n#   \u003e size_by: 'area' 또는 'width'\n#   \u003e poly_sort: 다각형 정점 정렬 활성화/비활성화 (참, 거짓)\nqt_o_area = qt(df,'id','speed', size_by='area', buffer=0)\nqt_o_width = qt(df,'id','speed', size_by='width', buffer=0)\n\n# 차트 그리기 (면적 및 너비에 따라 크기 조절)\nqt_o_area.quadtile_plot(color='quad', cw=0.75, opacity=.9)\nqt_o_width.quadtile_plot(color='quad', cw=0.75, opacity=.9)\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_18.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 v2를 사용해 봅시다:\n\n```js\n# Quad-Tile Chart v2\n# pip install vizmath==0.0.22\nfrom vizmath.quadtile_chart import polyquadtile as pqt\nimport pandas as pd\n\ndata = {\n    'id': [str(i) for i in range(1, 21)],\n    'speed': [242, 200, 105, 100, 100, 95, 92.5, 88, 80, 79, 75, 67.85, 61.06, 60, 56, 55, 55, 55, 50, 50]\n}\ndf = pd.DataFrame(data)\n\n# 쿼드타일 객체 생성\n#   \u003e df: 데이터를 포함하고 있는 DataFrame, 숫자형 데이터 컬럼과 id 필드를 가져야 함\n#   \u003e id_field: 필수 식별자 필드 (더미 값 사용 가능)\n#   \u003e value_field: 필수 값 컬럼\n#   \u003e xo: x축 원점\n#   \u003e yo: y축 원점\n#   \u003e buffer: 사각형 크기를 조절하는 보정값\n#   \u003e rotate: 차트 회전 각도\n#   \u003e sides: 포함시킬 변 선택 ('top', 'right', 'bottom', 'left')\n#   \u003e collapse: 축소/확대 설정 (True, False)\n#   \u003e constraints: 패킹할 다각형 컨테이너\n#   \u003e xc: x축 컨테이너 오프셋 값\n#   \u003e yc: y축 컨테이너 오프셋 값\n#   \u003e size_by: 'area' 또는 'width'\n#   \u003e auto: 자동 패킹 활성화/비활성화 (True, False)\n#   \u003e auto_max_iter: 자동 패킹 반복 횟수\n#   \u003e auto_min_val: 자동 패킹 최소 배수\n#   \u003e auto_max_val: 자동 패킹 최대 배수\n#   \u003e poly_sort: 다각형 꼭지점 정렬 활성화/비활성화 (True, False)\npqt_o_area = pqt(df, 'id', 'speed', size_by='area', buffer=0)\npqt_o_width = pqt(df, 'id', 'speed', size_by='width', buffer=0)\n\n# 차트 그리기 (면적 및 폭에 따라 사이즈가 지정된 차트)\npqt_o_area.polyquadtile_plot(color='quad', cw=0.75, opacity=0.9)\npqt_o_width.polyquadtile_plot(color='quad', cw=0.75, opacity=0.9)\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_19.png\" /\u003e\n\n이제 v1 및 v2의 랜덤 초기화 옵션을 포함한 몇 가지 추가 옵션을 조사해 봅시다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 1000개의 임의 크기 사각형을 테스트해봅시다:\nfrom vizmath.quadtile_chart import quadtile as qt\nfrom vizmath.quadtile_chart import polyquadtile as pqt\n\n# 상단 좌측에 회전된 Quad-Tile Chart v1\nqt_o1 = qt.random_quadtile(1000, rotate=45)\nqt_o1.quadtile_plot(color='quad', cw=0.75, opacity=.9)\n\n# 상단 우측에 비회전 Quad-Tile Chart v1\nqt_o2 = qt.random_quadtile(1000, rotate=0)\nqt_o2.quadtile_plot(color='quad', cw=0.75, opacity=.9)\n\n# 하단 좌측에 정사각형 컨테이너를 사용한 Quad-Tile Chart v2\npoly = [(-10,-10),(-10,10),(10,10),(10,-10)] # 다각형 컨테이너\npqt_o1 = pqt.random_polyquadtile(1000, constraints=poly, buffer=0)\npqt_o1.polyquadtile_plot(color='quad', cw=0.75, opacity=.9)\n\n# 중앙에 가로 세로 비율이 1:1인 Quad-Tile Chart v2\npqt_o2 = pqt.random_polyquadtile(1000, constraints=[(1,1)], buffer=0)\npqt_o2.polyquadtile_plot(color='quad', cw=0.75, opacity=.9)\n\n# 하단 우측에 가로 세로 비율이 1:1인 Quad-Tile Chart v2\npqt_o3 = pqt.random_polyquadtile(1000, constraints=[(1,1)],\n    buffer=0, rotate=0)\npqt_o3.polyquadtile_plot(color='quad', cw=0.75, opacity=.9, circles=False)\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_20.png\" /\u003e\n\n위 내용은 각 버전 간 배치 방법의 미묘한 차이를 보여줍니다 (v1은 y값이 가장 낮고 가장 긴 길이로 선택된 세그먼트, v2는 계단식 접근 방식). 또한 v2에 대한 무작위 초기화는 무작위 볼록 다각형을 생성할 것입니다 — 무엇이 나올지 아무도 모릅니다!\n\n```js\nfrom vizmath.quadtile_chart import polyquadtile as pqt\n\npqt_o = pqt.random_polyquadtile(100, collapse=True)\npqt_o.polyquadtile_plot(color='quad', cw=0.75, opacity=.9, circles=True,\n    show_constraints=True)\n\n# 계속해서 무작위 크기 사각형을 사용한 무작위 컨테이너 실행\r\n```  \n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_21.png\" /\u003e\n\n그리고 끝으로, 우리는 중심점을 사용하여 부모 사각형의 경계 상자 크기에 맞는 모든 모양으로 플롯할 수 있음을 기억하세요. 원형 차트의 경우에는 반소형 Bubble Chart만 플로팅한다는 소개를 참조하세요!\n\n이제 Quad-Tile Chart 알고리즘으로 생성된 사분면 다각형과 사분면 중심점 출력을 검토해 봅시다.\n\n사분면 다각형 출력:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- item — ‘id’ 입력 필드로 지정된 수신 식별자\n- a — 사각형의 상대적 면적 (버퍼는 포함되지 않음)\n- w — 할당된 공간의 너비: 사각형의 너비 + 버퍼*2\n- x, y — 레이아웃 내의 점에 대한 직교 좌표\n- path — 폴리곤을 둘러싼 경로를 나타내는 정수 순서 집합으로, Crystal Bar Chart의 각 크리스탈 ID 및 면에 대해 각각의 (x, y) 점과 함께 사용됨: 1부터 N까지\n\n```js\nfrom vizmath.quadtile_chart import polyquadtile as pqt\nimport pandas as pd\n\n# 컨테이너에 맞게 크기 조정 없이 초기 예제 데이터 사용:\ndata = {\n    'id' : [str(i) for i in range(1, 21)],\n    'speed' : [242,200,105,100,100,95,92.5,88,80,79,75,67.85,61.06,60,56,55,55,55,50,50]\n}\npoly = [(-1000,-1000),(-1000,1000),(1000,1000),(1000,-1000)] # 설명 예제 출력을 위한 충분히 큰 컨테이너\ndf = pd.DataFrame(data)\no_pq1 = pqt(df,'id','speed',buffer=5.0, collapse=True, constraints=poly, auto=False)\no_pq2 = pqt(df,'id','speed',buffer=5.0, collapse=True, constraints=poly, auto=False, size_by='width')\n\n# 면적에 따라 크기 조정:\no_pq1.o_polyquadtile_chart.df[['id','item','a','w','x','y','path']].head()\n# 너비에 따라 크기 조정:\no_pq2.o_polyquadtile_chart.df[['id','item','a','w','x','y','path']].head()\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_22.png\" /\u003e\n\n사각형 중심점은 'id' 대신 'item'으로 동일한 속성으로 추출될 수도 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n# 넓이 별 크기:\no_pq1.o_polysquares.df[['id','a','w','x','y']].head()\n\n# 너비 별 크기:\no_pq2.o_polysquares.df[['id','a','w','x','y']].head()\n\n\n![이미지](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_23.png)\n\n이제 Quad-Tile 차트로 무엇을 더 할 수 있는지 알아봅시다.\n\n## 확장성\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n캔버스 레이아웃을 활용하는 원래의 목표를 표준 및 비표준 컨테이너와 함께 다시 살펴보겠습니다. 볼록 다각형과 간단한 오목 다각형을 수용할 수 있는 방법을 보여드렸고, 이제는 소개에서 소개된 레이아웃을 채워봤습니다. 각각 100개의 정사각형이 들어가는 컨테이너에 대해 다양한 회전을 적용했습니다.\n\n![image](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_24.png)\n\n가장 일반적인 캔버스 레이아웃은 직사각형 컨테이너일 것이므로, 원하는 종횡비를 간단하게 전달하는 것이 유용합니다. 다음은 너비를 다양하게 조절한 예시입니다 (높이 조절 방법도 동일합니다):\n\n```js\nfrom vizmath.quadtile_chart import polyquadtile as pqt\n\naspect_ratio = (1,1) #(2,1) (3,1) (4,1)\npqt_o = pqt.random_polyquadtile(100, constraints=[aspect_ratio], \n    rotate=45, collapse=True, buffer=.02)\npqt_o.polyquadtile_plot(color='quad', cw=0.75, opacity=.9)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_25.png)\n\nExtensibility의 또 다른 흥미로운 측면은 계층적 데이터를 포함하는 것입니다. 기존 방법의 일부 단점은 다음과 같습니다:\n\n- 중첩된 원은 레벨별로 정확한 상대적인 면적을 유지할 수 없습니다. 이를 위해 중첩된 Radial이나 Voronoi Treemaps가 필요합니다.\n- Treemaps는 상위 레벨에서 불규칙한 차원을 가질 가능성이 있습니다. (사각형, 원형, 또는 Voronoi일 경우)\n\nQuad-Tile Chart는 계층의 상위 수준을 유사한 모양으로 캡처하여 초기 크기 비교를 제공함으로써 두 번째 문제를 우아하게 처리할 수 있습니다.🌟\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n첫 번째 문제에 대해 말씀드리면, 중첩된 Quad-Tile Charts는 중첩된 패킹된 원(타일 섹션에서 언급된대로)과 동일한 단점을 가지고 있지만, 전통적인 직사각형 Treemaps(또는 Voronoi Treemaps)으로 나무 전체에 대한 정확한 면적을 유지하는 대안을 제공합니다. 중첩된 직사각형 Treemaps은 부모 정사각형의 변을 사용하여 보다 직관적인 자식 직사각형 비교를 할 수 있어 원하는 경우가 있습니다.\n\n다음 단계의 직사각형 Treemaps에 대한 예시 몇 가지를 함께 공유드리겠습니다. 상위 수준에 정사각형을 포함한 Quad-Tile Chart에 중첩된 이들을 제가 “Squaremaps”라고 부르겠습니다!\n\n![Squaremaps](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_26.png)\n\n제가 vizmath에서 Squaremaps에 대한 구현을 다음과 같이 작성했습니다(그리고 필요 시 계층적 데이터를 동적으로 생성하는 기능도 추가했습니다!):\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\r\nimport pandas as pd\nfrom vizmath.quadtile_chart import squaremap as sm\n\n# 랜덤한 스퀘어 맵 생성\no_sm1 = sm.random_squaremap(num_levels=3, items_range=(2,4), \n    value_range=(1,1000), sig=0.8)\no_sm1.o_squaremap.plot_levels(level=3, fill='w')\n\n# 계층적 데이터를 사용하여 스퀘어 맵 생성\ndata = [\n    ['a1', 'b1', 'c1', 9.3],\n    ['a1', 'b1', 'c2', 6.7],\n    ['a1', 'b1', 'c3', 2.4],\n    ['a1', 'b2', 'c1', 4.5],\n    ['a1', 'b2', 'c2', 3.1],\n\n    ['a2', 'b1', 'c1', 5.9],\n    ['a2', 'b1', 'c2', 32.3],\n    ['a2', 'b1', 'c3', 12.3],\n    ['a2', 'b1', 'c4', 2.3],\n    ['a2', 'b2', 'c1', 9.1],\n    ['a2', 'b2', 'c2', 17.3],\n    ['a2', 'b2', 'c3', 6.7],\n    ['a2', 'b2', 'c4', 4.4],\n    ['a2', 'b2', 'c5', 11.3],\n\n    ['a3', 'b1', 'c1', 7.5],\n    ['a3', 'b1', 'c2', 9.5],\n    ['a3', 'b2', 'c3', 17.1],\n\n    ['a4', 'b2', 'c1', 5.1],\n    ['a4', 'b2', 'c2', 2.1],\n    ['a4', 'b2', 'c3', 11.1],\n    ['a4', 'b2', 'c4', 1.5]]\ndf = pd.DataFrame(data, columns = ['a', 'b', 'c', 'value'])\no_sm2 = sm(df, ['a','b','c'], 'value', constraints=[(1,1)], buffer=.2)\no_sm2.o_squaremap.plot_levels(level=3, fill='w')\r\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_27.png\" /\u003e\n\n## Tableau Public Implementation\n\n파이썬에서 Quad-Tile Chart를 소개했으며 계층적 확장에 대한 Squaremap을 포함하였습니다. 이어서 Tableau Public (v 2023.3.1)에서 양쪽 모두를 구현하는 방법을 보여드리겠습니다! 우선 간단한 Squaremap 구현부터 시작하여 대화형으로 만드는 더 체계적인 Quad-Tile Chart 구축으로 넘어가보겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTableau Public에서 Squaremap 구현\n\n더 자세한 안내를 위해서는, 저의 Radial Treemaps에 관한 글이 있습니다. 해당 글은 상호작용 가능한 계층을 만드는 방법에 대해 더 상세히 안내하며, 이를 위해 Squaremap과 동일한 그림 출력을 사용합니다! 지금은 임의의 입력을 생성하고 단순한 Tableau 예제에 대비한 그림 출력 데이터를 준비해보겠습니다.\n\n```js\nfrom vizmath.quadtile_chart import squaremap as sm\n\n# 임의의 계층 데이터 생성 및 Squaremap 작성\no_sm = sm.random_squaremap(num_levels=3, num_top_level_items=120,\n    items_range=(2,4), value_range=(1,10), sig=0.75, \n    collapse=True, buffer=0.05)\n# 초기 플롯 검토\no_sm.o_squaremap.plot_level(level=3)\n# 출력의 미리보기 (그림 데이터)\no_sm.o_squaremap.df_rad_treemap.head(10)\n# 데이터로 그림 객체 설정\no_sm.o_squaremap.o_rad_treemap.df = o_sm.o_squaremap.df_rad_treemap\n# Tableau에서 지도 레이어를 활용하기 위한 데이터 재조정\no_sm.o_squaremap.o_rad_treemap.dataframe_rescale(\n    xmin=-5, xmax=5, ymin=-5, ymax=5)\n# 데이터를 csv로 작성\no_sm.o_squaremap.o_rad_treemap.dataframe_to_csv('squaremap')\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_28.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- [Group]을 Marks 아래 Detail로 드래그하세요.\n- Marks 드롭다운 메뉴에서 Polygon을 선택하세요 (이 시점에서 이상하게 보인다고 걱정하지 마세요).\n- [Path]를 Marks 아래 Path로 드래그하고 현재 SUM(Path)인 항목을 우클릭하여 Dimension으로 선택하세요.\n- [Value]를 Color로 드래그하고 Dimension으로 변환하는 작업을 반복하세요.\n- Color 아래에서 \"색상 편집...\"을 선택하고 다음 옵션으로 구성하세요: '반전, 고급: (시작: 0, 끝: 10)'\n\n이제 더 재미를 위해 더 한 개의 레이어를 추가하여 색상을 변경해 봅시다:\n\n- [Treemap]을 지도 영역으로 드래그하면 팝업이 나타납니다: Marks 레이어 추가 - 이를 클릭하여 새로운 지도 레이어를 생성하세요.\n- 위의 단계를 반복하되 이제 [Side]를 Color로 사용하세요.\n- Color 아래에서 검은 테두리를 선택하고 투명도를 15%로 설정하세요.\n\n이제 아래와 유사한 차트가 나타날 것입니다 (입력의 무작위성으로 인해 고유한 것이 될 것입니다!). 이제 [Level]로 필터링하거나 필요에 맞는 상호 작용을 설정할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_29.png) \n\n이 Squaremap 구현이 당신의 계층적 데이터를 더 자세히 탐색하는 데 유용한 시작점이 되길 바랍니다!\n\nTableau Public에서 Quad-Tile Chart 구현\n\n이제 더 자세한 Quad-Tile Chart 구현에 초점을 맞추고 Tableau Public에서 상호작용형 시각화를 만들어 보겠습니다. 강 체계에 대한 위키피디아 데이터 일부로 시작해서 파일에 저장해보죠.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport pandas as pd\n\n# 위키백과에서 (2024년 1월 26일 기준) 상위 50개의 강 시스템 목록\n# https://en.wikipedia.org/wiki/List_of_river_systems_by_length\ndata = {\n    '강' : [str(i) for i in range(1, 51)],\n    '길이_km' : [\n        6650,6400,6300,6275,5539,5464,5410,4880,4700,4444,4400,4350,4241,\n        4200,3969,3672,3650,3645,3610,3596,3380,3211,3185,3180,3078,3060,\n        3058,3057,2989,2888,2809,2740,2720,2704,2620,2615,2570,2549,2513,\n        2500,2490,2450,2428,2410,2348,2333,2292,2287,2273,2270],\n    '길이_m' : [\n        4130,3976,3917,3902,3445,3395,3364,3030,2922,2763,2736,2705,2637,\n        2611,2466,2282,2270,2266,2250,2236,2100,1995,1980,1976,1913,1901,\n        1900,1900,1857,1795,1745.8,1703,1700,1690,1628,1625,1597,1584,\n        1562,1553,1547,1522,1509,1498,1459,1450,1424,1421,1412,1410],\n    '배수지역_km2' : [\n        3254555,7000000,1800000,2980000,2580000,745000,2990000,2582672,\n        3680000,1855000,2490000,810000,1790000,2090000,712035,1061000,\n        950000,1380000,960000,884000,1485200,63166,850000,610000,219000,\n        324000,1030000,570000,473000,817000,404200,1330000,454000,1024000,\n        534739,242259,1093000,900000,644000,270000,1547,1522,1509,1498,\n        1459,1450,1424,1421,1412,1410],\n    '평균유출량_m3_s' : [\n        2800,209000,30166,16792,18050,2571,12475,22000,41800,11400,15500,\n        16000,10300,5589,19800,767,13598,8080,7160,856,31200,8400,6210,\n        3300,703,3153,10100,82,3600,7130,13000,4880,1480,12037,1400,6000,\n        2575,4300,3800,270000,1547,1522,1509,1498,1459,1450,1424,1421,\n        1412,1410],\n    '방출지' : [\n        '지중해','대서양','동해','멕시코만',\n        '카라해','보해','오블만','리오데라플라타',\n        '대서양','오호츠크해','랩테프해','남중국해',\n        '보퍼트해','기니만','간지스','남쪽의해',\n        '대서양(마라조 만), 아마존 델타','카스피해',\n        '아라비아해','페르시아만','아마존','아마존','베링해',\n        '대서양','아랄해','안다만해','세인트로렌스만',\n        '멕시코만','예니세이강','흑해','안다만해',\n        '모잠비크해협','레나강','벵갈만','아랄해','아마존',\n        '헛슨만','파라나강','동시베리아해','파라과이강','옵강','이르티시강',\n        '카스피해','아마존','미시시피강','캘리포니아만',\n        '랩테프해','흑해','레나강','콩고'],\n    '이름': [\n        '나일–화이트나일–카게라–냐바롱고–모고고–루카라라',\n        '아마존–우카야리–탐보–에네–만타롤',\n        '창강–금샤강–통티안강–당쿠강 (장강)',\n        '미시시피–미주리–제퍼슨–비버헤드–레드락–헬로링',\n        '예니세이강–앙가라강–셀렝가강–이더','황허강',\n        '오블강–이르티시강','리오데라플라타–파라나강–리오그란데',\n        '콩고강–잠베시 (자이료)',\n        '두문강–아르군강–헤를런 (흑룽강)','레나강','메콩 (랑창강)',\n        '맥케너지강–스레이브강–피스강–핀레이','니제르강','브라마푸트라–얀룽창포',\n        '머리–달링–컬고아–발론–콘다믄','토칸찐스–아라구아이아',\n        '볼가','인다스–생거 장보','샤트알아랍–유프라테스–무랏',\n        '마데이라–마모레–그랜데–케인–로차','푸르스','유곤','상프란시스코',\n        '시르다리야–나린','살윈 (누강)',\n        '세인트로렌스–나이아가라–디트로이트–세인트클레어–세인트\\\n        메리스–세인트루이스–노스 (그레이트레이크스)','리오그란데','하횡강',\n        f\"도나우–브렉','두네르','두롱강–납마이강–둘롱강–케라올올루–가다쿠\",\n        '잠베지 (잠베지)','빌류이','간지스–후글리–팜다 (강가)',\n        '아무다리아–판즈','자푸라 (까퀘타)','넬슨–사스카추완',\n        '파라과이 (리오파라과이)','콜룸마','필코마요','상횡강–카툰',\n        '이심','우랄','주루아','아칸소어스','콜로라도 (미 서부)',\n        '올레니오크','드니프르','알단','우방기–우엘']\n}\n\ndf = pd.DataFrame(data)\ndf.to_csv('강_시스템.csv')\n```\n\n길이 (\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것은 좋아 보이네요. Tableau에서 지도 레이어를 활용하기 위해 차트 다각형 및 중심점의 출력 데이터를 저장해봅시다. 나중에 사용할 삼각형의 좌표도 출력하여 나준합니다.\n\n```js\n# 출력 파일 (Tableau에서 지도 레이어를 활용하기 위해 데이터 재조정)\n\n# Quad-Tile 차트 다각형 출력\no_pqt.o_polyquadtile_chart.dataframe_rescale(-3,3,-2,4)\no_pqt.o_polyquadtile_chart.df = pd.merge(\n    o_pqt.o_polyquadtile_chart.df, df, left_on='item', right_on='river')\no_pqt.o_polyquadtile_chart.df = o_pqt.o_polyquadtile_chart.df[\n    ['river','side','x','y','path','length_km','length_m',\n    'drainage_area_km2','average_discharge_m3_s','outflow','name']]\no_pqt.o_polyquadtile_chart.dataframe_to_csv('quadtile')\n\n# Quad-Tile 차트 중심점 출력\no_pqt.o_polysquares.dataframe_rescale(-3,3,-2,4)\no_pqt.o_polysquares.df = pd.merge(\n    o_pqt.o_polysquares.df, df, left_on='id', right_on='river')\no_pqt.o_polysquares.df = o_pqt.o_polysquares.df[\n    ['river','side','x','y','length_km','length_m',\n    'drainage_area_km2','average_discharge_m3_s','outflow','name']]\no_pqt.o_polysquares.dataframe_to_csv('quadtile_centroids')\n\n# 삼각형 컨테이너 좌표\npoly = o_pqt.constraints\nrs_poly_yx = [(vf.rescale(y, -2, 4, -1, 1),\n    vf.rescale(x, -3, 3, -1, 1)) for x,y in poly]\nprint(rs_poly_yx)\n# 결과:\n# [(-0.691813852924281, -0.9166666666666669), \n# (0.8615194804090525, 0.0), \n# (-0.691813852924281, 0.9166666666666667)]\r\n```\n\n마지막으로, 상호 작용을 더 활성화하기 위해 범례를 생성해봅시다.\n\n```js\r\n#%% 범례 플롯\ndf_legend = df.groupby('outflow')['name'].count().reset_index()\no_pqt_legend = pqt(df_legend,'outflow','name', \n    constraints=[(4,1)], collapse=True,\n    rotate=45, buffer=.1, size_by='width', sides=['top','right'])\no_pqt_legend.polyquadtile_plot(show_constraints=True)\n\n#%% 범례 데이터\no_pqt_legend.o_polyquadtile_chart.dataframe_rescale(-2,6,-4,4)\no_pqt_legend.o_polyquadtile_chart.df = pd.merge(\n    o_pqt_legend.o_polyquadtile_chart.df, df_legend, \n    left_on='item', right_on='outflow')\no_pqt_legend.o_polyquadtile_chart.df = o_pqt_legend.o_polyquadtile_chart.df[\n    ['outflow','side','x','y','path','name']]\no_pqt_legend.o_polyquadtile_chart.dataframe_to_csv('quadtile_legend')\r\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![그림](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_31.png)\n\n이제 Tableau를 준비했으니, 다음 3개 파일을 모두 가져오기 위해 텍스트 파일 옵션을 사용하여 시작해보겠습니다. Sheet 1로 이동한 다음, 상단 왼쪽 데이터 탭에서 쿼드타일 데이터 소스를 선택하고 다음과 같은 계산 열을 생성하세요:\n\n먼저 맵 영역에서 마우스를 오른쪽 클릭하여 배경 레이어를 선택하고 다음 옵션을 조정해보세요:\n\n- 모든 배경 맵 레이어 (베이스, 랜드 커버 등)을 선택 해제하세요.\n- 이제 맵 영역에서 마우스를 오른쪽 클릭하고 맵 옵션을 선택한 다음, 패널에서 모든 옵션을 선택 해제하세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n배경 레이어를 닫고 다음 단계를 계속해 보세요:\n\n- [Side]를 Marks 하위에 Detail로 드래그합니다.\n- Marks 드롭다운 메뉴에서 Polygon을 선택합니다.\n- Color 하위에서 검은색 테두리 색상을 선택하고 불투명도를 40%로 조절한 다음 색상을 연한 파랑색으로 설정합니다.\n\n다음으로, 사각형에 대한 윤곽선 레이어를 추가해 봅시다:\n\n- [Squares]를 맵 영역으로 드래그하면 팝업이 나타납니다: Marks 레이어 추가 - 이를 클릭하여 새 맵 레이어를 만듭니다.\n- 팝업 메뉴에서 드롭다운 메뉴를 통해 필드를 'Outlines'로 이름을 변경합니다.\n- [River]를 이 새로운 맵 레이어의 Marks 하위 Detail로 드래그합니다.\n- Marks 드롭다운 메뉴에서 Line을 선택합니다 (이 시점에서 이상하게 보인다 해도 걱정하지 마세요).\n- [Path]를 Marks 하위 Path로 드래그하고 차원으로 변환하는 프로세스를 반복합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n메인 스퀘어 레이어에 대해 Marks 드롭다운 메뉴에서 Polygon을 선택하여 새 레이어에 대해 위 과정을 반복하고, [Drainage Area Km2]로 색을 입힙니다. '시작: 0, 끝: 3,000,000'으로 설정해주세요.\n\n마지막으로, 데이터 탭에서 quadtile_centroids를 선택하여 중심점을 사용하는 레이어를 추가하고, 다음과 같은 계산된 열을 추가해주세요:\n\nTableau에서 올바른 크기 조정을 위해 길이를 제곱한 것을 알 수 있습니다. 이를 다음 단계에서 사용할 것입니다:\n\n- [Centroids]를 지도 영역으로 드래그하면 팝업이 표시됩니다: Marks 레이어 추가 - 피말을 해당 위치에 드래그하여 새 지도 레이어를 생성합니다.\n- 이 새 지도 레이어에서 Marks 아래 Detail로 [River]를 드래그합니다.\n- Marks 드롭다운 메뉴에서 Circle을 선택합니다.\n- [Size]를 Marks 아래 Size로 드래그하고 이를 차원으로 변환하는 과정과 크기 틱을 두 번째 해시로 설정합니다.\n- [Average Discharge M3 S]를 Color로 드래그하고 하얀 테두리를 추가하고 '시작: 0, 끝: 50,000'으로 설정해주세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n오른쪽 하단에 널 경고 표시가 나타납니다. 이를 마우스 오른쪽 단추로 클릭하고 숨김 표시를 선택할 수 있습니다. 이 시점에서 상호작용 및 레이블을 나중에 구현하기 위해 아래에 표시된 몇 가지 다른 세부 정보와 속성을 추가한 것처럼 보일 것입니다:\n\n![image](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_32.png)\n\n이제 대시보드의 소스 자료를 완성하기 위해 세 개의 시트를 추가해 보겠습니다. 설정을 위해 이미지를 참조하십시오.\n\n- \"Bars\" - quadtile_centroids 데이터 소스를 사용します.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![이미지](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_33.png)\n\n- “범례” - quadtile_legend 데이터 소스 사용\n\n![이미지](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_34.png)\n\n- “강” - quadtile_centroids 데이터 소스 사용, [이름]을 '정렬 기준: 필드, 정렬 순서: 내림차순, 필드 이름: [길이 Km], 집계: 최대값'으로 정렬 ('이름' 항목을 오른쪽 클릭하여 정렬... 선택)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_35.png\" /\u003e\n\n마지막 단계로, 이제 4개의 시트를 대시보드에 정리하고 대시보드 `동작` 아래의 상단 메뉴에서 몇 가지 동작을 설정해보겠습니다. 대시보드 `동작` 아래의 추가 동작 드롭다운을 클릭하고 `하이라이트`를 선택합니다. 대상 하이라이트에서 `선택한 필드`를 선택하고 [Outflow]과 [River] 필드를 선택합니다 ([Outflow]가 상기 시트에 세부사항으로 추가되었는지 확인). 마지막으로 오른쪽 상단의 `실행 동작` 아래에서 `가리키기` 옵션을 선택합니다.\n\n마지막 동작으로 추가 동작 드롭다운을 클릭하고 다음 옵션을 사용하여 필터를 선택합니다: '소스 시트: 범례, 대상 시트: 강, 선택한 필드: Outflow `quadtile_centroids` Outflow, 실행 동작: 선택시 실행, 선택 해제 시 모든 값 제외'. 이제 대시보드는 모든 시트에서 요청시 하이라이트를 표시하고 범례 시트에서 선택된 값에 대해 필터를 제외할 것입니다!\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1200/1*4CSKItCTjLiMaB7s09zolQ.gif\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 결론\n\n이 글에서 우리는 정방형이 원에 비해 채워진 도형 시각화에서 어떻게 성능을 발휘할 수 있는지 알아보기 위한 여정을 떠났습니다. 저희는 정방형의 적용을 테스트하기 위해 고수준 비교를 위한 최적화 프레임워크를 구현했고, 결국 정방형의 잠재력을 최대한 활용하기 위해 사용자 정의 알고리즘을 활용하기로 결정했습니다.\n\n저는 \"쿼드-타일 차트\"라고 명명한 것에 대한 상세한 안내서를 제공합니다. 이 차트는 값 세트를 시각화하는 데 사용되며, 또한 값 ​​계층 구조를 시각화하거나 시각화 캔버스의 사용 가능한 공간을 고려해 원하는 다각형 컨테이너 내에 정방형을 패킹하는 기능을 제공하는 \"스퀘어맵\"으로 확장됩니다.\n\n현재 데이터 시각화 공간에서 사용되는 주요 원 패킹 구현과는 다르게 다각형 컨테이너는 주요 장점으로 작용하며, Squaremap을 통해 계층 데이터는 새로운 집을 찾을 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가능하면, Quad-Tile Chart의 사각형 배열은 시각적으로 매력적으로 보입니다 (원과 경쟁하기 위해 필수적입니다!) 그리고 사각형은 원의 중심에 배치된 원들과 서로 바꿔 쓸 수 있습니다 (반응형인 Bubble Chart를 위해) 이것은 데이터를 사각형으로 구성하는 경향을 정당화하기 위한 우리의 노력의 승리로 결론내릴 수 있습니다.\n\n각종 데이터 시리즈와 계층이 모든 코너를 도발하고 있을 때, 여러분이 이러한 시각화 기술을 데이터 탐색 여정에서 유용한 도구로 활용하길 바랍니다!\n\n## 참고 자료\n\n본 문서에 포함된 모든 이미지는 별도로 명시하지 않은 한 저자가 제작했습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n[1] 위키백과 (CC BY-SA), “최고의 빠른 동물” (기준일: 2024년 1월 26일)\n\n[2] 위키백과 (CC BY-SA), “길이별 강 시스템 목록” (기준일: 2024년 1월 26일)\n\n관련 기사\n\n- 복잡한 집합 관계를 시각화하는 Multi-Chord Diagram 소개","ogImage":{"url":"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_0.png","tag":["Tech"],"readingTime":59},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_0.png\" alt=\"2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_0\"\u003e\u003c/p\u003e\n\u003ch1\u003e소개\u003c/h1\u003e\n\u003cp\u003e데이터 시각화에서 사용 가능한 캔버스의 크기와 모양은 항상 중요한 요소입니다. 이것은 공간을 절약하기 위한 수단으로 두 축 접근법을 사용하는 Crystal Bar Chart라는 차트를 최근 다른 기사에서 다룬 주제입니다.\u003c/p\u003e\n\u003cp\u003e이 기사에서는 값을 정사각형으로 시각화하고 볼록 다각형 또는 단순 오목 다각형 형태의 컨테이너를 가득 채우는 공간 절약 방법을 탐구하겠습니다. 또한 이 탐구 과정에 코드를 많이 활용해 보았으니, 다른 유용한 기술과 시각화 유형에 대한 재미있는 자습서로 제공될 수 있기를 희망합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 기사를 통해 달성하고자 하는 목표는 일반적이고 비표준적인 컨테이너 모양(아래 그림 참조)을 고려하고, 이와 유사한 모양의 값 집합을 제시하여 사용 가능한 공간을 최적화하고 직관적인 크기 비교를 제공하며 데이터를 사각형 모양으로 표현하는 것입니다!\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_1.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e새로운 축 없이 접근하기 전에, 결과를 측정할 좋은 기준을 찾을 수 있는 기존 축 기반 및 축 없는 방법에 대해 생각해 봅시다. 예를 들어, Wikipedia에서 제공하는 동물 중 상위 20마리의 최고 속도를 나타내는 정보를 활용하겠습니다.\u003c/p\u003e\n\u003ch2\u003e축 기반 데이터 시리즈 시각화\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003ey-축이 항목의 값을 나타내는 경우, 정렬된 막대 차트와 경쟁하기 어려울 수 있어요. 먼저 그것을 플롯하고, 저의 vizmath 패키지를 사용하여 몇 가지 더 축 기반의 차트를 만들어 보겠습니다.\u003c/p\u003e\n\u003cp\u003e막대 차트\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-attr\"\u003ehttps\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//en.wikipedia.org/wiki/Fastest_animals (2024년 1월 26일 기준)\u003c/span\u003e\n# \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e대 최고 빠른 동물 (최고속도, mph)\n\n데이터 = {\n    \u003cspan class=\"hljs-string\"\u003e'id'\u003c/span\u003e : [\u003cspan class=\"hljs-title function_\"\u003estr\u003c/span\u003e(i) \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e21\u003c/span\u003e)],\n    \u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e : [\u003cspan class=\"hljs-number\"\u003e242\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e105\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e95\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e92.5\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e88\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e80\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e79\u003c/span\u003e,\n        \u003cspan class=\"hljs-number\"\u003e75\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e67.85\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e61.06\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e56\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e55\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e55\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e55\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e]\n}\n\n# 막대 차트 (데이터는 이미 정렬되어 있음)\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e matplotlib.\u003cspan class=\"hljs-property\"\u003epyplot\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e plt\n\nplt.\u003cspan class=\"hljs-title function_\"\u003efigure\u003c/span\u003e(figsize=(\u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1.5\u003c/span\u003e))\n막대 = plt.\u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e21\u003c/span\u003e), 데이터[\u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e], edgecolor=\u003cspan class=\"hljs-string\"\u003e'black'\u003c/span\u003e,\n    color=\u003cspan class=\"hljs-string\"\u003e'white'\u003c/span\u003e, linewidth=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003exticks\u003c/span\u003e([])\nplt.\u003cspan class=\"hljs-title function_\"\u003egrid\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eshow\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_2.png\"\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e크리스털 막대 차트\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e vizmath.crystal_bar_chart \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e crystals\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pandas \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pd\n\n\u003cspan class=\"hljs-comment\"\u003e# 데이터: 위를 참조하십시오\u003c/span\u003e\n\ndf = pd.DataFrame(data)\ncbc = crystals(df, \u003cspan class=\"hljs-string\"\u003e'id'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e, height_range=\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, width_override=\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e,\n    rotation=\u003cspan class=\"hljs-number\"\u003e90\u003c/span\u003e, offset=\u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e, bottom_up=\u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e)\ncbc.cbc_plot(legend=\u003cspan class=\"hljs-literal\"\u003eFalse\u003c/span\u003e, alternate_color=\u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e, color=\u003cspan class=\"hljs-literal\"\u003eFalse\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e비스웜 플롯\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e vizmath.\u003cspan class=\"hljs-property\"\u003ebeeswarm\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e swarm\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pandas \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pd\n\n# 데이터: 위 참조\n\ndf = pd.\u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e(data)\ndiameter = \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e\nbs = \u003cspan class=\"hljs-title function_\"\u003eswarm\u003c/span\u003e(df, \u003cspan class=\"hljs-string\"\u003e'id'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e, size_override=pi*(diameter/\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)**\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\nbs.\u003cspan class=\"hljs-title function_\"\u003ebeeswarm_plot\u003c/span\u003e(color=\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_4.png\"\u003e\n\u003cp\u003e각각의 메소드들은 값의 크기를 반영하는 모양과 위치를 제공하면서 데이터 집합의 밀도 프로필을 제공하는 독특한 방식을 제공합니다.\u003c/p\u003e\n\u003cp\u003e이제 같은 값 세트를 사용하여 상대적인 크기 비교에 중점을 둔 축 없는 예제로 넘어가며 일부 반응형 Bubble Chart를 그려 Quad-Tile Chart 알고리즘을 미리보겠습니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e축 없이 데이터 시각화\u003c/h2\u003e\n\u003cp\u003e축 없이 도메인을 표현하기 위해 한 수준의 트리맵(저의 Radial Treemap에 관심이 있는 경우 해당 문서를 확인해보세요!)을 포함하고, 이어서 Bubble 차트를 추가해 봅시다.\u003c/p\u003e\n\u003cp\u003e트리맵 (한 수준의 파이, 도넛, 직사각형)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e vizmath.\u003cspan class=\"hljs-property\"\u003eradial_treemap\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e rad_treemap \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e rt\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pandas \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pd\n\n# 데이터: 위의 데이터를 참조하세요\n\n# 파이 트리맵\ndf = pd.\u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e(data)\no_rt = \u003cspan class=\"hljs-title function_\"\u003ert\u003c/span\u003e(df, [\u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e], \u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e, r1=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\no_rt.\u003cspan class=\"hljs-title function_\"\u003eplot_levels\u003c/span\u003e()\n\n# 도넛 트리맵\ndf = pd.\u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e(data)\no_rt = \u003cspan class=\"hljs-title function_\"\u003ert\u003c/span\u003e(df, [\u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e], \u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e)\no_rt.\u003cspan class=\"hljs-title function_\"\u003eplot_levels\u003c/span\u003e()\n\n# 트리맵\ndf = pd.\u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e(data)\no_rt = \u003cspan class=\"hljs-title function_\"\u003ert\u003c/span\u003e(df, [\u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e], \u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e, r1=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, r2=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n    a1=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, a2=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, rectangular=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\no_rt.\u003cspan class=\"hljs-title function_\"\u003eplot_levels\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_5.png\" alt=\"Bubble Chart (grid)\"\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e numpy \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e np\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pandas \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pd\n\n# \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e: 위에서 참조\n\ndf = pd.\u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e(data)\n\ndef \u003cspan class=\"hljs-title function_\"\u003egrid_bubbles\u003c/span\u003e(values, size_by=\u003cspan class=\"hljs-string\"\u003e'area'\u003c/span\u003e, rows=\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, cols=\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, buffer=\u003cspan class=\"hljs-number\"\u003e0.1\u003c/span\u003e):\n    fig, ax = plt.\u003cspan class=\"hljs-title function_\"\u003esubplots\u003c/span\u003e(rows, cols, figsize=(\u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1.5\u003c/span\u003e))\n    sorted_values = np.\u003cspan class=\"hljs-title function_\"\u003esort\u003c/span\u003e(values)[::-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e size_by == \u003cspan class=\"hljs-string\"\u003e'area'\u003c/span\u003e:\n        sizes = np.\u003cspan class=\"hljs-title function_\"\u003esqrt\u003c/span\u003e(sorted_values) # 반지름 입력 고려\n    elif size_by == \u003cspan class=\"hljs-string\"\u003e'diameter'\u003c/span\u003e:\n        sizes = sorted_values # 반지름에 비례\n    max_size = np.\u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e(sizes)\n    b = max_size*buffer\n    max_size += b\n    index = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(rows):\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e j \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(cols):\n            # \u003cspan class=\"hljs-title class_\"\u003eMatplotlib\u003c/span\u003e의 \u003cspan class=\"hljs-title class_\"\u003eCircle\u003c/span\u003e을 위한 반지름 입력\n            circle = plt.\u003cspan class=\"hljs-title class_\"\u003eCircle\u003c/span\u003e((\u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e), sizes[index]/max_size/\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\n                color=\u003cspan class=\"hljs-string\"\u003e'black'\u003c/span\u003e, fill=\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e, linewidth=\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\n            ax[i, j].\u003cspan class=\"hljs-title function_\"\u003eadd_artist\u003c/span\u003e(circle)\n            ax[i, j].\u003cspan class=\"hljs-title function_\"\u003eset_xlim\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n            ax[i, j].\u003cspan class=\"hljs-title function_\"\u003eset_ylim\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n            ax[i, j].\u003cspan class=\"hljs-title function_\"\u003eaxis\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'off'\u003c/span\u003e)\n            index += \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n    plt.\u003cspan class=\"hljs-title function_\"\u003etight_layout\u003c/span\u003e()\n    plt.\u003cspan class=\"hljs-title function_\"\u003eshow\u003c/span\u003e()\n\n\u003cspan class=\"hljs-title function_\"\u003egrid_bubbles\u003c/span\u003e(data[\u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e], size_by=\u003cspan class=\"hljs-string\"\u003e'area'\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003egrid_bubbles\u003c/span\u003e(data[\u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e], size_by=\u003cspan class=\"hljs-string\"\u003e'diameter'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_6.png\" alt=\"Bubble Chart (grid)\"\u003e\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e버블 차트 (내 새로운 Quad-Tile 차트 알고리즘을 사용하여 반 정렬)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e vizmath.\u003cspan class=\"hljs-property\"\u003equadtile_chart\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e polyquadtile \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pq\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pandas \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pd\n\n# 데이터: 위를 참조하세요\n\n# 면적에 따라 크기 조정\ndf = pd.\u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e(data)\ndf[\u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e] = df[\u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e]/df[\u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e()*\u003cspan class=\"hljs-number\"\u003e3.5\u003c/span\u003e\no_pq = \u003cspan class=\"hljs-title function_\"\u003epq\u003c/span\u003e(df,\u003cspan class=\"hljs-string\"\u003e'id'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e,buffer=\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e, collapse=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e,\n    constraints=[(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)], auto=\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e)\no_pq.\u003cspan class=\"hljs-title function_\"\u003epolyquadtile_plot\u003c/span\u003e(show_constraints=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e, poly_color=\u003cspan class=\"hljs-string\"\u003e'w'\u003c/span\u003e,\n    poly_line=\u003cspan class=\"hljs-string\"\u003e'black'\u003c/span\u003e, squares_off=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e, circles=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(o_pq.\u003cspan class=\"hljs-property\"\u003emultiplier\u003c/span\u003e)\n\n# 지름에 따라 크기 조정\ndf = pd.\u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e(data)\ndf[\u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e] = df[\u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e]**\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e # 지름 비율에 맞게 조정\ndf[\u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e] = df[\u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e]/df[\u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e()*\u003cspan class=\"hljs-number\"\u003e3.5\u003c/span\u003e\no_pq = \u003cspan class=\"hljs-title function_\"\u003epq\u003c/span\u003e(df,\u003cspan class=\"hljs-string\"\u003e'id'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e,buffer=\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e, collapse=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e,\n    constraints=[(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)], auto=\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e)\no_pq.\u003cspan class=\"hljs-title function_\"\u003epolyquadtile_plot\u003c/span\u003e(show_constraints=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e, poly_color=\u003cspan class=\"hljs-string\"\u003e'w'\u003c/span\u003e,\n    poly_line=\u003cspan class=\"hljs-string\"\u003e'black'\u003c/span\u003e, squares_off=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e, circles=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_7.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이러한 방법들은 값이 어떤 크기인지 직접적인 참조를 제공하는 축이 없어서 위치 변경 기능이 작동합니다. 따라서 값의 모양, 크기 및 레이아웃이 데이터 인사이트를 수집하는 데 중요합니다. 값 표현 간의 공간을 보존하는 방식으로 이러한 차트를 유용하게 만드는 파라미터 조정이 중요합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e숫자 축 기반 차트의 경우 멀리 떨어져 있는 값 모양을 나란히 보여줄 수 있지만, 축 없는 차트를 사용하면 값 모양을 옆으로 보여줄 수 있어요. 데이터와 사용 사례에 따라, 축 없는 방법의 시각화 압축은 축 기반 방법보다 상당한 장점이 될 수 있어요.\u003c/p\u003e\n\u003cp\u003e위의 버블 차트에서는 면적 및 지름별 크기 설정도 포함했어요. 크기 설정 메커니즘은 종종 간과될 수 있지만, 두 결과 간의 차이는 상당할 수 있어요! 데이터의 성겁과 시각화의 내러티브 맥락에 따라, 시각화 도구에서 크기 설정이 무엇을 기반으로 하는지 항상 알고 있으면, 정보에 기반한 선택을 할 수 있어요.\u003c/p\u003e\n\u003cp\u003e기본 케이스 (경쟁사)\u003c/p\u003e\n\u003cp\u003e위의 예시를 리뷰하면 버블 차트가 사용 가능한 공간을 보존하면서 비슷한 형태의 값 세트를 적절히 크기에 맞게 표현하는 우리의 초기 목표를 이루는 경쟁자임을 알 수 있어요.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e포장된 Bubble Chart(컨테이너)는 결과를 측정하기 위한 경쟁 상대가 될 것입니다. 그러나 아쉽게도 내가 찾은 구현 (아래에 표시됨)은 원형 레이아웃만 나타내므로 다른 컨테이너 모양을 탐색할 때 완벽한 비교 사례가 되지 않을 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# circlify\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e circlify\ncircles_circlify = circlify.\u003cspan class=\"hljs-title function_\"\u003ecirclify\u003c/span\u003e(data[\u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e], show_enclosure=\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e)\ncircles = [c \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e c \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e circles_circlify]\nmax_radius = \u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e(circle.\u003cspan class=\"hljs-property\"\u003er\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e circle \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e circles)\nxlim = \u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eabs\u003c/span\u003e(circle.\u003cspan class=\"hljs-property\"\u003ex\u003c/span\u003e) + max_radius \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e circle \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e circles)\nylim = \u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eabs\u003c/span\u003e(circle.\u003cspan class=\"hljs-property\"\u003ey\u003c/span\u003e) + max_radius \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e circle \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e circles)\nlimit = \u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e(xlim, ylim)\nfig, axs = plt.\u003cspan class=\"hljs-title function_\"\u003esubplots\u003c/span\u003e(figsize=(\u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e))\naxs.\u003cspan class=\"hljs-title function_\"\u003eaxis\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'off'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003exlim\u003c/span\u003e(-limit, limit)\nplt.\u003cspan class=\"hljs-title function_\"\u003eylim\u003c/span\u003e(-limit, limit)\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e circle \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecircles\u003c/span\u003e:\n    axs.\u003cspan class=\"hljs-title function_\"\u003eadd_patch\u003c/span\u003e(plt.\u003cspan class=\"hljs-title class_\"\u003eCircle\u003c/span\u003e((circle.\u003cspan class=\"hljs-property\"\u003ex\u003c/span\u003e, circle.\u003cspan class=\"hljs-property\"\u003ey\u003c/span\u003e), circle.\u003cspan class=\"hljs-property\"\u003er\u003c/span\u003e,\n        edgecolor=\u003cspan class=\"hljs-string\"\u003e'black'\u003c/span\u003e, facecolor=\u003cspan class=\"hljs-string\"\u003e'white'\u003c/span\u003e, linewidth=\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e))\nplt.\u003cspan class=\"hljs-title function_\"\u003eshow\u003c/span\u003e()\n\n# packcircles\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e packcircles\ncircles_packcircles = packcircles.\u003cspan class=\"hljs-title function_\"\u003epack\u003c/span\u003e(data[\u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e])\ncircles = [c \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e c \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e circles_packcircles]\n# circles\nmax_radius = \u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e(radius \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (_, _, radius) \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e circles)\nxlim = \u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eabs\u003c/span\u003e(x) + max_radius \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (x, _, _) \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e circles)\nylim = \u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eabs\u003c/span\u003e(y) + max_radius \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (_, y, _) \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e circles)\nlimit = \u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e(xlim, ylim)\nfig, axs = plt.\u003cspan class=\"hljs-title function_\"\u003esubplots\u003c/span\u003e(figsize=(\u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e))\naxs.\u003cspan class=\"hljs-title function_\"\u003eaxis\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'off'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003exlim\u003c/span\u003e(-limit, limit)\nplt.\u003cspan class=\"hljs-title function_\"\u003eylim\u003c/span\u003e(-limit, limit)\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (x, y, radius) \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecircles\u003c/span\u003e:\n    axs.\u003cspan class=\"hljs-title function_\"\u003eadd_patch\u003c/span\u003e(plt.\u003cspan class=\"hljs-title class_\"\u003eCircle\u003c/span\u003e((x, y), radius,\n        edgecolor=\u003cspan class=\"hljs-string\"\u003e'black'\u003c/span\u003e, facecolor=\u003cspan class=\"hljs-string\"\u003e'white'\u003c/span\u003e, linewidth=\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e))\nplt.\u003cspan class=\"hljs-title function_\"\u003eshow\u003c/span\u003e()\n\n# \u003cspan class=\"hljs-title class_\"\u003eTableau\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePublic\u003c/span\u003e:\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pandas \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pd\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e os\ndf = pd.\u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e(data)\ndf.\u003cspan class=\"hljs-title function_\"\u003eto_csv\u003c/span\u003e(os.\u003cspan class=\"hljs-property\"\u003epath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edirname\u003c/span\u003e(__file__) + \u003cspan class=\"hljs-string\"\u003e'/circles.csv'\u003c/span\u003e,\n    encoding=\u003cspan class=\"hljs-string\"\u003e'utf-8'\u003c/span\u003e, index=\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e)\n# select packed bubbles -\u003e \u003cspan class=\"hljs-title class_\"\u003eSize\u003c/span\u003e by [\u003cspan class=\"hljs-title class_\"\u003eSpeed\u003c/span\u003e], [\u003cspan class=\"hljs-title class_\"\u003eId\u003c/span\u003e] on \u003cspan class=\"hljs-title class_\"\u003eDetail\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_8.png\"\u003e\n\u003cp\u003e경쟁 상대를 선택했으니 이제 포장된 Bubble Chart가 홀로 서 있는지 또는 컨테이너 포장 목표를 충족하는 상대적 가치 비교를 위해 활용할 수 있는 다른 단순한 모양이 있는지 살펴보겠습니다. 이제 정사각형의 응용을 탐색해 보겠습니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e왜 Squarify를 사용해야 할까요?\u003c/h2\u003e\n\u003cp\u003e이미 패킹된 원들을 조사하는 무대를 마련했으니, 짧게 쉬어가며 질문을 해보는 게 좋을 것 같아요. 패킹된 원들이 존재하는데 왜 사각형에 관심을 가질까요?\u003c/p\u003e\n\u003cp\u003e데이터 시각화에서 이미 패킹된 원들이 널리 사용되고 있으므로 사람들은 원을 좋아하는 것으로 보입니다. 다양한 패킹된 버블 차트 구현은 다양한 프로그래밍 언어 및 소프트웨어에서 쉽게 찾을 수 있어요. 사실, Quad-Tile 차트를 만든 후 가장 먼저 한 일은 동그라미를 그리는 데 사용했어요 (소개 부분에 나와 있음). 그래서 동그라미의 매력은 실재해요!\u003c/p\u003e\n\u003cp\u003e하지만 사각형은 어떨까요? 다른 가능한 모양들과 비교했을 때 패킹된 사각형은 상대적으로 무해해 보이지만, 확실한 패킹된 사각형 차트 구현을 찾는 것은 어렵습니다. 왜 그럴까요...\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e간단한 비교를 하고 어떤 것을 발견해 봅시다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_9.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e위의 경우 1:2 비율을 사용하여 넓이나 길이를 비교하는 데 둥근 모양이나 사각형 모두 다른 것보다 직관성을 제공하지 않는 것으로 보입니다. 하지만 원은 더 부드럽고 사각형은 더 날카로운 것 같아요.\u003c/p\u003e\n\u003cp\u003e그렇다면, 나는 스퀘어리파이를 하는 이유가 다음과 같습니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e패킹된 사각형 구현은 존재하지 않는 것 같아서 시각적으로 얼마나 매력적인지 알기가 어렵습니다(패킹된 원의 대체물로). 따라서 조사할 가치가 있습니다.\u003c/li\u003e\n\u003cli\u003e파이썬의 사용 가능한 패킹된 원 구현물에서는 컨테이너를 활용할 수 있는 능력이 일반적으로 부족합니다(모두 원의 수가 증가함에 따라 원형 레이아웃만 제공하는 것으로 보입니다).\u003c/li\u003e\n\u003cli\u003e사각형의 단순성은 알고리즘을 통해 사각형을 채우려고 시도하면 수학적 연산이 직관적일 것으로 보입니다. 따라서 빠른 개념 증명이 가능할 수도 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e스퀘어화를 추구하는 동기를 제시했으니, 이제 사각형 패킹 노력의 핵심 구성 요소인 패킹을 살펴보고, 사각형이 원에 어떻게 대응하는지 확인해봅시다.\u003c/p\u003e\n\u003ch1\u003e모양 패킹 \u0026#x26; 컨테이너 패킹\u003c/h1\u003e\n\u003ch2\u003e타일링과 함께\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e수사 목적으로 명백한 것을 언급할 가치가 있습니다. 사각형은 가장을 가지고 있지만 원은 그렇지 않습니다. 이 특성은 유사한 크기의 사각형들을 테셀레이션할 수 있게 해주어, 패킹이라는 유용한 개념이 될 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e matplotlib.\u003cspan class=\"hljs-property\"\u003epyplot\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e plt\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e matplotlib.\u003cspan class=\"hljs-property\"\u003epatches\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e patches\n\n# 도형과 공간을 사용하여 다이아몬드 테셀레이션 모의실험을 해봅시다.\ndef \u003cspan class=\"hljs-title function_\"\u003ediamond_tessellation\u003c/span\u003e(rows, cols):\n    fig, ax = plt.\u003cspan class=\"hljs-title function_\"\u003esubplots\u003c/span\u003e()\n    ax.\u003cspan class=\"hljs-title function_\"\u003eset_aspect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'equal'\u003c/span\u003e, adjustable=\u003cspan class=\"hljs-string\"\u003e'box'\u003c/span\u003e)\n    plt.\u003cspan class=\"hljs-title function_\"\u003eaxis\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'off'\u003c/span\u003e)\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e row \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(rows):\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e col \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(cols):\n            diamond = patches.\u003cspan class=\"hljs-title class_\"\u003ePolygon\u003c/span\u003e([\n                (col + \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e, row), \n                (col + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, row + \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e), \n                (col + \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e, row + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e), \n                (col, row + \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e)\n                ], edgecolor=\u003cspan class=\"hljs-string\"\u003e'grey'\u003c/span\u003e, facecolor=\u003cspan class=\"hljs-string\"\u003e'whitesmoke'\u003c/span\u003e)\n            ax.\u003cspan class=\"hljs-title function_\"\u003eadd_patch\u003c/span\u003e(diamond)\n    ax.\u003cspan class=\"hljs-title function_\"\u003eset_xlim\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, cols)\n    ax.\u003cspan class=\"hljs-title function_\"\u003eset_ylim\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, rows)\n    plt.\u003cspan class=\"hljs-title function_\"\u003eshow\u003c/span\u003e()\n\n\u003cspan class=\"hljs-title function_\"\u003ediamond_tessellation\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_10.png\"\u003e\n\u003cp\u003e유감스럽게도, 테셀레이션은 데이터셋의 값이 동일하거나 편리한 비율을 가지는 것으로 가정하는 것이 현실적이지 않기 때문에 일반적인 해결책은 아닙니다. 그러나 간격이 없는 가장의 개념은 원보다 잠재적인 이점으로 더 탐구할 가치가 있습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e최적화로\u003c/h2\u003e\n\u003cp\u003e최적화 방법은 두 개의 모양을 비교하는 메커니즘으로 다음 단계로 가치 있는 것처럼 보입니다. 그래서 원과 정사각형 사이에 가능한 균일하게 적용할 수 있는 간단한 목적 함수에 집중하여 결과를 검토해 봅시다.\u003c/p\u003e\n\u003cp\u003e먼저, 목적 함수의 요소를 식별해야 합니다. 우리는 모양의 중첩을 방지하는 메커니즘과 밀접하게 패킹하려는 반대 힘이 필요합니다. 각각을 자세히 살펴보겠습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e중첩 방지 (밀어내기) - 중첩을 방지하기 위해 모양들의 총 중첩 영역을 고려하고, 다른 모양에 완전히 포함되는 모양에 대해 추가 벌칙을 부과하여 작은 모양의 중첩 방지를 촉진합니다.\u003c/li\u003e\n\u003cli\u003e패킹 촉진 (가까이 끌어모으기) - 패킹을 촉진하기 위해 모양을 특정 관심 지점으로 끌어당기는 것을 보상할 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e지금은 컨테이너를 무시하고 도형 패킹에 초점을 맞춰 각 도형의 기하학적 특징을 살펴봅시다. 이제 식별된 재료로 구현할 함수를 설정해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e shapely.\u003cspan class=\"hljs-property\"\u003egeometry\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePoint\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003ePolygon\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e shapely.\u003cspan class=\"hljs-property\"\u003eops\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e unary_union\n\n# 셰이프의 중심에서 관심 지점까지의 거리를 더하여 당김 힘을 설정합시다\ndef \u003cspan class=\"hljs-title function_\"\u003ecalc_distance_from_point\u003c/span\u003e(shapes, shape_type, origin):\n    penalty = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n    ref_point = \u003cspan class=\"hljs-title class_\"\u003ePoint\u003c/span\u003e(origin)\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e shape_type == \u003cspan class=\"hljs-string\"\u003e'circle'\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e x, y, _ \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eshapes\u003c/span\u003e:\n            centroid = \u003cspan class=\"hljs-title class_\"\u003ePoint\u003c/span\u003e(x, y)\n            penalty += centroid.\u003cspan class=\"hljs-title function_\"\u003edistance\u003c/span\u003e(ref_point)\n    elif shape_type == \u003cspan class=\"hljs-string\"\u003e'square'\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e x, y, side \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eshapes\u003c/span\u003e:\n            centroid = \u003cspan class=\"hljs-title class_\"\u003ePolygon\u003c/span\u003e([(x, y), (x + side, y),\n                (x + side, y + side), (x, y + side)]).\u003cspan class=\"hljs-property\"\u003ecentroid\u003c/span\u003e\n            penalty += centroid.\u003cspan class=\"hljs-title function_\"\u003edistance\u003c/span\u003e(ref_point)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e penalty\n\n# 이제 첫 번째 당김 힘을 설정하여 한 도형이 다른 도형 안에 포함되어 있는지 여부를 파악하고 발생 횟수를 더합시다\ndef \u003cspan class=\"hljs-title function_\"\u003ecalc_containment\u003c/span\u003e(shapes, shape_type):\n    penalty = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n    shapely_shapes = []\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e shape_type == \u003cspan class=\"hljs-string\"\u003e'circle'\u003c/span\u003e:\n        shapely_shapes = [\u003cspan class=\"hljs-title class_\"\u003ePoint\u003c/span\u003e(x, y).\u003cspan class=\"hljs-title function_\"\u003ebuffer\u003c/span\u003e(r) \n            \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e x, y, r \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e shapes]\n    elif shape_type == \u003cspan class=\"hljs-string\"\u003e'square'\u003c/span\u003e:\n        shapely_shapes = [\u003cspan class=\"hljs-title class_\"\u003ePolygon\u003c/span\u003e([(x, y), (x + side, y),\n            (x + side, y + side), (x, y + side)]) \n            \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e x, y, side \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e shapes]\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i, shape1 \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eenumerate\u003c/span\u003e(shapely_shapes):\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e j, shape2 \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eenumerate\u003c/span\u003e(shapely_shapes):\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e i != j and shape1.\u003cspan class=\"hljs-title function_\"\u003econtains\u003c/span\u003e(shape2):\n                penalty += \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e penalty\n\n# 당김 힘을 완성하기 위해 전체 도형 중첩 영역을 계산합시다\ndef \u003cspan class=\"hljs-title function_\"\u003ecalc_overlap_area\u003c/span\u003e(shapes, shape_type):\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e shape_type == \u003cspan class=\"hljs-string\"\u003e'circle'\u003c/span\u003e:\n        shapely_shapes = [\u003cspan class=\"hljs-title class_\"\u003ePoint\u003c/span\u003e(s[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e], s[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]).\u003cspan class=\"hljs-title function_\"\u003ebuffer\u003c/span\u003e(s[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e]) \n            \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e s \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e shapes]\n    elif shape_type == \u003cspan class=\"hljs-string\"\u003e'square'\u003c/span\u003e:\n        shapely_shapes = [\u003cspan class=\"hljs-title class_\"\u003ePolygon\u003c/span\u003e([(s[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e], s[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]), (s[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] + s[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e], s[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]), \n            (s[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] + s[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e], s[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] + s[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e]), (s[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e], s[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] + s[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e])]) \n            \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e s \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e shapes]\n    merged_area = \u003cspan class=\"hljs-title function_\"\u003eunary_union\u003c/span\u003e(shapely_shapes).\u003cspan class=\"hljs-property\"\u003earea\u003c/span\u003e\n    individual_areas = \u003cspan class=\"hljs-title function_\"\u003esum\u003c/span\u003e(shape.\u003cspan class=\"hljs-property\"\u003earea\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e shape \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e shapely_shapes)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eabs\u003c/span\u003e(individual_areas - merged_area)\n\n# 마지막으로, 힘을 종합하여 목적 함수로 만들어봅시다\ndef \u003cspan class=\"hljs-title function_\"\u003eobjective_function\u003c/span\u003e(variables, shapes, shape_type, \n    origin=(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e), prevent_overlap_factor=\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i, shape \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eenumerate\u003c/span\u003e(shapes):\n        shapes[i] = (variables[i*\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e], variables[i*\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e], shape[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e])\n    overlap_area = \u003cspan class=\"hljs-title function_\"\u003ecalc_overlap_area\u003c/span\u003e(shapes, shape_type)\n    contained = \u003cspan class=\"hljs-title function_\"\u003ecalc_containment\u003c/span\u003e(shapes, shape_type)\n    sum_distance = \u003cspan class=\"hljs-title function_\"\u003ecalc_distance_from_point\u003c/span\u003e(shapes, shape_type, origin)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e overlap_area * prevent_overlap_factor * (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e + contained) + sum_distance\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e목적 함수에서는 도형의 겹치는 영역을 포함하는 모양의 수와 곱하여 당김 패널티를 집중시키기로 선택했습니다. 그리고 당김 정도를 조절하는 'prevent_overlap_factor' 가중치를 추가했습니다.\u003c/p\u003e\n\u003cp\u003e이제 목적 함수가 준비되었으니, 이전의 예제 데이터를 사용하여 원과 사각형 패킹 최적화 루틴을 설정해 봅시다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 이전 예시 데이터:\r\ndata = {\r\n    \u003cspan class=\"hljs-string\"\u003e'id'\u003c/span\u003e : [\u003cspan class=\"hljs-title function_\"\u003estr\u003c/span\u003e(i) \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e21\u003c/span\u003e)],\r\n    \u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e : [\u003cspan class=\"hljs-number\"\u003e242\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e105\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e95\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e92.5\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e88\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e80\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e79\u003c/span\u003e,\r\n        \u003cspan class=\"hljs-number\"\u003e75\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e67.85\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e61.06\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e56\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e55\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e55\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e55\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e]\r\n}\r\n\r\n# 원하는 크기 창(\u003cspan class=\"hljs-title class_\"\u003eWindow\u003c/span\u003e) (계수)와 모양의 반복 가능한 랜덤 위치를 위한 시드를 설정해봅시다.\r\n\r\n계수 = \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e\r\n시드 = \u003cspan class=\"hljs-number\"\u003e123\u003c/span\u003e\r\n\r\n최대속도 = np.\u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e(data[\u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e])\r\nnp.\u003cspan class=\"hljs-property\"\u003erandom\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eseed\u003c/span\u003e(시드)\r\n\r\n모양들 = [(np.\u003cspan class=\"hljs-property\"\u003erandom\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003euniform\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, 계수*\u003cspan class=\"hljs-number\"\u003e1.5\u003c/span\u003e),\r\n    np.\u003cspan class=\"hljs-property\"\u003erandom\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003euniform\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, 계수*\u003cspan class=\"hljs-number\"\u003e1.5\u003c/span\u003e),\r\n    v/최대속도*계수) \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e v \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e data[\u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e]]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제, 원과 사각형의 입력을 분리하고 최적화 메서드에 전달할 경계를 추가해봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e numpy \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e np\r\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e copy\r\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e math \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e sqrt\r\n\r\n# 각 모양에 대해 최적화하기 위해 복사본을 만듭시다.\r\n원들 = copy.\u003cspan class=\"hljs-title function_\"\u003edeepcopy\u003c/span\u003e(모양들)\r\n사각형들 = copy.\u003cspan class=\"hljs-title function_\"\u003edeepcopy\u003c/span\u003e(모양들)\r\n\r\n# 위치를 최적화하기 위해 좌표를 평면으로 펼쳐봅시다\r\n초기_위치 = [val \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e s \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e 모양들 \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e val \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e s[:\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e]]\r\n\r\n# 이제 각 모양의 경계를 계산하여 최적화 함수에 전달합시다\r\ndef \u003cspan class=\"hljs-title function_\"\u003ecalc_bounds\u003c/span\u003e(모양들, 모양_유형):\r\n    총_면적 = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\r\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e 모양_유형 == \u003cspan class=\"hljs-string\"\u003e'원'\u003c/span\u003e:\r\n        총_면적 = \u003cspan class=\"hljs-title function_\"\u003esum\u003c/span\u003e(np.\u003cspan class=\"hljs-property\"\u003epi\u003c/span\u003e * (r**\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e _, _, r \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e 모양들)\r\n    elif 모양_유형 == \u003cspan class=\"hljs-string\"\u003e'사각형'\u003c/span\u003e:\r\n        총_면적 = \u003cspan class=\"hljs-title function_\"\u003esum\u003c/span\u003e(side**\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e _, _, side \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e 모양들)\r\n    추정된_한변의_길이 = \u003cspan class=\"hljs-title function_\"\u003esqrt\u003c/span\u003e(총_면적)\r\n    패딩 = 추정된_한변의_길이 / \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\r\n    하한 = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e - 패딩\r\n    상한 = 추정된_한변의_길이 + 패딩\r\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (하한, 상한)\r\n\r\n# 원과 사각형에 대한 경계 계산\r\n원의_경계 = \u003cspan class=\"hljs-title function_\"\u003ecalc_bounds\u003c/span\u003e(원들, \u003cspan class=\"hljs-string\"\u003e'원'\u003c/span\u003e)\r\n사각형의_경계 = \u003cspan class=\"hljs-title function_\"\u003ecalc_bounds\u003c/span\u003e(사각형들, \u003cspan class=\"hljs-string\"\u003e'사각형'\u003c/span\u003e)\r\n\r\n# 각 모양에 경계를 적용하여 최적화하기\r\n원_경계들 = [(원의_경계[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e], 원의_경계[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]) \r\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e _ \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(초기_위치))]\r\n사각형_경계들 = [(사각형의_경계[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e], 사각형의_경계[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e])\r\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e _ \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(초기_위치))]\r\n\r\n# 풀 힘을 위한 접힘점을 설정하기 위해 경계를 사용\r\n원의_접힘점 = (원의_경계[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]-원의_경계[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e])/\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e+원의_경계[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]\r\n사각형의_접힘점 = (사각형의_경계[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]-사각형의_경계[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e])/\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e+사각형의_경계[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]\r\n원의_접힘점들 = (원의_접힘점, 원의_접힘점)\r\n사각형의_접힘점들 = (사각형의_접힘점, 사각형의_접힘점)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e마지막으로, 결과를 시각화하기 위한 플로팅 함수를 설정하고 각 모양에 대해 최적화를 실행해보겠습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e matplotlib.\u003cspan class=\"hljs-property\"\u003epyplot\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e plt\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e matplotlib.\u003cspan class=\"hljs-property\"\u003epatches\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e patches\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e math \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e inf\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e scipy.\u003cspan class=\"hljs-property\"\u003eoptimize\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e minimize\n\n# 결과를 확인할 수 있는 plotting 함수를 만들어봅시다.\ndef \u003cspan class=\"hljs-title function_\"\u003eplot_shapes\u003c/span\u003e(shapes, shape_type):\n    fig, ax = plt.\u003cspan class=\"hljs-title function_\"\u003esubplots\u003c/span\u003e()\n    min_x, min_y, max_x, max_y = \u003cspan class=\"hljs-number\"\u003e0.\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e0.\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e0.\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e0.\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e s \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eshapes\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e shape_type == \u003cspan class=\"hljs-string\"\u003e'circle'\u003c/span\u003e:\n            circle = patches.\u003cspan class=\"hljs-title class_\"\u003eCircle\u003c/span\u003e((s[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e], s[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]), s[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e],\n                facecolor=\u003cspan class=\"hljs-string\"\u003e'lightgrey'\u003c/span\u003e, edgecolor=\u003cspan class=\"hljs-string\"\u003e'black'\u003c/span\u003e)\n            ax.\u003cspan class=\"hljs-title function_\"\u003eadd_patch\u003c/span\u003e(circle)\n            min_x = \u003cspan class=\"hljs-title function_\"\u003emin\u003c/span\u003e(min_x, s[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] - s[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e])\n            min_y = \u003cspan class=\"hljs-title function_\"\u003emin\u003c/span\u003e(min_y, s[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] - s[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e])\n            max_x = \u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e(max_x, s[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] + s[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e])\n            max_y = \u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e(max_y, s[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] + s[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e])\n        elif shape_type == \u003cspan class=\"hljs-string\"\u003e'square'\u003c/span\u003e:\n            square = patches.\u003cspan class=\"hljs-title class_\"\u003eRectangle\u003c/span\u003e((s[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e], s[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]), s[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e], s[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e],\n                facecolor=\u003cspan class=\"hljs-string\"\u003e'lightgrey'\u003c/span\u003e, edgecolor=\u003cspan class=\"hljs-string\"\u003e'black'\u003c/span\u003e)\n            ax.\u003cspan class=\"hljs-title function_\"\u003eadd_patch\u003c/span\u003e(square)\n            min_x = \u003cspan class=\"hljs-title function_\"\u003emin\u003c/span\u003e(min_x, s[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e])\n            min_y = \u003cspan class=\"hljs-title function_\"\u003emin\u003c/span\u003e(min_y, s[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e])\n            max_x = \u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e(max_x, s[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] + s[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e])\n            max_y = \u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e(max_y, s[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] + s[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e])\n    padding = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n    ax.\u003cspan class=\"hljs-title function_\"\u003eset_xlim\u003c/span\u003e(min_x - padding, max_x + padding)\n    ax.\u003cspan class=\"hljs-title function_\"\u003eset_ylim\u003c/span\u003e(min_y - padding, max_y + padding)\n    ax.\u003cspan class=\"hljs-title function_\"\u003eset_aspect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'equal'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'box'\u003c/span\u003e)\n    plt.\u003cspan class=\"hljs-title function_\"\u003eshow\u003c/span\u003e()\n\n# 마지막으로 반복을 모니터링하는 콜백 함수를 설정해봅시다.\ndef \u003cspan class=\"hljs-title function_\"\u003ecallback\u003c/span\u003e(i):\n    \u003cspan class=\"hljs-variable language_\"\u003eglobal\u003c/span\u003e iteration\n    iteration += \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e'반복 {iteration}'\u003c/span\u003e)\n\n# 원 최적화 실행:\niteration = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\noptimized_circles = \u003cspan class=\"hljs-title function_\"\u003eminimize\u003c/span\u003e(objective_function, initial_positions,\n    args=(circles, \u003cspan class=\"hljs-string\"\u003e'circle'\u003c/span\u003e, origin_circles), method=\u003cspan class=\"hljs-string\"\u003e'L-BFGS-B'\u003c/span\u003e,\n    bounds=bounds_circles, callback=callback,\n    options={\u003cspan class=\"hljs-string\"\u003e'maxiter'\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e300\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'maxfun'\u003c/span\u003e: inf, \u003cspan class=\"hljs-string\"\u003e'ftol'\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'gtol'\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e})\npacked_circles = [(optimized_circles.\u003cspan class=\"hljs-property\"\u003ex\u003c/span\u003e[i*\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e],\n    optimized_circles.\u003cspan class=\"hljs-property\"\u003ex\u003c/span\u003e[i*\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e], circles[i][\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e])\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(circles))]\n# \u003cspan class=\"hljs-title function_\"\u003eplot_shapes\u003c/span\u003e(shapes, \u003cspan class=\"hljs-string\"\u003e'circle'\u003c/span\u003e) # 초기 위치를 보려면 주석 해제\n\u003cspan class=\"hljs-title function_\"\u003eplot_shapes\u003c/span\u003e(packed_circles, \u003cspan class=\"hljs-string\"\u003e'circle'\u003c/span\u003e)\n\n# 사각형 최적화 실행:\niteration = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\noptimized_squares = \u003cspan class=\"hljs-title function_\"\u003eminimize\u003c/span\u003e(objective_function, initial_positions,\n    args=(squares, \u003cspan class=\"hljs-string\"\u003e'square'\u003c/span\u003e, origin_squares), method=\u003cspan class=\"hljs-string\"\u003e'L-BFGS-B'\u003c/span\u003e,\n    bounds=bounds_squares, callback=callback,\n    options={\u003cspan class=\"hljs-string\"\u003e'maxiter'\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e300\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'maxfun'\u003c/span\u003e: inf, \u003cspan class=\"hljs-string\"\u003e'ftol'\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'gtol'\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e})\npacked_squares = [(optimized_squares.\u003cspan class=\"hljs-property\"\u003ex\u003c/span\u003e[i*\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e],\n    optimized_squares.\u003cspan class=\"hljs-property\"\u003ex\u003c/span\u003e[i*\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e], squares[i][\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e])\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(squares))]\n# \u003cspan class=\"hljs-title function_\"\u003eplot_shapes\u003c/span\u003e(shapes, \u003cspan class=\"hljs-string\"\u003e'square'\u003c/span\u003e) # 초기 위치를 보려면 주석 해제\n\u003cspan class=\"hljs-title function_\"\u003eplot_shapes\u003c/span\u003e(packed_squares, \u003cspan class=\"hljs-string\"\u003e'square'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드에서는 'L-BFGS-B' 메서드를 선택하여 scipy의 'minimize' 함수에서 반복 횟수를 300으로 설정했습니다. 초기 위치를 제어하는 난수 시드는 결과에 영향을 미칠 수 있으므로 두 모양에 대해 각각 3가지 다른 시드를 살펴봅시다.\u003c/p\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_11.png\"\u003e\n\u003cp\u003e각 테스트 케이스를 생성하는 데 랩톱에서 약 5분이 걸렸으므로, 이 방법의 시간 요구 사항은 고려해야 할 불안정한 요소입니다. 이미 긴 대기 시간 때문에 컨테이너 중첩 비용을 목적 함수에 추가하여 컨테이너 패킹 통찰을 검토하는 것은 현재 필요하지 않은 것으로 보입니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e지면 배치 관련해서 원들이 더 조밀하게 배열되어 있는 것 같습니다. 이것이 데이터 시각화에서 패킹된 원이 패킹된 정사각형보다 흔한 이유를 설명하는 첫 번째 증거가 될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e하지만 포기하기 전에, 정사각형에 맞춤화된 알고리즘을 사용한 최종 평가로 넘어가 봅시다!\u003c/p\u003e\n\u003ch2\u003e알고리즘을 통해\u003c/h2\u003e\n\u003cp\u003e위의 실험에서 얻은 주요 결론은:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e일반 최적화 구현을 사용하여 단순 목적 함수에 따라 패킹된 모양을 생성하는 것은 어느 정도 작동하는 것 같아요.\u003c/li\u003e\n\u003cli\u003e그러나 이것은 정말 느리고 대규모 데이터셋을 처리하기에 부적합하죠.\u003c/li\u003e\n\u003cli\u003e원형 배열들이 (적어도 컨테이너 패킹 없이는) 사각형 배열보다 더 융합되어 보였어요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e우리는 대규모 데이터셋에서 성능이 우수하며 더 매력적인 사각형 배열을 생성할 수 있고, 컨테이너 패킹을 구현할 수 있는 특수화된 알고리즘이 필요하다는 것이 분명해요. 이 방식을 일반적인 최적화 프레임워크와 구분짓기 위해 사각형의 특정 특성을 활용하고, 포장 기회를 탐색할 필요가 있어요.\u003c/p\u003e\n\u003cp\u003e우리가 활용할 수 있는 사각형의 몇 가지 기하학적 요소를 나열하여 시작해봐요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e형태: 네 개의 직각을 감싸고 있는 같은 길이의 네 변을 가지며, 화면을 기준으로 회전할 수 있어 다른 외형이 될 수 있는\u003c/li\u003e\n\u003cli\u003e패킹: 간격 없이 사각형 사이에 이웃할 수 있는 능력\u003c/li\u003e\n\u003cli\u003e배치: 각 사각형의 각 변은 4개의 가능한 꼭지점 중 하나에서 시작하여 이웃할 사각형에게 이웃할 수 있는 평면적인 2차원 공간을 무한대로 제공함\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e다음에는 패킹된 사각형이 패킹된 원과 어떻게 경쟁할 수 있는지 이해하기 위해 Quad-Tile 차트라는 새로운 시각화 기술에 사용되는 알고리즘을 설명할 것입니다.\u003c/p\u003e\n\u003ch2\u003eQuad-Tile 차트\u003c/h2\u003e\n\u003ch3\u003e영감\u003c/h3\u003e\n\u003cp\u003e몇 년 전 어떤 사람이 패킹된 버블 차트는 대부분 쓸모없다고 말했습니다. 무슨 이유에서인지 그 말이 나에게 영감을 주어 패킹된 사각형 차트를 만들게 되었습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e첫 번째 버전을 개발하고 Tableau Public 시각화와 몇 가지 다른 기술과 함께 구체화된 결과물을 시험해 보았어요. 여기에는 18개의 사각형을 포함하는 Voronoi Treemaps가 있는 (v1) Quad-Tile Chart가 표시된 발췌본이 있어요. (Voronoi Treemaps는 D3.js를 사용하여 계산되었어요).\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_12.png\" alt=\"Quad-Tile Chart\"\u003e\u003c/p\u003e\n\u003cp\u003e아래에서는 이 알고리즘에 대해 설명하고, 몇 일 전에 다시 시작했을 때 최종적으로 채택한 방식을 설명할게요.\u003c/p\u003e\n\u003ch2\u003e(초기) 알고리즘 v1\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e내 초기 접근 방식인 2022년 초에는 컨테이너를 고려하지 않았습니다. 가장 큰 정사각형부터 시작하여 중앙에 배치한 후 모든 정사각형이 중심 정사각형 주변에 감싸지도록 연속적으로 나열하려고 노력했습니다. 가장 작은 정사각형은 가장 중심부터 먼 위치에 배치되었습니다.\u003c/p\u003e\n\u003cp\u003e마디 있는 정사각형 배열에 관해 스케치한 후에 나에게 온 개념 중에는 다음과 같은 것들이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e사분면 - 조사한 결과, 정사각형은 연속적인 사각형들을 분산하기 위한 4개의 오프셋 평면을 제공합니다.\u003c/li\u003e\n\u003cli\u003e자기 조직화 정사각형 배치 - 한 평면의 잠재적 너비와 오프셋 평면의 차지된 높이를 연관시킴으로써 자기 조직화를 가능케하도록 하며, 이는 공유 경계(분할된 세그먼트로 실행됨)를 구현함으로써 이루어집니다.\u003c/li\u003e\n\u003cli\u003e측면 전환 - 크기에 따라 정사각형들을 고르게 분산하기 위해, 원하는 순서로 하나를 배치한 후 측면을 전환합니다. (나는 기본적으로 윗쪽-오른쪽-아래쪽-왼쪽으로 전환했습니다.)\u003c/li\u003e\n\u003cli\u003e사용자 정의 - 이 방법은 값 정렬을 배제하지만, 일련의 규칙에 따라 다음 측면을 선택할 수 있는 기능을 구현할 수 있는 능력을 제공합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_13.png\"\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003ev1 알고리즘은 다음과 같아요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e먼저 양수 값들로 이루어진 집합부터 내림차순으로 정렬해요. 예를 들어, 9.4, 7.4, 1.5, 0.2\u003c/li\u003e\n\u003cli\u003e값을 패딩하기 위해 각 사각형 주변의 공간을 추가한 후 (예를 들어 0.5)\u003c/li\u003e\n\u003cli\u003e첫번째 (가장 큰) 사각형을 설정하고, 중앙 사각형 주변의 각 사분면을 위한 세그먼트 저장 메커니즘을 생성해요.\u003c/li\u003e\n\u003cli\u003e초기 세그먼트를 중앙 사각형의 변으로 설정하고, 각 사분면에 하나씩 배정해요.\u003c/li\u003e\n\u003cli\u003e옆면 순서 (기본값은 위, 오른쪽, 아래, 왼쪽)가 주어지면, 각 면을 반복하면서 작은 사각형을 배치해요. 각 사분면의 첫 번째 사각형은 해당 사분면 평면의 원점과 정렬되어, 해당 사분면의 초기 세그먼트 시작 위치에서 시작해요.\u003c/li\u003e\n\u003cli\u003e위쪽 면에 사각형을 배치하려면 (정렬 및 배치 요구 사항을 고려하여), 세그먼트를 가장 짧은 y값별로 정렬하고 가장 긴 길이를 가지는 세그먼트에서, 사각형의 너비 ≤ 세그먼트 길이인 첫 번째 세그먼트에 사각형을 배치해요.\u003c/li\u003e\n\u003cli\u003e사각형을 배치하면, 해당 사각형이 차지한 공간을 세그먼트에서 조절하여 세그먼트의 시작 위치 및 길이를 조정하고, 새로운 세그먼트를 만들어요.\u003c/li\u003e\n\u003cli\u003e배치된 사각형의 시작 위치가 사분면 평면의 오프셋 경계와 정렬되면 (중앙 사각형의 축에 수직인 경계), 중앙 사각형 주변의 자기 조직화 성장을 가능하게 하기 위해 영향을 받는 세그먼트의 세그먼트 길이를 연장해요.\u003c/li\u003e\n\u003cli\u003e원하는 스택 구성을 위해 필요한 측 선택 메커니즘을 구현해요.\u003c/li\u003e\n\u003cli\u003e사각형을 버퍼로 다시 원래 크기로 바꾸고, 원하는 회전으로 사각형을 회전시켜요 (기본값은 45도).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e아래 다이어그램은 세그먼트 기반 접근 방법을 보여줘요. 각 세그먼트는 다음과 같이 될 거에요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e원래 위치에서 한 방향으로 효과적으로 이동시켜져요 (사각형의 너비가 세그먼트 길이와 같은 경우)\u003c/li\u003e\n\u003cli\u003e두 섹션으로 분할돼요 (하나는 배치된 사각형의 너비를 따르고, 다른 하나는 시작 위치와 길이가 변경된 원래 세그먼트일거에요).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_14.png\"\u003e\n\u003cp\u003e재미로, 몇 가지 측면 선택 옵션을 구현했는데 'constraints' 입력란은 다각형을 받아들이고 외곽을 벗어나면 측면을 전환하려고 시도하여 다각형과 겹치는 특정 영역에서의 성장을 촉진합니다.\u003c/p\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_15.png\"\u003e\n\u003cp\u003e이것이 제 두 번째 영감으로 이어집니다. Quad-Tile Chart v1을 내 vizmath 패키지에 통합할 때 다각형 입력과 더 많은 작업을 할 수 있는지 생각하기 시작했습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e일부 실험 끝에, 주어진 다각형 내에 꼭지점이 깔끔하게 맞는 완전히 기능적인 컨테이너 패킹 구현이 재미있을 것이라고 결정하고 처음부터 알고리즘을 완전히 개편해보기로 했습니다! 다음에 해당하는 알고리즘을 확인해 봅시다: Quad-Tile Chart v2\u003c/p\u003e\n\u003ch2\u003e(최종) 알고리즘 v2\u003c/h2\u003e\n\u003cp\u003e이 알고리즘의 두 번째 버전은 v1의 일부 핵심 요소를 확장하고 쿼드런트-세그먼트 접근 방식을 유사하게 사용하면서 몇 가지 수정 사항과 컨테이너 패킹을 수용하기 위한 몇 가지 새로운 기능을 추가합니다.\u003c/p\u003e\n\u003cp\u003ev2에 대한 주요 세부 내용은 다음과 같습니다. 특별한 점을 확인해 보세요:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003eBridge Segments(컨테이너 채우기)\u003c/li\u003e\n\u003cli\u003eBackward Segment Extension(‘축소’ 옵션)\u003c/li\u003e\n\u003cli\u003eValue Multiplier Bisection Optimization(컨테이너 패킹)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_16.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e다음은 v2 알고리즘입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e단계 1~5는 v1과 동일하지만 2가지 세그먼트 속성(세그먼트 높이 및 세그먼트가 활성화되어 있는지), 3가지 사분면 레벨 속성(최소 바닥과 천장 및 해당 사분면 전체가 방을 다 쓴 것인지) 및 배치된 사각형에 대한 속성(왼쪽 아래 모서리 좌표 및 너비)가 추가됩니다.\u003c/li\u003e\n\u003cli\u003e이터레이터(처음에 0으로 설정)가 놓여야 하는 사각형 수보다 작을 동안 다음 절차가 수행됩니다:\u003c/li\u003e\n\u003cli\u003e마지막 바닥 세그먼트(LFS)를 찾습니다: max(segments: 'y=floor', sort: 'x')\u003c/li\u003e\n\u003cli\u003e정렬된 세그먼트 목록을 만듭니다: (segments: 'is active', sort: 'height, x')\u003c/li\u003e\n\u003cli\u003e정렬된 세그먼트를 루프합니다(아래에서 '세그먼트' 및 루프 반복 '세그먼트'로 참조됨) 및 진행합니다.\u003c/li\u003e\n\u003cli\u003e만약 사각형의 모퉁이가 다각형 내에 있고 사각형의 '너비'와 '높이'가 세그먼트의 '너비'와 '높이'에 맞는다면 사각형은 배치됩니다. 그렇지 않으면 세그먼트를 '비활성화'로 설정합니다.\u003c/li\u003e\n\u003cli\u003e세그먼트의 'y' 값이 사분면의 '바닥'과 같다면 사각형의 '너비'를 추가하여 '바닥'을 업데이트합니다.\u003c/li\u003e\n\u003cli\u003e사각형이 배치되면 사각형의 너비와 세그먼트 길이에 따라 현재 세그먼트를 대체할 1개 또는 2개의 새 세그먼트를 생성합니다.\u003c/li\u003e\n\u003cli\u003e축소가 활성화된 경우 다음 절차가 수행됩니다:\u003c/li\u003e\n\u003cli\u003e세그먼트를 새로 생성된 세그먼트 중 가장 왼쪽으로 설정(NLS).\u003c/li\u003e\n\u003cli\u003e확장할 세그먼트를 찾습니다: max(segments: 'x + 길이 = NLS.x', 'y = NLS.y', sort: 'x')\u003c/li\u003e\n\u003cli\u003e확장할 세그먼트가 존재하는 경우, NLS 길이를 추가하고 NLS를 제거합니다.\u003c/li\u003e\n\u003cli\u003e그렇지 않은 경우, 왼쪽 사각형(LS)을 찾습니다: max(squares: 'x+w≤NLS.x', 'y≤NLS.y', 'y+x≥NLS.y', sort: 'x')\u003c/li\u003e\n\u003cli\u003e왼쪽 사각형(LS)이 존재하면 LS.x + LS.w ≤ NLS.x를 확인하여 갭이 있는지 확인합니다.\u003c/li\u003e\n\u003cli\u003e그렇다면, 커버된 세그먼트(CS)를 확인합니다: max(segments: 'y=LS.y', 'x`NLS.x', sort: 'x')\u003c/li\u003e\n\u003cli\u003e커버된 세그먼트가 존재하는 경우, 세그먼트 높이를 사각형 너비와 동일하게 설정하고 병합 세그먼트를 확인합니다: max(segments: 'x+길이+CS.length = NLS.x', 'y=NLS.y', sort: x)\u003c/li\u003e\n\u003cli\u003e병합 세그먼트가 존재하는 경우, 사각형 너비와 CS.length를 추가하여 길이를 확장합니다.\u003c/li\u003e\n\u003cli\u003e그렇지 않은 경우, LS.x + LS.w ≤ NLS.x - 사각형 너비라면 NLS.x = LS.x+LS.w 및 NLS.길이 = CS.length으로 NLS를 조정합니다.\u003c/li\u003e\n\u003cli\u003e세그먼트가 LFS와 같고 배치되지 않았으며 사분면의 바닥이 천장과 다른 경우 다리 세그먼트를 생성합니다. 다음 절차를 따릅니다:\u003c/li\u003e\n\u003cli\u003eLFS.높이 및 사분면 바닥을 사분면 천장으로 업데이트합니다.\u003c/li\u003e\n\u003cli\u003e천장 세그먼트(CS)가 천장에서 존재하는지 확인합니다: max(segments: 'y=ceiling', sort: x)\u003c/li\u003e\n\u003cli\u003e존재하는 경우, 그 길이를 다각형 경계까지 확장합니다.\u003c/li\u003e\n\u003cli\u003e그렇지 않은 경우, (세그먼트.x, 천장)에 새 세그먼트를 생성하고 해당 지점과 다각형 경계 사이의 거리로 길이를 설정합니다.\u003c/li\u003e\n\u003cli\u003e마지막으로, 모든 세그먼트를 '활성화'로 설정하고 루프를 종료합니다.\u003c/li\u003e\n\u003cli\u003e그렇지 않은 경우, 사각형이 배치되면 사각형을 사각형 목록에 추가하고 해당 속성을 설정하고 사분면을 '방이있음'으로 설정하고 세그먼트가 마지막 세그먼트인 경우 모든 세그먼트를 '활성화'로 설정하고 이터레이터를 1 증가시키고 다음 측면을 설정하고 루프를 종료합니다.\u003c/li\u003e\n\u003cli\u003e그렇지 않은 경우, 마지막 세그먼트에 도달하면 가능한 경우 더 많은 다리 세그먼트를 추가하려 시도합니다. 다음 절차를 따릅니다:\u003c/li\u003e\n\u003cli\u003e다리 사각형(BS)을 확인합니다: 첫번째(squares: 'x+w=LFS.x', 'y=LFS.y')\u003c/li\u003e\n\u003cli\u003e있으면, LFS.높이 = BS.x로 설정하고 사분면 바닥을 BS.w만큼 증가시키고 사분면 천장을 바닥으로 설정합니다.\u003c/li\u003e\n\u003cli\u003e다리 사각형 세그먼트를 확인합니다: max(segments: 'y=floor', sort: x)\u003c/li\u003e\n\u003cli\u003e하나가 존재한다면, 그 길이를 다각형 경계까지 확장합니다.\u003c/li\u003e\n\u003cli\u003e그렇지 않은 경우, (BS.x+BS.w, 바닥)에 새 세그먼트를 생성하고 해당 지점과 다각형 경계 사이의 거리로 길이를 설정합니다.\u003c/li\u003e\n\u003cli\u003e마지막으로, 모든 세그먼트를 '활성화'로 설정하고 루프를 종료합니다.\u003c/li\u003e\n\u003cli\u003eBS를 찾지 못한 경우, 사분면을 '방이없음'으로 설정하고 모든 세그먼트를 '활성화'로 설정하고 다음 측면을 설정하고 모든 사분면이 방이없으면 이터레이터를 놓여야 하는 사각형 수로 설정(사실상 외부 while 루프를 종료합니다).\u003c/li\u003e\n\u003cli\u003ev1의 단계 10을 반복하며 각 사분면을 올바른 방향으로 회전합니다.\u003c/li\u003e\n\u003cli\u003e자동 배열 옵션이 선택된 경우(컨테이너 패킹), 변환된 값들\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003ev2 알고리즘은 컨테이너 패킹을 맞추기 위해 훨씬 더 많은 작업을 필요로했기 때문에 v1 알고리즘의 간단함에 비해 더 많은 노력이 필요했습니다. 하지만 정말 그만한 가치가 있었어요! v2에서 몇 가지 레이아웃 예제를 살펴봅시다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_17.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e위의 원 형태의 외곽선은 '축소' 기능을 사용하여 참조용으로 포함했습니다. v2의 이론적 한계는 아마도 자기 자신을 내부로 돌리는 다각형들일 것입니다 (이는 사분면의 타일링 평면에서 고유 다각형 갭을 처리하기 위한 향상된 세그먼트 논리가 필요할 것입니다).\u003c/p\u003e\n\u003cp\u003e다음으로, Python에서 Quad-Tile 차트를 구축하는 방법을 살펴보겠습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e파이썬 구현\u003c/h2\u003e\n\u003cp\u003e저는 제 Quad-Tile Chart 알고리즘 v1 및 v2를 파이썬에서 사용할 수 있도록 vizmath 패키지를 통해 구현했습니다. PyPI에서 제공됩니다. 소개에서 시작하는 초기 예제를 사용하여 몇 가지 추가 옵션을 살펴보고 입력 및 출력을 설명하겠습니다. 먼저 v1로 시작합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eQuad\u003c/span\u003e-\u003cspan class=\"hljs-title class_\"\u003eTile\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eChart\u003c/span\u003e v1\n# pip install vizmath==\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.22\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e vizmath.\u003cspan class=\"hljs-property\"\u003equadtile_chart\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e quadtile \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e qt\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pandas \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pd\n\ndata = {\n    \u003cspan class=\"hljs-string\"\u003e'id'\u003c/span\u003e : [\u003cspan class=\"hljs-title function_\"\u003estr\u003c/span\u003e(i) \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e21\u003c/span\u003e)],\n    \u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e : [\u003cspan class=\"hljs-number\"\u003e242\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e105\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e95\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e92.5\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e88\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e80\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e79\u003c/span\u003e,\n        \u003cspan class=\"hljs-number\"\u003e75\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e67.85\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e61.06\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e56\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e55\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e55\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e55\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e]\n}\ndf = pd.\u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e(data)\n\n# 쿼드타일 객체 생성\n#   \u003e \u003cspan class=\"hljs-attr\"\u003edf\u003c/span\u003e: 데이터와 id 필드가 있는 \u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e\n#   \u003e \u003cspan class=\"hljs-attr\"\u003eid_field\u003c/span\u003e: 필수 식별자 필드 (더미값 사용 가능)\n#   \u003e \u003cspan class=\"hljs-attr\"\u003evalue_field\u003c/span\u003e: 필수 값 열\n#   \u003e \u003cspan class=\"hljs-attr\"\u003exo\u003c/span\u003e: x축 기준점\n#   \u003e \u003cspan class=\"hljs-attr\"\u003eyo\u003c/span\u003e: y축 기준점\n#   \u003e \u003cspan class=\"hljs-attr\"\u003epacking\u003c/span\u003e: 패킹 방법 (\u003cspan class=\"hljs-string\"\u003e'auto'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'inc'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'num'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'max'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'min'\u003c/span\u003e)\n#   \u003e \u003cspan class=\"hljs-attr\"\u003eoverflow\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'num'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'max'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'min'\u003c/span\u003e 패킹을 위한 정수 임계값\n#   \u003e \u003cspan class=\"hljs-attr\"\u003ebuffer\u003c/span\u003e: 사각형 크기에 추가 값\n#   \u003e \u003cspan class=\"hljs-attr\"\u003erotate\u003c/span\u003e: 차트 회전 각도\n#   \u003e \u003cspan class=\"hljs-attr\"\u003econstraints\u003c/span\u003e: 둘레 내부 성장을 촉진하는 다각형\n#   \u003e \u003cspan class=\"hljs-attr\"\u003esize_by\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'area'\u003c/span\u003e 또는 \u003cspan class=\"hljs-string\"\u003e'width'\u003c/span\u003e\n#   \u003e \u003cspan class=\"hljs-attr\"\u003epoly_sort\u003c/span\u003e: 다각형 정점 정렬 활성화/비활성화 (참, 거짓)\nqt_o_area = \u003cspan class=\"hljs-title function_\"\u003eqt\u003c/span\u003e(df,\u003cspan class=\"hljs-string\"\u003e'id'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e, size_by=\u003cspan class=\"hljs-string\"\u003e'area'\u003c/span\u003e, buffer=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\nqt_o_width = \u003cspan class=\"hljs-title function_\"\u003eqt\u003c/span\u003e(df,\u003cspan class=\"hljs-string\"\u003e'id'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e, size_by=\u003cspan class=\"hljs-string\"\u003e'width'\u003c/span\u003e, buffer=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n\n# 차트 그리기 (면적 및 너비에 따라 크기 조절)\nqt_o_area.\u003cspan class=\"hljs-title function_\"\u003equadtile_plot\u003c/span\u003e(color=\u003cspan class=\"hljs-string\"\u003e'quad'\u003c/span\u003e, cw=\u003cspan class=\"hljs-number\"\u003e0.75\u003c/span\u003e, opacity=\u003cspan class=\"hljs-number\"\u003e.9\u003c/span\u003e)\nqt_o_width.\u003cspan class=\"hljs-title function_\"\u003equadtile_plot\u003c/span\u003e(color=\u003cspan class=\"hljs-string\"\u003e'quad'\u003c/span\u003e, cw=\u003cspan class=\"hljs-number\"\u003e0.75\u003c/span\u003e, opacity=\u003cspan class=\"hljs-number\"\u003e.9\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_18.png\"\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이제 v2를 사용해 봅시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eQuad\u003c/span\u003e-\u003cspan class=\"hljs-title class_\"\u003eTile\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eChart\u003c/span\u003e v2\n# pip install vizmath==\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.22\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e vizmath.\u003cspan class=\"hljs-property\"\u003equadtile_chart\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e polyquadtile \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pqt\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pandas \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pd\n\ndata = {\n    \u003cspan class=\"hljs-string\"\u003e'id'\u003c/span\u003e: [\u003cspan class=\"hljs-title function_\"\u003estr\u003c/span\u003e(i) \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e21\u003c/span\u003e)],\n    \u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e: [\u003cspan class=\"hljs-number\"\u003e242\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e105\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e95\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e92.5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e88\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e80\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e79\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e75\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e67.85\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e61.06\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e56\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e55\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e55\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e55\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e]\n}\ndf = pd.\u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e(data)\n\n# 쿼드타일 객체 생성\n#   \u003e \u003cspan class=\"hljs-attr\"\u003edf\u003c/span\u003e: 데이터를 포함하고 있는 \u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e, 숫자형 데이터 컬럼과 id 필드를 가져야 함\n#   \u003e \u003cspan class=\"hljs-attr\"\u003eid_field\u003c/span\u003e: 필수 식별자 필드 (더미 값 사용 가능)\n#   \u003e \u003cspan class=\"hljs-attr\"\u003evalue_field\u003c/span\u003e: 필수 값 컬럼\n#   \u003e \u003cspan class=\"hljs-attr\"\u003exo\u003c/span\u003e: x축 원점\n#   \u003e \u003cspan class=\"hljs-attr\"\u003eyo\u003c/span\u003e: y축 원점\n#   \u003e \u003cspan class=\"hljs-attr\"\u003ebuffer\u003c/span\u003e: 사각형 크기를 조절하는 보정값\n#   \u003e \u003cspan class=\"hljs-attr\"\u003erotate\u003c/span\u003e: 차트 회전 각도\n#   \u003e \u003cspan class=\"hljs-attr\"\u003esides\u003c/span\u003e: 포함시킬 변 선택 (\u003cspan class=\"hljs-string\"\u003e'top'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'right'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'bottom'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'left'\u003c/span\u003e)\n#   \u003e \u003cspan class=\"hljs-attr\"\u003ecollapse\u003c/span\u003e: 축소/확대 설정 (\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e)\n#   \u003e \u003cspan class=\"hljs-attr\"\u003econstraints\u003c/span\u003e: 패킹할 다각형 컨테이너\n#   \u003e \u003cspan class=\"hljs-attr\"\u003exc\u003c/span\u003e: x축 컨테이너 오프셋 값\n#   \u003e \u003cspan class=\"hljs-attr\"\u003eyc\u003c/span\u003e: y축 컨테이너 오프셋 값\n#   \u003e \u003cspan class=\"hljs-attr\"\u003esize_by\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'area'\u003c/span\u003e 또는 \u003cspan class=\"hljs-string\"\u003e'width'\u003c/span\u003e\n#   \u003e \u003cspan class=\"hljs-attr\"\u003eauto\u003c/span\u003e: 자동 패킹 활성화/비활성화 (\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e)\n#   \u003e \u003cspan class=\"hljs-attr\"\u003eauto_max_iter\u003c/span\u003e: 자동 패킹 반복 횟수\n#   \u003e \u003cspan class=\"hljs-attr\"\u003eauto_min_val\u003c/span\u003e: 자동 패킹 최소 배수\n#   \u003e \u003cspan class=\"hljs-attr\"\u003eauto_max_val\u003c/span\u003e: 자동 패킹 최대 배수\n#   \u003e \u003cspan class=\"hljs-attr\"\u003epoly_sort\u003c/span\u003e: 다각형 꼭지점 정렬 활성화/비활성화 (\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e)\npqt_o_area = \u003cspan class=\"hljs-title function_\"\u003epqt\u003c/span\u003e(df, \u003cspan class=\"hljs-string\"\u003e'id'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e, size_by=\u003cspan class=\"hljs-string\"\u003e'area'\u003c/span\u003e, buffer=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\npqt_o_width = \u003cspan class=\"hljs-title function_\"\u003epqt\u003c/span\u003e(df, \u003cspan class=\"hljs-string\"\u003e'id'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e, size_by=\u003cspan class=\"hljs-string\"\u003e'width'\u003c/span\u003e, buffer=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n\n# 차트 그리기 (면적 및 폭에 따라 사이즈가 지정된 차트)\npqt_o_area.\u003cspan class=\"hljs-title function_\"\u003epolyquadtile_plot\u003c/span\u003e(color=\u003cspan class=\"hljs-string\"\u003e'quad'\u003c/span\u003e, cw=\u003cspan class=\"hljs-number\"\u003e0.75\u003c/span\u003e, opacity=\u003cspan class=\"hljs-number\"\u003e0.9\u003c/span\u003e)\npqt_o_width.\u003cspan class=\"hljs-title function_\"\u003epolyquadtile_plot\u003c/span\u003e(color=\u003cspan class=\"hljs-string\"\u003e'quad'\u003c/span\u003e, cw=\u003cspan class=\"hljs-number\"\u003e0.75\u003c/span\u003e, opacity=\u003cspan class=\"hljs-number\"\u003e0.9\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_19.png\"\u003e\n\u003cp\u003e이제 v1 및 v2의 랜덤 초기화 옵션을 포함한 몇 가지 추가 옵션을 조사해 봅시다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e개의 임의 크기 사각형을 테스트해봅시다:\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e vizmath.\u003cspan class=\"hljs-property\"\u003equadtile_chart\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e quadtile \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e qt\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e vizmath.\u003cspan class=\"hljs-property\"\u003equadtile_chart\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e polyquadtile \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pqt\n\n# 상단 좌측에 회전된 \u003cspan class=\"hljs-title class_\"\u003eQuad\u003c/span\u003e-\u003cspan class=\"hljs-title class_\"\u003eTile\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eChart\u003c/span\u003e v1\nqt_o1 = qt.\u003cspan class=\"hljs-title function_\"\u003erandom_quadtile\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e, rotate=\u003cspan class=\"hljs-number\"\u003e45\u003c/span\u003e)\nqt_o1.\u003cspan class=\"hljs-title function_\"\u003equadtile_plot\u003c/span\u003e(color=\u003cspan class=\"hljs-string\"\u003e'quad'\u003c/span\u003e, cw=\u003cspan class=\"hljs-number\"\u003e0.75\u003c/span\u003e, opacity=\u003cspan class=\"hljs-number\"\u003e.9\u003c/span\u003e)\n\n# 상단 우측에 비회전 \u003cspan class=\"hljs-title class_\"\u003eQuad\u003c/span\u003e-\u003cspan class=\"hljs-title class_\"\u003eTile\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eChart\u003c/span\u003e v1\nqt_o2 = qt.\u003cspan class=\"hljs-title function_\"\u003erandom_quadtile\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e, rotate=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\nqt_o2.\u003cspan class=\"hljs-title function_\"\u003equadtile_plot\u003c/span\u003e(color=\u003cspan class=\"hljs-string\"\u003e'quad'\u003c/span\u003e, cw=\u003cspan class=\"hljs-number\"\u003e0.75\u003c/span\u003e, opacity=\u003cspan class=\"hljs-number\"\u003e.9\u003c/span\u003e)\n\n# 하단 좌측에 정사각형 컨테이너를 사용한 \u003cspan class=\"hljs-title class_\"\u003eQuad\u003c/span\u003e-\u003cspan class=\"hljs-title class_\"\u003eTile\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eChart\u003c/span\u003e v2\npoly = [(-\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e,-\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e),(-\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e),(\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e),(\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e,-\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e)] # 다각형 컨테이너\npqt_o1 = pqt.\u003cspan class=\"hljs-title function_\"\u003erandom_polyquadtile\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e, constraints=poly, buffer=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\npqt_o1.\u003cspan class=\"hljs-title function_\"\u003epolyquadtile_plot\u003c/span\u003e(color=\u003cspan class=\"hljs-string\"\u003e'quad'\u003c/span\u003e, cw=\u003cspan class=\"hljs-number\"\u003e0.75\u003c/span\u003e, opacity=\u003cspan class=\"hljs-number\"\u003e.9\u003c/span\u003e)\n\n# 중앙에 가로 세로 비율이 \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e인 \u003cspan class=\"hljs-title class_\"\u003eQuad\u003c/span\u003e-\u003cspan class=\"hljs-title class_\"\u003eTile\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eChart\u003c/span\u003e v2\npqt_o2 = pqt.\u003cspan class=\"hljs-title function_\"\u003erandom_polyquadtile\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e, constraints=[(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)], buffer=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\npqt_o2.\u003cspan class=\"hljs-title function_\"\u003epolyquadtile_plot\u003c/span\u003e(color=\u003cspan class=\"hljs-string\"\u003e'quad'\u003c/span\u003e, cw=\u003cspan class=\"hljs-number\"\u003e0.75\u003c/span\u003e, opacity=\u003cspan class=\"hljs-number\"\u003e.9\u003c/span\u003e)\n\n# 하단 우측에 가로 세로 비율이 \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e인 \u003cspan class=\"hljs-title class_\"\u003eQuad\u003c/span\u003e-\u003cspan class=\"hljs-title class_\"\u003eTile\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eChart\u003c/span\u003e v2\npqt_o3 = pqt.\u003cspan class=\"hljs-title function_\"\u003erandom_polyquadtile\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e, constraints=[(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)],\n    buffer=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, rotate=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\npqt_o3.\u003cspan class=\"hljs-title function_\"\u003epolyquadtile_plot\u003c/span\u003e(color=\u003cspan class=\"hljs-string\"\u003e'quad'\u003c/span\u003e, cw=\u003cspan class=\"hljs-number\"\u003e0.75\u003c/span\u003e, opacity=\u003cspan class=\"hljs-number\"\u003e.9\u003c/span\u003e, circles=\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_20.png\"\u003e\n\u003cp\u003e위 내용은 각 버전 간 배치 방법의 미묘한 차이를 보여줍니다 (v1은 y값이 가장 낮고 가장 긴 길이로 선택된 세그먼트, v2는 계단식 접근 방식). 또한 v2에 대한 무작위 초기화는 무작위 볼록 다각형을 생성할 것입니다 — 무엇이 나올지 아무도 모릅니다!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e vizmath.\u003cspan class=\"hljs-property\"\u003equadtile_chart\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e polyquadtile \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pqt\n\npqt_o = pqt.\u003cspan class=\"hljs-title function_\"\u003erandom_polyquadtile\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e, collapse=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\npqt_o.\u003cspan class=\"hljs-title function_\"\u003epolyquadtile_plot\u003c/span\u003e(color=\u003cspan class=\"hljs-string\"\u003e'quad'\u003c/span\u003e, cw=\u003cspan class=\"hljs-number\"\u003e0.75\u003c/span\u003e, opacity=\u003cspan class=\"hljs-number\"\u003e.9\u003c/span\u003e, circles=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e,\n    show_constraints=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\n\n# 계속해서 무작위 크기 사각형을 사용한 무작위 컨테이너 실행\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_21.png\"\u003e\n\u003cp\u003e그리고 끝으로, 우리는 중심점을 사용하여 부모 사각형의 경계 상자 크기에 맞는 모든 모양으로 플롯할 수 있음을 기억하세요. 원형 차트의 경우에는 반소형 Bubble Chart만 플로팅한다는 소개를 참조하세요!\u003c/p\u003e\n\u003cp\u003e이제 Quad-Tile Chart 알고리즘으로 생성된 사분면 다각형과 사분면 중심점 출력을 검토해 봅시다.\u003c/p\u003e\n\u003cp\u003e사분면 다각형 출력:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003eitem — ‘id’ 입력 필드로 지정된 수신 식별자\u003c/li\u003e\n\u003cli\u003ea — 사각형의 상대적 면적 (버퍼는 포함되지 않음)\u003c/li\u003e\n\u003cli\u003ew — 할당된 공간의 너비: 사각형의 너비 + 버퍼*2\u003c/li\u003e\n\u003cli\u003ex, y — 레이아웃 내의 점에 대한 직교 좌표\u003c/li\u003e\n\u003cli\u003epath — 폴리곤을 둘러싼 경로를 나타내는 정수 순서 집합으로, Crystal Bar Chart의 각 크리스탈 ID 및 면에 대해 각각의 (x, y) 점과 함께 사용됨: 1부터 N까지\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e vizmath.\u003cspan class=\"hljs-property\"\u003equadtile_chart\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e polyquadtile \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pqt\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pandas \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pd\n\n# 컨테이너에 맞게 크기 조정 없이 초기 예제 데이터 사용:\ndata = {\n    \u003cspan class=\"hljs-string\"\u003e'id'\u003c/span\u003e : [\u003cspan class=\"hljs-title function_\"\u003estr\u003c/span\u003e(i) \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e21\u003c/span\u003e)],\n    \u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e : [\u003cspan class=\"hljs-number\"\u003e242\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e105\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e95\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e92.5\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e88\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e80\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e79\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e75\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e67.85\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e61.06\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e56\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e55\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e55\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e55\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e]\n}\npoly = [(-\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e,-\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e),(-\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e),(\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e),(\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e,-\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e)] # 설명 예제 출력을 위한 충분히 큰 컨테이너\ndf = pd.\u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e(data)\no_pq1 = \u003cspan class=\"hljs-title function_\"\u003epqt\u003c/span\u003e(df,\u003cspan class=\"hljs-string\"\u003e'id'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e,buffer=\u003cspan class=\"hljs-number\"\u003e5.0\u003c/span\u003e, collapse=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e, constraints=poly, auto=\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e)\no_pq2 = \u003cspan class=\"hljs-title function_\"\u003epqt\u003c/span\u003e(df,\u003cspan class=\"hljs-string\"\u003e'id'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'speed'\u003c/span\u003e,buffer=\u003cspan class=\"hljs-number\"\u003e5.0\u003c/span\u003e, collapse=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e, constraints=poly, auto=\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e, size_by=\u003cspan class=\"hljs-string\"\u003e'width'\u003c/span\u003e)\n\n# 면적에 따라 크기 조정:\no_pq1.\u003cspan class=\"hljs-property\"\u003eo_polyquadtile_chart\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edf\u003c/span\u003e[[\u003cspan class=\"hljs-string\"\u003e'id'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'item'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'a'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'w'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'x'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'y'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'path'\u003c/span\u003e]].\u003cspan class=\"hljs-title function_\"\u003ehead\u003c/span\u003e()\n# 너비에 따라 크기 조정:\no_pq2.\u003cspan class=\"hljs-property\"\u003eo_polyquadtile_chart\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edf\u003c/span\u003e[[\u003cspan class=\"hljs-string\"\u003e'id'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'item'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'a'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'w'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'x'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'y'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'path'\u003c/span\u003e]].\u003cspan class=\"hljs-title function_\"\u003ehead\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_22.png\"\u003e\n\u003cp\u003e사각형 중심점은 'id' 대신 'item'으로 동일한 속성으로 추출될 수도 있습니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e넓이 별 크기:\u003c/h1\u003e\n\u003cp\u003eo_pq1.o_polysquares.df[['id','a','w','x','y']].head()\u003c/p\u003e\n\u003ch1\u003e너비 별 크기:\u003c/h1\u003e\n\u003cp\u003eo_pq2.o_polysquares.df[['id','a','w','x','y']].head()\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_23.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이제 Quad-Tile 차트로 무엇을 더 할 수 있는지 알아봅시다.\u003c/p\u003e\n\u003ch2\u003e확장성\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e캔버스 레이아웃을 활용하는 원래의 목표를 표준 및 비표준 컨테이너와 함께 다시 살펴보겠습니다. 볼록 다각형과 간단한 오목 다각형을 수용할 수 있는 방법을 보여드렸고, 이제는 소개에서 소개된 레이아웃을 채워봤습니다. 각각 100개의 정사각형이 들어가는 컨테이너에 대해 다양한 회전을 적용했습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_24.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e가장 일반적인 캔버스 레이아웃은 직사각형 컨테이너일 것이므로, 원하는 종횡비를 간단하게 전달하는 것이 유용합니다. 다음은 너비를 다양하게 조절한 예시입니다 (높이 조절 방법도 동일합니다):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e vizmath.\u003cspan class=\"hljs-property\"\u003equadtile_chart\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e polyquadtile \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pqt\n\naspect_ratio = (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) #(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) (\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) (\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\npqt_o = pqt.\u003cspan class=\"hljs-title function_\"\u003erandom_polyquadtile\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e, constraints=[aspect_ratio], \n    rotate=\u003cspan class=\"hljs-number\"\u003e45\u003c/span\u003e, collapse=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e, buffer=\u003cspan class=\"hljs-number\"\u003e.02\u003c/span\u003e)\npqt_o.\u003cspan class=\"hljs-title function_\"\u003epolyquadtile_plot\u003c/span\u003e(color=\u003cspan class=\"hljs-string\"\u003e'quad'\u003c/span\u003e, cw=\u003cspan class=\"hljs-number\"\u003e0.75\u003c/span\u003e, opacity=\u003cspan class=\"hljs-number\"\u003e.9\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_25.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eExtensibility의 또 다른 흥미로운 측면은 계층적 데이터를 포함하는 것입니다. 기존 방법의 일부 단점은 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e중첩된 원은 레벨별로 정확한 상대적인 면적을 유지할 수 없습니다. 이를 위해 중첩된 Radial이나 Voronoi Treemaps가 필요합니다.\u003c/li\u003e\n\u003cli\u003eTreemaps는 상위 레벨에서 불규칙한 차원을 가질 가능성이 있습니다. (사각형, 원형, 또는 Voronoi일 경우)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eQuad-Tile Chart는 계층의 상위 수준을 유사한 모양으로 캡처하여 초기 크기 비교를 제공함으로써 두 번째 문제를 우아하게 처리할 수 있습니다.🌟\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e첫 번째 문제에 대해 말씀드리면, 중첩된 Quad-Tile Charts는 중첩된 패킹된 원(타일 섹션에서 언급된대로)과 동일한 단점을 가지고 있지만, 전통적인 직사각형 Treemaps(또는 Voronoi Treemaps)으로 나무 전체에 대한 정확한 면적을 유지하는 대안을 제공합니다. 중첩된 직사각형 Treemaps은 부모 정사각형의 변을 사용하여 보다 직관적인 자식 직사각형 비교를 할 수 있어 원하는 경우가 있습니다.\u003c/p\u003e\n\u003cp\u003e다음 단계의 직사각형 Treemaps에 대한 예시 몇 가지를 함께 공유드리겠습니다. 상위 수준에 정사각형을 포함한 Quad-Tile Chart에 중첩된 이들을 제가 “Squaremaps”라고 부르겠습니다!\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_26.png\" alt=\"Squaremaps\"\u003e\u003c/p\u003e\n\u003cp\u003e제가 vizmath에서 Squaremaps에 대한 구현을 다음과 같이 작성했습니다(그리고 필요 시 계층적 데이터를 동적으로 생성하는 기능도 추가했습니다!):\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pandas \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pd\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e vizmath.\u003cspan class=\"hljs-property\"\u003equadtile_chart\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e squaremap \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e sm\n\n# 랜덤한 스퀘어 맵 생성\no_sm1 = sm.\u003cspan class=\"hljs-title function_\"\u003erandom_squaremap\u003c/span\u003e(num_levels=\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, items_range=(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e), \n    value_range=(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e), sig=\u003cspan class=\"hljs-number\"\u003e0.8\u003c/span\u003e)\no_sm1.\u003cspan class=\"hljs-property\"\u003eo_squaremap\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eplot_levels\u003c/span\u003e(level=\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, fill=\u003cspan class=\"hljs-string\"\u003e'w'\u003c/span\u003e)\n\n# 계층적 데이터를 사용하여 스퀘어 맵 생성\ndata = [\n    [\u003cspan class=\"hljs-string\"\u003e'a1'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'b1'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'c1'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e9.3\u003c/span\u003e],\n    [\u003cspan class=\"hljs-string\"\u003e'a1'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'b1'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'c2'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6.7\u003c/span\u003e],\n    [\u003cspan class=\"hljs-string\"\u003e'a1'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'b1'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'c3'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2.4\u003c/span\u003e],\n    [\u003cspan class=\"hljs-string\"\u003e'a1'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'b2'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'c1'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4.5\u003c/span\u003e],\n    [\u003cspan class=\"hljs-string\"\u003e'a1'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'b2'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'c2'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3.1\u003c/span\u003e],\n\n    [\u003cspan class=\"hljs-string\"\u003e'a2'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'b1'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'c1'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5.9\u003c/span\u003e],\n    [\u003cspan class=\"hljs-string\"\u003e'a2'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'b1'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'c2'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e32.3\u003c/span\u003e],\n    [\u003cspan class=\"hljs-string\"\u003e'a2'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'b1'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'c3'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e12.3\u003c/span\u003e],\n    [\u003cspan class=\"hljs-string\"\u003e'a2'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'b1'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'c4'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2.3\u003c/span\u003e],\n    [\u003cspan class=\"hljs-string\"\u003e'a2'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'b2'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'c1'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e9.1\u003c/span\u003e],\n    [\u003cspan class=\"hljs-string\"\u003e'a2'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'b2'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'c2'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e17.3\u003c/span\u003e],\n    [\u003cspan class=\"hljs-string\"\u003e'a2'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'b2'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'c3'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6.7\u003c/span\u003e],\n    [\u003cspan class=\"hljs-string\"\u003e'a2'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'b2'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'c4'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4.4\u003c/span\u003e],\n    [\u003cspan class=\"hljs-string\"\u003e'a2'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'b2'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'c5'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e11.3\u003c/span\u003e],\n\n    [\u003cspan class=\"hljs-string\"\u003e'a3'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'b1'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'c1'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7.5\u003c/span\u003e],\n    [\u003cspan class=\"hljs-string\"\u003e'a3'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'b1'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'c2'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e9.5\u003c/span\u003e],\n    [\u003cspan class=\"hljs-string\"\u003e'a3'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'b2'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'c3'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e17.1\u003c/span\u003e],\n\n    [\u003cspan class=\"hljs-string\"\u003e'a4'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'b2'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'c1'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5.1\u003c/span\u003e],\n    [\u003cspan class=\"hljs-string\"\u003e'a4'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'b2'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'c2'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2.1\u003c/span\u003e],\n    [\u003cspan class=\"hljs-string\"\u003e'a4'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'b2'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'c3'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e11.1\u003c/span\u003e],\n    [\u003cspan class=\"hljs-string\"\u003e'a4'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'b2'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'c4'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1.5\u003c/span\u003e]]\ndf = pd.\u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e(data, columns = [\u003cspan class=\"hljs-string\"\u003e'a'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'b'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'c'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'value'\u003c/span\u003e])\no_sm2 = \u003cspan class=\"hljs-title function_\"\u003esm\u003c/span\u003e(df, [\u003cspan class=\"hljs-string\"\u003e'a'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'b'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'c'\u003c/span\u003e], \u003cspan class=\"hljs-string\"\u003e'value'\u003c/span\u003e, constraints=[(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)], buffer=\u003cspan class=\"hljs-number\"\u003e.2\u003c/span\u003e)\no_sm2.\u003cspan class=\"hljs-property\"\u003eo_squaremap\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eplot_levels\u003c/span\u003e(level=\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, fill=\u003cspan class=\"hljs-string\"\u003e'w'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_27.png\"\u003e\n\u003ch2\u003eTableau Public Implementation\u003c/h2\u003e\n\u003cp\u003e파이썬에서 Quad-Tile Chart를 소개했으며 계층적 확장에 대한 Squaremap을 포함하였습니다. 이어서 Tableau Public (v 2023.3.1)에서 양쪽 모두를 구현하는 방법을 보여드리겠습니다! 우선 간단한 Squaremap 구현부터 시작하여 대화형으로 만드는 더 체계적인 Quad-Tile Chart 구축으로 넘어가보겠습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eTableau Public에서 Squaremap 구현\u003c/p\u003e\n\u003cp\u003e더 자세한 안내를 위해서는, 저의 Radial Treemaps에 관한 글이 있습니다. 해당 글은 상호작용 가능한 계층을 만드는 방법에 대해 더 상세히 안내하며, 이를 위해 Squaremap과 동일한 그림 출력을 사용합니다! 지금은 임의의 입력을 생성하고 단순한 Tableau 예제에 대비한 그림 출력 데이터를 준비해보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e vizmath.\u003cspan class=\"hljs-property\"\u003equadtile_chart\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e squaremap \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e sm\n\n# 임의의 계층 데이터 생성 및 \u003cspan class=\"hljs-title class_\"\u003eSquaremap\u003c/span\u003e 작성\no_sm = sm.\u003cspan class=\"hljs-title function_\"\u003erandom_squaremap\u003c/span\u003e(num_levels=\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, num_top_level_items=\u003cspan class=\"hljs-number\"\u003e120\u003c/span\u003e,\n    items_range=(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e), value_range=(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e), sig=\u003cspan class=\"hljs-number\"\u003e0.75\u003c/span\u003e, \n    collapse=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e, buffer=\u003cspan class=\"hljs-number\"\u003e0.05\u003c/span\u003e)\n# 초기 플롯 검토\no_sm.\u003cspan class=\"hljs-property\"\u003eo_squaremap\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eplot_level\u003c/span\u003e(level=\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e)\n# 출력의 미리보기 (그림 데이터)\no_sm.\u003cspan class=\"hljs-property\"\u003eo_squaremap\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edf_rad_treemap\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ehead\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e)\n# 데이터로 그림 객체 설정\no_sm.\u003cspan class=\"hljs-property\"\u003eo_squaremap\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eo_rad_treemap\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edf\u003c/span\u003e = o_sm.\u003cspan class=\"hljs-property\"\u003eo_squaremap\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edf_rad_treemap\u003c/span\u003e\n# \u003cspan class=\"hljs-title class_\"\u003eTableau\u003c/span\u003e에서 지도 레이어를 활용하기 위한 데이터 재조정\no_sm.\u003cspan class=\"hljs-property\"\u003eo_squaremap\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eo_rad_treemap\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edataframe_rescale\u003c/span\u003e(\n    xmin=-\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, xmax=\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, ymin=-\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, ymax=\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e)\n# 데이터를 csv로 작성\no_sm.\u003cspan class=\"hljs-property\"\u003eo_squaremap\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eo_rad_treemap\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edataframe_to_csv\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'squaremap'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_28.png\"\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e테이블 태그를 Markdown 형식으로 변경해주세요.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e[Group]을 Marks 아래 Detail로 드래그하세요.\u003c/li\u003e\n\u003cli\u003eMarks 드롭다운 메뉴에서 Polygon을 선택하세요 (이 시점에서 이상하게 보인다고 걱정하지 마세요).\u003c/li\u003e\n\u003cli\u003e[Path]를 Marks 아래 Path로 드래그하고 현재 SUM(Path)인 항목을 우클릭하여 Dimension으로 선택하세요.\u003c/li\u003e\n\u003cli\u003e[Value]를 Color로 드래그하고 Dimension으로 변환하는 작업을 반복하세요.\u003c/li\u003e\n\u003cli\u003eColor 아래에서 \"색상 편집...\"을 선택하고 다음 옵션으로 구성하세요: '반전, 고급: (시작: 0, 끝: 10)'\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이제 더 재미를 위해 더 한 개의 레이어를 추가하여 색상을 변경해 봅시다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e[Treemap]을 지도 영역으로 드래그하면 팝업이 나타납니다: Marks 레이어 추가 - 이를 클릭하여 새로운 지도 레이어를 생성하세요.\u003c/li\u003e\n\u003cli\u003e위의 단계를 반복하되 이제 [Side]를 Color로 사용하세요.\u003c/li\u003e\n\u003cli\u003eColor 아래에서 검은 테두리를 선택하고 투명도를 15%로 설정하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이제 아래와 유사한 차트가 나타날 것입니다 (입력의 무작위성으로 인해 고유한 것이 될 것입니다!). 이제 [Level]로 필터링하거나 필요에 맞는 상호 작용을 설정할 수 있습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_29.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e이 Squaremap 구현이 당신의 계층적 데이터를 더 자세히 탐색하는 데 유용한 시작점이 되길 바랍니다!\u003c/p\u003e\n\u003cp\u003eTableau Public에서 Quad-Tile Chart 구현\u003c/p\u003e\n\u003cp\u003e이제 더 자세한 Quad-Tile Chart 구현에 초점을 맞추고 Tableau Public에서 상호작용형 시각화를 만들어 보겠습니다. 강 체계에 대한 위키피디아 데이터 일부로 시작해서 파일에 저장해보죠.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pandas \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pd\n\n# 위키백과에서 (\u003cspan class=\"hljs-number\"\u003e2024\u003c/span\u003e년 \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e월 \u003cspan class=\"hljs-number\"\u003e26\u003c/span\u003e일 기준) 상위 \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e개의 강 시스템 목록\n# \u003cspan class=\"hljs-attr\"\u003ehttps\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//en.wikipedia.org/wiki/List_of_river_systems_by_length\u003c/span\u003e\ndata = {\n    \u003cspan class=\"hljs-string\"\u003e'강'\u003c/span\u003e : [\u003cspan class=\"hljs-title function_\"\u003estr\u003c/span\u003e(i) \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e51\u003c/span\u003e)],\n    \u003cspan class=\"hljs-string\"\u003e'길이_km'\u003c/span\u003e : [\n        \u003cspan class=\"hljs-number\"\u003e6650\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e6400\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e6300\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e6275\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e5539\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e5464\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e5410\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4880\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4700\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4444\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4400\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4350\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4241\u003c/span\u003e,\n        \u003cspan class=\"hljs-number\"\u003e4200\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3969\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3672\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3650\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3645\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3610\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3596\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3380\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3211\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3185\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3180\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3078\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3060\u003c/span\u003e,\n        \u003cspan class=\"hljs-number\"\u003e3058\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3057\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2989\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2888\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2809\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2740\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2720\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2704\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2620\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2615\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2570\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2549\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2513\u003c/span\u003e,\n        \u003cspan class=\"hljs-number\"\u003e2500\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2490\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2450\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2428\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2410\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2348\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2333\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2292\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2287\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2273\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2270\u003c/span\u003e],\n    \u003cspan class=\"hljs-string\"\u003e'길이_m'\u003c/span\u003e : [\n        \u003cspan class=\"hljs-number\"\u003e4130\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3976\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3917\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3902\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3445\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3395\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3364\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3030\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2922\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2763\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2736\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2705\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2637\u003c/span\u003e,\n        \u003cspan class=\"hljs-number\"\u003e2611\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2466\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2282\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2270\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2266\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2250\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2236\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2100\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1995\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1980\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1976\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1913\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1901\u003c/span\u003e,\n        \u003cspan class=\"hljs-number\"\u003e1900\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1900\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1857\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1795\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1745.8\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1703\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1700\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1690\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1628\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1625\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1597\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1584\u003c/span\u003e,\n        \u003cspan class=\"hljs-number\"\u003e1562\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1553\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1547\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1522\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1509\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1498\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1459\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1450\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1424\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1421\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1412\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1410\u003c/span\u003e],\n    \u003cspan class=\"hljs-string\"\u003e'배수지역_km2'\u003c/span\u003e : [\n        \u003cspan class=\"hljs-number\"\u003e3254555\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e7000000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1800000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2980000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2580000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e745000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2990000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2582672\u003c/span\u003e,\n        \u003cspan class=\"hljs-number\"\u003e3680000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1855000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2490000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e810000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1790000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2090000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e712035\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1061000\u003c/span\u003e,\n        \u003cspan class=\"hljs-number\"\u003e950000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1380000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e960000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e884000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1485200\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e63166\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e850000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e610000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e219000\u003c/span\u003e,\n        \u003cspan class=\"hljs-number\"\u003e324000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1030000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e570000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e473000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e817000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e404200\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1330000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e454000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1024000\u003c/span\u003e,\n        \u003cspan class=\"hljs-number\"\u003e534739\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e242259\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1093000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e900000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e644000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e270000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1547\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1522\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1509\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1498\u003c/span\u003e,\n        \u003cspan class=\"hljs-number\"\u003e1459\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1450\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1424\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1421\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1412\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1410\u003c/span\u003e],\n    \u003cspan class=\"hljs-string\"\u003e'평균유출량_m3_s'\u003c/span\u003e : [\n        \u003cspan class=\"hljs-number\"\u003e2800\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e209000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e30166\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e16792\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e18050\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2571\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e12475\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e22000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e41800\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e11400\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e15500\u003c/span\u003e,\n        \u003cspan class=\"hljs-number\"\u003e16000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e10300\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e5589\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e19800\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e767\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e13598\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e8080\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e7160\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e856\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e31200\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e8400\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e6210\u003c/span\u003e,\n        \u003cspan class=\"hljs-number\"\u003e3300\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e703\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3153\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e10100\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e82\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3600\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e7130\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e13000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4880\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1480\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e12037\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1400\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e6000\u003c/span\u003e,\n        \u003cspan class=\"hljs-number\"\u003e2575\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4300\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3800\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e270000\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1547\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1522\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1509\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1498\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1459\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1450\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1424\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1421\u003c/span\u003e,\n        \u003cspan class=\"hljs-number\"\u003e1412\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1410\u003c/span\u003e],\n    \u003cspan class=\"hljs-string\"\u003e'방출지'\u003c/span\u003e : [\n        \u003cspan class=\"hljs-string\"\u003e'지중해'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'대서양'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'동해'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'멕시코만'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'카라해'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'보해'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'오블만'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'리오데라플라타'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'대서양'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'오호츠크해'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'랩테프해'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'남중국해'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'보퍼트해'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'기니만'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'간지스'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'남쪽의해'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'대서양(마라조 만), 아마존 델타'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'카스피해'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'아라비아해'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'페르시아만'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'아마존'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'아마존'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'베링해'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'대서양'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'아랄해'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'안다만해'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'세인트로렌스만'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'멕시코만'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'예니세이강'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'흑해'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'안다만해'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'모잠비크해협'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'레나강'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'벵갈만'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'아랄해'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'아마존'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'헛슨만'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'파라나강'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'동시베리아해'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'파라과이강'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'옵강'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'이르티시강'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'카스피해'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'아마존'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'미시시피강'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'캘리포니아만'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'랩테프해'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'흑해'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'레나강'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'콩고'\u003c/span\u003e],\n    \u003cspan class=\"hljs-string\"\u003e'이름'\u003c/span\u003e: [\n        \u003cspan class=\"hljs-string\"\u003e'나일–화이트나일–카게라–냐바롱고–모고고–루카라라'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'아마존–우카야리–탐보–에네–만타롤'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'창강–금샤강–통티안강–당쿠강 (장강)'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'미시시피–미주리–제퍼슨–비버헤드–레드락–헬로링'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'예니세이강–앙가라강–셀렝가강–이더'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'황허강'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'오블강–이르티시강'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'리오데라플라타–파라나강–리오그란데'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'콩고강–잠베시 (자이료)'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'두문강–아르군강–헤를런 (흑룽강)'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'레나강'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'메콩 (랑창강)'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'맥케너지강–스레이브강–피스강–핀레이'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'니제르강'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'브라마푸트라–얀룽창포'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'머리–달링–컬고아–발론–콘다믄'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'토칸찐스–아라구아이아'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'볼가'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'인다스–생거 장보'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'샤트알아랍–유프라테스–무랏'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'마데이라–마모레–그랜데–케인–로차'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'푸르스'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'유곤'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'상프란시스코'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'시르다리야–나린'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'살윈 (누강)'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'세인트로렌스–나이아가라–디트로이트–세인트클레어–세인트\\\n        메리스–세인트루이스–노스 (그레이트레이크스)'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'리오그란데'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'하횡강'\u003c/span\u003e,\n        f\u003cspan class=\"hljs-string\"\u003e\"도나우–브렉','두네르','두롱강–납마이강–둘롱강–케라올올루–가다쿠\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'잠베지 (잠베지)'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'빌류이'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'간지스–후글리–팜다 (강가)'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'아무다리아–판즈'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'자푸라 (까퀘타)'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'넬슨–사스카추완'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'파라과이 (리오파라과이)'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'콜룸마'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'필코마요'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'상횡강–카툰'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'이심'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'우랄'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'주루아'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'아칸소어스'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'콜로라도 (미 서부)'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'올레니오크'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'드니프르'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'알단'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'우방기–우엘'\u003c/span\u003e]\n}\n\ndf = pd.\u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e(data)\ndf.\u003cspan class=\"hljs-title function_\"\u003eto_csv\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'강_시스템.csv'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e길이 (\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이것은 좋아 보이네요. Tableau에서 지도 레이어를 활용하기 위해 차트 다각형 및 중심점의 출력 데이터를 저장해봅시다. 나중에 사용할 삼각형의 좌표도 출력하여 나준합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 출력 파일 (\u003cspan class=\"hljs-title class_\"\u003eTableau\u003c/span\u003e에서 지도 레이어를 활용하기 위해 데이터 재조정)\n\n# \u003cspan class=\"hljs-title class_\"\u003eQuad\u003c/span\u003e-\u003cspan class=\"hljs-title class_\"\u003eTile\u003c/span\u003e 차트 다각형 출력\no_pqt.\u003cspan class=\"hljs-property\"\u003eo_polyquadtile_chart\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edataframe_rescale\u003c/span\u003e(-\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,-\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e)\no_pqt.\u003cspan class=\"hljs-property\"\u003eo_polyquadtile_chart\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edf\u003c/span\u003e = pd.\u003cspan class=\"hljs-title function_\"\u003emerge\u003c/span\u003e(\n    o_pqt.\u003cspan class=\"hljs-property\"\u003eo_polyquadtile_chart\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edf\u003c/span\u003e, df, left_on=\u003cspan class=\"hljs-string\"\u003e'item'\u003c/span\u003e, right_on=\u003cspan class=\"hljs-string\"\u003e'river'\u003c/span\u003e)\no_pqt.\u003cspan class=\"hljs-property\"\u003eo_polyquadtile_chart\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edf\u003c/span\u003e = o_pqt.\u003cspan class=\"hljs-property\"\u003eo_polyquadtile_chart\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edf\u003c/span\u003e[\n    [\u003cspan class=\"hljs-string\"\u003e'river'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'side'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'x'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'y'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'path'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'length_km'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'length_m'\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e'drainage_area_km2'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'average_discharge_m3_s'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'outflow'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'name'\u003c/span\u003e]]\no_pqt.\u003cspan class=\"hljs-property\"\u003eo_polyquadtile_chart\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edataframe_to_csv\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'quadtile'\u003c/span\u003e)\n\n# \u003cspan class=\"hljs-title class_\"\u003eQuad\u003c/span\u003e-\u003cspan class=\"hljs-title class_\"\u003eTile\u003c/span\u003e 차트 중심점 출력\no_pqt.\u003cspan class=\"hljs-property\"\u003eo_polysquares\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edataframe_rescale\u003c/span\u003e(-\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,-\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e)\no_pqt.\u003cspan class=\"hljs-property\"\u003eo_polysquares\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edf\u003c/span\u003e = pd.\u003cspan class=\"hljs-title function_\"\u003emerge\u003c/span\u003e(\n    o_pqt.\u003cspan class=\"hljs-property\"\u003eo_polysquares\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edf\u003c/span\u003e, df, left_on=\u003cspan class=\"hljs-string\"\u003e'id'\u003c/span\u003e, right_on=\u003cspan class=\"hljs-string\"\u003e'river'\u003c/span\u003e)\no_pqt.\u003cspan class=\"hljs-property\"\u003eo_polysquares\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edf\u003c/span\u003e = o_pqt.\u003cspan class=\"hljs-property\"\u003eo_polysquares\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edf\u003c/span\u003e[\n    [\u003cspan class=\"hljs-string\"\u003e'river'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'side'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'x'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'y'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'length_km'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'length_m'\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e'drainage_area_km2'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'average_discharge_m3_s'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'outflow'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'name'\u003c/span\u003e]]\no_pqt.\u003cspan class=\"hljs-property\"\u003eo_polysquares\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edataframe_to_csv\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'quadtile_centroids'\u003c/span\u003e)\n\n# 삼각형 컨테이너 좌표\npoly = o_pqt.\u003cspan class=\"hljs-property\"\u003econstraints\u003c/span\u003e\nrs_poly_yx = [(vf.\u003cspan class=\"hljs-title function_\"\u003erescale\u003c/span\u003e(y, -\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e),\n    vf.\u003cspan class=\"hljs-title function_\"\u003erescale\u003c/span\u003e(x, -\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)) \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e x,y \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e poly]\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(rs_poly_yx)\n# 결과:\n# [(-\u003cspan class=\"hljs-number\"\u003e0.691813852924281\u003c/span\u003e, -\u003cspan class=\"hljs-number\"\u003e0.9166666666666669\u003c/span\u003e), \n# (\u003cspan class=\"hljs-number\"\u003e0.8615194804090525\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e), \n# (-\u003cspan class=\"hljs-number\"\u003e0.691813852924281\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.9166666666666667\u003c/span\u003e)]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e마지막으로, 상호 작용을 더 활성화하기 위해 범례를 생성해봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e#%% 범례 플롯\ndf_legend = df.\u003cspan class=\"hljs-title function_\"\u003egroupby\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'outflow'\u003c/span\u003e)[\u003cspan class=\"hljs-string\"\u003e'name'\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003ecount\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003ereset_index\u003c/span\u003e()\no_pqt_legend = \u003cspan class=\"hljs-title function_\"\u003epqt\u003c/span\u003e(df_legend,\u003cspan class=\"hljs-string\"\u003e'outflow'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'name'\u003c/span\u003e, \n    constraints=[(\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)], collapse=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e,\n    rotate=\u003cspan class=\"hljs-number\"\u003e45\u003c/span\u003e, buffer=\u003cspan class=\"hljs-number\"\u003e.1\u003c/span\u003e, size_by=\u003cspan class=\"hljs-string\"\u003e'width'\u003c/span\u003e, sides=[\u003cspan class=\"hljs-string\"\u003e'top'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'right'\u003c/span\u003e])\no_pqt_legend.\u003cspan class=\"hljs-title function_\"\u003epolyquadtile_plot\u003c/span\u003e(show_constraints=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\n\n#%% 범례 데이터\no_pqt_legend.\u003cspan class=\"hljs-property\"\u003eo_polyquadtile_chart\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edataframe_rescale\u003c/span\u003e(-\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e,-\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e)\no_pqt_legend.\u003cspan class=\"hljs-property\"\u003eo_polyquadtile_chart\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edf\u003c/span\u003e = pd.\u003cspan class=\"hljs-title function_\"\u003emerge\u003c/span\u003e(\n    o_pqt_legend.\u003cspan class=\"hljs-property\"\u003eo_polyquadtile_chart\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edf\u003c/span\u003e, df_legend, \n    left_on=\u003cspan class=\"hljs-string\"\u003e'item'\u003c/span\u003e, right_on=\u003cspan class=\"hljs-string\"\u003e'outflow'\u003c/span\u003e)\no_pqt_legend.\u003cspan class=\"hljs-property\"\u003eo_polyquadtile_chart\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edf\u003c/span\u003e = o_pqt_legend.\u003cspan class=\"hljs-property\"\u003eo_polyquadtile_chart\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edf\u003c/span\u003e[\n    [\u003cspan class=\"hljs-string\"\u003e'outflow'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'side'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'x'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'y'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'path'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'name'\u003c/span\u003e]]\no_pqt_legend.\u003cspan class=\"hljs-property\"\u003eo_polyquadtile_chart\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edataframe_to_csv\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'quadtile_legend'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_31.png\" alt=\"그림\"\u003e\u003c/p\u003e\n\u003cp\u003e이제 Tableau를 준비했으니, 다음 3개 파일을 모두 가져오기 위해 텍스트 파일 옵션을 사용하여 시작해보겠습니다. Sheet 1로 이동한 다음, 상단 왼쪽 데이터 탭에서 쿼드타일 데이터 소스를 선택하고 다음과 같은 계산 열을 생성하세요:\u003c/p\u003e\n\u003cp\u003e먼저 맵 영역에서 마우스를 오른쪽 클릭하여 배경 레이어를 선택하고 다음 옵션을 조정해보세요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e모든 배경 맵 레이어 (베이스, 랜드 커버 등)을 선택 해제하세요.\u003c/li\u003e\n\u003cli\u003e이제 맵 영역에서 마우스를 오른쪽 클릭하고 맵 옵션을 선택한 다음, 패널에서 모든 옵션을 선택 해제하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e배경 레이어를 닫고 다음 단계를 계속해 보세요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e[Side]를 Marks 하위에 Detail로 드래그합니다.\u003c/li\u003e\n\u003cli\u003eMarks 드롭다운 메뉴에서 Polygon을 선택합니다.\u003c/li\u003e\n\u003cli\u003eColor 하위에서 검은색 테두리 색상을 선택하고 불투명도를 40%로 조절한 다음 색상을 연한 파랑색으로 설정합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음으로, 사각형에 대한 윤곽선 레이어를 추가해 봅시다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e[Squares]를 맵 영역으로 드래그하면 팝업이 나타납니다: Marks 레이어 추가 - 이를 클릭하여 새 맵 레이어를 만듭니다.\u003c/li\u003e\n\u003cli\u003e팝업 메뉴에서 드롭다운 메뉴를 통해 필드를 'Outlines'로 이름을 변경합니다.\u003c/li\u003e\n\u003cli\u003e[River]를 이 새로운 맵 레이어의 Marks 하위 Detail로 드래그합니다.\u003c/li\u003e\n\u003cli\u003eMarks 드롭다운 메뉴에서 Line을 선택합니다 (이 시점에서 이상하게 보인다 해도 걱정하지 마세요).\u003c/li\u003e\n\u003cli\u003e[Path]를 Marks 하위 Path로 드래그하고 차원으로 변환하는 프로세스를 반복합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e메인 스퀘어 레이어에 대해 Marks 드롭다운 메뉴에서 Polygon을 선택하여 새 레이어에 대해 위 과정을 반복하고, [Drainage Area Km2]로 색을 입힙니다. '시작: 0, 끝: 3,000,000'으로 설정해주세요.\u003c/p\u003e\n\u003cp\u003e마지막으로, 데이터 탭에서 quadtile_centroids를 선택하여 중심점을 사용하는 레이어를 추가하고, 다음과 같은 계산된 열을 추가해주세요:\u003c/p\u003e\n\u003cp\u003eTableau에서 올바른 크기 조정을 위해 길이를 제곱한 것을 알 수 있습니다. 이를 다음 단계에서 사용할 것입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e[Centroids]를 지도 영역으로 드래그하면 팝업이 표시됩니다: Marks 레이어 추가 - 피말을 해당 위치에 드래그하여 새 지도 레이어를 생성합니다.\u003c/li\u003e\n\u003cli\u003e이 새 지도 레이어에서 Marks 아래 Detail로 [River]를 드래그합니다.\u003c/li\u003e\n\u003cli\u003eMarks 드롭다운 메뉴에서 Circle을 선택합니다.\u003c/li\u003e\n\u003cli\u003e[Size]를 Marks 아래 Size로 드래그하고 이를 차원으로 변환하는 과정과 크기 틱을 두 번째 해시로 설정합니다.\u003c/li\u003e\n\u003cli\u003e[Average Discharge M3 S]를 Color로 드래그하고 하얀 테두리를 추가하고 '시작: 0, 끝: 50,000'으로 설정해주세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e오른쪽 하단에 널 경고 표시가 나타납니다. 이를 마우스 오른쪽 단추로 클릭하고 숨김 표시를 선택할 수 있습니다. 이 시점에서 상호작용 및 레이블을 나중에 구현하기 위해 아래에 표시된 몇 가지 다른 세부 정보와 속성을 추가한 것처럼 보일 것입니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_32.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e이제 대시보드의 소스 자료를 완성하기 위해 세 개의 시트를 추가해 보겠습니다. 설정을 위해 이미지를 참조하십시오.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\"Bars\" - quadtile_centroids 데이터 소스를 사용します.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_33.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e“범례” - quadtile_legend 데이터 소스 사용\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_34.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e“강” - quadtile_centroids 데이터 소스 사용, [이름]을 '정렬 기준: 필드, 정렬 순서: 내림차순, 필드 이름: [길이 Km], 집계: 최대값'으로 정렬 ('이름' 항목을 오른쪽 클릭하여 정렬... 선택)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_35.png\"\u003e\n\u003cp\u003e마지막 단계로, 이제 4개의 시트를 대시보드에 정리하고 대시보드 \u003ccode\u003e동작\u003c/code\u003e 아래의 상단 메뉴에서 몇 가지 동작을 설정해보겠습니다. 대시보드 \u003ccode\u003e동작\u003c/code\u003e 아래의 추가 동작 드롭다운을 클릭하고 \u003ccode\u003e하이라이트\u003c/code\u003e를 선택합니다. 대상 하이라이트에서 \u003ccode\u003e선택한 필드\u003c/code\u003e를 선택하고 [Outflow]과 [River] 필드를 선택합니다 ([Outflow]가 상기 시트에 세부사항으로 추가되었는지 확인). 마지막으로 오른쪽 상단의 \u003ccode\u003e실행 동작\u003c/code\u003e 아래에서 \u003ccode\u003e가리키기\u003c/code\u003e 옵션을 선택합니다.\u003c/p\u003e\n\u003cp\u003e마지막 동작으로 추가 동작 드롭다운을 클릭하고 다음 옵션을 사용하여 필터를 선택합니다: '소스 시트: 범례, 대상 시트: 강, 선택한 필드: Outflow \u003ccode\u003equadtile_centroids\u003c/code\u003e Outflow, 실행 동작: 선택시 실행, 선택 해제 시 모든 값 제외'. 이제 대시보드는 모든 시트에서 요청시 하이라이트를 표시하고 범례 시트에서 선택된 값에 대해 필터를 제외할 것입니다!\u003c/p\u003e\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1200/1*4CSKItCTjLiMaB7s09zolQ.gif\"\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e결론\u003c/h2\u003e\n\u003cp\u003e이 글에서 우리는 정방형이 원에 비해 채워진 도형 시각화에서 어떻게 성능을 발휘할 수 있는지 알아보기 위한 여정을 떠났습니다. 저희는 정방형의 적용을 테스트하기 위해 고수준 비교를 위한 최적화 프레임워크를 구현했고, 결국 정방형의 잠재력을 최대한 활용하기 위해 사용자 정의 알고리즘을 활용하기로 결정했습니다.\u003c/p\u003e\n\u003cp\u003e저는 \"쿼드-타일 차트\"라고 명명한 것에 대한 상세한 안내서를 제공합니다. 이 차트는 값 세트를 시각화하는 데 사용되며, 또한 값 ​​계층 구조를 시각화하거나 시각화 캔버스의 사용 가능한 공간을 고려해 원하는 다각형 컨테이너 내에 정방형을 패킹하는 기능을 제공하는 \"스퀘어맵\"으로 확장됩니다.\u003c/p\u003e\n\u003cp\u003e현재 데이터 시각화 공간에서 사용되는 주요 원 패킹 구현과는 다르게 다각형 컨테이너는 주요 장점으로 작용하며, Squaremap을 통해 계층 데이터는 새로운 집을 찾을 수 있습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e가능하면, Quad-Tile Chart의 사각형 배열은 시각적으로 매력적으로 보입니다 (원과 경쟁하기 위해 필수적입니다!) 그리고 사각형은 원의 중심에 배치된 원들과 서로 바꿔 쓸 수 있습니다 (반응형인 Bubble Chart를 위해) 이것은 데이터를 사각형으로 구성하는 경향을 정당화하기 위한 우리의 노력의 승리로 결론내릴 수 있습니다.\u003c/p\u003e\n\u003cp\u003e각종 데이터 시리즈와 계층이 모든 코너를 도발하고 있을 때, 여러분이 이러한 시각화 기술을 데이터 탐색 여정에서 유용한 도구로 활용하길 바랍니다!\u003c/p\u003e\n\u003ch2\u003e참고 자료\u003c/h2\u003e\n\u003cp\u003e본 문서에 포함된 모든 이미지는 별도로 명시하지 않은 한 저자가 제작했습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e[1] 위키백과 (CC BY-SA), “최고의 빠른 동물” (기준일: 2024년 1월 26일)\u003c/p\u003e\n\u003cp\u003e[2] 위키백과 (CC BY-SA), “길이별 강 시스템 목록” (기준일: 2024년 1월 26일)\u003c/p\u003e\n\u003cp\u003e관련 기사\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e복잡한 집합 관계를 시각화하는 Multi-Chord Diagram 소개\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData"},"buildId":"xx51Gh_JNHDTBdDwrgykD","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>