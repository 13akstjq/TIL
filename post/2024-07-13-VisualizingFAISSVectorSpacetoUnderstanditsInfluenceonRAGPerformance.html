<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>FAISS 벡터 공간 시각화를 통한 RAG 성능 이해하기 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="FAISS 벡터 공간 시각화를 통한 RAG 성능 이해하기 | TIL" data-gatsby-head="true"/><meta property="og:title" content="FAISS 벡터 공간 시각화를 통한 RAG 성능 이해하기 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance" data-gatsby-head="true"/><meta name="twitter:title" content="FAISS 벡터 공간 시각화를 통한 RAG 성능 이해하기 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-13 19:04" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/TIL/_next/static/chunks/463-925361deb4cec4b1.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-9d7ebbd29b9e08ce.js" defer=""></script><script src="/TIL/_next/static/FuXRqV9h16krA5Mvtd6Dn/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/FuXRqV9h16krA5Mvtd6Dn/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">FAISS 벡터 공간 시각화를 통한 RAG 성능 이해하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="FAISS 벡터 공간 시각화를 통한 RAG 성능 이해하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 13, 2024</span><span class="posts_reading_time__f7YPP">17<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_0.png">
<p>오픈 소스 대형 언어 모델의 성능이 계속해서 향상되면서, 코드 작성 및 분석, 추천, 텍스트 요약 및 질문-응답(QA)을 포함한 다양한 응용 프로그램에 진입하고 있습니다. QA 관련 질문에 대해 언어 모델이 자주 실패하는데, 이는 훈련 중에 사용되지 않은 문서와 관련된 질문들에 적용될 때 발생합니다. 그리고 이러한 내부 문서들 중 많은 것들은 규정 준수, 영업 비밀 또는 개인 정보 보호를 위해 기업의 벽 안에 유지되어야 합니다. 이러한 문서에 대해 쿼리를 실행할 때, 언어 모델은 가상 현상을 겪는데, 이는 관련 없거나 가짜 또는 일관성 없는 내용을 생성합니다.</p>
<p>이러한 도전과제를 해결하기 위한 하나의 기술은 검색 보강 생성(Retrieval-Augmented Generation, RAG)입니다. 이는 답변 생성 이전에 훈련 데이터 소스 외부의 권위 있는 지식 베이스를 참조하여 언어 모델의 응답을 개선하는 과정을 포함합니다. RAG 어플리케이션은 말뭉치로부터 관련 문서 단편을 가져오는 검색 시스템과, 검색된 단편을 컨텍스트로 사용하여 답변을 생성하는 언어 모델로 구성됩니다. 당연히, 말뭉치의 품질과 그것이 표현된 벡터 공간, 즉 임베딩(embeddings)은 RAG의 정확도에 중요한 역할을 할 것입니다.</p>
<p>본 기사에서는 FAISS 벡터 공간의 다차원 임베딩을 renumics-spotlight 시각화 라이브러리를 사용하여 2차원으로 시각화하는 방법을 살펴보겠습니다. 특정 핵심 벡터화 매개변수를 변화시킴으로써 RAG 응답 정확도를 향상시킬 기회를 찾아보겠습니다. 그리고 선택한 언어 모델로는 TinyLlama 1.1B Chat을 채택할 것인데, 이는 Llama 2와 동일한 아키텍처와 토크나이저를 갖추고 있습니다 [1]. 이 모델은 리소스 풋프린트가 상당히 작고 빠른 실행 시간을 가지고 있으면서 정확도가 비례적으로 감소하지 않는 장점을 갖추고 있습니다. 이는 빠른 실험에 이상적입니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>목차</h2>
<p>1.0 환경 설정
2.0 설계 및 구현
2.1 LoadFVectorize 모듈
2.2 주요 모듈
3.0 테스트 실행
3.1 청크 크기 및 중첩 매개변수 테스트
4.0 최종 생각</p>
<h1>1.0 환경 설정</h1>
<p>이 실험은 8GB RAM을 갖춘 MacBook Air M1에서 수행될 예정입니다. 여기서 사용하는 Python 버전은 3.10.5입니다. 먼저, 이 프로젝트를 관리하기 위해 가상 환경을 생성해 봅시다. 환경을 생성하고 활성화하기 위해 다음을 실행해 봅시다:</p>
<pre><code class="hljs language-js">python3<span class="hljs-number">.10</span> -m venv mychat
source mychat/bin/activate
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Library renumics-spotlight은 UMAP와 유사한 시각화를 사용하여 고차원 임베딩을 더 관리하기 쉬운 2D 시각화로 줄이는 동시에 중요한 속성을 보존합니다 [2]. 이제 필요한 모든 라이브러리를 설치해 보겠습니다:</p>
<pre><code class="hljs language-js">pip install langchain faiss-cpu sentence-transformers flask-sqlalchemy psutil unstructured pdf2image unstructured_inference pillow_heif opencv-python pikepdf pypdf
pip install renumics-spotlight
<span class="hljs-variable constant_">CMAKE_ARGS</span>=<span class="hljs-string">"-DLLAMA_METAL=on"</span> <span class="hljs-variable constant_">FORCE_CMAKE</span>=<span class="hljs-number">1</span> pip install --upgrade --force-reinstall llama-cpp-python --no-cache-dir
</code></pre>
<p>위의 마지막 줄은 M1 프로세서에서 하드웨어 가속을 사용하여 TinyLlama를 로드하는 데 사용될 메탈 지원이 포함된 llama-cpp-python 라이브러리를 설치하는 것을 의미합니다. Metal을 사용하면 계산이 GPU에서 실행됩니다.</p>
<p>환경이 준비되었으므로 시스템 설계를 살펴보고 구현을 따라갑시다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>2.0 디자인 및 구현</h1>
<p>이 QA 시스템에는 그림 1에 설명된 두 모듈이 있습니다.</p>
<p><img src="/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_1.png" alt="이미지"></p>
<p>LoadFVectorize 모듈은 PDF 또는 웹 문서를 로드하는 작업을 포함합니다. 초기 테스트 및 시각화를 위해, 최근에 출시된 (2023년 12월) 440페이지의 벤더 배포 가이드가 관심 문서로 사용됩니다. 이 모듈은 문서의 분할 및 벡터화를 처리합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>두 번째 모듈은 LLM을 로드하고 FAISS 검색기를 인스턴스화한 후, LLM, 검색기 및 사용자 정의 프롬프트를 포함하는 검색 체인을 생성하는 것으로 구성되어 있습니다. 마지막으로 벡터 공간 시각화를 시작합니다.</p>
<p>두 모듈의 세부 정보는 더 설명되어 있습니다.</p>
<h2>2.1 Module LoadFVectorize</h2>
<p>이 모듈은 3가지 함수로 구성되어 있습니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>load_doc 함수는 온라인 pdf 문서를 로드하고, 512자씩 묶어 chunk 단위로 나누며 100자의 overlap을 가지고 문서 목록을 반환합니다.</li>
<li>vectorize 함수는 위 load_doc 함수를 호출하여 문서의 chunked 목록을 가져와 임베딩을 생성하고 opdf_index 로컬 디렉토리에 저장한 뒤 FAISS 인스턴스를 반환합니다.</li>
<li>load_db 함수는 opdf_index 디렉토리 내에 FAISS 벡터 저장소가 있는지 확인하고, 없는 경우 vectorize 함수를 호출하여 문서를 로드하고 벡터화합니다. 최종적으로 FAISS 객체를 반환합니다.</li>
</ul>
<p>이 모듈의 전체 코드 목록은 아래와 같습니다.</p>
<pre><code class="hljs language-python"><span class="hljs-comment"># LoadFVectorize.py</span>

<span class="hljs-keyword">from</span> langchain_community.embeddings <span class="hljs-keyword">import</span> HuggingFaceEmbeddings
<span class="hljs-keyword">from</span> langchain_community.document_loaders <span class="hljs-keyword">import</span> OnlinePDFLoader
<span class="hljs-keyword">from</span> langchain.text_splitter <span class="hljs-keyword">import</span> RecursiveCharacterTextSplitter
<span class="hljs-keyword">from</span> langchain_community.vectorstores <span class="hljs-keyword">import</span> FAISS

<span class="hljs-comment"># 온라인 pdf에 접근</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">load_doc</span>() -> <span class="hljs-string">'List[Document]'</span>:
    loader = OnlinePDFLoader(<span class="hljs-string">"https://support.riverbed.com/bin/support/download?did=7q6behe7hotvnpqd9a03h1dji&#x26;version=9.15.0"</span>)
    documents = loader.load()
    text_splitter = RecursiveCharacterTextSplitter(chunk_size=<span class="hljs-number">512</span>, chunk_overlap=<span class="hljs-number">100</span>)
    docs = text_splitter.split_documents(documents)
    <span class="hljs-keyword">return</span> docs

<span class="hljs-comment"># 벡터화 및 디스크에 저장</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">vectorize</span>(<span class="hljs-params">embeddings_model</span>) -> <span class="hljs-string">'FAISS'</span>:
    docs = load_doc()
    db = FAISS.from_documents(docs, embeddings_model)
    db.save_local(<span class="hljs-string">"./opdf_index"</span>)
    <span class="hljs-keyword">return</span> db

<span class="hljs-comment"># 디스크에서 벡터 저장소를 로드하려고 시도</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">load_db</span>() -> <span class="hljs-string">'FAISS'</span>:
    embeddings_model = HuggingFaceEmbeddings()
    <span class="hljs-keyword">try</span>:
        db = FAISS.load_local(<span class="hljs-string">"./opdf_index"</span>, embeddings_model)
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f'Exception: <span class="hljs-subst">{e}</span>\n디스크에 인덱스가 없음, 새로 생성 중...'</span>)
        db = vectorize(embeddings_model)
    <span class="hljs-keyword">return</span> db
</code></pre>
<h2>2.2 메인 모듈</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>주요 모듈은 먼저 TinyLlama에 대한 프롬프트 템플릿을 정의합니다. 템플릿은 다음과 같습니다:</p>
<p><code>|system|</code>'context'<code>/s``|user|</code>'question'<code>/s``|assistant|</code></p>
<p>LLM 메모리 사용량을 더 줄이기 위해, TheBloke의 HuggingFace 레포지토리 [3]에서 TinyLlama의 양자화된 버전을 채택할 것입니다. 이는 모델 매개변수에 더 적은 비트를 사용하는 방식입니다. 이 LLM에 대한 추가적인 배경 정보나 활성화 기술에 대해 더 자세히 알고 싶은 분들은 이전에 작성한 기사를 확인해보세요. GGUF 형식으로 양자화된 LLM을 로드하기 위해 LlamaCpp를 사용합니다. 이전 모듈에서 반환된 FAISS 객체를 사용하여 FAISS retriever가 생성됩니다. 이러한 객체들을 사용하여 RetrievalQA 체인을 생성하고 질문에 사용합니다.</p>
<p>아래 코드는 이러한 단계를 포착합니다.</p>
<pre><code class="hljs language-js"># main.<span class="hljs-property">py</span>
<span class="hljs-keyword">from</span> langchain.<span class="hljs-property">chains</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">RetrievalQA</span>
<span class="hljs-keyword">from</span> langchain.<span class="hljs-property">prompts</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">PromptTemplate</span>
<span class="hljs-keyword">from</span> langchain_community.<span class="hljs-property">llms</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">LlamaCpp</span>
<span class="hljs-keyword">from</span> langchain_community.<span class="hljs-property">embeddings</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">HuggingFaceEmbeddings</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">LoadFVectorize</span>
<span class="hljs-keyword">from</span> renumics <span class="hljs-keyword">import</span> spotlight
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np

# 프롬프트 템플릿
qa_template = <span class="hljs-string">""</span><span class="hljs-string">"&#x3C;|system|>
정확하게 대답하는 친근한 채팅 봇입니다. 
알 수 없는 답변일 경우 공손하게 알려드릴 것입니다.
다음 맥락을 사용하여 아래 질문에 답변해주세요:
{context}&#x3C;/s>
&#x3C;|user|>
{question}&#x3C;/s>
&#x3C;|assistant|>
"</span><span class="hljs-string">""</span>

# 프롬프트 인스턴스 생성
<span class="hljs-variable constant_">QA_PROMPT</span> = <span class="hljs-title class_">PromptTemplate</span>.<span class="hljs-title function_">from_template</span>(qa_template)
# <span class="hljs-variable constant_">LLM</span> 로드
llm = <span class="hljs-title class_">LlamaCpp</span>(
    model_path=<span class="hljs-string">"./models/tinyllama_gguf/tinyllama-1.1b-chat-v1.0.Q5_K_M.gguf"</span>,
    temperature=<span class="hljs-number">0.01</span>,
    max_tokens=<span class="hljs-number">2000</span>,
    top_p=<span class="hljs-number">1</span>,
    verbose=<span class="hljs-title class_">False</span>,
    n_ctx=<span class="hljs-number">2048</span>
)
# 벡터화 및 retriever 생성
db = <span class="hljs-title class_">LoadFVectorize</span>.<span class="hljs-title function_">load_db</span>()
faiss_retriever = db.<span class="hljs-title function_">as_retriever</span>(search_type=<span class="hljs-string">"mmr"</span>, search_kwargs={<span class="hljs-string">'fetch_k'</span>: <span class="hljs-number">3</span>}, max_tokens_limit=<span class="hljs-number">1000</span>)
# <span class="hljs-variable constant_">QA</span> 체인 정의
qa_chain = <span class="hljs-title class_">RetrievalQA</span>.<span class="hljs-title function_">from_chain_type</span>(
    llm,
    retriever=faiss_retriever,
    chain_type_kwargs={<span class="hljs-string">"prompt"</span>: <span class="hljs-variable constant_">QA_PROMPT</span>}
)

query = <span class="hljs-string">'What versions of TLS supported by Client Accelerator 6.3.0?'</span>

result = <span class="hljs-title function_">qa_chain</span>({<span class="hljs-string">"query"</span>: query})
<span class="hljs-title function_">print</span>(f<span class="hljs-string">'--------------\nQ: {query}\nA: {result["result"]}'</span>)

<span class="hljs-title function_">visualize_distance</span>(db,query,result[<span class="hljs-string">"result"</span>])
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>벡터 공간 시각화 자체는 위 코드 목록의 마지막 줄인 visualize_distance에 의해 처리됩니다. 이 기능 또한 이 모듈에 정의되어 있습니다.</p>
<p>visualize_distance 함수에서는 먼저 FAISS 객체의 <strong>dict</strong> 속성에 액세스해야 합니다. 이는 인스턴스 변수용 사전입니다. 이를 통해 docstore에 액세스할 수 있습니다. 인스턴스 변수 index_to_docstore_id는 키 인덱스로 값 docstore-id의 사전입니다. 벡터화에 사용된 총 문서 수는 인덱스 객체의 ntotal 속성으로 나타냅니다.</p>
<pre><code class="hljs language-js">    vs = db.<span class="hljs-property">__dict__</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">"docstore"</span>)
    index_list = db.<span class="hljs-property">__dict__</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">"index_to_docstore_id"</span>).<span class="hljs-title function_">values</span>()
    doc_cnt = db.<span class="hljs-property">index</span>.<span class="hljs-property">ntotal</span>
</code></pre>
<p>벡터 공간을 대략적으로 복원하기 위해 우리는 단순히 객체 인덱스의 메서드인 reconstruct_n을 기본 매개변수와 함께 호출합니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">   embeddings_vec = db.<span class="hljs-property">index</span>.<span class="hljs-title function_">reconstruct_n</span>()
</code></pre>
<p>이제 인덱스 목록으로 문서 저장소 ID 목록이 있으므로, 관련 문서 객체를 찾아 해당 ID, 문서 메타데이터, 문서 내용 및 벡터 공간 내 임베딩을 포함하는 리스트를 생성해보겠습니다. 아래 코드를 참조해주세요.</p>
<pre><code class="hljs language-js">   doc_list = <span class="hljs-title function_">list</span>() 
   <span class="hljs-keyword">for</span> i, doc_id <span class="hljs-keyword">in</span> <span class="hljs-title function_">enumerate</span>(index_list):
       a_doc = vs.<span class="hljs-title function_">search</span>(doc_id)
       doc_list.<span class="hljs-title function_">append</span>([doc_id, a_doc.<span class="hljs-property">metadata</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">"source"</span>), a_doc.<span class="hljs-property">page_content</span>, embeddings_vec[i]])
</code></pre>
<p>그런 다음 이 리스트를 사용하여 열 제목이 있는 데이터프레임을 생성한 후, 시각화를 만들기 위해 spotlight 호출에 사용될 것입니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-python">    df = pd.DataFrame(doc_list, columns=[<span class="hljs-string">'id'</span>, <span class="hljs-string">'metadata'</span>, <span class="hljs-string">'document'</span>, <span class="hljs-string">'embedding'</span>])
</code></pre>
<p>시각화를 진행하기 전에 질문과 답변을 통합할 방법을 찾아야 합니다. 질문 및 답변을 위한 별도의 데이터프레임을 생성하고 주요 데이터프레임과 병합하여 두 데이터가 나머지 문서 청크와 함께 어디에 나타나는지 보여줄 수 있도록합니다:</p>
<pre><code class="hljs language-python">    <span class="hljs-comment"># 질문 및 답변을 위한 행 추가</span>
    embeddings_model = HuggingFaceEmbeddings()
    question_df = pd.DataFrame(
        {
            <span class="hljs-string">"id"</span>: <span class="hljs-string">"question"</span>,
            <span class="hljs-string">"question"</span>: question,
            <span class="hljs-string">"embedding"</span>: [embeddings_model.embed_query(question)],
        })
    answer_df = pd.DataFrame(
        {
            <span class="hljs-string">"id"</span>: <span class="hljs-string">"answer"</span>,
            <span class="hljs-string">"answer"</span>: answer,
            <span class="hljs-string">"embedding"</span>: [embeddings_model.embed_query(answer)],
        })
    df = pd.concat([question_df, answer_df, df])
</code></pre>
<p>이 공간에서 질문과 문서 간의 유클리드 거리를 찾으려면 질문을 위한 임베딩을 만든 다음 문서와 질문 임베딩 차이에 대해 numpy의 <code>linalg.norm</code>을 사용하십시오:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">    question_embedding = embeddings_model.<span class="hljs-title function_">embed_query</span>(question)
    # 벡터 거리를 나타내는 열 추가
    df[<span class="hljs-string">"dist"</span>] = df.<span class="hljs-title function_">apply</span>(                                                                                                                                                                         
        lambda <span class="hljs-attr">row</span>: np.<span class="hljs-property">linalg</span>.<span class="hljs-title function_">norm</span>(
            np.<span class="hljs-title function_">array</span>(row[<span class="hljs-string">"embedding"</span>]) - question_embedding
        ),axis=<span class="hljs-number">1</span>,)
</code></pre>
<p>데이터프레임을 얻었으면 spotlight.show를 호출하여 시각화를 생성합니다.</p>
<pre><code class="hljs language-js">spotlight.<span class="hljs-title function_">show</span>(df)
</code></pre>
<p>왔어요! 이렇게 하면 브라우저 창에서 spotlight가 열리고 pandas 데이터프레임이 탐색 준비가 됩니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>아래 GitHub 저장소에서 모든 코드에 액세스할 수 있습니다:</p>
<h2>3.0 테스트 실행</h2>
<p>첫 번째 실험을 용이하게하기 위해 선택된 샘플 질문은 아래와 같습니다:</p>
<p>채택된 문서에 따르면, 올바른 답은 :</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>또한, 다음 추가 정보가 응답에 포함될 수 있습니다.</p>
<p>아래는 위 질문에 대한 TinyLlama의 응답입니다:</p>
<p>이 응답은 실제 답변과 꽤 유사해 보이지만, 이 TLS 버전들이 기본값은 아니라는 점에서 완전히 정확하지는 않습니다.</p>
<p>Fig. 2는 스포트라이트의 스크린샷을 나타냅니다. 왼쪽 상단의 테이블 섹션에는 데이터프레임의 모든 열이 표시되고 시각화는 유사성 맵 탭 뷰 내에서 표시됩니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_2.png" alt="링크 텍스트"></p>
<p>가시적인 열 버튼을 사용하여 표시되는 열을 제어할 수 있습니다. "dist"로 테이블을 정렬하면 상위에 질문, 답변 및 가장 관련성 높은 문서 스니펫이 나타납니다. 임베딩 시각화를 살펴보면 여기의 거의 모든 문서를 하나의 클러스터로 나타냅니다. 이는 원래 pdf가 특정 제품의 배포 가이드임을 감안할 때 합리적일 것으로 생각됩니다. Similarity Map 탭 내의 필터 아이콘을 클릭하면 선택한 문서 목록만 강조 표시되며 나머지는 회색으로 표시됩니다(Fig. 3 참조).</p>
<p><img src="/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_3.png" alt="링크 텍스트"></p>
<h2>3.1 테스트 청크 크기 및 겹치기 매개변수</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>리트리버가 RAG 성능에 중요한 영향을 미친다고 해서, 우리는 임베딩 공간에 영향을 주는 몇 가지 매개변수를 살펴보겠습니다. 테이블 1은 문서 분할 중 TextSplitter의 청크 크기 (1000, 2000) 및/또는 오버랩 (100, 200) 매개변수가 다양하게 변할 때, TinyLlama의 응답을 포착하고 정리합니다.</p>
<p><img src="/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_4.png" alt="Image"></p>
<p>첫눈에, 모든 조합의 LLM 응답이 비슷해 보입니다. 그러나 정확한 답변과 각 응답을 주의 깊게 비교하면, 정확한 답변은 (1000, 200) 조합에 해당합니다. 다른 응답에서의 부정확한 세부사항은 빨간색으로 강조되었습니다. 이러한 행동을 설명하기 위해, Fig. 3은 각 조합에 대한 임베딩 맵을 옆으로 나란히 보여줍니다.</p>
<p><img src="/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_5.png" alt="Image"></p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>왼쪽부터 오른쪽으로 청크 크기를 증가시키면서 벡터 공간이 더 드문 형태로 변해갑니다. 아래에서 위로 가면 겹침이 두 배가 된 곳에서도 벡터 공간의 특성이 급격하게 변하지는 않습니다. 이 모든 맵에서 전체 컬렉션은 여전히 한 클러스터처럼 보이며 몇 개의 이상치만 존재합니다. 이는 생성된 응답에서 명확히 반영되며, 이들은 상당히 유사합니다. 질의가 클러스터의 중심에 있는 경우, 이웃들이 다를 가능성이 높으므로 이러한 매개변수의 변화에 따라 응답이 상당히 달라질 수 있습니다.</p>
<p>RAG 애플리케이션이 특정 질문에 대해 기대한 답변을 제공하지 않는 경우, 해당 질문들과 함께 위와 같은 시각화를 생성함으로써 말뭉치를 어떻게 분할하여 전체 성능을 개선할지에 대한 추가 통찰을 얻을 수 있습니다.</p>
<p>그리고 좀 더 설명하기 위해, 상관 없는 도메인의 두 개의 위키백과 문서가 차지하는 벡터 공간을 시각화해 봅시다. 이를 위해 LoadFVectorize 모듈 내 load_doc 함수의 첫 줄을 수정하여 웹 기반 두 URL의 WebBasedLoader를 구현하면 됩니다. 하나는 그래미 어워즈에 관한 것이고, 다른 하나는 JWST 망원경에 대한 것입니다. 아래와 같이 나타납니다.</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">load_doc</span>():
    loader = <span class="hljs-title class_">WebBaseLoader</span>([<span class="hljs-string">'https://en.wikipedia.org/wiki/66th_Annual_Grammy_Awards'</span>,<span class="hljs-string">'https://en.wikipedia.org/wiki/James_Webb_Space_Telescope'</span>])
    documents = loader.<span class="hljs-title function_">load</span>()
    ...
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>나머지 코드는 그대로 유지하고 있는 것을 확인하면, 우리는 그림 5에 나타난 벡터 공간 시각화를 얻을 수 있습니다.</p>
<img src="/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_6.png">
<p>예상대로, 여기에는 두 개의 명확하게 겹치지 않는 클러스터가 있습니다. 우리가 두 클러스터 모두 벗어난 질문을 하면, 검색기에서 얻는 결과 문맥은 적어도 LLM에게 도움이 되지는 않을 것이지만 오히려 해로울 것입니다. 그리고 재미로, 나는 이전에 묻은 같은 질문을 한 번 더 던져보기로 결정했습니다. 그리고 확실히 LLM은 환각하기 시작했습니다.</p>
<p>여기 우리 시스템 디자인에는 벡터 저장을 위해 FAISS를 사용했습니다. 만약 당신이 ChromaDB를 사용하고 비슷한 시각화를 수행하는 방법을 궁금해 한다면, 당신은 운이 좋습니다. renumics-spotlight 라이브러리 개발자 중 Markus Stoll이 여기에 관련된 흥미로운 기사를 썼습니다. 확인해보세요.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>4.0 마무리</h1>
<p>Retrieval-Augmented Generation (RAG)은 내부 문서에 교육되지 않은 큰 언어 모델(LM)을 활용할 수 있게 해줍니다. RAG은 벡터 저장소에서 여러 관련 문서 청크를 검색하여 LM이 생성을 위한 문맥으로 사용합니다. 따라서 임베딩의 품질은 RAG 성능에 중요한 역할을 합니다.</p>
<p>이 기사에서는 주요 벡터화 매개변수 중 일부가 전체 LM 성능에 미치는 영향을 시연하고 시각화했습니다. 우리는 리소스 풋프린트가 훨씬 작지만 여전히 높은 정확도를 자랑하는 TinyLlama 1.1B Chat를 선택했습니다. 라이브러리 'renumics-spotlight'를 사용하여 FAISS 벡터 공간 전체를 데이터프레임으로 표현하는 방법을 보여주었으며, 이를 사용하여 한 줄의 코드로 임베딩을 시각화했습니다. Spotlight의 직관적인 UI를 통해 질문에 대한 벡터 공간을 탐색하고, 이를 통해 LM의 응답을 더 잘 이해할 수 있습니다. 특정 벡터화 매개변수를 조정함으로써, 성능을 향상시키기 위해 생성 및 행동을 제어할 수 있습니다.</p>
<p>읽어 주셔서 감사합니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>참고 자료</h2>
<ol>
<li><a href="https://huggingface.co/TinyLlama/TinyLlama-1.1B-Chat-v1.0" rel="nofollow" target="_blank">TinyLlama-1.1B-Chat-v1.0</a></li>
<li><a href="https://github.com/Renumics/spotlight" rel="nofollow" target="_blank">spotlight</a></li>
<li><a href="https://huggingface.co/TheBloke/TinyLlama-1.1B-Chat-v1.0-GGUF" rel="nofollow" target="_blank">TinyLlama-1.1B-Chat-v1.0-GGUF</a></li>
</ol>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"FAISS 벡터 공간 시각화를 통한 RAG 성능 이해하기","description":"","date":"2024-07-13 19:04","slug":"2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance","content":"\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_0.png\" /\u003e\n\n오픈 소스 대형 언어 모델의 성능이 계속해서 향상되면서, 코드 작성 및 분석, 추천, 텍스트 요약 및 질문-응답(QA)을 포함한 다양한 응용 프로그램에 진입하고 있습니다. QA 관련 질문에 대해 언어 모델이 자주 실패하는데, 이는 훈련 중에 사용되지 않은 문서와 관련된 질문들에 적용될 때 발생합니다. 그리고 이러한 내부 문서들 중 많은 것들은 규정 준수, 영업 비밀 또는 개인 정보 보호를 위해 기업의 벽 안에 유지되어야 합니다. 이러한 문서에 대해 쿼리를 실행할 때, 언어 모델은 가상 현상을 겪는데, 이는 관련 없거나 가짜 또는 일관성 없는 내용을 생성합니다.\n\n이러한 도전과제를 해결하기 위한 하나의 기술은 검색 보강 생성(Retrieval-Augmented Generation, RAG)입니다. 이는 답변 생성 이전에 훈련 데이터 소스 외부의 권위 있는 지식 베이스를 참조하여 언어 모델의 응답을 개선하는 과정을 포함합니다. RAG 어플리케이션은 말뭉치로부터 관련 문서 단편을 가져오는 검색 시스템과, 검색된 단편을 컨텍스트로 사용하여 답변을 생성하는 언어 모델로 구성됩니다. 당연히, 말뭉치의 품질과 그것이 표현된 벡터 공간, 즉 임베딩(embeddings)은 RAG의 정확도에 중요한 역할을 할 것입니다.\n\n본 기사에서는 FAISS 벡터 공간의 다차원 임베딩을 renumics-spotlight 시각화 라이브러리를 사용하여 2차원으로 시각화하는 방법을 살펴보겠습니다. 특정 핵심 벡터화 매개변수를 변화시킴으로써 RAG 응답 정확도를 향상시킬 기회를 찾아보겠습니다. 그리고 선택한 언어 모델로는 TinyLlama 1.1B Chat을 채택할 것인데, 이는 Llama 2와 동일한 아키텍처와 토크나이저를 갖추고 있습니다 [1]. 이 모델은 리소스 풋프린트가 상당히 작고 빠른 실행 시간을 가지고 있으면서 정확도가 비례적으로 감소하지 않는 장점을 갖추고 있습니다. 이는 빠른 실험에 이상적입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 목차\n1.0 환경 설정\n2.0 설계 및 구현\n   2.1 LoadFVectorize 모듈\n   2.2 주요 모듈\n3.0 테스트 실행\n   3.1 청크 크기 및 중첩 매개변수 테스트\n4.0 최종 생각\n\n# 1.0 환경 설정\n\n이 실험은 8GB RAM을 갖춘 MacBook Air M1에서 수행될 예정입니다. 여기서 사용하는 Python 버전은 3.10.5입니다. 먼저, 이 프로젝트를 관리하기 위해 가상 환경을 생성해 봅시다. 환경을 생성하고 활성화하기 위해 다음을 실행해 봅시다:\n\n```js\npython3.10 -m venv mychat\nsource mychat/bin/activate\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLibrary renumics-spotlight은 UMAP와 유사한 시각화를 사용하여 고차원 임베딩을 더 관리하기 쉬운 2D 시각화로 줄이는 동시에 중요한 속성을 보존합니다 [2]. 이제 필요한 모든 라이브러리를 설치해 보겠습니다:\n\n```js\npip install langchain faiss-cpu sentence-transformers flask-sqlalchemy psutil unstructured pdf2image unstructured_inference pillow_heif opencv-python pikepdf pypdf\npip install renumics-spotlight\nCMAKE_ARGS=\"-DLLAMA_METAL=on\" FORCE_CMAKE=1 pip install --upgrade --force-reinstall llama-cpp-python --no-cache-dir\n```\n\n위의 마지막 줄은 M1 프로세서에서 하드웨어 가속을 사용하여 TinyLlama를 로드하는 데 사용될 메탈 지원이 포함된 llama-cpp-python 라이브러리를 설치하는 것을 의미합니다. Metal을 사용하면 계산이 GPU에서 실행됩니다.\n\n환경이 준비되었으므로 시스템 설계를 살펴보고 구현을 따라갑시다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 2.0 디자인 및 구현\n\n이 QA 시스템에는 그림 1에 설명된 두 모듈이 있습니다.\n\n![이미지](/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_1.png)\n\nLoadFVectorize 모듈은 PDF 또는 웹 문서를 로드하는 작업을 포함합니다. 초기 테스트 및 시각화를 위해, 최근에 출시된 (2023년 12월) 440페이지의 벤더 배포 가이드가 관심 문서로 사용됩니다. 이 모듈은 문서의 분할 및 벡터화를 처리합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n두 번째 모듈은 LLM을 로드하고 FAISS 검색기를 인스턴스화한 후, LLM, 검색기 및 사용자 정의 프롬프트를 포함하는 검색 체인을 생성하는 것으로 구성되어 있습니다. 마지막으로 벡터 공간 시각화를 시작합니다.\n\n두 모듈의 세부 정보는 더 설명되어 있습니다.\n\n## 2.1 Module LoadFVectorize\n\n이 모듈은 3가지 함수로 구성되어 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- load_doc 함수는 온라인 pdf 문서를 로드하고, 512자씩 묶어 chunk 단위로 나누며 100자의 overlap을 가지고 문서 목록을 반환합니다.\n- vectorize 함수는 위 load_doc 함수를 호출하여 문서의 chunked 목록을 가져와 임베딩을 생성하고 opdf_index 로컬 디렉토리에 저장한 뒤 FAISS 인스턴스를 반환합니다.\n- load_db 함수는 opdf_index 디렉토리 내에 FAISS 벡터 저장소가 있는지 확인하고, 없는 경우 vectorize 함수를 호출하여 문서를 로드하고 벡터화합니다. 최종적으로 FAISS 객체를 반환합니다.\n\n이 모듈의 전체 코드 목록은 아래와 같습니다.\n\n```python\n# LoadFVectorize.py\n\nfrom langchain_community.embeddings import HuggingFaceEmbeddings\nfrom langchain_community.document_loaders import OnlinePDFLoader\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\nfrom langchain_community.vectorstores import FAISS\n\n# 온라인 pdf에 접근\ndef load_doc() -\u003e 'List[Document]':\n    loader = OnlinePDFLoader(\"https://support.riverbed.com/bin/support/download?did=7q6behe7hotvnpqd9a03h1dji\u0026version=9.15.0\")\n    documents = loader.load()\n    text_splitter = RecursiveCharacterTextSplitter(chunk_size=512, chunk_overlap=100)\n    docs = text_splitter.split_documents(documents)\n    return docs\n\n# 벡터화 및 디스크에 저장\ndef vectorize(embeddings_model) -\u003e 'FAISS':\n    docs = load_doc()\n    db = FAISS.from_documents(docs, embeddings_model)\n    db.save_local(\"./opdf_index\")\n    return db\n\n# 디스크에서 벡터 저장소를 로드하려고 시도\ndef load_db() -\u003e 'FAISS':\n    embeddings_model = HuggingFaceEmbeddings()\n    try:\n        db = FAISS.load_local(\"./opdf_index\", embeddings_model)\n    except Exception as e:\n        print(f'Exception: {e}\\n디스크에 인덱스가 없음, 새로 생성 중...')\n        db = vectorize(embeddings_model)\n    return db\n```\n\n## 2.2 메인 모듈\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n주요 모듈은 먼저 TinyLlama에 대한 프롬프트 템플릿을 정의합니다. 템플릿은 다음과 같습니다:\n\n`|system|`'context'`/s``|user|`'question'`/s``|assistant|`\n\nLLM 메모리 사용량을 더 줄이기 위해, TheBloke의 HuggingFace 레포지토리 [3]에서 TinyLlama의 양자화된 버전을 채택할 것입니다. 이는 모델 매개변수에 더 적은 비트를 사용하는 방식입니다. 이 LLM에 대한 추가적인 배경 정보나 활성화 기술에 대해 더 자세히 알고 싶은 분들은 이전에 작성한 기사를 확인해보세요. GGUF 형식으로 양자화된 LLM을 로드하기 위해 LlamaCpp를 사용합니다. 이전 모듈에서 반환된 FAISS 객체를 사용하여 FAISS retriever가 생성됩니다. 이러한 객체들을 사용하여 RetrievalQA 체인을 생성하고 질문에 사용합니다.\n\n아래 코드는 이러한 단계를 포착합니다.\n\n```js\n# main.py\nfrom langchain.chains import RetrievalQA\nfrom langchain.prompts import PromptTemplate\nfrom langchain_community.llms import LlamaCpp\nfrom langchain_community.embeddings import HuggingFaceEmbeddings\nimport LoadFVectorize\nfrom renumics import spotlight\nimport pandas as pd\nimport numpy as np\n\n# 프롬프트 템플릿\nqa_template = \"\"\"\u003c|system|\u003e\n정확하게 대답하는 친근한 채팅 봇입니다. \n알 수 없는 답변일 경우 공손하게 알려드릴 것입니다.\n다음 맥락을 사용하여 아래 질문에 답변해주세요:\n{context}\u003c/s\u003e\n\u003c|user|\u003e\n{question}\u003c/s\u003e\n\u003c|assistant|\u003e\n\"\"\"\n\n# 프롬프트 인스턴스 생성\nQA_PROMPT = PromptTemplate.from_template(qa_template)\n# LLM 로드\nllm = LlamaCpp(\n    model_path=\"./models/tinyllama_gguf/tinyllama-1.1b-chat-v1.0.Q5_K_M.gguf\",\n    temperature=0.01,\n    max_tokens=2000,\n    top_p=1,\n    verbose=False,\n    n_ctx=2048\n)\n# 벡터화 및 retriever 생성\ndb = LoadFVectorize.load_db()\nfaiss_retriever = db.as_retriever(search_type=\"mmr\", search_kwargs={'fetch_k': 3}, max_tokens_limit=1000)\n# QA 체인 정의\nqa_chain = RetrievalQA.from_chain_type(\n    llm,\n    retriever=faiss_retriever,\n    chain_type_kwargs={\"prompt\": QA_PROMPT}\n)\n\nquery = 'What versions of TLS supported by Client Accelerator 6.3.0?'\n\nresult = qa_chain({\"query\": query})\nprint(f'--------------\\nQ: {query}\\nA: {result[\"result\"]}')\n\nvisualize_distance(db,query,result[\"result\"])\r\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n벡터 공간 시각화 자체는 위 코드 목록의 마지막 줄인 visualize_distance에 의해 처리됩니다. 이 기능 또한 이 모듈에 정의되어 있습니다.\n\nvisualize_distance 함수에서는 먼저 FAISS 객체의 __dict__ 속성에 액세스해야 합니다. 이는 인스턴스 변수용 사전입니다. 이를 통해 docstore에 액세스할 수 있습니다. 인스턴스 변수 index_to_docstore_id는 키 인덱스로 값 docstore-id의 사전입니다. 벡터화에 사용된 총 문서 수는 인덱스 객체의 ntotal 속성으로 나타냅니다.\n\n```js\n    vs = db.__dict__.get(\"docstore\")\n    index_list = db.__dict__.get(\"index_to_docstore_id\").values()\n    doc_cnt = db.index.ntotal\n```\n\n벡터 공간을 대략적으로 복원하기 위해 우리는 단순히 객체 인덱스의 메서드인 reconstruct_n을 기본 매개변수와 함께 호출합니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n   embeddings_vec = db.index.reconstruct_n()\n```\n\n이제 인덱스 목록으로 문서 저장소 ID 목록이 있으므로, 관련 문서 객체를 찾아 해당 ID, 문서 메타데이터, 문서 내용 및 벡터 공간 내 임베딩을 포함하는 리스트를 생성해보겠습니다. 아래 코드를 참조해주세요.\n\n```js\n   doc_list = list() \n   for i, doc_id in enumerate(index_list):\n       a_doc = vs.search(doc_id)\n       doc_list.append([doc_id, a_doc.metadata.get(\"source\"), a_doc.page_content, embeddings_vec[i]])\n```\n\n그런 다음 이 리스트를 사용하여 열 제목이 있는 데이터프레임을 생성한 후, 시각화를 만들기 위해 spotlight 호출에 사용될 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\n    df = pd.DataFrame(doc_list, columns=['id', 'metadata', 'document', 'embedding'])\n```\n\n시각화를 진행하기 전에 질문과 답변을 통합할 방법을 찾아야 합니다. 질문 및 답변을 위한 별도의 데이터프레임을 생성하고 주요 데이터프레임과 병합하여 두 데이터가 나머지 문서 청크와 함께 어디에 나타나는지 보여줄 수 있도록합니다:\n\n```python\n    # 질문 및 답변을 위한 행 추가\n    embeddings_model = HuggingFaceEmbeddings()\n    question_df = pd.DataFrame(\n        {\n            \"id\": \"question\",\n            \"question\": question,\n            \"embedding\": [embeddings_model.embed_query(question)],\n        })\n    answer_df = pd.DataFrame(\n        {\n            \"id\": \"answer\",\n            \"answer\": answer,\n            \"embedding\": [embeddings_model.embed_query(answer)],\n        })\n    df = pd.concat([question_df, answer_df, df])\n```\n\n이 공간에서 질문과 문서 간의 유클리드 거리를 찾으려면 질문을 위한 임베딩을 만든 다음 문서와 질문 임베딩 차이에 대해 numpy의 `linalg.norm`을 사용하십시오:  \n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n    question_embedding = embeddings_model.embed_query(question)\n    # 벡터 거리를 나타내는 열 추가\n    df[\"dist\"] = df.apply(                                                                                                                                                                         \n        lambda row: np.linalg.norm(\n            np.array(row[\"embedding\"]) - question_embedding\n        ),axis=1,)\n```\n\n데이터프레임을 얻었으면 spotlight.show를 호출하여 시각화를 생성합니다.\n\n```js\nspotlight.show(df)\n```\n\n왔어요! 이렇게 하면 브라우저 창에서 spotlight가 열리고 pandas 데이터프레임이 탐색 준비가 됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 GitHub 저장소에서 모든 코드에 액세스할 수 있습니다:\n\n## 3.0 테스트 실행\n\n첫 번째 실험을 용이하게하기 위해 선택된 샘플 질문은 아래와 같습니다:\n\n채택된 문서에 따르면, 올바른 답은 :\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n또한, 다음 추가 정보가 응답에 포함될 수 있습니다.\n\n아래는 위 질문에 대한 TinyLlama의 응답입니다:\n\n이 응답은 실제 답변과 꽤 유사해 보이지만, 이 TLS 버전들이 기본값은 아니라는 점에서 완전히 정확하지는 않습니다.\n\nFig. 2는 스포트라이트의 스크린샷을 나타냅니다. 왼쪽 상단의 테이블 섹션에는 데이터프레임의 모든 열이 표시되고 시각화는 유사성 맵 탭 뷰 내에서 표시됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![링크 텍스트](/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_2.png)\n\n가시적인 열 버튼을 사용하여 표시되는 열을 제어할 수 있습니다. \"dist\"로 테이블을 정렬하면 상위에 질문, 답변 및 가장 관련성 높은 문서 스니펫이 나타납니다. 임베딩 시각화를 살펴보면 여기의 거의 모든 문서를 하나의 클러스터로 나타냅니다. 이는 원래 pdf가 특정 제품의 배포 가이드임을 감안할 때 합리적일 것으로 생각됩니다. Similarity Map 탭 내의 필터 아이콘을 클릭하면 선택한 문서 목록만 강조 표시되며 나머지는 회색으로 표시됩니다(Fig. 3 참조).\n\n![링크 텍스트](/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_3.png)\n\n## 3.1 테스트 청크 크기 및 겹치기 매개변수\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n리트리버가 RAG 성능에 중요한 영향을 미친다고 해서, 우리는 임베딩 공간에 영향을 주는 몇 가지 매개변수를 살펴보겠습니다. 테이블 1은 문서 분할 중 TextSplitter의 청크 크기 (1000, 2000) 및/또는 오버랩 (100, 200) 매개변수가 다양하게 변할 때, TinyLlama의 응답을 포착하고 정리합니다.\n\n![Image](/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_4.png)\n\n첫눈에, 모든 조합의 LLM 응답이 비슷해 보입니다. 그러나 정확한 답변과 각 응답을 주의 깊게 비교하면, 정확한 답변은 (1000, 200) 조합에 해당합니다. 다른 응답에서의 부정확한 세부사항은 빨간색으로 강조되었습니다. 이러한 행동을 설명하기 위해, Fig. 3은 각 조합에 대한 임베딩 맵을 옆으로 나란히 보여줍니다.\n\n![Image](/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_5.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n왼쪽부터 오른쪽으로 청크 크기를 증가시키면서 벡터 공간이 더 드문 형태로 변해갑니다. 아래에서 위로 가면 겹침이 두 배가 된 곳에서도 벡터 공간의 특성이 급격하게 변하지는 않습니다. 이 모든 맵에서 전체 컬렉션은 여전히 한 클러스터처럼 보이며 몇 개의 이상치만 존재합니다. 이는 생성된 응답에서 명확히 반영되며, 이들은 상당히 유사합니다. 질의가 클러스터의 중심에 있는 경우, 이웃들이 다를 가능성이 높으므로 이러한 매개변수의 변화에 따라 응답이 상당히 달라질 수 있습니다.\n\nRAG 애플리케이션이 특정 질문에 대해 기대한 답변을 제공하지 않는 경우, 해당 질문들과 함께 위와 같은 시각화를 생성함으로써 말뭉치를 어떻게 분할하여 전체 성능을 개선할지에 대한 추가 통찰을 얻을 수 있습니다.\n\n그리고 좀 더 설명하기 위해, 상관 없는 도메인의 두 개의 위키백과 문서가 차지하는 벡터 공간을 시각화해 봅시다. 이를 위해 LoadFVectorize 모듈 내 load_doc 함수의 첫 줄을 수정하여 웹 기반 두 URL의 WebBasedLoader를 구현하면 됩니다. 하나는 그래미 어워즈에 관한 것이고, 다른 하나는 JWST 망원경에 대한 것입니다. 아래와 같이 나타납니다.\n\n```js\ndef load_doc():\n    loader = WebBaseLoader(['https://en.wikipedia.org/wiki/66th_Annual_Grammy_Awards','https://en.wikipedia.org/wiki/James_Webb_Space_Telescope'])\n    documents = loader.load()\n    ...\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n나머지 코드는 그대로 유지하고 있는 것을 확인하면, 우리는 그림 5에 나타난 벡터 공간 시각화를 얻을 수 있습니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_6.png\" /\u003e\n\n예상대로, 여기에는 두 개의 명확하게 겹치지 않는 클러스터가 있습니다. 우리가 두 클러스터 모두 벗어난 질문을 하면, 검색기에서 얻는 결과 문맥은 적어도 LLM에게 도움이 되지는 않을 것이지만 오히려 해로울 것입니다. 그리고 재미로, 나는 이전에 묻은 같은 질문을 한 번 더 던져보기로 결정했습니다. 그리고 확실히 LLM은 환각하기 시작했습니다.\n\n여기 우리 시스템 디자인에는 벡터 저장을 위해 FAISS를 사용했습니다. 만약 당신이 ChromaDB를 사용하고 비슷한 시각화를 수행하는 방법을 궁금해 한다면, 당신은 운이 좋습니다. renumics-spotlight 라이브러리 개발자 중 Markus Stoll이 여기에 관련된 흥미로운 기사를 썼습니다. 확인해보세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 4.0 마무리\n\nRetrieval-Augmented Generation (RAG)은 내부 문서에 교육되지 않은 큰 언어 모델(LM)을 활용할 수 있게 해줍니다. RAG은 벡터 저장소에서 여러 관련 문서 청크를 검색하여 LM이 생성을 위한 문맥으로 사용합니다. 따라서 임베딩의 품질은 RAG 성능에 중요한 역할을 합니다.\n\n이 기사에서는 주요 벡터화 매개변수 중 일부가 전체 LM 성능에 미치는 영향을 시연하고 시각화했습니다. 우리는 리소스 풋프린트가 훨씬 작지만 여전히 높은 정확도를 자랑하는 TinyLlama 1.1B Chat를 선택했습니다. 라이브러리 'renumics-spotlight'를 사용하여 FAISS 벡터 공간 전체를 데이터프레임으로 표현하는 방법을 보여주었으며, 이를 사용하여 한 줄의 코드로 임베딩을 시각화했습니다. Spotlight의 직관적인 UI를 통해 질문에 대한 벡터 공간을 탐색하고, 이를 통해 LM의 응답을 더 잘 이해할 수 있습니다. 특정 벡터화 매개변수를 조정함으로써, 성능을 향상시키기 위해 생성 및 행동을 제어할 수 있습니다.\n\n읽어 주셔서 감사합니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 참고 자료\n\n1. [TinyLlama-1.1B-Chat-v1.0](https://huggingface.co/TinyLlama/TinyLlama-1.1B-Chat-v1.0)\n2. [spotlight](https://github.com/Renumics/spotlight)\n3. [TinyLlama-1.1B-Chat-v1.0-GGUF](https://huggingface.co/TheBloke/TinyLlama-1.1B-Chat-v1.0-GGUF)","ogImage":{"url":"/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_0.png","tag":["Tech"],"readingTime":17},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_0.png\"\u003e\n\u003cp\u003e오픈 소스 대형 언어 모델의 성능이 계속해서 향상되면서, 코드 작성 및 분석, 추천, 텍스트 요약 및 질문-응답(QA)을 포함한 다양한 응용 프로그램에 진입하고 있습니다. QA 관련 질문에 대해 언어 모델이 자주 실패하는데, 이는 훈련 중에 사용되지 않은 문서와 관련된 질문들에 적용될 때 발생합니다. 그리고 이러한 내부 문서들 중 많은 것들은 규정 준수, 영업 비밀 또는 개인 정보 보호를 위해 기업의 벽 안에 유지되어야 합니다. 이러한 문서에 대해 쿼리를 실행할 때, 언어 모델은 가상 현상을 겪는데, 이는 관련 없거나 가짜 또는 일관성 없는 내용을 생성합니다.\u003c/p\u003e\n\u003cp\u003e이러한 도전과제를 해결하기 위한 하나의 기술은 검색 보강 생성(Retrieval-Augmented Generation, RAG)입니다. 이는 답변 생성 이전에 훈련 데이터 소스 외부의 권위 있는 지식 베이스를 참조하여 언어 모델의 응답을 개선하는 과정을 포함합니다. RAG 어플리케이션은 말뭉치로부터 관련 문서 단편을 가져오는 검색 시스템과, 검색된 단편을 컨텍스트로 사용하여 답변을 생성하는 언어 모델로 구성됩니다. 당연히, 말뭉치의 품질과 그것이 표현된 벡터 공간, 즉 임베딩(embeddings)은 RAG의 정확도에 중요한 역할을 할 것입니다.\u003c/p\u003e\n\u003cp\u003e본 기사에서는 FAISS 벡터 공간의 다차원 임베딩을 renumics-spotlight 시각화 라이브러리를 사용하여 2차원으로 시각화하는 방법을 살펴보겠습니다. 특정 핵심 벡터화 매개변수를 변화시킴으로써 RAG 응답 정확도를 향상시킬 기회를 찾아보겠습니다. 그리고 선택한 언어 모델로는 TinyLlama 1.1B Chat을 채택할 것인데, 이는 Llama 2와 동일한 아키텍처와 토크나이저를 갖추고 있습니다 [1]. 이 모델은 리소스 풋프린트가 상당히 작고 빠른 실행 시간을 가지고 있으면서 정확도가 비례적으로 감소하지 않는 장점을 갖추고 있습니다. 이는 빠른 실험에 이상적입니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e목차\u003c/h2\u003e\n\u003cp\u003e1.0 환경 설정\n2.0 설계 및 구현\n2.1 LoadFVectorize 모듈\n2.2 주요 모듈\n3.0 테스트 실행\n3.1 청크 크기 및 중첩 매개변수 테스트\n4.0 최종 생각\u003c/p\u003e\n\u003ch1\u003e1.0 환경 설정\u003c/h1\u003e\n\u003cp\u003e이 실험은 8GB RAM을 갖춘 MacBook Air M1에서 수행될 예정입니다. 여기서 사용하는 Python 버전은 3.10.5입니다. 먼저, 이 프로젝트를 관리하기 위해 가상 환경을 생성해 봅시다. 환경을 생성하고 활성화하기 위해 다음을 실행해 봅시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epython3\u003cspan class=\"hljs-number\"\u003e.10\u003c/span\u003e -m venv mychat\nsource mychat/bin/activate\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eLibrary renumics-spotlight은 UMAP와 유사한 시각화를 사용하여 고차원 임베딩을 더 관리하기 쉬운 2D 시각화로 줄이는 동시에 중요한 속성을 보존합니다 [2]. 이제 필요한 모든 라이브러리를 설치해 보겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epip install langchain faiss-cpu sentence-transformers flask-sqlalchemy psutil unstructured pdf2image unstructured_inference pillow_heif opencv-python pikepdf pypdf\npip install renumics-spotlight\n\u003cspan class=\"hljs-variable constant_\"\u003eCMAKE_ARGS\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"-DLLAMA_METAL=on\"\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eFORCE_CMAKE\u003c/span\u003e=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e pip install --upgrade --force-reinstall llama-cpp-python --no-cache-dir\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위의 마지막 줄은 M1 프로세서에서 하드웨어 가속을 사용하여 TinyLlama를 로드하는 데 사용될 메탈 지원이 포함된 llama-cpp-python 라이브러리를 설치하는 것을 의미합니다. Metal을 사용하면 계산이 GPU에서 실행됩니다.\u003c/p\u003e\n\u003cp\u003e환경이 준비되었으므로 시스템 설계를 살펴보고 구현을 따라갑시다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e2.0 디자인 및 구현\u003c/h1\u003e\n\u003cp\u003e이 QA 시스템에는 그림 1에 설명된 두 모듈이 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eLoadFVectorize 모듈은 PDF 또는 웹 문서를 로드하는 작업을 포함합니다. 초기 테스트 및 시각화를 위해, 최근에 출시된 (2023년 12월) 440페이지의 벤더 배포 가이드가 관심 문서로 사용됩니다. 이 모듈은 문서의 분할 및 벡터화를 처리합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e두 번째 모듈은 LLM을 로드하고 FAISS 검색기를 인스턴스화한 후, LLM, 검색기 및 사용자 정의 프롬프트를 포함하는 검색 체인을 생성하는 것으로 구성되어 있습니다. 마지막으로 벡터 공간 시각화를 시작합니다.\u003c/p\u003e\n\u003cp\u003e두 모듈의 세부 정보는 더 설명되어 있습니다.\u003c/p\u003e\n\u003ch2\u003e2.1 Module LoadFVectorize\u003c/h2\u003e\n\u003cp\u003e이 모듈은 3가지 함수로 구성되어 있습니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003eload_doc 함수는 온라인 pdf 문서를 로드하고, 512자씩 묶어 chunk 단위로 나누며 100자의 overlap을 가지고 문서 목록을 반환합니다.\u003c/li\u003e\n\u003cli\u003evectorize 함수는 위 load_doc 함수를 호출하여 문서의 chunked 목록을 가져와 임베딩을 생성하고 opdf_index 로컬 디렉토리에 저장한 뒤 FAISS 인스턴스를 반환합니다.\u003c/li\u003e\n\u003cli\u003eload_db 함수는 opdf_index 디렉토리 내에 FAISS 벡터 저장소가 있는지 확인하고, 없는 경우 vectorize 함수를 호출하여 문서를 로드하고 벡터화합니다. 최종적으로 FAISS 객체를 반환합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 모듈의 전체 코드 목록은 아래와 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-comment\"\u003e# LoadFVectorize.py\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain_community.embeddings \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e HuggingFaceEmbeddings\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain_community.document_loaders \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e OnlinePDFLoader\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain.text_splitter \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e RecursiveCharacterTextSplitter\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain_community.vectorstores \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e FAISS\n\n\u003cspan class=\"hljs-comment\"\u003e# 온라인 pdf에 접근\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eload_doc\u003c/span\u003e() -\u003e \u003cspan class=\"hljs-string\"\u003e'List[Document]'\u003c/span\u003e:\n    loader = OnlinePDFLoader(\u003cspan class=\"hljs-string\"\u003e\"https://support.riverbed.com/bin/support/download?did=7q6behe7hotvnpqd9a03h1dji\u0026#x26;version=9.15.0\"\u003c/span\u003e)\n    documents = loader.load()\n    text_splitter = RecursiveCharacterTextSplitter(chunk_size=\u003cspan class=\"hljs-number\"\u003e512\u003c/span\u003e, chunk_overlap=\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e)\n    docs = text_splitter.split_documents(documents)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e docs\n\n\u003cspan class=\"hljs-comment\"\u003e# 벡터화 및 디스크에 저장\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003evectorize\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eembeddings_model\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-string\"\u003e'FAISS'\u003c/span\u003e:\n    docs = load_doc()\n    db = FAISS.from_documents(docs, embeddings_model)\n    db.save_local(\u003cspan class=\"hljs-string\"\u003e\"./opdf_index\"\u003c/span\u003e)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e db\n\n\u003cspan class=\"hljs-comment\"\u003e# 디스크에서 벡터 저장소를 로드하려고 시도\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eload_db\u003c/span\u003e() -\u003e \u003cspan class=\"hljs-string\"\u003e'FAISS'\u003c/span\u003e:\n    embeddings_model = HuggingFaceEmbeddings()\n    \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e:\n        db = FAISS.load_local(\u003cspan class=\"hljs-string\"\u003e\"./opdf_index\"\u003c/span\u003e, embeddings_model)\n    \u003cspan class=\"hljs-keyword\"\u003eexcept\u003c/span\u003e Exception \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e e:\n        \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003ef'Exception: \u003cspan class=\"hljs-subst\"\u003e{e}\u003c/span\u003e\\n디스크에 인덱스가 없음, 새로 생성 중...'\u003c/span\u003e)\n        db = vectorize(embeddings_model)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e db\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e2.2 메인 모듈\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e주요 모듈은 먼저 TinyLlama에 대한 프롬프트 템플릿을 정의합니다. 템플릿은 다음과 같습니다:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e|system|\u003c/code\u003e'context'\u003ccode\u003e/s``|user|\u003c/code\u003e'question'\u003ccode\u003e/s``|assistant|\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eLLM 메모리 사용량을 더 줄이기 위해, TheBloke의 HuggingFace 레포지토리 [3]에서 TinyLlama의 양자화된 버전을 채택할 것입니다. 이는 모델 매개변수에 더 적은 비트를 사용하는 방식입니다. 이 LLM에 대한 추가적인 배경 정보나 활성화 기술에 대해 더 자세히 알고 싶은 분들은 이전에 작성한 기사를 확인해보세요. GGUF 형식으로 양자화된 LLM을 로드하기 위해 LlamaCpp를 사용합니다. 이전 모듈에서 반환된 FAISS 객체를 사용하여 FAISS retriever가 생성됩니다. 이러한 객체들을 사용하여 RetrievalQA 체인을 생성하고 질문에 사용합니다.\u003c/p\u003e\n\u003cp\u003e아래 코드는 이러한 단계를 포착합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# main.\u003cspan class=\"hljs-property\"\u003epy\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain.\u003cspan class=\"hljs-property\"\u003echains\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRetrievalQA\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain.\u003cspan class=\"hljs-property\"\u003eprompts\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromptTemplate\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain_community.\u003cspan class=\"hljs-property\"\u003ellms\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLlamaCpp\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain_community.\u003cspan class=\"hljs-property\"\u003eembeddings\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHuggingFaceEmbeddings\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLoadFVectorize\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e renumics \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e spotlight\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pandas \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pd\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e numpy \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e np\n\n# 프롬프트 템플릿\nqa_template = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\u0026#x3C;|system|\u003e\n정확하게 대답하는 친근한 채팅 봇입니다. \n알 수 없는 답변일 경우 공손하게 알려드릴 것입니다.\n다음 맥락을 사용하여 아래 질문에 답변해주세요:\n{context}\u0026#x3C;/s\u003e\n\u0026#x3C;|user|\u003e\n{question}\u0026#x3C;/s\u003e\n\u0026#x3C;|assistant|\u003e\n\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n\n# 프롬프트 인스턴스 생성\n\u003cspan class=\"hljs-variable constant_\"\u003eQA_PROMPT\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003ePromptTemplate\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efrom_template\u003c/span\u003e(qa_template)\n# \u003cspan class=\"hljs-variable constant_\"\u003eLLM\u003c/span\u003e 로드\nllm = \u003cspan class=\"hljs-title class_\"\u003eLlamaCpp\u003c/span\u003e(\n    model_path=\u003cspan class=\"hljs-string\"\u003e\"./models/tinyllama_gguf/tinyllama-1.1b-chat-v1.0.Q5_K_M.gguf\"\u003c/span\u003e,\n    temperature=\u003cspan class=\"hljs-number\"\u003e0.01\u003c/span\u003e,\n    max_tokens=\u003cspan class=\"hljs-number\"\u003e2000\u003c/span\u003e,\n    top_p=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n    verbose=\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e,\n    n_ctx=\u003cspan class=\"hljs-number\"\u003e2048\u003c/span\u003e\n)\n# 벡터화 및 retriever 생성\ndb = \u003cspan class=\"hljs-title class_\"\u003eLoadFVectorize\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eload_db\u003c/span\u003e()\nfaiss_retriever = db.\u003cspan class=\"hljs-title function_\"\u003eas_retriever\u003c/span\u003e(search_type=\u003cspan class=\"hljs-string\"\u003e\"mmr\"\u003c/span\u003e, search_kwargs={\u003cspan class=\"hljs-string\"\u003e'fetch_k'\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e}, max_tokens_limit=\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e)\n# \u003cspan class=\"hljs-variable constant_\"\u003eQA\u003c/span\u003e 체인 정의\nqa_chain = \u003cspan class=\"hljs-title class_\"\u003eRetrievalQA\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efrom_chain_type\u003c/span\u003e(\n    llm,\n    retriever=faiss_retriever,\n    chain_type_kwargs={\u003cspan class=\"hljs-string\"\u003e\"prompt\"\u003c/span\u003e: \u003cspan class=\"hljs-variable constant_\"\u003eQA_PROMPT\u003c/span\u003e}\n)\n\nquery = \u003cspan class=\"hljs-string\"\u003e'What versions of TLS supported by Client Accelerator 6.3.0?'\u003c/span\u003e\n\nresult = \u003cspan class=\"hljs-title function_\"\u003eqa_chain\u003c/span\u003e({\u003cspan class=\"hljs-string\"\u003e\"query\"\u003c/span\u003e: query})\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e'--------------\\nQ: {query}\\nA: {result[\"result\"]}'\u003c/span\u003e)\n\n\u003cspan class=\"hljs-title function_\"\u003evisualize_distance\u003c/span\u003e(db,query,result[\u003cspan class=\"hljs-string\"\u003e\"result\"\u003c/span\u003e])\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e벡터 공간 시각화 자체는 위 코드 목록의 마지막 줄인 visualize_distance에 의해 처리됩니다. 이 기능 또한 이 모듈에 정의되어 있습니다.\u003c/p\u003e\n\u003cp\u003evisualize_distance 함수에서는 먼저 FAISS 객체의 \u003cstrong\u003edict\u003c/strong\u003e 속성에 액세스해야 합니다. 이는 인스턴스 변수용 사전입니다. 이를 통해 docstore에 액세스할 수 있습니다. 인스턴스 변수 index_to_docstore_id는 키 인덱스로 값 docstore-id의 사전입니다. 벡터화에 사용된 총 문서 수는 인덱스 객체의 ntotal 속성으로 나타냅니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e    vs = db.\u003cspan class=\"hljs-property\"\u003e__dict__\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"docstore\"\u003c/span\u003e)\n    index_list = db.\u003cspan class=\"hljs-property\"\u003e__dict__\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"index_to_docstore_id\"\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003evalues\u003c/span\u003e()\n    doc_cnt = db.\u003cspan class=\"hljs-property\"\u003eindex\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003entotal\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e벡터 공간을 대략적으로 복원하기 위해 우리는 단순히 객체 인덱스의 메서드인 reconstruct_n을 기본 매개변수와 함께 호출합니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e   embeddings_vec = db.\u003cspan class=\"hljs-property\"\u003eindex\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ereconstruct_n\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 인덱스 목록으로 문서 저장소 ID 목록이 있으므로, 관련 문서 객체를 찾아 해당 ID, 문서 메타데이터, 문서 내용 및 벡터 공간 내 임베딩을 포함하는 리스트를 생성해보겠습니다. 아래 코드를 참조해주세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e   doc_list = \u003cspan class=\"hljs-title function_\"\u003elist\u003c/span\u003e() \n   \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i, doc_id \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eenumerate\u003c/span\u003e(index_list):\n       a_doc = vs.\u003cspan class=\"hljs-title function_\"\u003esearch\u003c/span\u003e(doc_id)\n       doc_list.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e([doc_id, a_doc.\u003cspan class=\"hljs-property\"\u003emetadata\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"source\"\u003c/span\u003e), a_doc.\u003cspan class=\"hljs-property\"\u003epage_content\u003c/span\u003e, embeddings_vec[i]])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런 다음 이 리스트를 사용하여 열 제목이 있는 데이터프레임을 생성한 후, 시각화를 만들기 위해 spotlight 호출에 사용될 것입니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e    df = pd.DataFrame(doc_list, columns=[\u003cspan class=\"hljs-string\"\u003e'id'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'metadata'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'document'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'embedding'\u003c/span\u003e])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e시각화를 진행하기 전에 질문과 답변을 통합할 방법을 찾아야 합니다. 질문 및 답변을 위한 별도의 데이터프레임을 생성하고 주요 데이터프레임과 병합하여 두 데이터가 나머지 문서 청크와 함께 어디에 나타나는지 보여줄 수 있도록합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e    \u003cspan class=\"hljs-comment\"\u003e# 질문 및 답변을 위한 행 추가\u003c/span\u003e\n    embeddings_model = HuggingFaceEmbeddings()\n    question_df = pd.DataFrame(\n        {\n            \u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"question\"\u003c/span\u003e,\n            \u003cspan class=\"hljs-string\"\u003e\"question\"\u003c/span\u003e: question,\n            \u003cspan class=\"hljs-string\"\u003e\"embedding\"\u003c/span\u003e: [embeddings_model.embed_query(question)],\n        })\n    answer_df = pd.DataFrame(\n        {\n            \u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"answer\"\u003c/span\u003e,\n            \u003cspan class=\"hljs-string\"\u003e\"answer\"\u003c/span\u003e: answer,\n            \u003cspan class=\"hljs-string\"\u003e\"embedding\"\u003c/span\u003e: [embeddings_model.embed_query(answer)],\n        })\n    df = pd.concat([question_df, answer_df, df])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 공간에서 질문과 문서 간의 유클리드 거리를 찾으려면 질문을 위한 임베딩을 만든 다음 문서와 질문 임베딩 차이에 대해 numpy의 \u003ccode\u003elinalg.norm\u003c/code\u003e을 사용하십시오:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e    question_embedding = embeddings_model.\u003cspan class=\"hljs-title function_\"\u003eembed_query\u003c/span\u003e(question)\n    # 벡터 거리를 나타내는 열 추가\n    df[\u003cspan class=\"hljs-string\"\u003e\"dist\"\u003c/span\u003e] = df.\u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e(                                                                                                                                                                         \n        lambda \u003cspan class=\"hljs-attr\"\u003erow\u003c/span\u003e: np.\u003cspan class=\"hljs-property\"\u003elinalg\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enorm\u003c/span\u003e(\n            np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e(row[\u003cspan class=\"hljs-string\"\u003e\"embedding\"\u003c/span\u003e]) - question_embedding\n        ),axis=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e데이터프레임을 얻었으면 spotlight.show를 호출하여 시각화를 생성합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003espotlight.\u003cspan class=\"hljs-title function_\"\u003eshow\u003c/span\u003e(df)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e왔어요! 이렇게 하면 브라우저 창에서 spotlight가 열리고 pandas 데이터프레임이 탐색 준비가 됩니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e아래 GitHub 저장소에서 모든 코드에 액세스할 수 있습니다:\u003c/p\u003e\n\u003ch2\u003e3.0 테스트 실행\u003c/h2\u003e\n\u003cp\u003e첫 번째 실험을 용이하게하기 위해 선택된 샘플 질문은 아래와 같습니다:\u003c/p\u003e\n\u003cp\u003e채택된 문서에 따르면, 올바른 답은 :\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e또한, 다음 추가 정보가 응답에 포함될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e아래는 위 질문에 대한 TinyLlama의 응답입니다:\u003c/p\u003e\n\u003cp\u003e이 응답은 실제 답변과 꽤 유사해 보이지만, 이 TLS 버전들이 기본값은 아니라는 점에서 완전히 정확하지는 않습니다.\u003c/p\u003e\n\u003cp\u003eFig. 2는 스포트라이트의 스크린샷을 나타냅니다. 왼쪽 상단의 테이블 섹션에는 데이터프레임의 모든 열이 표시되고 시각화는 유사성 맵 탭 뷰 내에서 표시됩니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_2.png\" alt=\"링크 텍스트\"\u003e\u003c/p\u003e\n\u003cp\u003e가시적인 열 버튼을 사용하여 표시되는 열을 제어할 수 있습니다. \"dist\"로 테이블을 정렬하면 상위에 질문, 답변 및 가장 관련성 높은 문서 스니펫이 나타납니다. 임베딩 시각화를 살펴보면 여기의 거의 모든 문서를 하나의 클러스터로 나타냅니다. 이는 원래 pdf가 특정 제품의 배포 가이드임을 감안할 때 합리적일 것으로 생각됩니다. Similarity Map 탭 내의 필터 아이콘을 클릭하면 선택한 문서 목록만 강조 표시되며 나머지는 회색으로 표시됩니다(Fig. 3 참조).\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_3.png\" alt=\"링크 텍스트\"\u003e\u003c/p\u003e\n\u003ch2\u003e3.1 테스트 청크 크기 및 겹치기 매개변수\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e리트리버가 RAG 성능에 중요한 영향을 미친다고 해서, 우리는 임베딩 공간에 영향을 주는 몇 가지 매개변수를 살펴보겠습니다. 테이블 1은 문서 분할 중 TextSplitter의 청크 크기 (1000, 2000) 및/또는 오버랩 (100, 200) 매개변수가 다양하게 변할 때, TinyLlama의 응답을 포착하고 정리합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_4.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003e첫눈에, 모든 조합의 LLM 응답이 비슷해 보입니다. 그러나 정확한 답변과 각 응답을 주의 깊게 비교하면, 정확한 답변은 (1000, 200) 조합에 해당합니다. 다른 응답에서의 부정확한 세부사항은 빨간색으로 강조되었습니다. 이러한 행동을 설명하기 위해, Fig. 3은 각 조합에 대한 임베딩 맵을 옆으로 나란히 보여줍니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_5.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e왼쪽부터 오른쪽으로 청크 크기를 증가시키면서 벡터 공간이 더 드문 형태로 변해갑니다. 아래에서 위로 가면 겹침이 두 배가 된 곳에서도 벡터 공간의 특성이 급격하게 변하지는 않습니다. 이 모든 맵에서 전체 컬렉션은 여전히 한 클러스터처럼 보이며 몇 개의 이상치만 존재합니다. 이는 생성된 응답에서 명확히 반영되며, 이들은 상당히 유사합니다. 질의가 클러스터의 중심에 있는 경우, 이웃들이 다를 가능성이 높으므로 이러한 매개변수의 변화에 따라 응답이 상당히 달라질 수 있습니다.\u003c/p\u003e\n\u003cp\u003eRAG 애플리케이션이 특정 질문에 대해 기대한 답변을 제공하지 않는 경우, 해당 질문들과 함께 위와 같은 시각화를 생성함으로써 말뭉치를 어떻게 분할하여 전체 성능을 개선할지에 대한 추가 통찰을 얻을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e그리고 좀 더 설명하기 위해, 상관 없는 도메인의 두 개의 위키백과 문서가 차지하는 벡터 공간을 시각화해 봅시다. 이를 위해 LoadFVectorize 모듈 내 load_doc 함수의 첫 줄을 수정하여 웹 기반 두 URL의 WebBasedLoader를 구현하면 됩니다. 하나는 그래미 어워즈에 관한 것이고, 다른 하나는 JWST 망원경에 대한 것입니다. 아래와 같이 나타납니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003eload_doc\u003c/span\u003e():\n    loader = \u003cspan class=\"hljs-title class_\"\u003eWebBaseLoader\u003c/span\u003e([\u003cspan class=\"hljs-string\"\u003e'https://en.wikipedia.org/wiki/66th_Annual_Grammy_Awards'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'https://en.wikipedia.org/wiki/James_Webb_Space_Telescope'\u003c/span\u003e])\n    documents = loader.\u003cspan class=\"hljs-title function_\"\u003eload\u003c/span\u003e()\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e나머지 코드는 그대로 유지하고 있는 것을 확인하면, 우리는 그림 5에 나타난 벡터 공간 시각화를 얻을 수 있습니다.\u003c/p\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_6.png\"\u003e\n\u003cp\u003e예상대로, 여기에는 두 개의 명확하게 겹치지 않는 클러스터가 있습니다. 우리가 두 클러스터 모두 벗어난 질문을 하면, 검색기에서 얻는 결과 문맥은 적어도 LLM에게 도움이 되지는 않을 것이지만 오히려 해로울 것입니다. 그리고 재미로, 나는 이전에 묻은 같은 질문을 한 번 더 던져보기로 결정했습니다. 그리고 확실히 LLM은 환각하기 시작했습니다.\u003c/p\u003e\n\u003cp\u003e여기 우리 시스템 디자인에는 벡터 저장을 위해 FAISS를 사용했습니다. 만약 당신이 ChromaDB를 사용하고 비슷한 시각화를 수행하는 방법을 궁금해 한다면, 당신은 운이 좋습니다. renumics-spotlight 라이브러리 개발자 중 Markus Stoll이 여기에 관련된 흥미로운 기사를 썼습니다. 확인해보세요.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e4.0 마무리\u003c/h1\u003e\n\u003cp\u003eRetrieval-Augmented Generation (RAG)은 내부 문서에 교육되지 않은 큰 언어 모델(LM)을 활용할 수 있게 해줍니다. RAG은 벡터 저장소에서 여러 관련 문서 청크를 검색하여 LM이 생성을 위한 문맥으로 사용합니다. 따라서 임베딩의 품질은 RAG 성능에 중요한 역할을 합니다.\u003c/p\u003e\n\u003cp\u003e이 기사에서는 주요 벡터화 매개변수 중 일부가 전체 LM 성능에 미치는 영향을 시연하고 시각화했습니다. 우리는 리소스 풋프린트가 훨씬 작지만 여전히 높은 정확도를 자랑하는 TinyLlama 1.1B Chat를 선택했습니다. 라이브러리 'renumics-spotlight'를 사용하여 FAISS 벡터 공간 전체를 데이터프레임으로 표현하는 방법을 보여주었으며, 이를 사용하여 한 줄의 코드로 임베딩을 시각화했습니다. Spotlight의 직관적인 UI를 통해 질문에 대한 벡터 공간을 탐색하고, 이를 통해 LM의 응답을 더 잘 이해할 수 있습니다. 특정 벡터화 매개변수를 조정함으로써, 성능을 향상시키기 위해 생성 및 행동을 제어할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e읽어 주셔서 감사합니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e참고 자료\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://huggingface.co/TinyLlama/TinyLlama-1.1B-Chat-v1.0\" rel=\"nofollow\" target=\"_blank\"\u003eTinyLlama-1.1B-Chat-v1.0\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/Renumics/spotlight\" rel=\"nofollow\" target=\"_blank\"\u003espotlight\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://huggingface.co/TheBloke/TinyLlama-1.1B-Chat-v1.0-GGUF\" rel=\"nofollow\" target=\"_blank\"\u003eTinyLlama-1.1B-Chat-v1.0-GGUF\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance"},"buildId":"FuXRqV9h16krA5Mvtd6Dn","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>