<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>프라이빗 데이터를 활용한 Amazon Bedrock 지식 베이스 구축 방법 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="프라이빗 데이터를 활용한 Amazon Bedrock 지식 베이스 구축 방법 | TIL" data-gatsby-head="true"/><meta property="og:title" content="프라이빗 데이터를 활용한 Amazon Bedrock 지식 베이스 구축 방법 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData" data-gatsby-head="true"/><meta name="twitter:title" content="프라이빗 데이터를 활용한 Amazon Bedrock 지식 베이스 구축 방법 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-07 19:23" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-5ecfd58aae5a7e3d.js" defer=""></script><script src="/_next/static/xx51Gh_JNHDTBdDwrgykD/_buildManifest.js" defer=""></script><script src="/_next/static/xx51Gh_JNHDTBdDwrgykD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">프라이빗 데이터를 활용한 Amazon Bedrock 지식 베이스 구축 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="프라이빗 데이터를 활용한 Amazon Bedrock 지식 베이스 구축 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 7, 2024</span><span class="posts_reading_time__f7YPP">17<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/TIL/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_0.png">
<h2>서문</h2>
<p>✔️ 아마존 베드락 지식베이스에 대해 다루겠습니다.
✔️ AWS 아키텍처를 설명합니다.
✔️ TypeScript 및 AWS CDK 코드를 살펴봅니다.
✔️ 작동 방식을 확인하기 위해 몇 가지 테스트를 수행합니다.</p>
<h1>소개 👋🏽</h1>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 기사에서는 Amazon Bedrock Knowledge Bases에 대해 이야기하고, 최신 비공개 회사 정보로 AI 모델을 장착하는 방법에 대해 얘기할 것입니다. 이를 통해 사용자들이 자체 사용자 정의 데이터로 AI를 활용할 수 있게 됩니다. 우리는 코드 예제와 관련된 AWS 아키텍처에 대해 설명할 것입니다.</p>
<p><img src="/TIL/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_1.png" alt="이미지"></p>
<p>우리의 예시에서는 'LJ Medical Center'라는 허구의 회사를 위한 사용 사례에 대해 이야기할 것입니다. 여기서 우리의 접수 직원들이 회사 정보를 질의하기 위해 AI 모델을 사용할 수 있습니다.</p>
<p><img src="/TIL/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_2.png" alt="이미지"></p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>접대 직원은 자연어를 사용하여 사설 데이터를 쿼리할 수 있습니다. 예를 들어, 의료 분야에서 지불 지연에 대한 정책이 무엇인지 묻는 것이 있습니다.</p>
<p><img src="/TIL/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_3.png" alt="이미지"></p>
<p>아래에 TypeScript로 작성된 전체 코드 예제와 AWS CDK를 찾을 수 있습니다:</p>
<p>👇 더 나아가기 전에 — LinkedIn에서 저와 연결해주세요. 미래의 블로그 게시물과 서버리스 뉴스를 만날 수 있습니다. <a href="https://www.linkedin.com/in/lee-james-gilmore/" rel="nofollow" target="_blank">https://www.linkedin.com/in/lee-james-gilmore/</a></p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<img src="/TIL/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_4.png">
<h1>아마존 베드락은 무엇인가요? 🤖</h1>
<p>이제 아마존 베드락이 무엇이고 어떻게 작동하는지 알아봅시다. 먼저 몇 가지 주요 약어를 이해하는 것부터 시작해보겠습니다.</p>
<h2>약어</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>시작하기 전에, 몇 가지 약어와 그 의미에 대해 알아보겠습니다:</p>
<ul>
<li>FMs — Foundational Models.</li>
<li>RAG — Retrieval Augmented Generation.</li>
</ul>
<p><img src="/TIL/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_5.png" alt="이미지"></p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>Bedrock Knowledge Bases란 무엇인가요? 🤖</h2>
<p>최신 및 사용자 정의 정보를 시설 관리자(FM)에게 제공하기 위해, 기업 및 비즈니스는 RAG(Retrieval Augmented Generation) 기법을 사용합니다. 이 기법은 회사 데이터 소스에서 데이터를 가져와 프롬프트를 보다 관련성 높고 정확한 응답을 제공하기 위해 풍부하게 합니다.</p>
<p>지식 베이스는 사용자 쿼리에 대답하는 데뿐만 아니라 프롬프트에 맥락을 제공함으로써 기초 모델이 제공하는 프롬프트를 보강하는 데 사용될 수 있습니다.</p>
<h2>사용자 정의 데이터를 어디에 저장하나요? 🤖</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>아마존 베드락 지식 베이스를 사용하면 데이터 수집부터 Amazon S3에서 데이터를 검색하고 프롬프트 추가까지 전체 RAG 워크플로우를 구현할 수 있습니다. 사용자는 데이터 소스에 맞춤 통합을 작성하거나 데이터 흐름을 관리할 필요 없이 쉽게 다중 대화를 지원할 수 있습니다.</p>
<p>아마존 S3에서 사용자 정의 데이터를 가리킨 후, 아마존 베드락을 사용하면 데이터를 자동으로 가져와 텍스트 블록으로 나누고 이를 임베딩으로 변환하여 벡터 데이터베이스에 저장합니다. 이 기사에서는 임베딩을 아마존 오픈서치 서버리스 벡터에 저장할 것입니다.</p>
<h2>사용자 정의 데이터는 어떻게 저장되나요? 🤖</h2>
<p>벡터 임베딩에는 문서 내 텍스트 데이터의 숫자 표현이 포함됩니다. 각 임베딩은 데이터의 의미나 문맥적 의미를 포착하기 위해 노력합니다. 아마존 베드락은 벡터 저장소에서 임베딩을 생성, 저장, 관리 및 업데이트하며 데이터가 항상 벡터 저장소와 동기화되도록 보장합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>✔️ 전처리</p>
<p>데이터 검색을 개선하기 위해 문서를 작은 세그먼트로 나누어 임베딩으로 변환한 후 벡터 인덱스에 저장하여 원본 문서와의 연결을 유지합니다. 이러한 임베딩은 데이터 원본에서 효율적인 쿼리 일치를 위한 의미 유사성 비교를 가능하게 합니다. 이 과정은 첨부된 이미지에 설명되어 있습니다.</p>
<p><img src="/TIL/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_6.png" alt="image"></p>
<p>✔️ 런타임 실행</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>실시간으로 모델은 사용자의 쿼리를 벡터로 변환하고 의미적으로 유사한 청크를 찾기 위해 벡터 인덱스를 탐색합니다. 이러한 청크들은 사용자 프롬프트를 보강하는 데 사용되고, 그 후에 모델로 전송되어 응답을 생성합니다. 이 프로세스는 아래 이미지에서 RAG의 실행 중인 작업을 보여줍니다.</p>
<p><img src="/TIL/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_7.png" alt="RAG의 실행 중인 작업"></p>
<p>✔️ 데이터 동기화</p>
<p>우리의 Amazon S3 버킷에 새 문서를 업로드하면 지식 베이스 데이터 원본으로 사용하게 되는데, 이때 데이터를 주기적으로 동기화하여 색인 작업과 쿼리를 위해 지식 베이스와 동기화해야 합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>업데이트 동기화는 마지막 동기화 이후에 S3 버킷에 새로 추가되거나 수정된 객체들만을 처리하여 지식 베이스를 증분적으로 업데이트합니다.</p>
<h1>무엇을 만드는 중인가요? 🛠️</h1>
<p>자, 이제 Amazon Bedrock의 지식 베이스에 대해 심도있는 탐구를 했고, 이론적으로 어떻게 작동하는지 이해했으니, 이제 이 글에서 무엇을 만드는지 살펴보겠습니다:</p>
<p><img src="/TIL/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_8.png" alt="Amazon Bedrock Knowledge Bases with Private Data"></p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>위 다이어그램에서 알 수 있듯이:</p>
<ul>
<li>수신 직원 팀의 사용자는 그들의 응용 프로그램을 통해 Amazon API Gateway에 요청을 보냅니다.</li>
<li>Amazon API Gateway는 쿼리를 기반으로 한 POST 요청에 따라 람다 함수를 호출합니다.</li>
<li>람다 함수는 사용자의 쿼리를 오픈서치 서버리스 벡터 저장소의 데이터로 보완하기 위해 Bedrock Knowledge Base를 호출합니다.</li>
<li>S3 버킷에서 객체가 수정, 작성 또는 삭제되면 Ingestion 람다를 호출합니다.</li>
<li>람다 함수는 수정 사항이 있었기 때문에 Amazon S3 버킷의 데이터를 동기화하기 위해 Knowledge Base를 호출합니다.</li>
</ul>
<p>이제 우리가 전체 아키텍처를 토론했으니, 이를 실제로 보고 주요 코드를 설명해 보겠습니다.</p>
<h1>주요 코드 설명하기 👨‍💻</h1>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>알겠어요. 우리는 이 기본 예제를 살펴보았으니 이제 TypeScript와 CDK 코드를 살펴보겠습니다. 전체 솔루션은 여기에서 찾을 수 있음을 기억해 주세요.</p>
<h2>상태를 가지는 스택</h2>
<p>먼저, 저희의 상태를 가지는 스택을 살펴봅시다. 아마존 베드락 지식베이스 및 데이터를 저장할 S3 버킷이 있는 스택입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 베드락 지식베이스 생성</span>
<span class="hljs-keyword">const</span> kb = <span class="hljs-keyword">new</span> bedrock.<span class="hljs-title class_">KnowledgeBase</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">"BedrockKnowledgeBase"</span>, {
  <span class="hljs-attr">embeddingsModel</span>: bedrock.<span class="hljs-property">BedrockFoundationModel</span>.<span class="hljs-property">TITAN_EMBED_TEXT_V1</span>,
  <span class="hljs-attr">instruction</span>: <span class="hljs-string">`환자 기록에 대한 질문에 답변하는 데 사용할 지식베이스입니다.`</span>,
});

<span class="hljs-comment">// 환자 데이터를 저장하는 S3 버킷 생성 (베드락을 위한 소스)</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">bucket</span> = <span class="hljs-keyword">new</span> s3.<span class="hljs-title class_">Bucket</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">"PatientRecordsBucket"</span>, {
  <span class="hljs-attr">bucketName</span>: <span class="hljs-string">"lj-medical-center-patient-records"</span>,
  <span class="hljs-attr">autoDeleteObjects</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">removalPolicy</span>: cdk.<span class="hljs-property">RemovalPolicy</span>.<span class="hljs-property">DESTROY</span>,
});
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>위의 코드에서는 Titan Text V1 기본 모델을 사용하고 있음을 알 수 있습니다.</p>
<p>다음으로, 첫 번째 배포 시에는 데이터 폴더에서 예제 문서를 S3 버킷으로 업로드해야 합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// cdk 배포의 일부로 데이터가 업로드되도록 보장</span>
<span class="hljs-keyword">new</span> s3deploy.<span class="hljs-title class_">BucketDeployment</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">"ClientBucketDeployment"</span>, {
  <span class="hljs-attr">sources</span>: [s3deploy.<span class="hljs-property">Source</span>.<span class="hljs-title function_">asset</span>(path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">"../../data/"</span>))],
  <span class="hljs-attr">destinationBucket</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">bucket</span>,
});
</code></pre>
<p>마지막으로, 지식 베이스용 데이터 소스를 생성하며, 이는 우리의 S3 버킷을 가리킵니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-comment">// knowledge base를 위한 s3 버킷의 데이터 소스 설정</span>
<span class="hljs-keyword">const</span> dataSource = <span class="hljs-keyword">new</span> bedrock.<span class="hljs-title function_">S3DataSource</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">"DataSource"</span>, {
  <span class="hljs-attr">bucket</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">bucket</span>,
  <span class="hljs-attr">knowledgeBase</span>: kb,
  <span class="hljs-attr">dataSourceName</span>: <span class="hljs-string">"patients"</span>,
  <span class="hljs-attr">chunkingStrategy</span>: bedrock.<span class="hljs-property">ChunkingStrategy</span>.<span class="hljs-property">DEFAULT</span>,
  <span class="hljs-attr">maxTokens</span>: <span class="hljs-number">500</span>,
  <span class="hljs-attr">overlapPercentage</span>: <span class="hljs-number">20</span>,
});
</code></pre>
<p>Stateful 스택을 배포하려면 npm 스크립트 npm run deploy:stateful을 사용하고, 완료되면 콘솔에 로그인하여 '동기화'를 실행할 수 있습니다:</p>
<h2>Stateless Stack</h2>
<p>이제 Stateless 스택을 살펴보겠습니다. 우선 S3 트리거를 추가하여 S3 버킷 내에서 변경 사항(새 파일, 수정, 삭제 등)이 발생할 때 Ingestion Lambda 함수를 호출하는 방법을 살펴보겠습니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-comment">// 객체가 추가, 수정 또는 삭제될 때의 s3 이벤트 소스를 만듭니다</span>
bucket.<span class="hljs-title function_">addEventNotification</span>(s3.<span class="hljs-property">EventType</span>.<span class="hljs-property">OBJECT_CREATED_PUT</span>, <span class="hljs-keyword">new</span> s3n.<span class="hljs-title class_">LambdaDestination</span>(ingestionLambda));
bucket.<span class="hljs-title function_">addEventNotification</span>(s3.<span class="hljs-property">EventType</span>.<span class="hljs-property">OBJECT_REMOVED</span>, <span class="hljs-keyword">new</span> s3n.<span class="hljs-title class_">LambdaDestination</span>(ingestionLambda));
</code></pre>
<p>그런 다음 Ingestion Lambda에는 데이터 소스를 동기화하기 위해 다음 코드를 실행하는 보조 어댑터가 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> {
  <span class="hljs-title class_">BedrockAgentClient</span>,
  <span class="hljs-title class_">StartIngestionJobCommand</span>,
  <span class="hljs-title class_">StartIngestionJobCommandInput</span>,
  <span class="hljs-title class_">StartIngestionJobCommandOutput</span>,
} <span class="hljs-keyword">from</span> <span class="hljs-string">"@aws-sdk/client-bedrock-agent"</span>;

<span class="hljs-keyword">import</span> { config } <span class="hljs-keyword">from</span> <span class="hljs-string">"@config"</span>;
<span class="hljs-keyword">import</span> { logger } <span class="hljs-keyword">from</span> <span class="hljs-string">"@shared/logger"</span>;
<span class="hljs-keyword">import</span> { v4 <span class="hljs-keyword">as</span> uuid } <span class="hljs-keyword">from</span> <span class="hljs-string">"uuid"</span>;

<span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BedrockAgentClient</span>();
<span class="hljs-keyword">const</span> knowledgeBaseId = config.<span class="hljs-title function_">get</span>(<span class="hljs-string">"knowledgeBaseId"</span>);
<span class="hljs-keyword">const</span> dataSourceId = config.<span class="hljs-title function_">get</span>(<span class="hljs-string">"dataSourceId"</span>);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ingestionProcess</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">Promise</span>&#x3C;string> {
  <span class="hljs-keyword">const</span> <span class="hljs-attr">input</span>: <span class="hljs-title class_">StartIngestionJobCommandInput</span> = {
    <span class="hljs-attr">knowledgeBaseId</span>: knowledgeBaseId,
    <span class="hljs-attr">dataSourceId</span>: dataSourceId,
    <span class="hljs-attr">clientToken</span>: <span class="hljs-title function_">uuid</span>(),
  };
  <span class="hljs-keyword">const</span> <span class="hljs-attr">command</span>: <span class="hljs-title class_">StartIngestionJobCommand</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StartIngestionJobCommand</span>(input);

  <span class="hljs-keyword">const</span> <span class="hljs-attr">response</span>: <span class="hljs-title class_">StartIngestionJobCommandOutput</span> = <span class="hljs-keyword">await</span> client.<span class="hljs-title function_">send</span>(command);
  logger.<span class="hljs-title function_">info</span>(<span class="hljs-string">`response: <span class="hljs-subst">${response}</span>`</span>);

  <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
    <span class="hljs-attr">ingestionJob</span>: response.<span class="hljs-property">ingestionJob</span>,
  });
}
</code></pre>
<p>다음으로 Lambda 함수가 동기화 수행을 허용하기 위해 필요한 IAM 정책을 살펴보겠습니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-comment">// ensure that the lambda function can start a data ingestion job</span>
ingestionLambda.<span class="hljs-title function_">addToRolePolicy</span>(
  <span class="hljs-keyword">new</span> iam.<span class="hljs-title class_">PolicyStatement</span>({
    <span class="hljs-attr">actions</span>: [<span class="hljs-string">"bedrock:StartIngestionJob"</span>],
    <span class="hljs-attr">resources</span>: [knowledgeBaseArn],
  })
);
</code></pre>
<p>우리 쿼리 람다에 유사한 정책을 추가합니다. 이 정책에 따라 쿼리 람다가 Amazon Bedrock에 대해 작업을 수행할 수 있게 됩니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 쿼리 람다 함수가 모델을 쿼리할 수 있도록 허용합니다</span>
queryModelLambda.<span class="hljs-title function_">addToRolePolicy</span>(
  <span class="hljs-keyword">new</span> iam.<span class="hljs-title class_">PolicyStatement</span>({
    <span class="hljs-attr">actions</span>: [<span class="hljs-string">"bedrock:RetrieveAndGenerate"</span>, <span class="hljs-string">"bedrock:Retrieve"</span>, <span class="hljs-string">"bedrock:InvokeModel"</span>],
    <span class="hljs-attr">resources</span>: [<span class="hljs-string">"*"</span>],
  })
);
</code></pre>
<p>쿼리 람다의 두 번째 어댑터에 대한 코드가 아래에 표시되어 있습니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> {
  <span class="hljs-title class_">BedrockAgentRuntimeClient</span>,
  <span class="hljs-title class_">RetrieveAndGenerateCommand</span>,
  <span class="hljs-title class_">RetrieveAndGenerateCommandInput</span>,
  <span class="hljs-title class_">RetrieveAndGenerateCommandOutput</span>,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'@aws-sdk/client-bedrock-agent-runtime'</span>;

<span class="hljs-keyword">import</span> { config } <span class="hljs-keyword">from</span> <span class="hljs-string">'@config'</span>;

<span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BedrockAgentRuntimeClient</span>();
<span class="hljs-keyword">const</span> knowledgeBaseId = config.<span class="hljs-title function_">get</span>(<span class="hljs-string">'knowledgeBaseId'</span>);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">queryModel</span>(<span class="hljs-params">prompt: string</span>): <span class="hljs-title class_">Promise</span>&#x3C;string> {
  <span class="hljs-keyword">const</span> <span class="hljs-attr">input</span>: <span class="hljs-title class_">RetrieveAndGenerateCommandInput</span> = {
    <span class="hljs-attr">input</span>: {
      <span class="hljs-attr">text</span>: prompt,
    },
    <span class="hljs-attr">retrieveAndGenerateConfiguration</span>: {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'KNOWLEDGE_BASE'</span>,
      <span class="hljs-attr">knowledgeBaseConfiguration</span>: {
        <span class="hljs-attr">knowledgeBaseId</span>: knowledgeBaseId,
        <span class="hljs-comment">// we are using Anthropic Claude v2 in us-east-1 in this example</span>
        <span class="hljs-attr">modelArn</span>: <span class="hljs-string">`arn:aws:bedrock:us-east-1::foundation-model/anthropic.claude-v2`</span>,
      },
    },
  };
  <span class="hljs-keyword">const</span> <span class="hljs-attr">command</span>: <span class="hljs-title class_">RetrieveAndGenerateCommand</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RetrieveAndGenerateCommand</span>(
    input
  );
  <span class="hljs-keyword">const</span> <span class="hljs-attr">response</span>: <span class="hljs-title class_">RetrieveAndGenerateCommandOutput</span> = <span class="hljs-keyword">await</span> client.<span class="hljs-title function_">send</span>(command);
  <span class="hljs-keyword">return</span> response.<span class="hljs-property">output</span>?.<span class="hljs-property">text</span> <span class="hljs-keyword">as</span> string;
}
</code></pre>
<p>마지막 단계는 우리의 Amazon API Gateway를 추가하고, /queries/ 리소스에 대해 Query Lambda 함수를 호출하도록 허용하는 것입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 우리 수의원 앱에서 사용할 API를 생성합니다</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">api</span>: apigw.<span class="hljs-property">RestApi</span> = <span class="hljs-keyword">new</span> apigw.<span class="hljs-title class_">RestApi</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">"Api"</span>, {
  <span class="hljs-attr">description</span>: <span class="hljs-string">"LJ Medical Center API"</span>,
  <span class="hljs-attr">restApiName</span>: <span class="hljs-string">"lj-medical-center-api"</span>,
  <span class="hljs-attr">deploy</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">endpointTypes</span>: [apigw.<span class="hljs-property">EndpointType</span>.<span class="hljs-property">REGIONAL</span>],
  <span class="hljs-attr">deployOptions</span>: {
    <span class="hljs-attr">stageName</span>: <span class="hljs-string">"prod"</span>,
    <span class="hljs-attr">dataTraceEnabled</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">loggingLevel</span>: apigw.<span class="hljs-property">MethodLoggingLevel</span>.<span class="hljs-property">INFO</span>,
    <span class="hljs-attr">tracingEnabled</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">metricsEnabled</span>: <span class="hljs-literal">true</span>,
  },
});

<span class="hljs-comment">// API에 대한 쿼리 리소스 생성</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">queries</span>: apigw.<span class="hljs-property">Resource</span> = api.<span class="hljs-property">root</span>.<span class="hljs-title function_">addResource</span>(<span class="hljs-string">"queries"</span>);

<span class="hljs-comment">// 지식 베이스 쿼리 엔드포인트 추가 (POST) - prod/queries/</span>
queries.<span class="hljs-title function_">addMethod</span>(
  <span class="hljs-string">"POST"</span>,
  <span class="hljs-keyword">new</span> apigw.<span class="hljs-title class_">LambdaIntegration</span>(queryModelLambda, {
    <span class="hljs-attr">proxy</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">allowTestInvoke</span>: <span class="hljs-literal">false</span>,
  })
);
</code></pre>
<p>이제 npm 스크립트 npm run deploy:stateless로 무상태 스택을 배포하고 기능을 테스트할 수 있습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>앱 테스트 🧪</h1>
<h2>Postman을 통한 테스팅</h2>
<p>postman/Bedrock Knowledge Bases.postman_collection.json 파일을 사용하여 자신의 URL 정보로 테스트할 수 있습니다.</p>
<p>늦은 지불에 관한 간단한 쿼리를 시작해보세요:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>위의 스크린샷에서 올바른 응답을 받았음을 확인할 수 있습니다:</p>
<p>그런 다음 다음과 같은 쿼리를 요청할 수 있습니다:</p>
<p>위의 쿼리에서 답변을 성공적으로 받았음을 확인할 수 있습니다:</p>
<p>위의 예시는 우리 접수 직원이 모든 정책에서 필요한 정보를 빠르게 찾을 수 있는 두 가지 예시에 불과합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>어째서 이 기능을 사용해보지 않고 가상의 환자 기록을 추가해 보시겠어요? 솔루션을 배포하는 비용을 기억해 주세요!</p>
<h1>마무리 인사 👋🏽</h1>
<p>이 글을 즐겁게 읽어주셨으면 공유와 피드백도 부탁드립니다!</p>
<p>제 유튜브 채널을 방문해 비슷한 콘텐츠를 구독해주세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/TIL/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_9.png" alt="이미지"></p>
<p>함께 소통하고 싶어요! 아래 링크에서 저와 연계해 주세요:</p>
<p><a href="https://www.linkedin.com/in/lee-james-gilmore/" rel="nofollow" target="_blank">LinkedIn</a>
<a href="https://twitter.com/LeeJamesGilmore" rel="nofollow" target="_blank">Twitter</a></p>
<p>만약 글을 즐겼다면, 저의 프로필 Lee James Gilmore를 팔로우하여 더 많은 글/시리즈를 만나보세요. 그리고 연락하여 인사도 잊지 마세요! 👋</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>나에 대해</h2>
<p>“안녕하세요, 저는 영국을 기반으로 하는 AWS 커뮤니티 빌더, 블로거, AWS 인증 클라우드 아키텍트이자 City Electrical Factors (UK) &#x26; City Electric Supply (US)에서 글로벌 기술 및 아키텍처 총괄을 맡고 있는 Lee입니다. 지난 6년간 주로 AWS에서 풀스택 JavaScript 개발을 하였습니다.</p>
<p>저는 서버리스를 주장하는 사람으로, AWS, 혁신, 소프트웨어 아키텍처, 기술 전반에 관심을 가지고 있습니다.”
클래프 기능을 사용하여 이 게시물이 마음에 드셨다면 반드시 박수를 눌러주세요! (여러 번 박수를 두드릴 수 있어요!!)</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><strong>_ 제공된 정보는 제 개인적인 의견이며 정보 사용에 대한 책임은 지지 않습니다. _</strong></p>
<p>아래 정보도 참고하실만 합니다:</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"프라이빗 데이터를 활용한 Amazon Bedrock 지식 베이스 구축 방법","description":"","date":"2024-07-07 19:23","slug":"2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData","content":"\n\u003cimg src=\"/TIL/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_0.png\" /\u003e\n\n## 서문\n\n✔️ 아마존 베드락 지식베이스에 대해 다루겠습니다.\n✔️ AWS 아키텍처를 설명합니다.\n✔️ TypeScript 및 AWS CDK 코드를 살펴봅니다.\n✔️ 작동 방식을 확인하기 위해 몇 가지 테스트를 수행합니다.\n\n# 소개 👋🏽\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기사에서는 Amazon Bedrock Knowledge Bases에 대해 이야기하고, 최신 비공개 회사 정보로 AI 모델을 장착하는 방법에 대해 얘기할 것입니다. 이를 통해 사용자들이 자체 사용자 정의 데이터로 AI를 활용할 수 있게 됩니다. 우리는 코드 예제와 관련된 AWS 아키텍처에 대해 설명할 것입니다.\n\n![이미지](/TIL/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_1.png)\n\n우리의 예시에서는 'LJ Medical Center'라는 허구의 회사를 위한 사용 사례에 대해 이야기할 것입니다. 여기서 우리의 접수 직원들이 회사 정보를 질의하기 위해 AI 모델을 사용할 수 있습니다.\n\n![이미지](/TIL/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_2.png)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n접대 직원은 자연어를 사용하여 사설 데이터를 쿼리할 수 있습니다. 예를 들어, 의료 분야에서 지불 지연에 대한 정책이 무엇인지 묻는 것이 있습니다.\n\n![이미지](/TIL/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_3.png)\n\n아래에 TypeScript로 작성된 전체 코드 예제와 AWS CDK를 찾을 수 있습니다:\n\n👇 더 나아가기 전에 — LinkedIn에서 저와 연결해주세요. 미래의 블로그 게시물과 서버리스 뉴스를 만날 수 있습니다. https://www.linkedin.com/in/lee-james-gilmore/\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_4.png\" /\u003e\n\n# 아마존 베드락은 무엇인가요? 🤖\n\n이제 아마존 베드락이 무엇이고 어떻게 작동하는지 알아봅시다. 먼저 몇 가지 주요 약어를 이해하는 것부터 시작해보겠습니다.\n\n## 약어\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n시작하기 전에, 몇 가지 약어와 그 의미에 대해 알아보겠습니다:\n\n- FMs — Foundational Models.\n- RAG — Retrieval Augmented Generation.\n\n![이미지](/TIL/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_5.png)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Bedrock Knowledge Bases란 무엇인가요? 🤖\n\n최신 및 사용자 정의 정보를 시설 관리자(FM)에게 제공하기 위해, 기업 및 비즈니스는 RAG(Retrieval Augmented Generation) 기법을 사용합니다. 이 기법은 회사 데이터 소스에서 데이터를 가져와 프롬프트를 보다 관련성 높고 정확한 응답을 제공하기 위해 풍부하게 합니다.\n\n지식 베이스는 사용자 쿼리에 대답하는 데뿐만 아니라 프롬프트에 맥락을 제공함으로써 기초 모델이 제공하는 프롬프트를 보강하는 데 사용될 수 있습니다.\n\n## 사용자 정의 데이터를 어디에 저장하나요? 🤖\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아마존 베드락 지식 베이스를 사용하면 데이터 수집부터 Amazon S3에서 데이터를 검색하고 프롬프트 추가까지 전체 RAG 워크플로우를 구현할 수 있습니다. 사용자는 데이터 소스에 맞춤 통합을 작성하거나 데이터 흐름을 관리할 필요 없이 쉽게 다중 대화를 지원할 수 있습니다.\n\n아마존 S3에서 사용자 정의 데이터를 가리킨 후, 아마존 베드락을 사용하면 데이터를 자동으로 가져와 텍스트 블록으로 나누고 이를 임베딩으로 변환하여 벡터 데이터베이스에 저장합니다. 이 기사에서는 임베딩을 아마존 오픈서치 서버리스 벡터에 저장할 것입니다.\n\n## 사용자 정의 데이터는 어떻게 저장되나요? 🤖\n\n벡터 임베딩에는 문서 내 텍스트 데이터의 숫자 표현이 포함됩니다. 각 임베딩은 데이터의 의미나 문맥적 의미를 포착하기 위해 노력합니다. 아마존 베드락은 벡터 저장소에서 임베딩을 생성, 저장, 관리 및 업데이트하며 데이터가 항상 벡터 저장소와 동기화되도록 보장합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n✔️ 전처리\n\n데이터 검색을 개선하기 위해 문서를 작은 세그먼트로 나누어 임베딩으로 변환한 후 벡터 인덱스에 저장하여 원본 문서와의 연결을 유지합니다. 이러한 임베딩은 데이터 원본에서 효율적인 쿼리 일치를 위한 의미 유사성 비교를 가능하게 합니다. 이 과정은 첨부된 이미지에 설명되어 있습니다.\n\n![image](/TIL/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_6.png)\n\n✔️ 런타임 실행\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n실시간으로 모델은 사용자의 쿼리를 벡터로 변환하고 의미적으로 유사한 청크를 찾기 위해 벡터 인덱스를 탐색합니다. 이러한 청크들은 사용자 프롬프트를 보강하는 데 사용되고, 그 후에 모델로 전송되어 응답을 생성합니다. 이 프로세스는 아래 이미지에서 RAG의 실행 중인 작업을 보여줍니다.\n\n![RAG의 실행 중인 작업](/TIL/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_7.png)\n\n✔️ 데이터 동기화\n\n우리의 Amazon S3 버킷에 새 문서를 업로드하면 지식 베이스 데이터 원본으로 사용하게 되는데, 이때 데이터를 주기적으로 동기화하여 색인 작업과 쿼리를 위해 지식 베이스와 동기화해야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n업데이트 동기화는 마지막 동기화 이후에 S3 버킷에 새로 추가되거나 수정된 객체들만을 처리하여 지식 베이스를 증분적으로 업데이트합니다.\n\n# 무엇을 만드는 중인가요? 🛠️\n\n자, 이제 Amazon Bedrock의 지식 베이스에 대해 심도있는 탐구를 했고, 이론적으로 어떻게 작동하는지 이해했으니, 이제 이 글에서 무엇을 만드는지 살펴보겠습니다:\n\n![Amazon Bedrock Knowledge Bases with Private Data](/TIL/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_8.png)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 다이어그램에서 알 수 있듯이:\n\n- 수신 직원 팀의 사용자는 그들의 응용 프로그램을 통해 Amazon API Gateway에 요청을 보냅니다.\n- Amazon API Gateway는 쿼리를 기반으로 한 POST 요청에 따라 람다 함수를 호출합니다.\n- 람다 함수는 사용자의 쿼리를 오픈서치 서버리스 벡터 저장소의 데이터로 보완하기 위해 Bedrock Knowledge Base를 호출합니다.\n- S3 버킷에서 객체가 수정, 작성 또는 삭제되면 Ingestion 람다를 호출합니다.\n- 람다 함수는 수정 사항이 있었기 때문에 Amazon S3 버킷의 데이터를 동기화하기 위해 Knowledge Base를 호출합니다.\n\n이제 우리가 전체 아키텍처를 토론했으니, 이를 실제로 보고 주요 코드를 설명해 보겠습니다.\n\n# 주요 코드 설명하기 👨‍💻\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n알겠어요. 우리는 이 기본 예제를 살펴보았으니 이제 TypeScript와 CDK 코드를 살펴보겠습니다. 전체 솔루션은 여기에서 찾을 수 있음을 기억해 주세요.\n\n## 상태를 가지는 스택\n\n먼저, 저희의 상태를 가지는 스택을 살펴봅시다. 아마존 베드락 지식베이스 및 데이터를 저장할 S3 버킷이 있는 스택입니다:\n\n```js\n// 베드락 지식베이스 생성\nconst kb = new bedrock.KnowledgeBase(this, \"BedrockKnowledgeBase\", {\n  embeddingsModel: bedrock.BedrockFoundationModel.TITAN_EMBED_TEXT_V1,\n  instruction: `환자 기록에 대한 질문에 답변하는 데 사용할 지식베이스입니다.`,\n});\n\n// 환자 데이터를 저장하는 S3 버킷 생성 (베드락을 위한 소스)\nthis.bucket = new s3.Bucket(this, \"PatientRecordsBucket\", {\n  bucketName: \"lj-medical-center-patient-records\",\n  autoDeleteObjects: true,\n  removalPolicy: cdk.RemovalPolicy.DESTROY,\n});\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 코드에서는 Titan Text V1 기본 모델을 사용하고 있음을 알 수 있습니다.\n\n다음으로, 첫 번째 배포 시에는 데이터 폴더에서 예제 문서를 S3 버킷으로 업로드해야 합니다:\n\n```js\n// cdk 배포의 일부로 데이터가 업로드되도록 보장\nnew s3deploy.BucketDeployment(this, \"ClientBucketDeployment\", {\n  sources: [s3deploy.Source.asset(path.join(__dirname, \"../../data/\"))],\n  destinationBucket: this.bucket,\n});\n```\n\n마지막으로, 지식 베이스용 데이터 소스를 생성하며, 이는 우리의 S3 버킷을 가리킵니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n// knowledge base를 위한 s3 버킷의 데이터 소스 설정\nconst dataSource = new bedrock.S3DataSource(this, \"DataSource\", {\n  bucket: this.bucket,\n  knowledgeBase: kb,\n  dataSourceName: \"patients\",\n  chunkingStrategy: bedrock.ChunkingStrategy.DEFAULT,\n  maxTokens: 500,\n  overlapPercentage: 20,\n});\n```\n\nStateful 스택을 배포하려면 npm 스크립트 npm run deploy:stateful을 사용하고, 완료되면 콘솔에 로그인하여 '동기화'를 실행할 수 있습니다:\n\n## Stateless Stack\n\n이제 Stateless 스택을 살펴보겠습니다. 우선 S3 트리거를 추가하여 S3 버킷 내에서 변경 사항(새 파일, 수정, 삭제 등)이 발생할 때 Ingestion Lambda 함수를 호출하는 방법을 살펴보겠습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n// 객체가 추가, 수정 또는 삭제될 때의 s3 이벤트 소스를 만듭니다\nbucket.addEventNotification(s3.EventType.OBJECT_CREATED_PUT, new s3n.LambdaDestination(ingestionLambda));\nbucket.addEventNotification(s3.EventType.OBJECT_REMOVED, new s3n.LambdaDestination(ingestionLambda));\n```\n\n그런 다음 Ingestion Lambda에는 데이터 소스를 동기화하기 위해 다음 코드를 실행하는 보조 어댑터가 있습니다:\n\n```js\nimport {\n  BedrockAgentClient,\n  StartIngestionJobCommand,\n  StartIngestionJobCommandInput,\n  StartIngestionJobCommandOutput,\n} from \"@aws-sdk/client-bedrock-agent\";\n\nimport { config } from \"@config\";\nimport { logger } from \"@shared/logger\";\nimport { v4 as uuid } from \"uuid\";\n\nconst client = new BedrockAgentClient();\nconst knowledgeBaseId = config.get(\"knowledgeBaseId\");\nconst dataSourceId = config.get(\"dataSourceId\");\n\nexport async function ingestionProcess(): Promise\u003cstring\u003e {\n  const input: StartIngestionJobCommandInput = {\n    knowledgeBaseId: knowledgeBaseId,\n    dataSourceId: dataSourceId,\n    clientToken: uuid(),\n  };\n  const command: StartIngestionJobCommand = new StartIngestionJobCommand(input);\n\n  const response: StartIngestionJobCommandOutput = await client.send(command);\n  logger.info(`response: ${response}`);\n\n  return JSON.stringify({\n    ingestionJob: response.ingestionJob,\n  });\n}\n```\n\n다음으로 Lambda 함수가 동기화 수행을 허용하기 위해 필요한 IAM 정책을 살펴보겠습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n// ensure that the lambda function can start a data ingestion job\ningestionLambda.addToRolePolicy(\n  new iam.PolicyStatement({\n    actions: [\"bedrock:StartIngestionJob\"],\n    resources: [knowledgeBaseArn],\n  })\n);\n```\n\n우리 쿼리 람다에 유사한 정책을 추가합니다. 이 정책에 따라 쿼리 람다가 Amazon Bedrock에 대해 작업을 수행할 수 있게 됩니다:\n\n```js\n// 쿼리 람다 함수가 모델을 쿼리할 수 있도록 허용합니다\nqueryModelLambda.addToRolePolicy(\n  new iam.PolicyStatement({\n    actions: [\"bedrock:RetrieveAndGenerate\", \"bedrock:Retrieve\", \"bedrock:InvokeModel\"],\n    resources: [\"*\"],\n  })\n);\n```\n\n쿼리 람다의 두 번째 어댑터에 대한 코드가 아래에 표시되어 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport {\n  BedrockAgentRuntimeClient,\n  RetrieveAndGenerateCommand,\n  RetrieveAndGenerateCommandInput,\n  RetrieveAndGenerateCommandOutput,\n} from '@aws-sdk/client-bedrock-agent-runtime';\n\nimport { config } from '@config';\n\nconst client = new BedrockAgentRuntimeClient();\nconst knowledgeBaseId = config.get('knowledgeBaseId');\n\nexport async function queryModel(prompt: string): Promise\u003cstring\u003e {\n  const input: RetrieveAndGenerateCommandInput = {\n    input: {\n      text: prompt,\n    },\n    retrieveAndGenerateConfiguration: {\n      type: 'KNOWLEDGE_BASE',\n      knowledgeBaseConfiguration: {\n        knowledgeBaseId: knowledgeBaseId,\n        // we are using Anthropic Claude v2 in us-east-1 in this example\n        modelArn: `arn:aws:bedrock:us-east-1::foundation-model/anthropic.claude-v2`,\n      },\n    },\n  };\n  const command: RetrieveAndGenerateCommand = new RetrieveAndGenerateCommand(\n    input\n  );\n  const response: RetrieveAndGenerateCommandOutput = await client.send(command);\n  return response.output?.text as string;\n}\n```\n\n마지막 단계는 우리의 Amazon API Gateway를 추가하고, /queries/ 리소스에 대해 Query Lambda 함수를 호출하도록 허용하는 것입니다.\n\n```js\n// 우리 수의원 앱에서 사용할 API를 생성합니다\nconst api: apigw.RestApi = new apigw.RestApi(this, \"Api\", {\n  description: \"LJ Medical Center API\",\n  restApiName: \"lj-medical-center-api\",\n  deploy: true,\n  endpointTypes: [apigw.EndpointType.REGIONAL],\n  deployOptions: {\n    stageName: \"prod\",\n    dataTraceEnabled: true,\n    loggingLevel: apigw.MethodLoggingLevel.INFO,\n    tracingEnabled: true,\n    metricsEnabled: true,\n  },\n});\n\n// API에 대한 쿼리 리소스 생성\nconst queries: apigw.Resource = api.root.addResource(\"queries\");\n\n// 지식 베이스 쿼리 엔드포인트 추가 (POST) - prod/queries/\nqueries.addMethod(\n  \"POST\",\n  new apigw.LambdaIntegration(queryModelLambda, {\n    proxy: true,\n    allowTestInvoke: false,\n  })\n);\n```\n\n이제 npm 스크립트 npm run deploy:stateless로 무상태 스택을 배포하고 기능을 테스트할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 앱 테스트 🧪\n\n## Postman을 통한 테스팅\n\npostman/Bedrock Knowledge Bases.postman_collection.json 파일을 사용하여 자신의 URL 정보로 테스트할 수 있습니다.\n\n늦은 지불에 관한 간단한 쿼리를 시작해보세요:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 스크린샷에서 올바른 응답을 받았음을 확인할 수 있습니다:\n\n그런 다음 다음과 같은 쿼리를 요청할 수 있습니다:\n\n위의 쿼리에서 답변을 성공적으로 받았음을 확인할 수 있습니다:\n\n위의 예시는 우리 접수 직원이 모든 정책에서 필요한 정보를 빠르게 찾을 수 있는 두 가지 예시에 불과합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n어째서 이 기능을 사용해보지 않고 가상의 환자 기록을 추가해 보시겠어요? 솔루션을 배포하는 비용을 기억해 주세요!\n\n# 마무리 인사 👋🏽\n\n이 글을 즐겁게 읽어주셨으면 공유와 피드백도 부탁드립니다!\n\n제 유튜브 채널을 방문해 비슷한 콘텐츠를 구독해주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/TIL/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_9.png)\n\n함께 소통하고 싶어요! 아래 링크에서 저와 연계해 주세요:\n\n[LinkedIn](https://www.linkedin.com/in/lee-james-gilmore/)\n[Twitter](https://twitter.com/LeeJamesGilmore)\n\n만약 글을 즐겼다면, 저의 프로필 Lee James Gilmore를 팔로우하여 더 많은 글/시리즈를 만나보세요. 그리고 연락하여 인사도 잊지 마세요! 👋\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 나에 대해\n\n“안녕하세요, 저는 영국을 기반으로 하는 AWS 커뮤니티 빌더, 블로거, AWS 인증 클라우드 아키텍트이자 City Electrical Factors (UK) \u0026 City Electric Supply (US)에서 글로벌 기술 및 아키텍처 총괄을 맡고 있는 Lee입니다. 지난 6년간 주로 AWS에서 풀스택 JavaScript 개발을 하였습니다.\n\n저는 서버리스를 주장하는 사람으로, AWS, 혁신, 소프트웨어 아키텍처, 기술 전반에 관심을 가지고 있습니다.”\n클래프 기능을 사용하여 이 게시물이 마음에 드셨다면 반드시 박수를 눌러주세요! (여러 번 박수를 두드릴 수 있어요!!)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n**_ 제공된 정보는 제 개인적인 의견이며 정보 사용에 대한 책임은 지지 않습니다. _**\n\n아래 정보도 참고하실만 합니다:\n","ogImage":{"url":"/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_0.png","tag":["Tech"],"readingTime":17},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_0.png\"\u003e\n\u003ch2\u003e서문\u003c/h2\u003e\n\u003cp\u003e✔️ 아마존 베드락 지식베이스에 대해 다루겠습니다.\n✔️ AWS 아키텍처를 설명합니다.\n✔️ TypeScript 및 AWS CDK 코드를 살펴봅니다.\n✔️ 작동 방식을 확인하기 위해 몇 가지 테스트를 수행합니다.\u003c/p\u003e\n\u003ch1\u003e소개 👋🏽\u003c/h1\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 기사에서는 Amazon Bedrock Knowledge Bases에 대해 이야기하고, 최신 비공개 회사 정보로 AI 모델을 장착하는 방법에 대해 얘기할 것입니다. 이를 통해 사용자들이 자체 사용자 정의 데이터로 AI를 활용할 수 있게 됩니다. 우리는 코드 예제와 관련된 AWS 아키텍처에 대해 설명할 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e우리의 예시에서는 'LJ Medical Center'라는 허구의 회사를 위한 사용 사례에 대해 이야기할 것입니다. 여기서 우리의 접수 직원들이 회사 정보를 질의하기 위해 AI 모델을 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e접대 직원은 자연어를 사용하여 사설 데이터를 쿼리할 수 있습니다. 예를 들어, 의료 분야에서 지불 지연에 대한 정책이 무엇인지 묻는 것이 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e아래에 TypeScript로 작성된 전체 코드 예제와 AWS CDK를 찾을 수 있습니다:\u003c/p\u003e\n\u003cp\u003e👇 더 나아가기 전에 — LinkedIn에서 저와 연결해주세요. 미래의 블로그 게시물과 서버리스 뉴스를 만날 수 있습니다. \u003ca href=\"https://www.linkedin.com/in/lee-james-gilmore/\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://www.linkedin.com/in/lee-james-gilmore/\u003c/a\u003e\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_4.png\"\u003e\n\u003ch1\u003e아마존 베드락은 무엇인가요? 🤖\u003c/h1\u003e\n\u003cp\u003e이제 아마존 베드락이 무엇이고 어떻게 작동하는지 알아봅시다. 먼저 몇 가지 주요 약어를 이해하는 것부터 시작해보겠습니다.\u003c/p\u003e\n\u003ch2\u003e약어\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e시작하기 전에, 몇 가지 약어와 그 의미에 대해 알아보겠습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFMs — Foundational Models.\u003c/li\u003e\n\u003cli\u003eRAG — Retrieval Augmented Generation.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_5.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003eBedrock Knowledge Bases란 무엇인가요? 🤖\u003c/h2\u003e\n\u003cp\u003e최신 및 사용자 정의 정보를 시설 관리자(FM)에게 제공하기 위해, 기업 및 비즈니스는 RAG(Retrieval Augmented Generation) 기법을 사용합니다. 이 기법은 회사 데이터 소스에서 데이터를 가져와 프롬프트를 보다 관련성 높고 정확한 응답을 제공하기 위해 풍부하게 합니다.\u003c/p\u003e\n\u003cp\u003e지식 베이스는 사용자 쿼리에 대답하는 데뿐만 아니라 프롬프트에 맥락을 제공함으로써 기초 모델이 제공하는 프롬프트를 보강하는 데 사용될 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e사용자 정의 데이터를 어디에 저장하나요? 🤖\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e아마존 베드락 지식 베이스를 사용하면 데이터 수집부터 Amazon S3에서 데이터를 검색하고 프롬프트 추가까지 전체 RAG 워크플로우를 구현할 수 있습니다. 사용자는 데이터 소스에 맞춤 통합을 작성하거나 데이터 흐름을 관리할 필요 없이 쉽게 다중 대화를 지원할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e아마존 S3에서 사용자 정의 데이터를 가리킨 후, 아마존 베드락을 사용하면 데이터를 자동으로 가져와 텍스트 블록으로 나누고 이를 임베딩으로 변환하여 벡터 데이터베이스에 저장합니다. 이 기사에서는 임베딩을 아마존 오픈서치 서버리스 벡터에 저장할 것입니다.\u003c/p\u003e\n\u003ch2\u003e사용자 정의 데이터는 어떻게 저장되나요? 🤖\u003c/h2\u003e\n\u003cp\u003e벡터 임베딩에는 문서 내 텍스트 데이터의 숫자 표현이 포함됩니다. 각 임베딩은 데이터의 의미나 문맥적 의미를 포착하기 위해 노력합니다. 아마존 베드락은 벡터 저장소에서 임베딩을 생성, 저장, 관리 및 업데이트하며 데이터가 항상 벡터 저장소와 동기화되도록 보장합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e✔️ 전처리\u003c/p\u003e\n\u003cp\u003e데이터 검색을 개선하기 위해 문서를 작은 세그먼트로 나누어 임베딩으로 변환한 후 벡터 인덱스에 저장하여 원본 문서와의 연결을 유지합니다. 이러한 임베딩은 데이터 원본에서 효율적인 쿼리 일치를 위한 의미 유사성 비교를 가능하게 합니다. 이 과정은 첨부된 이미지에 설명되어 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_6.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e✔️ 런타임 실행\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e실시간으로 모델은 사용자의 쿼리를 벡터로 변환하고 의미적으로 유사한 청크를 찾기 위해 벡터 인덱스를 탐색합니다. 이러한 청크들은 사용자 프롬프트를 보강하는 데 사용되고, 그 후에 모델로 전송되어 응답을 생성합니다. 이 프로세스는 아래 이미지에서 RAG의 실행 중인 작업을 보여줍니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_7.png\" alt=\"RAG의 실행 중인 작업\"\u003e\u003c/p\u003e\n\u003cp\u003e✔️ 데이터 동기화\u003c/p\u003e\n\u003cp\u003e우리의 Amazon S3 버킷에 새 문서를 업로드하면 지식 베이스 데이터 원본으로 사용하게 되는데, 이때 데이터를 주기적으로 동기화하여 색인 작업과 쿼리를 위해 지식 베이스와 동기화해야 합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e업데이트 동기화는 마지막 동기화 이후에 S3 버킷에 새로 추가되거나 수정된 객체들만을 처리하여 지식 베이스를 증분적으로 업데이트합니다.\u003c/p\u003e\n\u003ch1\u003e무엇을 만드는 중인가요? 🛠️\u003c/h1\u003e\n\u003cp\u003e자, 이제 Amazon Bedrock의 지식 베이스에 대해 심도있는 탐구를 했고, 이론적으로 어떻게 작동하는지 이해했으니, 이제 이 글에서 무엇을 만드는지 살펴보겠습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_8.png\" alt=\"Amazon Bedrock Knowledge Bases with Private Data\"\u003e\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e위 다이어그램에서 알 수 있듯이:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e수신 직원 팀의 사용자는 그들의 응용 프로그램을 통해 Amazon API Gateway에 요청을 보냅니다.\u003c/li\u003e\n\u003cli\u003eAmazon API Gateway는 쿼리를 기반으로 한 POST 요청에 따라 람다 함수를 호출합니다.\u003c/li\u003e\n\u003cli\u003e람다 함수는 사용자의 쿼리를 오픈서치 서버리스 벡터 저장소의 데이터로 보완하기 위해 Bedrock Knowledge Base를 호출합니다.\u003c/li\u003e\n\u003cli\u003eS3 버킷에서 객체가 수정, 작성 또는 삭제되면 Ingestion 람다를 호출합니다.\u003c/li\u003e\n\u003cli\u003e람다 함수는 수정 사항이 있었기 때문에 Amazon S3 버킷의 데이터를 동기화하기 위해 Knowledge Base를 호출합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이제 우리가 전체 아키텍처를 토론했으니, 이를 실제로 보고 주요 코드를 설명해 보겠습니다.\u003c/p\u003e\n\u003ch1\u003e주요 코드 설명하기 👨‍💻\u003c/h1\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e알겠어요. 우리는 이 기본 예제를 살펴보았으니 이제 TypeScript와 CDK 코드를 살펴보겠습니다. 전체 솔루션은 여기에서 찾을 수 있음을 기억해 주세요.\u003c/p\u003e\n\u003ch2\u003e상태를 가지는 스택\u003c/h2\u003e\n\u003cp\u003e먼저, 저희의 상태를 가지는 스택을 살펴봅시다. 아마존 베드락 지식베이스 및 데이터를 저장할 S3 버킷이 있는 스택입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 베드락 지식베이스 생성\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e kb = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e bedrock.\u003cspan class=\"hljs-title class_\"\u003eKnowledgeBase\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"BedrockKnowledgeBase\"\u003c/span\u003e, {\n  \u003cspan class=\"hljs-attr\"\u003eembeddingsModel\u003c/span\u003e: bedrock.\u003cspan class=\"hljs-property\"\u003eBedrockFoundationModel\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eTITAN_EMBED_TEXT_V1\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003einstruction\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`환자 기록에 대한 질문에 답변하는 데 사용할 지식베이스입니다.`\u003c/span\u003e,\n});\n\n\u003cspan class=\"hljs-comment\"\u003e// 환자 데이터를 저장하는 S3 버킷 생성 (베드락을 위한 소스)\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ebucket\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e s3.\u003cspan class=\"hljs-title class_\"\u003eBucket\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"PatientRecordsBucket\"\u003c/span\u003e, {\n  \u003cspan class=\"hljs-attr\"\u003ebucketName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"lj-medical-center-patient-records\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eautoDeleteObjects\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eremovalPolicy\u003c/span\u003e: cdk.\u003cspan class=\"hljs-property\"\u003eRemovalPolicy\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eDESTROY\u003c/span\u003e,\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e위의 코드에서는 Titan Text V1 기본 모델을 사용하고 있음을 알 수 있습니다.\u003c/p\u003e\n\u003cp\u003e다음으로, 첫 번째 배포 시에는 데이터 폴더에서 예제 문서를 S3 버킷으로 업로드해야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// cdk 배포의 일부로 데이터가 업로드되도록 보장\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e s3deploy.\u003cspan class=\"hljs-title class_\"\u003eBucketDeployment\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"ClientBucketDeployment\"\u003c/span\u003e, {\n  \u003cspan class=\"hljs-attr\"\u003esources\u003c/span\u003e: [s3deploy.\u003cspan class=\"hljs-property\"\u003eSource\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003easset\u003c/span\u003e(path.\u003cspan class=\"hljs-title function_\"\u003ejoin\u003c/span\u003e(__dirname, \u003cspan class=\"hljs-string\"\u003e\"../../data/\"\u003c/span\u003e))],\n  \u003cspan class=\"hljs-attr\"\u003edestinationBucket\u003c/span\u003e: \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ebucket\u003c/span\u003e,\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e마지막으로, 지식 베이스용 데이터 소스를 생성하며, 이는 우리의 S3 버킷을 가리킵니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// knowledge base를 위한 s3 버킷의 데이터 소스 설정\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e dataSource = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e bedrock.\u003cspan class=\"hljs-title function_\"\u003eS3DataSource\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"DataSource\"\u003c/span\u003e, {\n  \u003cspan class=\"hljs-attr\"\u003ebucket\u003c/span\u003e: \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ebucket\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eknowledgeBase\u003c/span\u003e: kb,\n  \u003cspan class=\"hljs-attr\"\u003edataSourceName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"patients\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003echunkingStrategy\u003c/span\u003e: bedrock.\u003cspan class=\"hljs-property\"\u003eChunkingStrategy\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eDEFAULT\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003emaxTokens\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eoverlapPercentage\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e,\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eStateful 스택을 배포하려면 npm 스크립트 npm run deploy:stateful을 사용하고, 완료되면 콘솔에 로그인하여 '동기화'를 실행할 수 있습니다:\u003c/p\u003e\n\u003ch2\u003eStateless Stack\u003c/h2\u003e\n\u003cp\u003e이제 Stateless 스택을 살펴보겠습니다. 우선 S3 트리거를 추가하여 S3 버킷 내에서 변경 사항(새 파일, 수정, 삭제 등)이 발생할 때 Ingestion Lambda 함수를 호출하는 방법을 살펴보겠습니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 객체가 추가, 수정 또는 삭제될 때의 s3 이벤트 소스를 만듭니다\u003c/span\u003e\nbucket.\u003cspan class=\"hljs-title function_\"\u003eaddEventNotification\u003c/span\u003e(s3.\u003cspan class=\"hljs-property\"\u003eEventType\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eOBJECT_CREATED_PUT\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e s3n.\u003cspan class=\"hljs-title class_\"\u003eLambdaDestination\u003c/span\u003e(ingestionLambda));\nbucket.\u003cspan class=\"hljs-title function_\"\u003eaddEventNotification\u003c/span\u003e(s3.\u003cspan class=\"hljs-property\"\u003eEventType\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eOBJECT_REMOVED\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e s3n.\u003cspan class=\"hljs-title class_\"\u003eLambdaDestination\u003c/span\u003e(ingestionLambda));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런 다음 Ingestion Lambda에는 데이터 소스를 동기화하기 위해 다음 코드를 실행하는 보조 어댑터가 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e {\n  \u003cspan class=\"hljs-title class_\"\u003eBedrockAgentClient\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eStartIngestionJobCommand\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eStartIngestionJobCommandInput\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eStartIngestionJobCommandOutput\u003c/span\u003e,\n} \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"@aws-sdk/client-bedrock-agent\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { config } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"@config\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { logger } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"@shared/logger\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { v4 \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e uuid } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"uuid\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e client = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBedrockAgentClient\u003c/span\u003e();\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e knowledgeBaseId = config.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"knowledgeBaseId\"\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e dataSourceId = config.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"dataSourceId\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eingestionProcess\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e): \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e\u0026#x3C;string\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003einput\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eStartIngestionJobCommandInput\u003c/span\u003e = {\n    \u003cspan class=\"hljs-attr\"\u003eknowledgeBaseId\u003c/span\u003e: knowledgeBaseId,\n    \u003cspan class=\"hljs-attr\"\u003edataSourceId\u003c/span\u003e: dataSourceId,\n    \u003cspan class=\"hljs-attr\"\u003eclientToken\u003c/span\u003e: \u003cspan class=\"hljs-title function_\"\u003euuid\u003c/span\u003e(),\n  };\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecommand\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eStartIngestionJobCommand\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eStartIngestionJobCommand\u003c/span\u003e(input);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eresponse\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eStartIngestionJobCommandOutput\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e client.\u003cspan class=\"hljs-title function_\"\u003esend\u003c/span\u003e(command);\n  logger.\u003cspan class=\"hljs-title function_\"\u003einfo\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`response: \u003cspan class=\"hljs-subst\"\u003e${response}\u003c/span\u003e`\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003estringify\u003c/span\u003e({\n    \u003cspan class=\"hljs-attr\"\u003eingestionJob\u003c/span\u003e: response.\u003cspan class=\"hljs-property\"\u003eingestionJob\u003c/span\u003e,\n  });\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로 Lambda 함수가 동기화 수행을 허용하기 위해 필요한 IAM 정책을 살펴보겠습니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// ensure that the lambda function can start a data ingestion job\u003c/span\u003e\ningestionLambda.\u003cspan class=\"hljs-title function_\"\u003eaddToRolePolicy\u003c/span\u003e(\n  \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e iam.\u003cspan class=\"hljs-title class_\"\u003ePolicyStatement\u003c/span\u003e({\n    \u003cspan class=\"hljs-attr\"\u003eactions\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\"bedrock:StartIngestionJob\"\u003c/span\u003e],\n    \u003cspan class=\"hljs-attr\"\u003eresources\u003c/span\u003e: [knowledgeBaseArn],\n  })\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리 쿼리 람다에 유사한 정책을 추가합니다. 이 정책에 따라 쿼리 람다가 Amazon Bedrock에 대해 작업을 수행할 수 있게 됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 쿼리 람다 함수가 모델을 쿼리할 수 있도록 허용합니다\u003c/span\u003e\nqueryModelLambda.\u003cspan class=\"hljs-title function_\"\u003eaddToRolePolicy\u003c/span\u003e(\n  \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e iam.\u003cspan class=\"hljs-title class_\"\u003ePolicyStatement\u003c/span\u003e({\n    \u003cspan class=\"hljs-attr\"\u003eactions\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\"bedrock:RetrieveAndGenerate\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"bedrock:Retrieve\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"bedrock:InvokeModel\"\u003c/span\u003e],\n    \u003cspan class=\"hljs-attr\"\u003eresources\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\"*\"\u003c/span\u003e],\n  })\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e쿼리 람다의 두 번째 어댑터에 대한 코드가 아래에 표시되어 있습니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e {\n  \u003cspan class=\"hljs-title class_\"\u003eBedrockAgentRuntimeClient\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eRetrieveAndGenerateCommand\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eRetrieveAndGenerateCommandInput\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eRetrieveAndGenerateCommandOutput\u003c/span\u003e,\n} \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@aws-sdk/client-bedrock-agent-runtime'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { config } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@config'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e client = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBedrockAgentRuntimeClient\u003c/span\u003e();\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e knowledgeBaseId = config.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'knowledgeBaseId'\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003equeryModel\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eprompt: string\u003c/span\u003e): \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e\u0026#x3C;string\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003einput\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eRetrieveAndGenerateCommandInput\u003c/span\u003e = {\n    \u003cspan class=\"hljs-attr\"\u003einput\u003c/span\u003e: {\n      \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: prompt,\n    },\n    \u003cspan class=\"hljs-attr\"\u003eretrieveAndGenerateConfiguration\u003c/span\u003e: {\n      \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'KNOWLEDGE_BASE'\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eknowledgeBaseConfiguration\u003c/span\u003e: {\n        \u003cspan class=\"hljs-attr\"\u003eknowledgeBaseId\u003c/span\u003e: knowledgeBaseId,\n        \u003cspan class=\"hljs-comment\"\u003e// we are using Anthropic Claude v2 in us-east-1 in this example\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003emodelArn\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`arn:aws:bedrock:us-east-1::foundation-model/anthropic.claude-v2`\u003c/span\u003e,\n      },\n    },\n  };\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecommand\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eRetrieveAndGenerateCommand\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRetrieveAndGenerateCommand\u003c/span\u003e(\n    input\n  );\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eresponse\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eRetrieveAndGenerateCommandOutput\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e client.\u003cspan class=\"hljs-title function_\"\u003esend\u003c/span\u003e(command);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e response.\u003cspan class=\"hljs-property\"\u003eoutput\u003c/span\u003e?.\u003cspan class=\"hljs-property\"\u003etext\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e string;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e마지막 단계는 우리의 Amazon API Gateway를 추가하고, /queries/ 리소스에 대해 Query Lambda 함수를 호출하도록 허용하는 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 우리 수의원 앱에서 사용할 API를 생성합니다\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eapi\u003c/span\u003e: apigw.\u003cspan class=\"hljs-property\"\u003eRestApi\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e apigw.\u003cspan class=\"hljs-title class_\"\u003eRestApi\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"Api\"\u003c/span\u003e, {\n  \u003cspan class=\"hljs-attr\"\u003edescription\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"LJ Medical Center API\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003erestApiName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"lj-medical-center-api\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003edeploy\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eendpointTypes\u003c/span\u003e: [apigw.\u003cspan class=\"hljs-property\"\u003eEndpointType\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eREGIONAL\u003c/span\u003e],\n  \u003cspan class=\"hljs-attr\"\u003edeployOptions\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003estageName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"prod\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003edataTraceEnabled\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eloggingLevel\u003c/span\u003e: apigw.\u003cspan class=\"hljs-property\"\u003eMethodLoggingLevel\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eINFO\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003etracingEnabled\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003emetricsEnabled\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  },\n});\n\n\u003cspan class=\"hljs-comment\"\u003e// API에 대한 쿼리 리소스 생성\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003equeries\u003c/span\u003e: apigw.\u003cspan class=\"hljs-property\"\u003eResource\u003c/span\u003e = api.\u003cspan class=\"hljs-property\"\u003eroot\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eaddResource\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"queries\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// 지식 베이스 쿼리 엔드포인트 추가 (POST) - prod/queries/\u003c/span\u003e\nqueries.\u003cspan class=\"hljs-title function_\"\u003eaddMethod\u003c/span\u003e(\n  \u003cspan class=\"hljs-string\"\u003e\"POST\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e apigw.\u003cspan class=\"hljs-title class_\"\u003eLambdaIntegration\u003c/span\u003e(queryModelLambda, {\n    \u003cspan class=\"hljs-attr\"\u003eproxy\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eallowTestInvoke\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n  })\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 npm 스크립트 npm run deploy:stateless로 무상태 스택을 배포하고 기능을 테스트할 수 있습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e앱 테스트 🧪\u003c/h1\u003e\n\u003ch2\u003ePostman을 통한 테스팅\u003c/h2\u003e\n\u003cp\u003epostman/Bedrock Knowledge Bases.postman_collection.json 파일을 사용하여 자신의 URL 정보로 테스트할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e늦은 지불에 관한 간단한 쿼리를 시작해보세요:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e위의 스크린샷에서 올바른 응답을 받았음을 확인할 수 있습니다:\u003c/p\u003e\n\u003cp\u003e그런 다음 다음과 같은 쿼리를 요청할 수 있습니다:\u003c/p\u003e\n\u003cp\u003e위의 쿼리에서 답변을 성공적으로 받았음을 확인할 수 있습니다:\u003c/p\u003e\n\u003cp\u003e위의 예시는 우리 접수 직원이 모든 정책에서 필요한 정보를 빠르게 찾을 수 있는 두 가지 예시에 불과합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e어째서 이 기능을 사용해보지 않고 가상의 환자 기록을 추가해 보시겠어요? 솔루션을 배포하는 비용을 기억해 주세요!\u003c/p\u003e\n\u003ch1\u003e마무리 인사 👋🏽\u003c/h1\u003e\n\u003cp\u003e이 글을 즐겁게 읽어주셨으면 공유와 피드백도 부탁드립니다!\u003c/p\u003e\n\u003cp\u003e제 유튜브 채널을 방문해 비슷한 콘텐츠를 구독해주세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_9.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e함께 소통하고 싶어요! 아래 링크에서 저와 연계해 주세요:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.linkedin.com/in/lee-james-gilmore/\" rel=\"nofollow\" target=\"_blank\"\u003eLinkedIn\u003c/a\u003e\n\u003ca href=\"https://twitter.com/LeeJamesGilmore\" rel=\"nofollow\" target=\"_blank\"\u003eTwitter\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e만약 글을 즐겼다면, 저의 프로필 Lee James Gilmore를 팔로우하여 더 많은 글/시리즈를 만나보세요. 그리고 연락하여 인사도 잊지 마세요! 👋\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e나에 대해\u003c/h2\u003e\n\u003cp\u003e“안녕하세요, 저는 영국을 기반으로 하는 AWS 커뮤니티 빌더, 블로거, AWS 인증 클라우드 아키텍트이자 City Electrical Factors (UK) \u0026#x26; City Electric Supply (US)에서 글로벌 기술 및 아키텍처 총괄을 맡고 있는 Lee입니다. 지난 6년간 주로 AWS에서 풀스택 JavaScript 개발을 하였습니다.\u003c/p\u003e\n\u003cp\u003e저는 서버리스를 주장하는 사람으로, AWS, 혁신, 소프트웨어 아키텍처, 기술 전반에 관심을 가지고 있습니다.”\n클래프 기능을 사용하여 이 게시물이 마음에 드셨다면 반드시 박수를 눌러주세요! (여러 번 박수를 두드릴 수 있어요!!)\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cstrong\u003e_ 제공된 정보는 제 개인적인 의견이며 정보 사용에 대한 책임은 지지 않습니다. _\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e아래 정보도 참고하실만 합니다:\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData"},"buildId":"xx51Gh_JNHDTBdDwrgykD","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>