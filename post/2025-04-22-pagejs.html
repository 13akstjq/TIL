<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Next.js 15 page.js로 페이지 구성하는 방법 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-pagejs" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Next.js 15 page.js로 페이지 구성하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:title" content="Next.js 15 page.js로 페이지 구성하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-pagejs" data-gatsby-head="true"/><meta name="twitter:title" content="Next.js 15 page.js로 페이지 구성하는 방법 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2025-04-22 02:43" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/0eef537492fed77a.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/0eef537492fed77a.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-8ded8b979ba73586.js" defer=""></script><script src="/TIL/_next/static/KUC9M_yIlA1Ugo01xmkHL/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/KUC9M_yIlA1Ugo01xmkHL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Next.js 15 page.js로 페이지 구성하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Next.js 15 page.js로 페이지 구성하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Apr 22, 2025</span><span class="posts_reading_time__f7YPP">13<!-- --> min read</span></span></div></div></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>page.js 파일 이해하기</h1>
<p>이번에는 Next.js에서 route(경로)마다 고유한 UI를 정의할 수 있는 <code>page.js</code> 파일에 대해 이야기해볼게요. 간단히 말해서, 특정 경로에 연결되는 페이지 컴포넌트를 만들고 싶으면, 해당 경로 폴더 안에 <code>page.js</code> 파일을 만들고 기본 내보내기(default export)로 컴포넌트를 작성하면 됩니다.</p>
<p>예를 들어, 이렇게 작성할 수 있어요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params">{
  params,
  searchParams,
}: {
  params: <span class="hljs-built_in">Promise</span>&#x3C;{ slug: string }>
  searchParams: <span class="hljs-built_in">Promise</span>&#x3C;{ [key: string]: string | string[] | <span class="hljs-literal">undefined</span> }>
}</span>) {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>My Page<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span></span>
}
</code></pre>
<ul>
<li><strong>params</strong>: URL 경로의 동적 세그먼트(예: <code>/post/[slug]</code>에서 <code>slug</code> 값)를 받을 때 사용돼요.</li>
<li><strong>searchParams</strong>: 쿼리 스트링에 포함된 키-값 쌍을 객체 형태로 받을 수 있어요.</li>
</ul>
<p>하지만 위 예제에서는 params와 searchParams 타입을 <code>Promise</code>로 감싸고 있는데, 이는 Next.js 13+에서 서버 컴포넌트가 비동기 작업을 할 수 있어서 그런 경우가 많아요.</p>
<hr>
<h2>여기서 알아두면 좋은 점들</h2>

























<table><thead><tr><th>내용</th><th>설명</th></tr></thead><tbody><tr><td>기본 내보내기 필수</td><td><code>page.js</code>에 기본으로 export된 React 컴포넌트가 있어야 Next.js가 해당 페이지를 인식해요.</td></tr><tr><td>서버 컴포넌트 기본 적용</td><td>Next.js 13부터는 기본적으로 <code>page.js</code>는 서버 컴포넌트라서, 클라이언트 상태 관리가 필요하면 별도 설정 필요해요.(예: <code>'use client'</code> 선언)</td></tr><tr><td>동적 라우팅 지원</td><td><code>params</code>를 통해 동적 경로 세그먼트를 쉽게 받아올 수 있어 동적인 페이지 구현이 편리해졌어요.</td></tr><tr><td>쿼리 파라미터 사용법</td><td><code>searchParams</code>로 URL에 전달된 쿼리 파라미터를 받을 수 있어, 필터링이나 검색 기능 구현 가능해요.</td></tr></tbody></table>
<hr>
<h3>추가 팁!</h3>
<ul>
<li>
<p><strong><code>'use client'</code> 선언</strong><br>
만약 해당 <code>page.js</code> 안에서 <code>useState</code>, <code>useEffect</code> 같은 클라이언트 전용 API를 사용한다면, 파일 최상단에 <code>'use client'</code>를 꼭 작성해 줘야 해요. 그래야 Next.js가 클라이언트 컴포넌트로 취급합니다.</p>
</li>
<li>
<p><strong>비동기 컴포넌트</strong><br>
위 코드처럼 파라미터가 <code>Promise</code>로 되어 있다면, 컴포넌트를 <code>async</code> 함수로 만들어서 데이터를 서버에서 직접 fetch하거나 처리할 수도 있어요.</p>
</li>
<li>
<p><strong>파일 위치에 따른 라우팅</strong><br>
<code>app</code> 디렉터리 구조에 따라서 자동으로 URL 경로가 결정되니까, 폴더 이름과 파일 이름이 곧 URL이 된다고 생각하면 편합니다.</p>
</li>
</ul>
<hr>
<p><code>page.js</code>를 활용하면 각 경로별로 독립적인 UI 및 데이터 처리가 매우 편리해져서, Next.js의 강력한 기능을 실제 프로젝트에 잘 녹여내는 데 큰 도움이 됩니다!</p>
<p>한번 직접 만들어 보면서 익혀보시길 추천드려요 :)</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이번 글에서는 Next.js에서 페이지 파일과 라우팅에 대해 간단하게 정리해볼게요. 주로 <code>.js</code>, <code>.jsx</code>, <code>.tsx</code> 확장자를 가진 파일들이 페이지로서 사용되는데, 이 부분부터 시작해봅시다.</p>
<hr>
<h3>Next.js 페이지 파일 정리</h3>
<ul>
<li>
<p><strong>페이지 확장자</strong><br>
<code>.js</code>, <code>.jsx</code>, <code>.tsx</code> 확장자가 페이지 파일로 사용됩니다.<br>
즉, 이 파일들을 <code>pages</code> 디렉토리나 앱 디렉토리(route segment) 안에 넣으면 해당 파일이 하나의 페이지로 처리돼요.</p>
</li>
<li>
<p><strong>페이지가 항상 라우트 트리의 '리프(leaf)'이다</strong><br>
이 말은, 페이지가 최종적으로 도착하는 경로의 끝부분(리프 노드)이란 뜻입니다.<br>
중간 경로(segment)는 레이아웃이나 다른 로직을 담당하고, 실제 화면에 그려지는 페이지는 트리의 가장 끝에 있어요.</p>
</li>
<li>
<p><strong>라우트 세그먼트를 공개하려면 페이지 파일이 필수!</strong><br>
어떤 경로(segment)를 외부에서 접근 가능하게 만들려면 해당 위치에 페이지 파일이 꼭 필요합니다.<br>
페이지 파일이 없다면 그 경로는 사용자에게 보여지지 않아요.</p>
</li>
<li>
<p><strong>페이지는 기본적으로 서버 컴포넌트(Server Components)</strong><br>
Next.js 13부터는 페이지가 서버 컴포넌트로 기본 설정되어 있어 서버에서 렌더링됩니다.<br>
하지만 필요에 따라 클라이언트 컴포넌트(Client Component)로 설정할 수도 있어, 인터랙티브한 UI가 필요할 때는 클라이언트 컴포넌트로 바꿔주면 됩니다.</p>
</li>
</ul>
<hr>
<h3>참고: Props 중 params</h3>
<p>페이지 컴포넌트에 전달되는 <code>params</code>는 선택 사항이며, 동적 라우팅에 많이 사용됩니다.<br>
URL 경로에서 동적 세그먼트를 추출해 매개변수로 전달해주기 때문에, 예를 들어 블로그 글 ID 같은 값을 받아 처리할 때 유용하죠.</p>
<hr>
<h3>추가로 알아두면 좋은 점들</h3>
<ul>
<li>
<p><strong>서버 컴포넌트 vs 클라이언트 컴포넌트</strong></p>
<ul>
<li>서버 컴포넌트는 초기 렌더링 속도가 빠르고 SEO에 유리하며, 서버에서만 실행됩니다.</li>
<li>클라이언트 컴포넌트는 사용자 인터랙션, 상태 관리, 이벤트 핸들러에 필요하지만, 번들 크기가 커질 수 있으니 꼭 필요한 곳에만 사용하세요.</li>
</ul>
</li>
<li>
<p><strong>_app.js, _document.js 같은 특수 파일은 pages 디렉토리에서만 사용 가능하다?</strong><br>
Next.js의 앱 라우팅 시스템과 기존 pages 시스템은 약간 다르기 때문에 혼동될 수 있습니다. 만약 최신 앱 디렉토리를 사용하고 있다면, 그에 맞게 구조를 잡아야 해요.</p>
</li>
</ul>
<hr>
<p>다음에도 Next.js 라우팅이나 페이지 관련 정보를 더 쉽게 풀어서 알려드릴게요! 필요하면 댓글로 궁금한 점 주세요! 😊</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>루트 세그먼트부터 해당 페이지까지 전달되는 동적 라우트 파라미터들을 담고 있는 객체를 반환하는 Promise에 대해 살펴볼게요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params">{
  params,
}: {
  params: <span class="hljs-built_in">Promise</span>&#x3C;{ slug: string }>
}</span>) {
  <span class="hljs-keyword">const</span> { slug } = <span class="hljs-keyword">await</span> params
}
</code></pre>
<p>여기서 <code>params</code>는 Promise 형태로 넘어오기 때문에, 값을 얻어내려면 꼭 <code>async/await</code>을 써야 합니다. 혹은 React의 use 함수와 같은 방법을 써도 좋아요.</p>
<p>아래는 동적 라우팅에 따른 <code>params</code> 값 예시입니다.</p>

























<table><thead><tr><th>Example Route</th><th>URL</th><th>params</th></tr></thead><tbody><tr><td><code>app/shop/[slug]/page.js</code></td><td><code>/shop/1</code></td><td><code>Promise&#x3C;{ slug: '1' }></code></td></tr><tr><td><code>app/shop/[category]/[item]/page.js</code></td><td><code>/shop/1/2</code></td><td><code>Promise&#x3C;{ category: '1', item: '2' }></code></td></tr><tr><td><code>app/shop/[...slug]/page.js</code></td><td><code>/shop/1/2</code></td><td><code>Promise&#x3C;{ slug: ['1', '2'] }></code></td></tr></tbody></table>
<hr>
<p>참고로, Next.js 14버전까지는 <code>params</code>가 동기 프로퍼티였어요. 그래서 바로 접근 가능했죠. 근데 Next.js 15부터는 이게 Promise 형태가 됐습니다. 아직 15버전에서는 예전처럼 동기적으로 접근해도 동작하지만, 앞으로는 deprecated(사용 중단 예정)이 될 거니까 미리 <code>async/await</code> 패턴으로 바꾸는 게 좋아요.</p>
<p>추가 팁을 드리자면, 동적 라우팅에서 여러 개의 파라미터가 있을 때는 <code>params</code> 객체에 그 이름대로 키가 잡히고, catch-all 라우트(<code>[...slug]</code>)처럼 경로의 여러 값을 배열로 받을 때도 있으니 구조 분해할 때 조심하세요.</p>
<p>요약하자면,</p>
<ul>
<li>Next.js 15부터 <code>params</code>는 Promise다.</li>
<li><code>async/await</code>나 React의 use 함수로 값을 받아야 한다.</li>
<li>기존 동기 접근은 당분간 유지되지만, 곧 없어질 예정이다.</li>
</ul>
<p>이 점만 기억하면 동적 라우팅을 다룰 때 좀 더 깔끔하고 미래에도 문제없는 코드를 작성할 수 있을 거예요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h4>searchParams (선택 사항)</h4>
<p><code>searchParams</code>는 현재 URL의 쿼리 파라미터를 담고 있는 객체로, Promise 형태로 전달됩니다. 예를 들어, 이렇게 받아올 수 있죠:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params">{
  searchParams,
}: {
  searchParams: <span class="hljs-built_in">Promise</span>&#x3C;{ [key: string]: string | string[] | <span class="hljs-literal">undefined</span> }>
}</span>) {
  <span class="hljs-keyword">const</span> filters = (<span class="hljs-keyword">await</span> searchParams).<span class="hljs-property">filters</span>;
}
</code></pre>
<p>예를 들어 URL이 <code>/shop?a=1</code>이라면 <code>searchParams</code>는 <code>{ a: '1' }</code>라는 객체를 Promise로 감싸 전달합니다.</p>





















<table><thead><tr><th>예시 URL</th><th>searchParams 타입</th></tr></thead><tbody><tr><td><code>/shop?a=1</code></td><td><code>Promise&#x3C;{ a: '1' }></code></td></tr><tr><td><code>/shop?a=1&#x26;b=2</code></td><td><code>Promise&#x3C;{ a: '1', b: '2' }></code></td></tr><tr><td><code>/shop?a=1&#x26;a=2</code></td><td><code>Promise&#x3C;{ a: ['1', '2'] }></code></td></tr></tbody></table>
<p>여기서 중요한 점은, 같은 키에 여러 값이 있을 때는 배열 형태로 받아온다는 거예요. (예: <code>?a=1&#x26;a=2</code>)</p>
<hr>
<p>추가 팁을 하나 드리자면, 이 <code>searchParams</code>를 활용해 필터링 기능이나 페이징 같은 걸 페이지에서 직접 다룰 수 있어서, 서버에서 별도 처리를 하지 않고도 쿼리 기반 UI를 손쉽게 만들 수 있습니다. Next.js 13 이상 같은 최신 프레임워크에서 특히 유용한 패턴이니, 꼭 기억해두세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 내용은 Next.js의 <code>searchParams</code> prop 사용법에 관한 업데이트를 다루고 있는데요, 쉽게 말해서 <code>searchParams</code>가 이제는 Promise 형태라는 점을 기억해 두셔야 합니다. 예전(버전 14 이하)에는 동기적으로 바로 접근할 수 있었지만, 버전 15부터는 비동기적으로 값을 받아야 하므로 <code>async/await</code>이나 React의 비동기 훅을 꼭 써야 한다는 뜻이죠.</p>
<hr>
<h3>주요 포인트 정리</h3>

























<table><thead><tr><th>내용</th><th>설명</th></tr></thead><tbody><tr><td><code>searchParams</code>가 Promise 형태</td><td><code>searchParams</code>가 비동기 값이 되었어요. 따라서 값을 사용할 때 꼭 <code>await</code>를 사용하거나 비동기 훅을 사용하세요.</td></tr><tr><td>이전 버전과의 호환성</td><td>Next.js 15에서는 이전처럼 동기적으로 접근 가능하지만, 앞으로는 지원이 끊깁니다. 지금부터는 비동기로 처리하는게 안전해요.</td></tr><tr><td>동적 API</td><td><code>searchParams</code>는 동적인 API라서 해당 값을 미리 알 수 없고, 이를 쓰면 서버가 요청 시점에 페이지를 렌더링 합니다. 따라서 빌드 타임에 완전히 고정된 페이지는 아니게 돼요.</td></tr><tr><td>객체 형태</td><td><code>searchParams</code>는 <code>URLSearchParams</code> 인스턴스가 아니라 일반 자바스크립트 객체입니다. 즉, 메서드 같은 건 없고 단순 키-값 쌍이에요.</td></tr></tbody></table>
<hr>
<h3>좀 더 쉽게 이해할 수 있는 예시</h3>
<p>만약 URL에 <code>?category=books</code>라는 쿼리파라미터가 붙었다고 해볼게요. 기존에는 이렇게 바로 썼겠죠?</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params">{ searchParams }</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(searchParams.<span class="hljs-property">category</span>);
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>{searchParams.category}<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>;
}
</code></pre>
<p>하지만 이제는 이렇게 바꿔야 합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params">{ searchParams }</span>) {
  <span class="hljs-keyword">const</span> params = <span class="hljs-keyword">await</span> searchParams;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(params.<span class="hljs-property">category</span>);
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>{params.category}<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>;
}
</code></pre>
<p>또는 React의 <code>useEffect</code>를 쓰는 컴포넌트 안이라면:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">PageWrapper</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [category, setCategory] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);

  <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getParams</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">const</span> params = <span class="hljs-keyword">await</span> searchParams;
      <span class="hljs-title function_">setCategory</span>(params.<span class="hljs-property">category</span>);
    }
    <span class="hljs-title function_">getParams</span>();
  }, []);

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>{category ? category : '로딩중...'}<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>;
}
</code></pre>
<hr>
<h3>정리하며</h3>
<ul>
<li>Next.js 15부터는 <code>searchParams</code>가 비동기로 바뀌었으니, <code>await</code> 안 쓰면 제대로 된 값 못 받아요.</li>
<li>이번 업데이트로 인해 약간의 코드 수정이 필요하지만, 동적 쿼리에 더 유연하게 대응할 수 있어져서 좋은 점도 많아요.</li>
<li>참고로, <code>searchParams</code>는 그냥 키-값 객체라서 <code>get()</code> 이런 메서드는 없습니다.</li>
</ul>
<hr>
<p>앞으로 쿼리파라미터를 다룰 때 이 점 꼭 기억하시고 미리 준비해두세요! 개발할 때 예상치 못한 비동기 문제에 걸려서 당황하는 일이 크게 줄어들 거예요. 혹시 동적 라우팅이나 쿼리 데이터 처리에 대해 더 궁금한 점 있으면 언제든지 알려주세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Next.js의 새로운 app 폴더 구조에서는 페이지 컴포넌트에 <code>params</code>와 <code>searchParams</code>를 props로 전달할 수 있어요. 이걸 활용하면 동적 경로나 쿼리스트링을 쉽게 처리할 수 있답니다.</p>
<p>먼저, <code>params</code>를 이용한 예제부터 볼게요. 아래 코드에서 <code>params</code>는 URL의 동적 세그먼트(예: <code>/blog/[slug]</code>의 slug)를 의미해요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params">{
  params,
}: {
  params: <span class="hljs-built_in">Promise</span>&#x3C;{ slug: string }>
}</span>) {
  <span class="hljs-keyword">const</span> { slug } = <span class="hljs-keyword">await</span> params
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>Blog Post: {slug}<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span></span>
}
</code></pre>
<p>여기서 주목할 부분은 <code>params</code>가 Promise 형태라는 것! 그래서 <code>await</code>으로 먼저 값을 꺼내줘야해요. 이렇게 하면 URL에 따라 각기 다른 블로그 포스트를 보여줄 수 있죠.</p>
<hr>
<p>다음은 <code>searchParams</code>를 이용해서 URL 쿼리스트링을 가져오는 방법이에요. 예를 들어, <code>?page=2&#x26;sort=desc&#x26;query=apple</code> 같은 쿼리가 있을 때 유용하죠.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params">{
  searchParams,
}: {
  searchParams: <span class="hljs-built_in">Promise</span>&#x3C;{ [key: string]: string | string[] | <span class="hljs-literal">undefined</span> }>
}</span>) {
  <span class="hljs-keyword">const</span> { page = <span class="hljs-string">'1'</span>, sort = <span class="hljs-string">'asc'</span>, query = <span class="hljs-string">''</span> } = <span class="hljs-keyword">await</span> searchParams
 
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>Product Listing<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>Search query: {query}<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>Current page: {page}<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>Sort order: {sort}<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  )
}
</code></pre>
<p><code>searchParams</code> 역시 Promise 형태라서 <code>await</code> 해준 뒤 각 파라미터를 디폴트값과 함께 받는 게 좋아요. 이렇게 하면 필터링, 페이지네이션, 정렬 같은 작업을 쉽게 처리할 수 있어요.</p>
<hr>
<h3>추가 팁</h3>
<ul>
<li>
<p><code>params</code>는 동적 라우팅에서만 전달되고, <code>searchParams</code>는 URL의 쿼리스트링이 있을 때만 의미가 있습니다.</p>
</li>
<li>
<p>쿼리파라미터가 배열 형태일 수도 있으니, 타입을 <code>{ [key: string]: string | string[] | undefined }</code> 같이 지정해주는 게 좋아요.</p>
</li>
<li>
<p><code>await</code>을 꼭 사용해야 하는데, async 함수인 점을 잊지 마세요!</p>
</li>
<li>
<p>실제로는 데이터를 서버에서 가져오는 코드와 결합해서 화면에 뿌리는 경우가 많아요. 이 부분만 분리해서 써도 Next.js의 라우팅과 데이터 패칭이 간단해집니다.</p>
</li>
</ul>
<p>이제 Next.js의 새 라우팅 방식으로 더 편리한 동적 페이지와 쿼리 처리 구현해보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>클라이언트 컴포넌트에서 searchParams와 params 읽기</h3>
<p>Next.js 13의 앱 라우팅에서는 클라이언트 컴포넌트(Client Component)에서는 <code>async</code> 함수를 사용할 수 없기 때문에, <code>searchParams</code>와 <code>params</code>처럼 비동기 데이터를 직접 받아서 처리하는 데 약간의 꼼수가 필요합니다.</p>
<p>바로 React 18에서 도입된 <code>use</code> 훅을 활용하면, 비동기 <code>Promise</code> 형태로 전달되는 <code>params</code>와 <code>searchParams</code>를 간단히 읽을 수 있어요.</p>
<pre><code class="hljs language-jsx"><span class="hljs-string">'use client'</span>

<span class="hljs-keyword">import</span> { use } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params">{
  params,
  searchParams,
}: {
  params: <span class="hljs-built_in">Promise</span>&#x3C;{ slug: string }>
  searchParams: <span class="hljs-built_in">Promise</span>&#x3C;{ [key: string]: string | string[] | <span class="hljs-literal">undefined</span> }>
}</span>) {
  <span class="hljs-keyword">const</span> { slug } = <span class="hljs-title function_">use</span>(params)
  <span class="hljs-keyword">const</span> { query } = <span class="hljs-title function_">use</span>(searchParams)

  <span class="hljs-comment">// 이 시점에서는 slug와 query가 실제 데이터로 변환되어 사용 가능</span>
}
</code></pre>
<p>여기서 중요한 점은 <code>params</code>와 <code>searchParams</code>가 <code>Promise</code>로 전달된다는 것입니다. 그래서 이걸 바로 읽기 위해 <code>use(params)</code>, <code>use(searchParams)</code>를 사용하는 거죠. 이렇게 하면 동기적으로 사용할 수 있어서, 클라이언트 컴포넌트에서도 자연스럽게 데이터를 사용할 수 있습니다.</p>
<blockquote>
<p>참고로, <code>use</code> 훅은 아직 실험적인 기능이라서 프로젝트 환경이나 React 버전에 따라 다소 차이가 있을 수 있으니, 최신 공식 문서나 Next.js 업데이트를 꼭 확인하는 게 좋아요.</p>
</blockquote>
<hr>
<h2>버전 히스토리</h2>

















<table><thead><tr><th>버전</th><th>내용</th></tr></thead><tbody><tr><td>13.4</td><td>클라이언트 컴포넌트에서 <code>use</code> 훅을 활용해 <code>params</code>와 <code>searchParams</code>를 쉽게 읽을 수 있는 기능 추가</td></tr><tr><td>-</td><td><code>use</code> 훅은 React 18의 실험적 기능으로서, 점차 안정화 중</td></tr></tbody></table>
<hr>
<p>개발하면서 이런 작은 변화들이 실제 코드 작성 방식을 많이 바꾸는데요, 특히 Next.js처럼 SSR과 클라이언트 렌더링이 섞여 있는 환경에서는 비동기 데이터 처리 방법이 중요해집니다. 앞으로도 새로운 React 기능이나 Next.js 업데이트 소식 공유할게요! 도움이 되셨다면 댓글로 남겨주세요 :)</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

















<table><thead><tr><th>Version</th><th>Changes</th></tr></thead><tbody><tr><td><code>v15.0.0-RC</code></td><td><code>params</code>와 <code>searchParams</code>가 이제 Promise로 바뀌었어요. 관련해서 <a href="https://nextjs.org/docs/app/guides/upgrading/codemods#150" rel="nofollow" target="_blank">codemod</a> 도 준비되어 있으니 참고하세요!</td></tr><tr><td><code>v13.0.0</code></td><td><code>page</code>가 도입되었습니다.</td></tr></tbody></table>
<p>요즘 Next.js 업데이트 소식 전해드릴게요! 특히 <code>v15.0.0-RC</code>부터는 <code>params</code>와 <code>searchParams</code>가 비동기 처리 방식으로 바뀌어서, 기존 코드에선 약간의 수정이 필요해요. 다행히 공식에서 자동으로 코드를 바꿔주는 codemod 도구를 제공하고 있어서, 크게 어렵지 않게 적용할 수 있답니다.</p>
<p>또, 좀 더 기본적인 부분으로 돌아가 보면 <code>v13.0.0</code>에서는 이제 <code>page</code>가 도입되었는데요, Next.js 사용하시면서 페이지 단위로 구조를 잡을 때 참고하시면 좋아요. 버전 바뀔 때마다 새로운 기능이 추가되니, 자주 공식 문서 한번씩 훑어보는 걸 추천드려요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Next.js 15 page.js로 페이지 구성하는 방법","description":"","date":"2025-04-22 02:43","slug":"2025-04-22-pagejs","content":"\n\n# page.js 파일 이해하기\n\n이번에는 Next.js에서 route(경로)마다 고유한 UI를 정의할 수 있는 `page.js` 파일에 대해 이야기해볼게요. 간단히 말해서, 특정 경로에 연결되는 페이지 컴포넌트를 만들고 싶으면, 해당 경로 폴더 안에 `page.js` 파일을 만들고 기본 내보내기(default export)로 컴포넌트를 작성하면 됩니다.\n\n예를 들어, 이렇게 작성할 수 있어요:\n\n```js\nexport default function Page({\n  params,\n  searchParams,\n}: {\n  params: Promise\u003c{ slug: string }\u003e\n  searchParams: Promise\u003c{ [key: string]: string | string[] | undefined }\u003e\n}) {\n  return \u003ch1\u003eMy Page\u003c/h1\u003e\n}\n```\n\n- **params**: URL 경로의 동적 세그먼트(예: `/post/[slug]`에서 `slug` 값)를 받을 때 사용돼요.\n- **searchParams**: 쿼리 스트링에 포함된 키-값 쌍을 객체 형태로 받을 수 있어요.\n\n하지만 위 예제에서는 params와 searchParams 타입을 `Promise`로 감싸고 있는데, 이는 Next.js 13+에서 서버 컴포넌트가 비동기 작업을 할 수 있어서 그런 경우가 많아요.\n\n---\n\n## 여기서 알아두면 좋은 점들\n\n| 내용                     | 설명                                                                                      |\n|--------------------------|-------------------------------------------------------------------------------------------|\n| 기본 내보내기 필수        | `page.js`에 기본으로 export된 React 컴포넌트가 있어야 Next.js가 해당 페이지를 인식해요.       |\n| 서버 컴포넌트 기본 적용    | Next.js 13부터는 기본적으로 `page.js`는 서버 컴포넌트라서, 클라이언트 상태 관리가 필요하면 별도 설정 필요해요.(예: `'use client'` 선언) |\n| 동적 라우팅 지원          | `params`를 통해 동적 경로 세그먼트를 쉽게 받아올 수 있어 동적인 페이지 구현이 편리해졌어요.       |\n| 쿼리 파라미터 사용법      | `searchParams`로 URL에 전달된 쿼리 파라미터를 받을 수 있어, 필터링이나 검색 기능 구현 가능해요.   |\n\n---\n\n### 추가 팁! \n\n- **`'use client'` 선언**  \n  만약 해당 `page.js` 안에서 `useState`, `useEffect` 같은 클라이언트 전용 API를 사용한다면, 파일 최상단에 `'use client'`를 꼭 작성해 줘야 해요. 그래야 Next.js가 클라이언트 컴포넌트로 취급합니다.\n\n- **비동기 컴포넌트**  \n  위 코드처럼 파라미터가 `Promise`로 되어 있다면, 컴포넌트를 `async` 함수로 만들어서 데이터를 서버에서 직접 fetch하거나 처리할 수도 있어요.\n\n- **파일 위치에 따른 라우팅**  \n  `app` 디렉터리 구조에 따라서 자동으로 URL 경로가 결정되니까, 폴더 이름과 파일 이름이 곧 URL이 된다고 생각하면 편합니다.\n\n---\n\n`page.js`를 활용하면 각 경로별로 독립적인 UI 및 데이터 처리가 매우 편리해져서, Next.js의 강력한 기능을 실제 프로젝트에 잘 녹여내는 데 큰 도움이 됩니다!\n\n한번 직접 만들어 보면서 익혀보시길 추천드려요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번 글에서는 Next.js에서 페이지 파일과 라우팅에 대해 간단하게 정리해볼게요. 주로 `.js`, `.jsx`, `.tsx` 확장자를 가진 파일들이 페이지로서 사용되는데, 이 부분부터 시작해봅시다.\n\n---\n\n### Next.js 페이지 파일 정리\n\n- **페이지 확장자**  \n  `.js`, `.jsx`, `.tsx` 확장자가 페이지 파일로 사용됩니다.  \n  즉, 이 파일들을 `pages` 디렉토리나 앱 디렉토리(route segment) 안에 넣으면 해당 파일이 하나의 페이지로 처리돼요.\n\n- **페이지가 항상 라우트 트리의 '리프(leaf)'이다**  \n  이 말은, 페이지가 최종적으로 도착하는 경로의 끝부분(리프 노드)이란 뜻입니다.  \n  중간 경로(segment)는 레이아웃이나 다른 로직을 담당하고, 실제 화면에 그려지는 페이지는 트리의 가장 끝에 있어요.\n\n- **라우트 세그먼트를 공개하려면 페이지 파일이 필수!**  \n  어떤 경로(segment)를 외부에서 접근 가능하게 만들려면 해당 위치에 페이지 파일이 꼭 필요합니다.  \n  페이지 파일이 없다면 그 경로는 사용자에게 보여지지 않아요.\n\n- **페이지는 기본적으로 서버 컴포넌트(Server Components)**  \n  Next.js 13부터는 페이지가 서버 컴포넌트로 기본 설정되어 있어 서버에서 렌더링됩니다.  \n  하지만 필요에 따라 클라이언트 컴포넌트(Client Component)로 설정할 수도 있어, 인터랙티브한 UI가 필요할 때는 클라이언트 컴포넌트로 바꿔주면 됩니다.\n\n---\n\n### 참고: Props 중 params\n\n페이지 컴포넌트에 전달되는 `params`는 선택 사항이며, 동적 라우팅에 많이 사용됩니다.  \nURL 경로에서 동적 세그먼트를 추출해 매개변수로 전달해주기 때문에, 예를 들어 블로그 글 ID 같은 값을 받아 처리할 때 유용하죠.\n\n---\n\n### 추가로 알아두면 좋은 점들\n\n- **서버 컴포넌트 vs 클라이언트 컴포넌트**  \n  - 서버 컴포넌트는 초기 렌더링 속도가 빠르고 SEO에 유리하며, 서버에서만 실행됩니다.  \n  - 클라이언트 컴포넌트는 사용자 인터랙션, 상태 관리, 이벤트 핸들러에 필요하지만, 번들 크기가 커질 수 있으니 꼭 필요한 곳에만 사용하세요.\n\n- **_app.js, _document.js 같은 특수 파일은 pages 디렉토리에서만 사용 가능하다?**  \n  Next.js의 앱 라우팅 시스템과 기존 pages 시스템은 약간 다르기 때문에 혼동될 수 있습니다. 만약 최신 앱 디렉토리를 사용하고 있다면, 그에 맞게 구조를 잡아야 해요.\n\n---\n\n다음에도 Next.js 라우팅이나 페이지 관련 정보를 더 쉽게 풀어서 알려드릴게요! 필요하면 댓글로 궁금한 점 주세요! 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n루트 세그먼트부터 해당 페이지까지 전달되는 동적 라우트 파라미터들을 담고 있는 객체를 반환하는 Promise에 대해 살펴볼게요.\n\n```js\nexport default async function Page({\n  params,\n}: {\n  params: Promise\u003c{ slug: string }\u003e\n}) {\n  const { slug } = await params\n}\n```\n\n여기서 `params`는 Promise 형태로 넘어오기 때문에, 값을 얻어내려면 꼭 `async/await`을 써야 합니다. 혹은 React의 use 함수와 같은 방법을 써도 좋아요.\n\n아래는 동적 라우팅에 따른 `params` 값 예시입니다.\n\n| Example Route                      | URL        | params                          |\n|----------------------------------|------------|--------------------------------|\n| `app/shop/[slug]/page.js`         | `/shop/1`  | `Promise\u003c{ slug: '1' }\u003e`        |\n| `app/shop/[category]/[item]/page.js` | `/shop/1/2` | `Promise\u003c{ category: '1', item: '2' }\u003e` |\n| `app/shop/[...slug]/page.js`      | `/shop/1/2` | `Promise\u003c{ slug: ['1', '2'] }\u003e` |\n\n---\n\n참고로, Next.js 14버전까지는 `params`가 동기 프로퍼티였어요. 그래서 바로 접근 가능했죠. 근데 Next.js 15부터는 이게 Promise 형태가 됐습니다. 아직 15버전에서는 예전처럼 동기적으로 접근해도 동작하지만, 앞으로는 deprecated(사용 중단 예정)이 될 거니까 미리 `async/await` 패턴으로 바꾸는 게 좋아요.\n\n추가 팁을 드리자면, 동적 라우팅에서 여러 개의 파라미터가 있을 때는 `params` 객체에 그 이름대로 키가 잡히고, catch-all 라우트(`[...slug]`)처럼 경로의 여러 값을 배열로 받을 때도 있으니 구조 분해할 때 조심하세요.\n\n요약하자면,\n\n- Next.js 15부터 `params`는 Promise다.\n- `async/await`나 React의 use 함수로 값을 받아야 한다.\n- 기존 동기 접근은 당분간 유지되지만, 곧 없어질 예정이다.\n\n이 점만 기억하면 동적 라우팅을 다룰 때 좀 더 깔끔하고 미래에도 문제없는 코드를 작성할 수 있을 거예요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n#### searchParams (선택 사항)\n\n`searchParams`는 현재 URL의 쿼리 파라미터를 담고 있는 객체로, Promise 형태로 전달됩니다. 예를 들어, 이렇게 받아올 수 있죠:\n\n```js\nexport default async function Page({\n  searchParams,\n}: {\n  searchParams: Promise\u003c{ [key: string]: string | string[] | undefined }\u003e\n}) {\n  const filters = (await searchParams).filters;\n}\n```\n\n예를 들어 URL이 `/shop?a=1`이라면 `searchParams`는 `{ a: '1' }`라는 객체를 Promise로 감싸 전달합니다.\n\n| 예시 URL           | searchParams 타입              |\n|------------------|------------------------------|\n| `/shop?a=1`       | `Promise\u003c{ a: '1' }\u003e`         |\n| `/shop?a=1\u0026b=2`   | `Promise\u003c{ a: '1', b: '2' }\u003e` |\n| `/shop?a=1\u0026a=2`   | `Promise\u003c{ a: ['1', '2'] }\u003e`  |\n\n여기서 중요한 점은, 같은 키에 여러 값이 있을 때는 배열 형태로 받아온다는 거예요. (예: `?a=1\u0026a=2`)\n\n---\n\n추가 팁을 하나 드리자면, 이 `searchParams`를 활용해 필터링 기능이나 페이징 같은 걸 페이지에서 직접 다룰 수 있어서, 서버에서 별도 처리를 하지 않고도 쿼리 기반 UI를 손쉽게 만들 수 있습니다. Next.js 13 이상 같은 최신 프레임워크에서 특히 유용한 패턴이니, 꼭 기억해두세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 내용은 Next.js의 `searchParams` prop 사용법에 관한 업데이트를 다루고 있는데요, 쉽게 말해서 `searchParams`가 이제는 Promise 형태라는 점을 기억해 두셔야 합니다. 예전(버전 14 이하)에는 동기적으로 바로 접근할 수 있었지만, 버전 15부터는 비동기적으로 값을 받아야 하므로 `async/await`이나 React의 비동기 훅을 꼭 써야 한다는 뜻이죠.\n\n---\n\n### 주요 포인트 정리\n\n| 내용 | 설명 |\n|-------|---------|\n| `searchParams`가 Promise 형태 | `searchParams`가 비동기 값이 되었어요. 따라서 값을 사용할 때 꼭 `await`를 사용하거나 비동기 훅을 사용하세요. |\n| 이전 버전과의 호환성 | Next.js 15에서는 이전처럼 동기적으로 접근 가능하지만, 앞으로는 지원이 끊깁니다. 지금부터는 비동기로 처리하는게 안전해요. |\n| 동적 API | `searchParams`는 동적인 API라서 해당 값을 미리 알 수 없고, 이를 쓰면 서버가 요청 시점에 페이지를 렌더링 합니다. 따라서 빌드 타임에 완전히 고정된 페이지는 아니게 돼요. |\n| 객체 형태 | `searchParams`는 `URLSearchParams` 인스턴스가 아니라 일반 자바스크립트 객체입니다. 즉, 메서드 같은 건 없고 단순 키-값 쌍이에요. |\n\n---\n\n### 좀 더 쉽게 이해할 수 있는 예시\n\n만약 URL에 `?category=books`라는 쿼리파라미터가 붙었다고 해볼게요. 기존에는 이렇게 바로 썼겠죠?\n\n```js\nfunction Page({ searchParams }) {\n  console.log(searchParams.category);\n  return \u003cdiv\u003e{searchParams.category}\u003c/div\u003e;\n}\n```\n\n하지만 이제는 이렇게 바꿔야 합니다.\n\n```js\nasync function Page({ searchParams }) {\n  const params = await searchParams;\n  console.log(params.category);\n  return \u003cdiv\u003e{params.category}\u003c/div\u003e;\n}\n```\n\n또는 React의 `useEffect`를 쓰는 컴포넌트 안이라면:\n\n```js\nfunction PageWrapper() {\n  const [category, setCategory] = React.useState(null);\n\n  React.useEffect(() =\u003e {\n    async function getParams() {\n      const params = await searchParams;\n      setCategory(params.category);\n    }\n    getParams();\n  }, []);\n\n  return \u003cdiv\u003e{category ? category : '로딩중...'}\u003c/div\u003e;\n}\n```\n\n---\n\n### 정리하며\n\n- Next.js 15부터는 `searchParams`가 비동기로 바뀌었으니, `await` 안 쓰면 제대로 된 값 못 받아요.  \n- 이번 업데이트로 인해 약간의 코드 수정이 필요하지만, 동적 쿼리에 더 유연하게 대응할 수 있어져서 좋은 점도 많아요.  \n- 참고로, `searchParams`는 그냥 키-값 객체라서 `get()` 이런 메서드는 없습니다.\n\n---\n\n앞으로 쿼리파라미터를 다룰 때 이 점 꼭 기억하시고 미리 준비해두세요! 개발할 때 예상치 못한 비동기 문제에 걸려서 당황하는 일이 크게 줄어들 거예요. 혹시 동적 라우팅이나 쿼리 데이터 처리에 대해 더 궁금한 점 있으면 언제든지 알려주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js의 새로운 app 폴더 구조에서는 페이지 컴포넌트에 `params`와 `searchParams`를 props로 전달할 수 있어요. 이걸 활용하면 동적 경로나 쿼리스트링을 쉽게 처리할 수 있답니다.\n\n먼저, `params`를 이용한 예제부터 볼게요. 아래 코드에서 `params`는 URL의 동적 세그먼트(예: `/blog/[slug]`의 slug)를 의미해요.\n\n```js\nexport default async function Page({\n  params,\n}: {\n  params: Promise\u003c{ slug: string }\u003e\n}) {\n  const { slug } = await params\n  return \u003ch1\u003eBlog Post: {slug}\u003c/h1\u003e\n}\n```\n\n여기서 주목할 부분은 `params`가 Promise 형태라는 것! 그래서 `await`으로 먼저 값을 꺼내줘야해요. 이렇게 하면 URL에 따라 각기 다른 블로그 포스트를 보여줄 수 있죠.\n\n---\n\n다음은 `searchParams`를 이용해서 URL 쿼리스트링을 가져오는 방법이에요. 예를 들어, `?page=2\u0026sort=desc\u0026query=apple` 같은 쿼리가 있을 때 유용하죠.\n\n```js\nexport default async function Page({\n  searchParams,\n}: {\n  searchParams: Promise\u003c{ [key: string]: string | string[] | undefined }\u003e\n}) {\n  const { page = '1', sort = 'asc', query = '' } = await searchParams\n \n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003eProduct Listing\u003c/h1\u003e\n      \u003cp\u003eSearch query: {query}\u003c/p\u003e\n      \u003cp\u003eCurrent page: {page}\u003c/p\u003e\n      \u003cp\u003eSort order: {sort}\u003c/p\u003e\n    \u003c/div\u003e\n  )\n}\n```\n\n`searchParams` 역시 Promise 형태라서 `await` 해준 뒤 각 파라미터를 디폴트값과 함께 받는 게 좋아요. 이렇게 하면 필터링, 페이지네이션, 정렬 같은 작업을 쉽게 처리할 수 있어요.\n\n---\n\n### 추가 팁\n\n- `params`는 동적 라우팅에서만 전달되고, `searchParams`는 URL의 쿼리스트링이 있을 때만 의미가 있습니다.\n\n- 쿼리파라미터가 배열 형태일 수도 있으니, 타입을 `{ [key: string]: string | string[] | undefined }` 같이 지정해주는 게 좋아요.\n\n- `await`을 꼭 사용해야 하는데, async 함수인 점을 잊지 마세요!\n\n- 실제로는 데이터를 서버에서 가져오는 코드와 결합해서 화면에 뿌리는 경우가 많아요. 이 부분만 분리해서 써도 Next.js의 라우팅과 데이터 패칭이 간단해집니다.\n\n이제 Next.js의 새 라우팅 방식으로 더 편리한 동적 페이지와 쿼리 처리 구현해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 클라이언트 컴포넌트에서 searchParams와 params 읽기\n\nNext.js 13의 앱 라우팅에서는 클라이언트 컴포넌트(Client Component)에서는 `async` 함수를 사용할 수 없기 때문에, `searchParams`와 `params`처럼 비동기 데이터를 직접 받아서 처리하는 데 약간의 꼼수가 필요합니다.\n\n바로 React 18에서 도입된 `use` 훅을 활용하면, 비동기 `Promise` 형태로 전달되는 `params`와 `searchParams`를 간단히 읽을 수 있어요.\n\n```jsx\n'use client'\n\nimport { use } from 'react'\n\nexport default function Page({\n  params,\n  searchParams,\n}: {\n  params: Promise\u003c{ slug: string }\u003e\n  searchParams: Promise\u003c{ [key: string]: string | string[] | undefined }\u003e\n}) {\n  const { slug } = use(params)\n  const { query } = use(searchParams)\n\n  // 이 시점에서는 slug와 query가 실제 데이터로 변환되어 사용 가능\n}\n```\n\n여기서 중요한 점은 `params`와 `searchParams`가 `Promise`로 전달된다는 것입니다. 그래서 이걸 바로 읽기 위해 `use(params)`, `use(searchParams)`를 사용하는 거죠. 이렇게 하면 동기적으로 사용할 수 있어서, 클라이언트 컴포넌트에서도 자연스럽게 데이터를 사용할 수 있습니다.\n\n\u003e 참고로, `use` 훅은 아직 실험적인 기능이라서 프로젝트 환경이나 React 버전에 따라 다소 차이가 있을 수 있으니, 최신 공식 문서나 Next.js 업데이트를 꼭 확인하는 게 좋아요.\n\n---\n\n## 버전 히스토리\n\n| 버전  | 내용                                         |\n|-------|----------------------------------------------|\n| 13.4  | 클라이언트 컴포넌트에서 `use` 훅을 활용해 `params`와 `searchParams`를 쉽게 읽을 수 있는 기능 추가 |\n| -     | `use` 훅은 React 18의 실험적 기능으로서, 점차 안정화 중                  |\n\n---\n\n개발하면서 이런 작은 변화들이 실제 코드 작성 방식을 많이 바꾸는데요, 특히 Next.js처럼 SSR과 클라이언트 렌더링이 섞여 있는 환경에서는 비동기 데이터 처리 방법이 중요해집니다. 앞으로도 새로운 React 기능이나 Next.js 업데이트 소식 공유할게요! 도움이 되셨다면 댓글로 남겨주세요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n| Version      | Changes                                                                                   |\n|--------------|-------------------------------------------------------------------------------------------|\n| `v15.0.0-RC` | `params`와 `searchParams`가 이제 Promise로 바뀌었어요. 관련해서 [codemod](https://nextjs.org/docs/app/guides/upgrading/codemods#150) 도 준비되어 있으니 참고하세요! |\n| `v13.0.0`    | `page`가 도입되었습니다.                                                                  |\n\n요즘 Next.js 업데이트 소식 전해드릴게요! 특히 `v15.0.0-RC`부터는 `params`와 `searchParams`가 비동기 처리 방식으로 바뀌어서, 기존 코드에선 약간의 수정이 필요해요. 다행히 공식에서 자동으로 코드를 바꿔주는 codemod 도구를 제공하고 있어서, 크게 어렵지 않게 적용할 수 있답니다.\n\n또, 좀 더 기본적인 부분으로 돌아가 보면 `v13.0.0`에서는 이제 `page`가 도입되었는데요, Next.js 사용하시면서 페이지 단위로 구조를 잡을 때 참고하시면 좋아요. 버전 바뀔 때마다 새로운 기능이 추가되니, 자주 공식 문서 한번씩 훑어보는 걸 추천드려요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":13},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003epage.js 파일 이해하기\u003c/h1\u003e\n\u003cp\u003e이번에는 Next.js에서 route(경로)마다 고유한 UI를 정의할 수 있는 \u003ccode\u003epage.js\u003c/code\u003e 파일에 대해 이야기해볼게요. 간단히 말해서, 특정 경로에 연결되는 페이지 컴포넌트를 만들고 싶으면, 해당 경로 폴더 안에 \u003ccode\u003epage.js\u003c/code\u003e 파일을 만들고 기본 내보내기(default export)로 컴포넌트를 작성하면 됩니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 이렇게 작성할 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{\n  params,\n  searchParams,\n}: {\n  params: \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e\u0026#x3C;{ slug: string }\u003e\n  searchParams: \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e\u0026#x3C;{ [key: string]: string | string[] | \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e }\u003e\n}\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003eMy Page\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eparams\u003c/strong\u003e: URL 경로의 동적 세그먼트(예: \u003ccode\u003e/post/[slug]\u003c/code\u003e에서 \u003ccode\u003eslug\u003c/code\u003e 값)를 받을 때 사용돼요.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003esearchParams\u003c/strong\u003e: 쿼리 스트링에 포함된 키-값 쌍을 객체 형태로 받을 수 있어요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e하지만 위 예제에서는 params와 searchParams 타입을 \u003ccode\u003ePromise\u003c/code\u003e로 감싸고 있는데, 이는 Next.js 13+에서 서버 컴포넌트가 비동기 작업을 할 수 있어서 그런 경우가 많아요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e여기서 알아두면 좋은 점들\u003c/h2\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e내용\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e기본 내보내기 필수\u003c/td\u003e\u003ctd\u003e\u003ccode\u003epage.js\u003c/code\u003e에 기본으로 export된 React 컴포넌트가 있어야 Next.js가 해당 페이지를 인식해요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e서버 컴포넌트 기본 적용\u003c/td\u003e\u003ctd\u003eNext.js 13부터는 기본적으로 \u003ccode\u003epage.js\u003c/code\u003e는 서버 컴포넌트라서, 클라이언트 상태 관리가 필요하면 별도 설정 필요해요.(예: \u003ccode\u003e'use client'\u003c/code\u003e 선언)\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e동적 라우팅 지원\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eparams\u003c/code\u003e를 통해 동적 경로 세그먼트를 쉽게 받아올 수 있어 동적인 페이지 구현이 편리해졌어요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e쿼리 파라미터 사용법\u003c/td\u003e\u003ctd\u003e\u003ccode\u003esearchParams\u003c/code\u003e로 URL에 전달된 쿼리 파라미터를 받을 수 있어, 필터링이나 검색 기능 구현 가능해요.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003ch3\u003e추가 팁!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003e'use client'\u003c/code\u003e 선언\u003c/strong\u003e\u003cbr\u003e\n만약 해당 \u003ccode\u003epage.js\u003c/code\u003e 안에서 \u003ccode\u003euseState\u003c/code\u003e, \u003ccode\u003euseEffect\u003c/code\u003e 같은 클라이언트 전용 API를 사용한다면, 파일 최상단에 \u003ccode\u003e'use client'\u003c/code\u003e를 꼭 작성해 줘야 해요. 그래야 Next.js가 클라이언트 컴포넌트로 취급합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e비동기 컴포넌트\u003c/strong\u003e\u003cbr\u003e\n위 코드처럼 파라미터가 \u003ccode\u003ePromise\u003c/code\u003e로 되어 있다면, 컴포넌트를 \u003ccode\u003easync\u003c/code\u003e 함수로 만들어서 데이터를 서버에서 직접 fetch하거나 처리할 수도 있어요.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e파일 위치에 따른 라우팅\u003c/strong\u003e\u003cbr\u003e\n\u003ccode\u003eapp\u003c/code\u003e 디렉터리 구조에 따라서 자동으로 URL 경로가 결정되니까, 폴더 이름과 파일 이름이 곧 URL이 된다고 생각하면 편합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e\u003ccode\u003epage.js\u003c/code\u003e를 활용하면 각 경로별로 독립적인 UI 및 데이터 처리가 매우 편리해져서, Next.js의 강력한 기능을 실제 프로젝트에 잘 녹여내는 데 큰 도움이 됩니다!\u003c/p\u003e\n\u003cp\u003e한번 직접 만들어 보면서 익혀보시길 추천드려요 :)\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이번 글에서는 Next.js에서 페이지 파일과 라우팅에 대해 간단하게 정리해볼게요. 주로 \u003ccode\u003e.js\u003c/code\u003e, \u003ccode\u003e.jsx\u003c/code\u003e, \u003ccode\u003e.tsx\u003c/code\u003e 확장자를 가진 파일들이 페이지로서 사용되는데, 이 부분부터 시작해봅시다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003eNext.js 페이지 파일 정리\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e페이지 확장자\u003c/strong\u003e\u003cbr\u003e\n\u003ccode\u003e.js\u003c/code\u003e, \u003ccode\u003e.jsx\u003c/code\u003e, \u003ccode\u003e.tsx\u003c/code\u003e 확장자가 페이지 파일로 사용됩니다.\u003cbr\u003e\n즉, 이 파일들을 \u003ccode\u003epages\u003c/code\u003e 디렉토리나 앱 디렉토리(route segment) 안에 넣으면 해당 파일이 하나의 페이지로 처리돼요.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e페이지가 항상 라우트 트리의 '리프(leaf)'이다\u003c/strong\u003e\u003cbr\u003e\n이 말은, 페이지가 최종적으로 도착하는 경로의 끝부분(리프 노드)이란 뜻입니다.\u003cbr\u003e\n중간 경로(segment)는 레이아웃이나 다른 로직을 담당하고, 실제 화면에 그려지는 페이지는 트리의 가장 끝에 있어요.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e라우트 세그먼트를 공개하려면 페이지 파일이 필수!\u003c/strong\u003e\u003cbr\u003e\n어떤 경로(segment)를 외부에서 접근 가능하게 만들려면 해당 위치에 페이지 파일이 꼭 필요합니다.\u003cbr\u003e\n페이지 파일이 없다면 그 경로는 사용자에게 보여지지 않아요.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e페이지는 기본적으로 서버 컴포넌트(Server Components)\u003c/strong\u003e\u003cbr\u003e\nNext.js 13부터는 페이지가 서버 컴포넌트로 기본 설정되어 있어 서버에서 렌더링됩니다.\u003cbr\u003e\n하지만 필요에 따라 클라이언트 컴포넌트(Client Component)로 설정할 수도 있어, 인터랙티브한 UI가 필요할 때는 클라이언트 컴포넌트로 바꿔주면 됩니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003e참고: Props 중 params\u003c/h3\u003e\n\u003cp\u003e페이지 컴포넌트에 전달되는 \u003ccode\u003eparams\u003c/code\u003e는 선택 사항이며, 동적 라우팅에 많이 사용됩니다.\u003cbr\u003e\nURL 경로에서 동적 세그먼트를 추출해 매개변수로 전달해주기 때문에, 예를 들어 블로그 글 ID 같은 값을 받아 처리할 때 유용하죠.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e추가로 알아두면 좋은 점들\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e서버 컴포넌트 vs 클라이언트 컴포넌트\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e서버 컴포넌트는 초기 렌더링 속도가 빠르고 SEO에 유리하며, 서버에서만 실행됩니다.\u003c/li\u003e\n\u003cli\u003e클라이언트 컴포넌트는 사용자 인터랙션, 상태 관리, 이벤트 핸들러에 필요하지만, 번들 크기가 커질 수 있으니 꼭 필요한 곳에만 사용하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e_app.js, _document.js 같은 특수 파일은 pages 디렉토리에서만 사용 가능하다?\u003c/strong\u003e\u003cbr\u003e\nNext.js의 앱 라우팅 시스템과 기존 pages 시스템은 약간 다르기 때문에 혼동될 수 있습니다. 만약 최신 앱 디렉토리를 사용하고 있다면, 그에 맞게 구조를 잡아야 해요.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e다음에도 Next.js 라우팅이나 페이지 관련 정보를 더 쉽게 풀어서 알려드릴게요! 필요하면 댓글로 궁금한 점 주세요! 😊\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e루트 세그먼트부터 해당 페이지까지 전달되는 동적 라우트 파라미터들을 담고 있는 객체를 반환하는 Promise에 대해 살펴볼게요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{\n  params,\n}: {\n  params: \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e\u0026#x3C;{ slug: string }\u003e\n}\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { slug } = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e params\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 \u003ccode\u003eparams\u003c/code\u003e는 Promise 형태로 넘어오기 때문에, 값을 얻어내려면 꼭 \u003ccode\u003easync/await\u003c/code\u003e을 써야 합니다. 혹은 React의 use 함수와 같은 방법을 써도 좋아요.\u003c/p\u003e\n\u003cp\u003e아래는 동적 라우팅에 따른 \u003ccode\u003eparams\u003c/code\u003e 값 예시입니다.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eExample Route\u003c/th\u003e\u003cth\u003eURL\u003c/th\u003e\u003cth\u003eparams\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eapp/shop/[slug]/page.js\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e/shop/1\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003ePromise\u0026#x3C;{ slug: '1' }\u003e\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eapp/shop/[category]/[item]/page.js\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e/shop/1/2\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003ePromise\u0026#x3C;{ category: '1', item: '2' }\u003e\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eapp/shop/[...slug]/page.js\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e/shop/1/2\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003ePromise\u0026#x3C;{ slug: ['1', '2'] }\u003e\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003cp\u003e참고로, Next.js 14버전까지는 \u003ccode\u003eparams\u003c/code\u003e가 동기 프로퍼티였어요. 그래서 바로 접근 가능했죠. 근데 Next.js 15부터는 이게 Promise 형태가 됐습니다. 아직 15버전에서는 예전처럼 동기적으로 접근해도 동작하지만, 앞으로는 deprecated(사용 중단 예정)이 될 거니까 미리 \u003ccode\u003easync/await\u003c/code\u003e 패턴으로 바꾸는 게 좋아요.\u003c/p\u003e\n\u003cp\u003e추가 팁을 드리자면, 동적 라우팅에서 여러 개의 파라미터가 있을 때는 \u003ccode\u003eparams\u003c/code\u003e 객체에 그 이름대로 키가 잡히고, catch-all 라우트(\u003ccode\u003e[...slug]\u003c/code\u003e)처럼 경로의 여러 값을 배열로 받을 때도 있으니 구조 분해할 때 조심하세요.\u003c/p\u003e\n\u003cp\u003e요약하자면,\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eNext.js 15부터 \u003ccode\u003eparams\u003c/code\u003e는 Promise다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003easync/await\u003c/code\u003e나 React의 use 함수로 값을 받아야 한다.\u003c/li\u003e\n\u003cli\u003e기존 동기 접근은 당분간 유지되지만, 곧 없어질 예정이다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 점만 기억하면 동적 라우팅을 다룰 때 좀 더 깔끔하고 미래에도 문제없는 코드를 작성할 수 있을 거예요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch4\u003esearchParams (선택 사항)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003esearchParams\u003c/code\u003e는 현재 URL의 쿼리 파라미터를 담고 있는 객체로, Promise 형태로 전달됩니다. 예를 들어, 이렇게 받아올 수 있죠:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{\n  searchParams,\n}: {\n  searchParams: \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e\u0026#x3C;{ [key: string]: string | string[] | \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e }\u003e\n}\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e filters = (\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e searchParams).\u003cspan class=\"hljs-property\"\u003efilters\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예를 들어 URL이 \u003ccode\u003e/shop?a=1\u003c/code\u003e이라면 \u003ccode\u003esearchParams\u003c/code\u003e는 \u003ccode\u003e{ a: '1' }\u003c/code\u003e라는 객체를 Promise로 감싸 전달합니다.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e예시 URL\u003c/th\u003e\u003cth\u003esearchParams 타입\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e/shop?a=1\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003ePromise\u0026#x3C;{ a: '1' }\u003e\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e/shop?a=1\u0026#x26;b=2\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003ePromise\u0026#x3C;{ a: '1', b: '2' }\u003e\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e/shop?a=1\u0026#x26;a=2\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003ePromise\u0026#x3C;{ a: ['1', '2'] }\u003e\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e여기서 중요한 점은, 같은 키에 여러 값이 있을 때는 배열 형태로 받아온다는 거예요. (예: \u003ccode\u003e?a=1\u0026#x26;a=2\u003c/code\u003e)\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e추가 팁을 하나 드리자면, 이 \u003ccode\u003esearchParams\u003c/code\u003e를 활용해 필터링 기능이나 페이징 같은 걸 페이지에서 직접 다룰 수 있어서, 서버에서 별도 처리를 하지 않고도 쿼리 기반 UI를 손쉽게 만들 수 있습니다. Next.js 13 이상 같은 최신 프레임워크에서 특히 유용한 패턴이니, 꼭 기억해두세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 내용은 Next.js의 \u003ccode\u003esearchParams\u003c/code\u003e prop 사용법에 관한 업데이트를 다루고 있는데요, 쉽게 말해서 \u003ccode\u003esearchParams\u003c/code\u003e가 이제는 Promise 형태라는 점을 기억해 두셔야 합니다. 예전(버전 14 이하)에는 동기적으로 바로 접근할 수 있었지만, 버전 15부터는 비동기적으로 값을 받아야 하므로 \u003ccode\u003easync/await\u003c/code\u003e이나 React의 비동기 훅을 꼭 써야 한다는 뜻이죠.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e주요 포인트 정리\u003c/h3\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e내용\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003esearchParams\u003c/code\u003e가 Promise 형태\u003c/td\u003e\u003ctd\u003e\u003ccode\u003esearchParams\u003c/code\u003e가 비동기 값이 되었어요. 따라서 값을 사용할 때 꼭 \u003ccode\u003eawait\u003c/code\u003e를 사용하거나 비동기 훅을 사용하세요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e이전 버전과의 호환성\u003c/td\u003e\u003ctd\u003eNext.js 15에서는 이전처럼 동기적으로 접근 가능하지만, 앞으로는 지원이 끊깁니다. 지금부터는 비동기로 처리하는게 안전해요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e동적 API\u003c/td\u003e\u003ctd\u003e\u003ccode\u003esearchParams\u003c/code\u003e는 동적인 API라서 해당 값을 미리 알 수 없고, 이를 쓰면 서버가 요청 시점에 페이지를 렌더링 합니다. 따라서 빌드 타임에 완전히 고정된 페이지는 아니게 돼요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e객체 형태\u003c/td\u003e\u003ctd\u003e\u003ccode\u003esearchParams\u003c/code\u003e는 \u003ccode\u003eURLSearchParams\u003c/code\u003e 인스턴스가 아니라 일반 자바스크립트 객체입니다. 즉, 메서드 같은 건 없고 단순 키-값 쌍이에요.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003ch3\u003e좀 더 쉽게 이해할 수 있는 예시\u003c/h3\u003e\n\u003cp\u003e만약 URL에 \u003ccode\u003e?category=books\u003c/code\u003e라는 쿼리파라미터가 붙었다고 해볼게요. 기존에는 이렇게 바로 썼겠죠?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ searchParams }\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(searchParams.\u003cspan class=\"hljs-property\"\u003ecategory\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e{searchParams.category}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e하지만 이제는 이렇게 바꿔야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ searchParams }\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e params = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e searchParams;\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(params.\u003cspan class=\"hljs-property\"\u003ecategory\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e{params.category}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또는 React의 \u003ccode\u003euseEffect\u003c/code\u003e를 쓰는 컴포넌트 안이라면:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePageWrapper\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [category, setCategory] = \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003euseEffect\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetParams\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e params = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e searchParams;\n      \u003cspan class=\"hljs-title function_\"\u003esetCategory\u003c/span\u003e(params.\u003cspan class=\"hljs-property\"\u003ecategory\u003c/span\u003e);\n    }\n    \u003cspan class=\"hljs-title function_\"\u003egetParams\u003c/span\u003e();\n  }, []);\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e{category ? category : '로딩중...'}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003e정리하며\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eNext.js 15부터는 \u003ccode\u003esearchParams\u003c/code\u003e가 비동기로 바뀌었으니, \u003ccode\u003eawait\u003c/code\u003e 안 쓰면 제대로 된 값 못 받아요.\u003c/li\u003e\n\u003cli\u003e이번 업데이트로 인해 약간의 코드 수정이 필요하지만, 동적 쿼리에 더 유연하게 대응할 수 있어져서 좋은 점도 많아요.\u003c/li\u003e\n\u003cli\u003e참고로, \u003ccode\u003esearchParams\u003c/code\u003e는 그냥 키-값 객체라서 \u003ccode\u003eget()\u003c/code\u003e 이런 메서드는 없습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e앞으로 쿼리파라미터를 다룰 때 이 점 꼭 기억하시고 미리 준비해두세요! 개발할 때 예상치 못한 비동기 문제에 걸려서 당황하는 일이 크게 줄어들 거예요. 혹시 동적 라우팅이나 쿼리 데이터 처리에 대해 더 궁금한 점 있으면 언제든지 알려주세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eNext.js의 새로운 app 폴더 구조에서는 페이지 컴포넌트에 \u003ccode\u003eparams\u003c/code\u003e와 \u003ccode\u003esearchParams\u003c/code\u003e를 props로 전달할 수 있어요. 이걸 활용하면 동적 경로나 쿼리스트링을 쉽게 처리할 수 있답니다.\u003c/p\u003e\n\u003cp\u003e먼저, \u003ccode\u003eparams\u003c/code\u003e를 이용한 예제부터 볼게요. 아래 코드에서 \u003ccode\u003eparams\u003c/code\u003e는 URL의 동적 세그먼트(예: \u003ccode\u003e/blog/[slug]\u003c/code\u003e의 slug)를 의미해요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{\n  params,\n}: {\n  params: \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e\u0026#x3C;{ slug: string }\u003e\n}\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { slug } = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e params\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003eBlog Post: {slug}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 주목할 부분은 \u003ccode\u003eparams\u003c/code\u003e가 Promise 형태라는 것! 그래서 \u003ccode\u003eawait\u003c/code\u003e으로 먼저 값을 꺼내줘야해요. 이렇게 하면 URL에 따라 각기 다른 블로그 포스트를 보여줄 수 있죠.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e다음은 \u003ccode\u003esearchParams\u003c/code\u003e를 이용해서 URL 쿼리스트링을 가져오는 방법이에요. 예를 들어, \u003ccode\u003e?page=2\u0026#x26;sort=desc\u0026#x26;query=apple\u003c/code\u003e 같은 쿼리가 있을 때 유용하죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{\n  searchParams,\n}: {\n  searchParams: \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e\u0026#x3C;{ [key: string]: string | string[] | \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e }\u003e\n}\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { page = \u003cspan class=\"hljs-string\"\u003e'1'\u003c/span\u003e, sort = \u003cspan class=\"hljs-string\"\u003e'asc'\u003c/span\u003e, query = \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e } = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e searchParams\n \n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003eProduct Listing\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003eSearch query: {query}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003eCurrent page: {page}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003eSort order: {sort}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003esearchParams\u003c/code\u003e 역시 Promise 형태라서 \u003ccode\u003eawait\u003c/code\u003e 해준 뒤 각 파라미터를 디폴트값과 함께 받는 게 좋아요. 이렇게 하면 필터링, 페이지네이션, 정렬 같은 작업을 쉽게 처리할 수 있어요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e추가 팁\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eparams\u003c/code\u003e는 동적 라우팅에서만 전달되고, \u003ccode\u003esearchParams\u003c/code\u003e는 URL의 쿼리스트링이 있을 때만 의미가 있습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e쿼리파라미터가 배열 형태일 수도 있으니, 타입을 \u003ccode\u003e{ [key: string]: string | string[] | undefined }\u003c/code\u003e 같이 지정해주는 게 좋아요.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eawait\u003c/code\u003e을 꼭 사용해야 하는데, async 함수인 점을 잊지 마세요!\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e실제로는 데이터를 서버에서 가져오는 코드와 결합해서 화면에 뿌리는 경우가 많아요. 이 부분만 분리해서 써도 Next.js의 라우팅과 데이터 패칭이 간단해집니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이제 Next.js의 새 라우팅 방식으로 더 편리한 동적 페이지와 쿼리 처리 구현해보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003e클라이언트 컴포넌트에서 searchParams와 params 읽기\u003c/h3\u003e\n\u003cp\u003eNext.js 13의 앱 라우팅에서는 클라이언트 컴포넌트(Client Component)에서는 \u003ccode\u003easync\u003c/code\u003e 함수를 사용할 수 없기 때문에, \u003ccode\u003esearchParams\u003c/code\u003e와 \u003ccode\u003eparams\u003c/code\u003e처럼 비동기 데이터를 직접 받아서 처리하는 데 약간의 꼼수가 필요합니다.\u003c/p\u003e\n\u003cp\u003e바로 React 18에서 도입된 \u003ccode\u003euse\u003c/code\u003e 훅을 활용하면, 비동기 \u003ccode\u003ePromise\u003c/code\u003e 형태로 전달되는 \u003ccode\u003eparams\u003c/code\u003e와 \u003ccode\u003esearchParams\u003c/code\u003e를 간단히 읽을 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-string\"\u003e'use client'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { use } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{\n  params,\n  searchParams,\n}: {\n  params: \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e\u0026#x3C;{ slug: string }\u003e\n  searchParams: \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e\u0026#x3C;{ [key: string]: string | string[] | \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e }\u003e\n}\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { slug } = \u003cspan class=\"hljs-title function_\"\u003euse\u003c/span\u003e(params)\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { query } = \u003cspan class=\"hljs-title function_\"\u003euse\u003c/span\u003e(searchParams)\n\n  \u003cspan class=\"hljs-comment\"\u003e// 이 시점에서는 slug와 query가 실제 데이터로 변환되어 사용 가능\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 중요한 점은 \u003ccode\u003eparams\u003c/code\u003e와 \u003ccode\u003esearchParams\u003c/code\u003e가 \u003ccode\u003ePromise\u003c/code\u003e로 전달된다는 것입니다. 그래서 이걸 바로 읽기 위해 \u003ccode\u003euse(params)\u003c/code\u003e, \u003ccode\u003euse(searchParams)\u003c/code\u003e를 사용하는 거죠. 이렇게 하면 동기적으로 사용할 수 있어서, 클라이언트 컴포넌트에서도 자연스럽게 데이터를 사용할 수 있습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e참고로, \u003ccode\u003euse\u003c/code\u003e 훅은 아직 실험적인 기능이라서 프로젝트 환경이나 React 버전에 따라 다소 차이가 있을 수 있으니, 최신 공식 문서나 Next.js 업데이트를 꼭 확인하는 게 좋아요.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch2\u003e버전 히스토리\u003c/h2\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e버전\u003c/th\u003e\u003cth\u003e내용\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e13.4\u003c/td\u003e\u003ctd\u003e클라이언트 컴포넌트에서 \u003ccode\u003euse\u003c/code\u003e 훅을 활용해 \u003ccode\u003eparams\u003c/code\u003e와 \u003ccode\u003esearchParams\u003c/code\u003e를 쉽게 읽을 수 있는 기능 추가\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e-\u003c/td\u003e\u003ctd\u003e\u003ccode\u003euse\u003c/code\u003e 훅은 React 18의 실험적 기능으로서, 점차 안정화 중\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003cp\u003e개발하면서 이런 작은 변화들이 실제 코드 작성 방식을 많이 바꾸는데요, 특히 Next.js처럼 SSR과 클라이언트 렌더링이 섞여 있는 환경에서는 비동기 데이터 처리 방법이 중요해집니다. 앞으로도 새로운 React 기능이나 Next.js 업데이트 소식 공유할게요! 도움이 되셨다면 댓글로 남겨주세요 :)\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eVersion\u003c/th\u003e\u003cth\u003eChanges\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev15.0.0-RC\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eparams\u003c/code\u003e와 \u003ccode\u003esearchParams\u003c/code\u003e가 이제 Promise로 바뀌었어요. 관련해서 \u003ca href=\"https://nextjs.org/docs/app/guides/upgrading/codemods#150\" rel=\"nofollow\" target=\"_blank\"\u003ecodemod\u003c/a\u003e 도 준비되어 있으니 참고하세요!\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev13.0.0\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003epage\u003c/code\u003e가 도입되었습니다.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e요즘 Next.js 업데이트 소식 전해드릴게요! 특히 \u003ccode\u003ev15.0.0-RC\u003c/code\u003e부터는 \u003ccode\u003eparams\u003c/code\u003e와 \u003ccode\u003esearchParams\u003c/code\u003e가 비동기 처리 방식으로 바뀌어서, 기존 코드에선 약간의 수정이 필요해요. 다행히 공식에서 자동으로 코드를 바꿔주는 codemod 도구를 제공하고 있어서, 크게 어렵지 않게 적용할 수 있답니다.\u003c/p\u003e\n\u003cp\u003e또, 좀 더 기본적인 부분으로 돌아가 보면 \u003ccode\u003ev13.0.0\u003c/code\u003e에서는 이제 \u003ccode\u003epage\u003c/code\u003e가 도입되었는데요, Next.js 사용하시면서 페이지 단위로 구조를 잡을 때 참고하시면 좋아요. 버전 바뀔 때마다 새로운 기능이 추가되니, 자주 공식 문서 한번씩 훑어보는 걸 추천드려요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2025-04-22-pagejs"},"buildId":"KUC9M_yIlA1Ugo01xmkHL","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>