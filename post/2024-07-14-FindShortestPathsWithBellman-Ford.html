<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>벨만-포드 알고리즘으로 최단 경로 찾는 방법 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2024-07-14-FindShortestPathsWithBellman-Ford" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="벨만-포드 알고리즘으로 최단 경로 찾는 방법 | TIL" data-gatsby-head="true"/><meta property="og:title" content="벨만-포드 알고리즘으로 최단 경로 찾는 방법 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2024-07-14-FindShortestPathsWithBellman-Ford" data-gatsby-head="true"/><meta name="twitter:title" content="벨만-포드 알고리즘으로 최단 경로 찾는 방법 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-14 20:09" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-5ecfd58aae5a7e3d.js" defer=""></script><script src="/TIL/_next/static/B2TETmJptwqhd4vJNGZoH/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/B2TETmJptwqhd4vJNGZoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">벨만-포드 알고리즘으로 최단 경로 찾는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="벨만-포드 알고리즘으로 최단 경로 찾는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 14, 2024</span><span class="posts_reading_time__f7YPP">11<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-07-14-FindShortestPathsWithBellman-Ford&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_0.png">
<p>최단 경로 찾기는 컴퓨터 과학에서 기본적인 문제로, 네트워크 라우팅 프로토콜부터 그래프 분석까지 다양한 알고리즘과 응용프로그램의 기초를 형성합니다. 현실에서는 물류 및 통신 네트워크에서 효율적인 경로를 찾고 여행 시간을 최소화하는 데 핵심적인 문제입니다.</p>
<p>이 문제가 이렇게 중요하기 때문에 많은 사람들이 이를 해결하는 방법에 대해 고민했습니다. 이는 다양한 가정과 실행 시간을 가진 다양한 알고리즘의 동물원으로 이어졌습니다. 이 글에서는 벨만-포드 알고리즘의 작동 방식과 Python 및 Rust에서의 구현 방법을 보여 드리고자 합니다.</p>
<h1>(Shimbel-)벨만-포드(-무어) 알고리즘</h1>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>알고리즘의 이름부터 헷갈릴 수 있어요. 문헌에서는 벨만-포드 알고리즘으로 알려져 있지만 많은 사람들이 관여했습니다. Alexander Schrijver의 논문 "조합 최적화의 역사에 대하여"에 따르면, Alfonso Shimbel은 1955년에 동등한 알고리즘을 개발했고, Richard Bellman과 Lester Ford Jr.은 각각 1958년과 1956년에 이 알고리즘을 설명했습니다. 이후 Edward F. Moore가 1959년에 알고리즘의 변형을 발표했어요. 하지만 걱정하지 마세요, 이 알고리즘 자체는 그 역사보다 이해하기 쉬워요.</p>
<p>이들의 알고리즘은 여러분이 주어진 그래프의 고정된 노드에서 시작하여 다른 각 노드까지의 최단 경로 문제를 해결해요. 다음과 같은 그래프를 예시로 삼아볼게요:</p>
<img src="/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_1.png">
<p>총 6개의 방향성이 있는 에지로 연결된 네 개의 노드를 볼 수 있어요. 각 에지는 가중치가 있습니다. 예를 들어, 3에서 0으로 가는 에지의 가중치는 1이에요. 노드 0에서 노드 2로의 최단 경로는 직접적인 0-2가 아닌 총 비용이 (-1)+1+0 = 0인 0-1-3-2일 수 있어요. 이제 이러한 경로를 알고리즘적으로 찾는 고수준 아이디어에 대해 이야기해볼게요.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>아이디어</h2>
<p>알고리즘은 시작 노드로부터 i개 이하의 엣지를 사용하여 다른 모든 노드까지의 최단 경로의 길이를 배열 형태로 유지하는 간단한 아이디어를 중심으로 돌아갑니다.</p>
<p>이 배열을 i = 0, 1, ...부터 순차적으로 계산합니다. 각 반복에서 i에 대한 정보는 이전 반복 i-1의 배열과 그래프의 엣지를 사용합니다.</p>
<h2>예시</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>자 그럼 이제 작은 예제를 사용해보자. 노드 0에서 다른 모든 노드로 가는 최단 경로 길이를 찾고 싶다고 가정해보자. 나중 단계에서 실제 경로도 재구성할 것이지만, 일단은 일 노드 간의 경로 길이에만 관심을 갖자.</p>
<p>거리 배열을 [0, ∞, ∞, ∞]로 시작한다. 즉, 우리는 최대 edge 0을 사용하여 0 노드에서 0 노드로 총 길이 0만큼 도달할 수 있다는 것이다. 이것은 우리가 정한 정의다. 두 번째 항목은 0 노드에서 1 노드로 최대 edge 0을 사용하여 ∞ 길이로 도달할 수 있음을 의미하는데, 즉 해당 노드에 도달할 수 없다는 것이다. 동일한 이유로 0 노드에서 2와 3으로 가는 것도 동일하다.</p>
<p>거리를 해당 노드 옆에 써보자:</p>
<p><img src="/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_2.png" alt="이미지"></p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>다음 반복에서는 최소경로 길이를 포함하는 다른 배열 [a, b, c, d]를 채우려고 합니다. 이 배열은 노드 0에서 최대 한 개의 엣지를 사용하여 다른 모든 노드까지의 최단 경로 길이를 포함합니다. 이전 배열을 사용하여 이를 어떻게 계산하는지 살펴봅시다. 예를 들어, 노드 0에서 1까지의 최단 경로 길이를 알고 싶다면 두 가지 가능성이 있습니다:</p>
<ul>
<li>
<p>0에서 1까지 엣지를 사용하지 않고 이동하거나</p>
</li>
<li>
<p>0에서 1까지 추가 엣지를 사용하여 이동합니다.</p>
</li>
</ul>
<p>옵션 1은 이전 배열 [0, ∞, ∞, ∞]에서 볼 수 있듯이 길이가 ∞입니다. 두 번째 옵션의 길이는 -1이며 그래프를 통해 노드 0에서 노드 1로 -1의 비용으로 이동할 수 있습니다. 분명히 이전에 보았던 ∞보다 -1이 더 작으므로 배열에 이를 넣어 보겠습니다. 다른 노드에 대해 동일한 작업을 수행하면 업데이트된 배열 [0, -1, 1, ∞]이 됩니다. 이제 이 반복이 완료되었습니다.</p>
<p>그래픽적으로表시하면:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_3.png" alt="image"></p>
<p>다음 이터레이션에서는 같은 게임을 다시 합니다. 노드 0에서 다른 모든 노드로 가는 최단 경로 길이가 최대 두 개의 변을 사용하여 [a, b, c, d]를 채우고 싶습니다. 예를 들어, 노드 0에서 노드 3까지의 최단 경로 길이를 계산해 봅시다. 노드 0에서 노드 3으로 가는 여러 옵션이 있습니다:</p>
<ul>
<li>단일 변을 사용하여 0에서 3으로 이동: 길이는 이전 이터레이션의 배열에서 볼 수있는대로 ∞입니다.</li>
<li>먼저 노드 1로 이동한 다음 1에서 3으로 가는 변을 사용할 수 있습니다. 하나의 변만 사용하여 노드 1로 가는 데 드는 비용은 배열에서 확인할 수 있는대로 -1입니다. 노드 1에서 노드 3으로 한 단계 더 가는 데 드는 비용은 그래프에서 확인할 수 있는대로 1입니다. 따라서 이미 이전 옵션보다 작은 비용인 0으로 노드 0에서 노드 3에 도달할 수 있습니다.</li>
<li>먼저 노드 2로 이동한 다음 2에서 3으로 가는 변을 사용할 수 있습니다. 따라서 노드 0에서 노드 3으로 2 단계로 도달하여 비용은 1 + 2 = 3입니다.</li>
</ul>
<p>다른 옵션이 없으므로 두 번째 옵션에서 최단 경로 길이는 0입니다. 다른 노드에 대해도 수행하면 배열 [0, -1, 1, 0]을 얻을 수 있습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_4.png" alt="이미지"></p>
<p>이전 배열 [0, -1, 1, 0]에서 시작하는 한 번 더의 반복 작업을 합니다. 이번 반복에서는 노드 0에서 노드 2로의 최단 경로 길이가 변하는 것 외에는 큰 변화가 없습니다. 이전 배열에서 볼 수 있듯이, 최대 두 개의 엣지를 사용하여 길이가 1인 것을 알 수 있습니다. 그러나 처음에 우리는 실제로 길이가 (-1) + 1 + 0 = 0인 0–1–3–2의 최단 경로를 보았습니다. 우리는 현재 반복에서 이 경로 길이를 찾을 것이며, 그러면 알고리즘이 종료됩니다. 이것은 네 개의 노드를 가지면 최단 경로가 최대 세 개의 엣지만을 포함해야 하거나 일반적으로 N 노드를 가지면 N— 1개의 엣지를 포함해야 하기 때문입니다.</p>
<p><img src="/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_5.png" alt="이미지"></p>
<h2>음수 순환이란</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>마지막 문장에서 조금 거짓말을 한 것 같아요. 음의 순환이 존재할 수 있다는 건데요, 예를 들어 노드 u에서 자신으로 돌아와 경로의 총 길이가 0보다 작은 것입니다. 이 경우 순환을 돌 때마다 경로의 길이를 줄일 수 있기 때문에 최단한 경로가 없는 것이죠. 음의 순환을 찾으려면 N개의 노드가 있을 때 N번째 반복을 실행해야 합니다. 음의 순환하지 않는다면 이 반복에서 우리 배열이 변하지 않아야 합니다. 이것이 여전히 변경된다면, 어딘가에 음의 순환이 있다는 것을 알 수 있습니다. 이를 복원할 수도 있지만, 여기서는 그렇게 하지 않겠습니다.</p>
<h1>구현</h1>
<p>작은 코드량에 대한 많은 글입니다. 두 가지 다른 프로그래밍 언어인 Python과 Rust로 어떻게 하는지 살펴봅시다.</p>
<h2>Python</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>여기 있습니다. 제가 경로 길이 뿐만 아니라 가장 짧은 경로를 재구성할 수 있는 다른 배열 prev도 계산합니다.</p>
<pre><code class="hljs language-js">N = <span class="hljs-number">4</span>
graph = {<span class="hljs-number">0</span>: {<span class="hljs-number">1</span>: -<span class="hljs-number">1</span>, <span class="hljs-number">2</span>: <span class="hljs-number">1</span>}, <span class="hljs-number">1</span>: {<span class="hljs-number">3</span>: <span class="hljs-number">1</span>}, <span class="hljs-number">2</span>: {<span class="hljs-number">3</span>: <span class="hljs-number">2</span>}, <span class="hljs-number">3</span>: {<span class="hljs-number">0</span>: <span class="hljs-number">1</span>, <span class="hljs-number">2</span>: <span class="hljs-number">0</span>}}
start = <span class="hljs-number">0</span>

dists = [<span class="hljs-title function_">float</span>(<span class="hljs-string">"inf"</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(N)]
prev = [<span class="hljs-title class_">None</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(N)]

dists[start] = <span class="hljs-number">0</span>
prev[start] = start

<span class="hljs-keyword">for</span> _i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(N):
    <span class="hljs-keyword">for</span> node, edges <span class="hljs-keyword">in</span> graph.<span class="hljs-title function_">items</span>():            # 모두에 대해 반복
        <span class="hljs-keyword">for</span> next_node, weight <span class="hljs-keyword">in</span> edges.<span class="hljs-title function_">items</span>():  # <span class="hljs-string">`node`</span>에서 시작하는 모든 간선에 대해 반복
            candidate_length = dists[node] + weight
            <span class="hljs-keyword">if</span> candidate_length &#x3C; dists[next_node]:
                dists[next_node] = candidate_length
                prev[next_node] = node # <span class="hljs-string">`node`</span>에서 <span class="hljs-string">`next_node`</span>로 이동하는 것이 이전 경로보다 나은 것

<span class="hljs-keyword">for</span> node, edges <span class="hljs-keyword">in</span> graph.<span class="hljs-title function_">items</span>():
    <span class="hljs-keyword">for</span> next_node, weight <span class="hljs-keyword">in</span> edges.<span class="hljs-title function_">items</span>():
        <span class="hljs-keyword">if</span> dists[node] + weight &#x3C; dists[next_node]:
            <span class="hljs-title function_">print</span>(<span class="hljs-string">"음의 사이클이 감지되었습니다!"</span>)

<span class="hljs-title function_">print</span>(dists)
<span class="hljs-title function_">print</span>(prev)
</code></pre>
<p>출력은 다음과 같습니다.</p>
<pre><code class="hljs language-js">[<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]
[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>]
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>첫 번째 배열은 노드 0부터 노드 0, 1, 2 및 3으로 가는 가장 짧은 경로가 각각 0, -1, 0 및 0임을 나타냅니다.</p>
<p>노드 0에서 노드 2로 길이가 0인 경로를 어떻게 얻을 수 있을까요? 두 번째 배열 prev를 살펴봅시다. 거기서 prev[2] == 3 이므로 노드 3에서 노드 2로 이동합니다. 따라서 경로는 3–2로 끝납니다. 또한 노드 3에서 노드 1로 이동한다는 것을 알 수 있습니다. 따라서 경로는 1–3–2로 끝납니다. 그리고 노드 1에서 노드 0으로 이동한다는 것을 알 수 있습니다. 따라서 전체 경로는 0–1–3–2 입니다.</p>
<p>좋아요, Rust에서 같은 작업을 해봅시다!</p>
<h2>Rust</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>한 줄 씩 번역해 보았습니다. Rust에 관심이 있는 분들에게 도움이 될 수도 있을 것 같아요.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">use</span> std::collections::HashMap;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">const</span> N: <span class="hljs-type">usize</span> = <span class="hljs-number">4</span>;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">graph</span>: HashMap&#x3C;<span class="hljs-type">usize</span>, HashMap&#x3C;<span class="hljs-type">usize</span>, <span class="hljs-type">f32</span>>> = HashMap::<span class="hljs-title function_ invoke__">from</span>([
        (<span class="hljs-number">0</span>, HashMap::<span class="hljs-title function_ invoke__">from</span>([(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>.), (<span class="hljs-number">2</span>, <span class="hljs-number">1</span>.)])),
        (<span class="hljs-number">1</span>, HashMap::<span class="hljs-title function_ invoke__">from</span>([(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>.)])),
        (<span class="hljs-number">2</span>, HashMap::<span class="hljs-title function_ invoke__">from</span>([(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>.)])),
        (<span class="hljs-number">3</span>, HashMap::<span class="hljs-title function_ invoke__">from</span>([(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>.), (<span class="hljs-number">2</span>, <span class="hljs-number">0</span>.)])),
    ]);
    <span class="hljs-keyword">let</span> <span class="hljs-variable">start</span>: <span class="hljs-type">usize</span> = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">dists</span> = [<span class="hljs-type">f32</span>::INFINITY; N];
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">prev</span> = [None::&#x3C;<span class="hljs-type">usize</span>>; N];

    dists[start] = <span class="hljs-number">0.0</span>;
    prev[start] = <span class="hljs-title function_ invoke__">Some</span>(start);

    <span class="hljs-keyword">for</span> <span class="hljs-variable">_i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..N - <span class="hljs-number">1</span> {
        <span class="hljs-title function_ invoke__">for</span> (node, edges) <span class="hljs-keyword">in</span> graph.<span class="hljs-title function_ invoke__">iter</span>() {
            <span class="hljs-title function_ invoke__">for</span> (next_node, weight) <span class="hljs-keyword">in</span> edges.<span class="hljs-title function_ invoke__">iter</span>() {
                <span class="hljs-keyword">let</span> <span class="hljs-variable">candidate_length</span> = dists[*node] + *weight;
                <span class="hljs-keyword">if</span> candidate_length &#x3C; dists[*next_node] {
                    dists[*next_node] = candidate_length;
                    prev[*next_node] = <span class="hljs-title function_ invoke__">Some</span>(*node);
                }
            }
        }
    }

    <span class="hljs-title function_ invoke__">for</span> (node, edges) <span class="hljs-keyword">in</span> graph.<span class="hljs-title function_ invoke__">iter</span>() {
        <span class="hljs-title function_ invoke__">for</span> (next_node, weight) <span class="hljs-keyword">in</span> edges.<span class="hljs-title function_ invoke__">iter</span>() {
            <span class="hljs-keyword">if</span> dists[*node] + *weight &#x3C; dists[*next_node] {
                <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Negative cycle detected!"</span>);
            }
        }
    }

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, dists);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, prev);
}
</code></pre>
<h2>실행 시간과 메모리</h2>
<p>이 알고리즘은 그래프의 노드 수를 의미하는 N과 그래프의 간선 수를 의미하는 E에 대해 O(N · E) 시간에 실행된다는 것을 확인할 수 있어요. 이는 모든 N 노드를 순회하는 루프와 모든 E 간선을 순회하는 내부 루프가 중첩되어 있기 때문에 나타나는 직접적인 결과입니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>메모리 사용량 측면에서는 추가로 크기가 N인 두 개의 배열과 몇 개의 상수만 저장하면 되므로 추가 메모리 복잡도는 O(N)이 됩니다.</p>
<p>프로그래밍 언어의 성능 측정가들을 위해: 내 Python 버전은 평균적으로 노드당 10개의 이웃을 갖는 랜덤 1000개 노드 그래프에서 3초가 걸렸지만, Rust 버전은 동일한 그래프에서 0.5초가 걸렸습니다.</p>
<h1>결론</h1>
<p>이 글에서는 한 노드로부터 모든 노드까지의 최단 경로 길이와 최단 경로를 찾는 방법을 배웠습니다. 이를 위해 우리는 벨만-포드 알고리즘을 선택했습니다. 이 알고리즘은 빠르고 간단하며 효율적으로 구현할 수 있으며 추가 메모리를 많이 사용하지 않는 편리한 알고리즘입니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>더 빠른 알고리즘인 다익스트라 알고리즘을 사용할 수는 없지만, 우리 예시에는 사용할 수 없습니다. 다익스트라 알고리즘은 양의 간선 가중치를 전제로 하기 때문이죠. 그래서 약간의 음의 간선 가중치를 더해 다른 알고리즘을 사용해야 했어요. 😉</p>
<p>그래서 최단 경로 알고리즘을 구현하거나 이를 대신 처리해주는 라이브러리를 사용해야 할 때, 그 알고리즘이 어떻게 작동하는지 이해하게 되었으면 합니다.</p>
<p>오늘 새롭고 흥미로운 가치있는 것을 배우셨기를 바랍니다. 읽어주셔서 감사합니다!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"벨만-포드 알고리즘으로 최단 경로 찾는 방법","description":"","date":"2024-07-14 20:09","slug":"2024-07-14-FindShortestPathsWithBellman-Ford","content":"\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_0.png\" /\u003e\n\n최단 경로 찾기는 컴퓨터 과학에서 기본적인 문제로, 네트워크 라우팅 프로토콜부터 그래프 분석까지 다양한 알고리즘과 응용프로그램의 기초를 형성합니다. 현실에서는 물류 및 통신 네트워크에서 효율적인 경로를 찾고 여행 시간을 최소화하는 데 핵심적인 문제입니다.\n\n이 문제가 이렇게 중요하기 때문에 많은 사람들이 이를 해결하는 방법에 대해 고민했습니다. 이는 다양한 가정과 실행 시간을 가진 다양한 알고리즘의 동물원으로 이어졌습니다. 이 글에서는 벨만-포드 알고리즘의 작동 방식과 Python 및 Rust에서의 구현 방법을 보여 드리고자 합니다.\n\n# (Shimbel-)벨만-포드(-무어) 알고리즘\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n알고리즘의 이름부터 헷갈릴 수 있어요. 문헌에서는 벨만-포드 알고리즘으로 알려져 있지만 많은 사람들이 관여했습니다. Alexander Schrijver의 논문 \"조합 최적화의 역사에 대하여\"에 따르면, Alfonso Shimbel은 1955년에 동등한 알고리즘을 개발했고, Richard Bellman과 Lester Ford Jr.은 각각 1958년과 1956년에 이 알고리즘을 설명했습니다. 이후 Edward F. Moore가 1959년에 알고리즘의 변형을 발표했어요. 하지만 걱정하지 마세요, 이 알고리즘 자체는 그 역사보다 이해하기 쉬워요.\n\n이들의 알고리즘은 여러분이 주어진 그래프의 고정된 노드에서 시작하여 다른 각 노드까지의 최단 경로 문제를 해결해요. 다음과 같은 그래프를 예시로 삼아볼게요:\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_1.png\" /\u003e\n\n총 6개의 방향성이 있는 에지로 연결된 네 개의 노드를 볼 수 있어요. 각 에지는 가중치가 있습니다. 예를 들어, 3에서 0으로 가는 에지의 가중치는 1이에요. 노드 0에서 노드 2로의 최단 경로는 직접적인 0-2가 아닌 총 비용이 (-1)+1+0 = 0인 0-1-3-2일 수 있어요. 이제 이러한 경로를 알고리즘적으로 찾는 고수준 아이디어에 대해 이야기해볼게요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 아이디어\n\n알고리즘은 시작 노드로부터 i개 이하의 엣지를 사용하여 다른 모든 노드까지의 최단 경로의 길이를 배열 형태로 유지하는 간단한 아이디어를 중심으로 돌아갑니다.\n\n이 배열을 i = 0, 1, ...부터 순차적으로 계산합니다. 각 반복에서 i에 대한 정보는 이전 반복 i-1의 배열과 그래프의 엣지를 사용합니다.\n\n## 예시\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자 그럼 이제 작은 예제를 사용해보자. 노드 0에서 다른 모든 노드로 가는 최단 경로 길이를 찾고 싶다고 가정해보자. 나중 단계에서 실제 경로도 재구성할 것이지만, 일단은 일 노드 간의 경로 길이에만 관심을 갖자.\n\n거리 배열을 [0, ∞, ∞, ∞]로 시작한다. 즉, 우리는 최대 edge 0을 사용하여 0 노드에서 0 노드로 총 길이 0만큼 도달할 수 있다는 것이다. 이것은 우리가 정한 정의다. 두 번째 항목은 0 노드에서 1 노드로 최대 edge 0을 사용하여 ∞ 길이로 도달할 수 있음을 의미하는데, 즉 해당 노드에 도달할 수 없다는 것이다. 동일한 이유로 0 노드에서 2와 3으로 가는 것도 동일하다.\n\n거리를 해당 노드 옆에 써보자:\n\n![이미지](/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_2.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 반복에서는 최소경로 길이를 포함하는 다른 배열 [a, b, c, d]를 채우려고 합니다. 이 배열은 노드 0에서 최대 한 개의 엣지를 사용하여 다른 모든 노드까지의 최단 경로 길이를 포함합니다. 이전 배열을 사용하여 이를 어떻게 계산하는지 살펴봅시다. 예를 들어, 노드 0에서 1까지의 최단 경로 길이를 알고 싶다면 두 가지 가능성이 있습니다:\n\n- 0에서 1까지 엣지를 사용하지 않고 이동하거나\n\n- 0에서 1까지 추가 엣지를 사용하여 이동합니다.\n\n옵션 1은 이전 배열 [0, ∞, ∞, ∞]에서 볼 수 있듯이 길이가 ∞입니다. 두 번째 옵션의 길이는 -1이며 그래프를 통해 노드 0에서 노드 1로 -1의 비용으로 이동할 수 있습니다. 분명히 이전에 보았던 ∞보다 -1이 더 작으므로 배열에 이를 넣어 보겠습니다. 다른 노드에 대해 동일한 작업을 수행하면 업데이트된 배열 [0, -1, 1, ∞]이 됩니다. 이제 이 반복이 완료되었습니다.\n\n그래픽적으로表시하면:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_3.png)\n\n다음 이터레이션에서는 같은 게임을 다시 합니다. 노드 0에서 다른 모든 노드로 가는 최단 경로 길이가 최대 두 개의 변을 사용하여 [a, b, c, d]를 채우고 싶습니다. 예를 들어, 노드 0에서 노드 3까지의 최단 경로 길이를 계산해 봅시다. 노드 0에서 노드 3으로 가는 여러 옵션이 있습니다:\n\n- 단일 변을 사용하여 0에서 3으로 이동: 길이는 이전 이터레이션의 배열에서 볼 수있는대로 ∞입니다.\n- 먼저 노드 1로 이동한 다음 1에서 3으로 가는 변을 사용할 수 있습니다. 하나의 변만 사용하여 노드 1로 가는 데 드는 비용은 배열에서 확인할 수 있는대로 -1입니다. 노드 1에서 노드 3으로 한 단계 더 가는 데 드는 비용은 그래프에서 확인할 수 있는대로 1입니다. 따라서 이미 이전 옵션보다 작은 비용인 0으로 노드 0에서 노드 3에 도달할 수 있습니다.\n- 먼저 노드 2로 이동한 다음 2에서 3으로 가는 변을 사용할 수 있습니다. 따라서 노드 0에서 노드 3으로 2 단계로 도달하여 비용은 1 + 2 = 3입니다.\n\n다른 옵션이 없으므로 두 번째 옵션에서 최단 경로 길이는 0입니다. 다른 노드에 대해도 수행하면 배열 [0, -1, 1, 0]을 얻을 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![이미지](/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_4.png)\n\n이전 배열 [0, -1, 1, 0]에서 시작하는 한 번 더의 반복 작업을 합니다. 이번 반복에서는 노드 0에서 노드 2로의 최단 경로 길이가 변하는 것 외에는 큰 변화가 없습니다. 이전 배열에서 볼 수 있듯이, 최대 두 개의 엣지를 사용하여 길이가 1인 것을 알 수 있습니다. 그러나 처음에 우리는 실제로 길이가 (-1) + 1 + 0 = 0인 0–1–3–2의 최단 경로를 보았습니다. 우리는 현재 반복에서 이 경로 길이를 찾을 것이며, 그러면 알고리즘이 종료됩니다. 이것은 네 개의 노드를 가지면 최단 경로가 최대 세 개의 엣지만을 포함해야 하거나 일반적으로 N 노드를 가지면 N— 1개의 엣지를 포함해야 하기 때문입니다.\n\n![이미지](/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_5.png)\n\n## 음수 순환이란\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마지막 문장에서 조금 거짓말을 한 것 같아요. 음의 순환이 존재할 수 있다는 건데요, 예를 들어 노드 u에서 자신으로 돌아와 경로의 총 길이가 0보다 작은 것입니다. 이 경우 순환을 돌 때마다 경로의 길이를 줄일 수 있기 때문에 최단한 경로가 없는 것이죠. 음의 순환을 찾으려면 N개의 노드가 있을 때 N번째 반복을 실행해야 합니다. 음의 순환하지 않는다면 이 반복에서 우리 배열이 변하지 않아야 합니다. 이것이 여전히 변경된다면, 어딘가에 음의 순환이 있다는 것을 알 수 있습니다. 이를 복원할 수도 있지만, 여기서는 그렇게 하지 않겠습니다.\n\n# 구현\n\n작은 코드량에 대한 많은 글입니다. 두 가지 다른 프로그래밍 언어인 Python과 Rust로 어떻게 하는지 살펴봅시다.\n\n## Python\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기 있습니다. 제가 경로 길이 뿐만 아니라 가장 짧은 경로를 재구성할 수 있는 다른 배열 prev도 계산합니다.\n\n```js\nN = 4\ngraph = {0: {1: -1, 2: 1}, 1: {3: 1}, 2: {3: 2}, 3: {0: 1, 2: 0}}\nstart = 0\n\ndists = [float(\"inf\") for i in range(N)]\nprev = [None for i in range(N)]\n\ndists[start] = 0\nprev[start] = start\n\nfor _i in range(N):\n    for node, edges in graph.items():            # 모두에 대해 반복\n        for next_node, weight in edges.items():  # `node`에서 시작하는 모든 간선에 대해 반복\n            candidate_length = dists[node] + weight\n            if candidate_length \u003c dists[next_node]:\n                dists[next_node] = candidate_length\n                prev[next_node] = node # `node`에서 `next_node`로 이동하는 것이 이전 경로보다 나은 것\n\nfor node, edges in graph.items():\n    for next_node, weight in edges.items():\n        if dists[node] + weight \u003c dists[next_node]:\n            print(\"음의 사이클이 감지되었습니다!\")\n\nprint(dists)\nprint(prev)\n```\n\n출력은 다음과 같습니다.\n\n```js\n[0, -1, 0, 0]\n[0, 0, 3, 1]\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n첫 번째 배열은 노드 0부터 노드 0, 1, 2 및 3으로 가는 가장 짧은 경로가 각각 0, -1, 0 및 0임을 나타냅니다.\n\n노드 0에서 노드 2로 길이가 0인 경로를 어떻게 얻을 수 있을까요? 두 번째 배열 prev를 살펴봅시다. 거기서 prev[2] == 3 이므로 노드 3에서 노드 2로 이동합니다. 따라서 경로는 3–2로 끝납니다. 또한 노드 3에서 노드 1로 이동한다는 것을 알 수 있습니다. 따라서 경로는 1–3–2로 끝납니다. 그리고 노드 1에서 노드 0으로 이동한다는 것을 알 수 있습니다. 따라서 전체 경로는 0–1–3–2 입니다.\n\n좋아요, Rust에서 같은 작업을 해봅시다!\n\n## Rust\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한 줄 씩 번역해 보았습니다. Rust에 관심이 있는 분들에게 도움이 될 수도 있을 것 같아요.\n\n```rust\nuse std::collections::HashMap;\n\nfn main() {\n    const N: usize = 4;\n    let graph: HashMap\u003cusize, HashMap\u003cusize, f32\u003e\u003e = HashMap::from([\n        (0, HashMap::from([(1, -1.), (2, 1.)])),\n        (1, HashMap::from([(3, 1.)])),\n        (2, HashMap::from([(3, 2.)])),\n        (3, HashMap::from([(0, 1.), (2, 0.)])),\n    ]);\n    let start: usize = 0;\n\n    let mut dists = [f32::INFINITY; N];\n    let mut prev = [None::\u003cusize\u003e; N];\n\n    dists[start] = 0.0;\n    prev[start] = Some(start);\n\n    for _i in 0..N - 1 {\n        for (node, edges) in graph.iter() {\n            for (next_node, weight) in edges.iter() {\n                let candidate_length = dists[*node] + *weight;\n                if candidate_length \u003c dists[*next_node] {\n                    dists[*next_node] = candidate_length;\n                    prev[*next_node] = Some(*node);\n                }\n            }\n        }\n    }\n\n    for (node, edges) in graph.iter() {\n        for (next_node, weight) in edges.iter() {\n            if dists[*node] + *weight \u003c dists[*next_node] {\n                println!(\"Negative cycle detected!\");\n            }\n        }\n    }\n\n    println!(\"{:?}\", dists);\n    println!(\"{:?}\", prev);\n}\n```\n\n## 실행 시간과 메모리\n\n이 알고리즘은 그래프의 노드 수를 의미하는 N과 그래프의 간선 수를 의미하는 E에 대해 O(N · E) 시간에 실행된다는 것을 확인할 수 있어요. 이는 모든 N 노드를 순회하는 루프와 모든 E 간선을 순회하는 내부 루프가 중첩되어 있기 때문에 나타나는 직접적인 결과입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n메모리 사용량 측면에서는 추가로 크기가 N인 두 개의 배열과 몇 개의 상수만 저장하면 되므로 추가 메모리 복잡도는 O(N)이 됩니다.\n\n프로그래밍 언어의 성능 측정가들을 위해: 내 Python 버전은 평균적으로 노드당 10개의 이웃을 갖는 랜덤 1000개 노드 그래프에서 3초가 걸렸지만, Rust 버전은 동일한 그래프에서 0.5초가 걸렸습니다.\n\n# 결론\n\n이 글에서는 한 노드로부터 모든 노드까지의 최단 경로 길이와 최단 경로를 찾는 방법을 배웠습니다. 이를 위해 우리는 벨만-포드 알고리즘을 선택했습니다. 이 알고리즘은 빠르고 간단하며 효율적으로 구현할 수 있으며 추가 메모리를 많이 사용하지 않는 편리한 알고리즘입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n더 빠른 알고리즘인 다익스트라 알고리즘을 사용할 수는 없지만, 우리 예시에는 사용할 수 없습니다. 다익스트라 알고리즘은 양의 간선 가중치를 전제로 하기 때문이죠. 그래서 약간의 음의 간선 가중치를 더해 다른 알고리즘을 사용해야 했어요. 😉\n\n그래서 최단 경로 알고리즘을 구현하거나 이를 대신 처리해주는 라이브러리를 사용해야 할 때, 그 알고리즘이 어떻게 작동하는지 이해하게 되었으면 합니다.\n\n오늘 새롭고 흥미로운 가치있는 것을 배우셨기를 바랍니다. 읽어주셔서 감사합니다!","ogImage":{"url":"/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_0.png","tag":["Tech"],"readingTime":11},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_0.png\"\u003e\n\u003cp\u003e최단 경로 찾기는 컴퓨터 과학에서 기본적인 문제로, 네트워크 라우팅 프로토콜부터 그래프 분석까지 다양한 알고리즘과 응용프로그램의 기초를 형성합니다. 현실에서는 물류 및 통신 네트워크에서 효율적인 경로를 찾고 여행 시간을 최소화하는 데 핵심적인 문제입니다.\u003c/p\u003e\n\u003cp\u003e이 문제가 이렇게 중요하기 때문에 많은 사람들이 이를 해결하는 방법에 대해 고민했습니다. 이는 다양한 가정과 실행 시간을 가진 다양한 알고리즘의 동물원으로 이어졌습니다. 이 글에서는 벨만-포드 알고리즘의 작동 방식과 Python 및 Rust에서의 구현 방법을 보여 드리고자 합니다.\u003c/p\u003e\n\u003ch1\u003e(Shimbel-)벨만-포드(-무어) 알고리즘\u003c/h1\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e알고리즘의 이름부터 헷갈릴 수 있어요. 문헌에서는 벨만-포드 알고리즘으로 알려져 있지만 많은 사람들이 관여했습니다. Alexander Schrijver의 논문 \"조합 최적화의 역사에 대하여\"에 따르면, Alfonso Shimbel은 1955년에 동등한 알고리즘을 개발했고, Richard Bellman과 Lester Ford Jr.은 각각 1958년과 1956년에 이 알고리즘을 설명했습니다. 이후 Edward F. Moore가 1959년에 알고리즘의 변형을 발표했어요. 하지만 걱정하지 마세요, 이 알고리즘 자체는 그 역사보다 이해하기 쉬워요.\u003c/p\u003e\n\u003cp\u003e이들의 알고리즘은 여러분이 주어진 그래프의 고정된 노드에서 시작하여 다른 각 노드까지의 최단 경로 문제를 해결해요. 다음과 같은 그래프를 예시로 삼아볼게요:\u003c/p\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_1.png\"\u003e\n\u003cp\u003e총 6개의 방향성이 있는 에지로 연결된 네 개의 노드를 볼 수 있어요. 각 에지는 가중치가 있습니다. 예를 들어, 3에서 0으로 가는 에지의 가중치는 1이에요. 노드 0에서 노드 2로의 최단 경로는 직접적인 0-2가 아닌 총 비용이 (-1)+1+0 = 0인 0-1-3-2일 수 있어요. 이제 이러한 경로를 알고리즘적으로 찾는 고수준 아이디어에 대해 이야기해볼게요.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e아이디어\u003c/h2\u003e\n\u003cp\u003e알고리즘은 시작 노드로부터 i개 이하의 엣지를 사용하여 다른 모든 노드까지의 최단 경로의 길이를 배열 형태로 유지하는 간단한 아이디어를 중심으로 돌아갑니다.\u003c/p\u003e\n\u003cp\u003e이 배열을 i = 0, 1, ...부터 순차적으로 계산합니다. 각 반복에서 i에 대한 정보는 이전 반복 i-1의 배열과 그래프의 엣지를 사용합니다.\u003c/p\u003e\n\u003ch2\u003e예시\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e자 그럼 이제 작은 예제를 사용해보자. 노드 0에서 다른 모든 노드로 가는 최단 경로 길이를 찾고 싶다고 가정해보자. 나중 단계에서 실제 경로도 재구성할 것이지만, 일단은 일 노드 간의 경로 길이에만 관심을 갖자.\u003c/p\u003e\n\u003cp\u003e거리 배열을 [0, ∞, ∞, ∞]로 시작한다. 즉, 우리는 최대 edge 0을 사용하여 0 노드에서 0 노드로 총 길이 0만큼 도달할 수 있다는 것이다. 이것은 우리가 정한 정의다. 두 번째 항목은 0 노드에서 1 노드로 최대 edge 0을 사용하여 ∞ 길이로 도달할 수 있음을 의미하는데, 즉 해당 노드에 도달할 수 없다는 것이다. 동일한 이유로 0 노드에서 2와 3으로 가는 것도 동일하다.\u003c/p\u003e\n\u003cp\u003e거리를 해당 노드 옆에 써보자:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e다음 반복에서는 최소경로 길이를 포함하는 다른 배열 [a, b, c, d]를 채우려고 합니다. 이 배열은 노드 0에서 최대 한 개의 엣지를 사용하여 다른 모든 노드까지의 최단 경로 길이를 포함합니다. 이전 배열을 사용하여 이를 어떻게 계산하는지 살펴봅시다. 예를 들어, 노드 0에서 1까지의 최단 경로 길이를 알고 싶다면 두 가지 가능성이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e0에서 1까지 엣지를 사용하지 않고 이동하거나\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e0에서 1까지 추가 엣지를 사용하여 이동합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e옵션 1은 이전 배열 [0, ∞, ∞, ∞]에서 볼 수 있듯이 길이가 ∞입니다. 두 번째 옵션의 길이는 -1이며 그래프를 통해 노드 0에서 노드 1로 -1의 비용으로 이동할 수 있습니다. 분명히 이전에 보았던 ∞보다 -1이 더 작으므로 배열에 이를 넣어 보겠습니다. 다른 노드에 대해 동일한 작업을 수행하면 업데이트된 배열 [0, -1, 1, ∞]이 됩니다. 이제 이 반복이 완료되었습니다.\u003c/p\u003e\n\u003cp\u003e그래픽적으로表시하면:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_3.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e다음 이터레이션에서는 같은 게임을 다시 합니다. 노드 0에서 다른 모든 노드로 가는 최단 경로 길이가 최대 두 개의 변을 사용하여 [a, b, c, d]를 채우고 싶습니다. 예를 들어, 노드 0에서 노드 3까지의 최단 경로 길이를 계산해 봅시다. 노드 0에서 노드 3으로 가는 여러 옵션이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e단일 변을 사용하여 0에서 3으로 이동: 길이는 이전 이터레이션의 배열에서 볼 수있는대로 ∞입니다.\u003c/li\u003e\n\u003cli\u003e먼저 노드 1로 이동한 다음 1에서 3으로 가는 변을 사용할 수 있습니다. 하나의 변만 사용하여 노드 1로 가는 데 드는 비용은 배열에서 확인할 수 있는대로 -1입니다. 노드 1에서 노드 3으로 한 단계 더 가는 데 드는 비용은 그래프에서 확인할 수 있는대로 1입니다. 따라서 이미 이전 옵션보다 작은 비용인 0으로 노드 0에서 노드 3에 도달할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e먼저 노드 2로 이동한 다음 2에서 3으로 가는 변을 사용할 수 있습니다. 따라서 노드 0에서 노드 3으로 2 단계로 도달하여 비용은 1 + 2 = 3입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다른 옵션이 없으므로 두 번째 옵션에서 최단 경로 길이는 0입니다. 다른 노드에 대해도 수행하면 배열 [0, -1, 1, 0]을 얻을 수 있습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_4.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이전 배열 [0, -1, 1, 0]에서 시작하는 한 번 더의 반복 작업을 합니다. 이번 반복에서는 노드 0에서 노드 2로의 최단 경로 길이가 변하는 것 외에는 큰 변화가 없습니다. 이전 배열에서 볼 수 있듯이, 최대 두 개의 엣지를 사용하여 길이가 1인 것을 알 수 있습니다. 그러나 처음에 우리는 실제로 길이가 (-1) + 1 + 0 = 0인 0–1–3–2의 최단 경로를 보았습니다. 우리는 현재 반복에서 이 경로 길이를 찾을 것이며, 그러면 알고리즘이 종료됩니다. 이것은 네 개의 노드를 가지면 최단 경로가 최대 세 개의 엣지만을 포함해야 하거나 일반적으로 N 노드를 가지면 N— 1개의 엣지를 포함해야 하기 때문입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_5.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003e음수 순환이란\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e마지막 문장에서 조금 거짓말을 한 것 같아요. 음의 순환이 존재할 수 있다는 건데요, 예를 들어 노드 u에서 자신으로 돌아와 경로의 총 길이가 0보다 작은 것입니다. 이 경우 순환을 돌 때마다 경로의 길이를 줄일 수 있기 때문에 최단한 경로가 없는 것이죠. 음의 순환을 찾으려면 N개의 노드가 있을 때 N번째 반복을 실행해야 합니다. 음의 순환하지 않는다면 이 반복에서 우리 배열이 변하지 않아야 합니다. 이것이 여전히 변경된다면, 어딘가에 음의 순환이 있다는 것을 알 수 있습니다. 이를 복원할 수도 있지만, 여기서는 그렇게 하지 않겠습니다.\u003c/p\u003e\n\u003ch1\u003e구현\u003c/h1\u003e\n\u003cp\u003e작은 코드량에 대한 많은 글입니다. 두 가지 다른 프로그래밍 언어인 Python과 Rust로 어떻게 하는지 살펴봅시다.\u003c/p\u003e\n\u003ch2\u003ePython\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e여기 있습니다. 제가 경로 길이 뿐만 아니라 가장 짧은 경로를 재구성할 수 있는 다른 배열 prev도 계산합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eN = \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e\ngraph = {\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e: {\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e: -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e}, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e: {\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e}, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e: {\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e}, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e: {\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e}}\nstart = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n\ndists = [\u003cspan class=\"hljs-title function_\"\u003efloat\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"inf\"\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(N)]\nprev = [\u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(N)]\n\ndists[start] = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\nprev[start] = start\n\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e _i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(N):\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e node, edges \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e graph.\u003cspan class=\"hljs-title function_\"\u003eitems\u003c/span\u003e():            # 모두에 대해 반복\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e next_node, weight \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e edges.\u003cspan class=\"hljs-title function_\"\u003eitems\u003c/span\u003e():  # \u003cspan class=\"hljs-string\"\u003e`node`\u003c/span\u003e에서 시작하는 모든 간선에 대해 반복\n            candidate_length = dists[node] + weight\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e candidate_length \u0026#x3C; dists[next_node]:\n                dists[next_node] = candidate_length\n                prev[next_node] = node # \u003cspan class=\"hljs-string\"\u003e`node`\u003c/span\u003e에서 \u003cspan class=\"hljs-string\"\u003e`next_node`\u003c/span\u003e로 이동하는 것이 이전 경로보다 나은 것\n\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e node, edges \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e graph.\u003cspan class=\"hljs-title function_\"\u003eitems\u003c/span\u003e():\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e next_node, weight \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e edges.\u003cspan class=\"hljs-title function_\"\u003eitems\u003c/span\u003e():\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e dists[node] + weight \u0026#x3C; dists[next_node]:\n            \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"음의 사이클이 감지되었습니다!\"\u003c/span\u003e)\n\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(dists)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(prev)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e출력은 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]\n[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e첫 번째 배열은 노드 0부터 노드 0, 1, 2 및 3으로 가는 가장 짧은 경로가 각각 0, -1, 0 및 0임을 나타냅니다.\u003c/p\u003e\n\u003cp\u003e노드 0에서 노드 2로 길이가 0인 경로를 어떻게 얻을 수 있을까요? 두 번째 배열 prev를 살펴봅시다. 거기서 prev[2] == 3 이므로 노드 3에서 노드 2로 이동합니다. 따라서 경로는 3–2로 끝납니다. 또한 노드 3에서 노드 1로 이동한다는 것을 알 수 있습니다. 따라서 경로는 1–3–2로 끝납니다. 그리고 노드 1에서 노드 0으로 이동한다는 것을 알 수 있습니다. 따라서 전체 경로는 0–1–3–2 입니다.\u003c/p\u003e\n\u003cp\u003e좋아요, Rust에서 같은 작업을 해봅시다!\u003c/p\u003e\n\u003ch2\u003eRust\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e한 줄 씩 번역해 보았습니다. Rust에 관심이 있는 분들에게 도움이 될 수도 있을 것 같아요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e std::collections::HashMap;\n\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e() {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e N: \u003cspan class=\"hljs-type\"\u003eusize\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003egraph\u003c/span\u003e: HashMap\u0026#x3C;\u003cspan class=\"hljs-type\"\u003eusize\u003c/span\u003e, HashMap\u0026#x3C;\u003cspan class=\"hljs-type\"\u003eusize\u003c/span\u003e, \u003cspan class=\"hljs-type\"\u003ef32\u003c/span\u003e\u003e\u003e = HashMap::\u003cspan class=\"hljs-title function_ invoke__\"\u003efrom\u003c/span\u003e([\n        (\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, HashMap::\u003cspan class=\"hljs-title function_ invoke__\"\u003efrom\u003c/span\u003e([(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e.), (\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e.)])),\n        (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, HashMap::\u003cspan class=\"hljs-title function_ invoke__\"\u003efrom\u003c/span\u003e([(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e.)])),\n        (\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, HashMap::\u003cspan class=\"hljs-title function_ invoke__\"\u003efrom\u003c/span\u003e([(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e.)])),\n        (\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, HashMap::\u003cspan class=\"hljs-title function_ invoke__\"\u003efrom\u003c/span\u003e([(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e.), (\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e.)])),\n    ]);\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003estart\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eusize\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003emut \u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003edists\u003c/span\u003e = [\u003cspan class=\"hljs-type\"\u003ef32\u003c/span\u003e::INFINITY; N];\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003emut \u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003eprev\u003c/span\u003e = [None::\u0026#x3C;\u003cspan class=\"hljs-type\"\u003eusize\u003c/span\u003e\u003e; N];\n\n    dists[start] = \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e;\n    prev[start] = \u003cspan class=\"hljs-title function_ invoke__\"\u003eSome\u003c/span\u003e(start);\n\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003e_i\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e..N - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e {\n        \u003cspan class=\"hljs-title function_ invoke__\"\u003efor\u003c/span\u003e (node, edges) \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e graph.\u003cspan class=\"hljs-title function_ invoke__\"\u003eiter\u003c/span\u003e() {\n            \u003cspan class=\"hljs-title function_ invoke__\"\u003efor\u003c/span\u003e (next_node, weight) \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e edges.\u003cspan class=\"hljs-title function_ invoke__\"\u003eiter\u003c/span\u003e() {\n                \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ecandidate_length\u003c/span\u003e = dists[*node] + *weight;\n                \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e candidate_length \u0026#x3C; dists[*next_node] {\n                    dists[*next_node] = candidate_length;\n                    prev[*next_node] = \u003cspan class=\"hljs-title function_ invoke__\"\u003eSome\u003c/span\u003e(*node);\n                }\n            }\n        }\n    }\n\n    \u003cspan class=\"hljs-title function_ invoke__\"\u003efor\u003c/span\u003e (node, edges) \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e graph.\u003cspan class=\"hljs-title function_ invoke__\"\u003eiter\u003c/span\u003e() {\n        \u003cspan class=\"hljs-title function_ invoke__\"\u003efor\u003c/span\u003e (next_node, weight) \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e edges.\u003cspan class=\"hljs-title function_ invoke__\"\u003eiter\u003c/span\u003e() {\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e dists[*node] + *weight \u0026#x3C; dists[*next_node] {\n                \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Negative cycle detected!\"\u003c/span\u003e);\n            }\n        }\n    }\n\n    \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"{:?}\"\u003c/span\u003e, dists);\n    \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"{:?}\"\u003c/span\u003e, prev);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e실행 시간과 메모리\u003c/h2\u003e\n\u003cp\u003e이 알고리즘은 그래프의 노드 수를 의미하는 N과 그래프의 간선 수를 의미하는 E에 대해 O(N · E) 시간에 실행된다는 것을 확인할 수 있어요. 이는 모든 N 노드를 순회하는 루프와 모든 E 간선을 순회하는 내부 루프가 중첩되어 있기 때문에 나타나는 직접적인 결과입니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e메모리 사용량 측면에서는 추가로 크기가 N인 두 개의 배열과 몇 개의 상수만 저장하면 되므로 추가 메모리 복잡도는 O(N)이 됩니다.\u003c/p\u003e\n\u003cp\u003e프로그래밍 언어의 성능 측정가들을 위해: 내 Python 버전은 평균적으로 노드당 10개의 이웃을 갖는 랜덤 1000개 노드 그래프에서 3초가 걸렸지만, Rust 버전은 동일한 그래프에서 0.5초가 걸렸습니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e이 글에서는 한 노드로부터 모든 노드까지의 최단 경로 길이와 최단 경로를 찾는 방법을 배웠습니다. 이를 위해 우리는 벨만-포드 알고리즘을 선택했습니다. 이 알고리즘은 빠르고 간단하며 효율적으로 구현할 수 있으며 추가 메모리를 많이 사용하지 않는 편리한 알고리즘입니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e더 빠른 알고리즘인 다익스트라 알고리즘을 사용할 수는 없지만, 우리 예시에는 사용할 수 없습니다. 다익스트라 알고리즘은 양의 간선 가중치를 전제로 하기 때문이죠. 그래서 약간의 음의 간선 가중치를 더해 다른 알고리즘을 사용해야 했어요. 😉\u003c/p\u003e\n\u003cp\u003e그래서 최단 경로 알고리즘을 구현하거나 이를 대신 처리해주는 라이브러리를 사용해야 할 때, 그 알고리즘이 어떻게 작동하는지 이해하게 되었으면 합니다.\u003c/p\u003e\n\u003cp\u003e오늘 새롭고 흥미로운 가치있는 것을 배우셨기를 바랍니다. 읽어주셔서 감사합니다!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-14-FindShortestPathsWithBellman-Ford"},"buildId":"B2TETmJptwqhd4vJNGZoH","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>