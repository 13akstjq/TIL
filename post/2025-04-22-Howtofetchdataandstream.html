<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Next.js 15에서 데이터 fetch하는 방법 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-Howtofetchdataandstream" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Next.js 15에서 데이터 fetch하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:title" content="Next.js 15에서 데이터 fetch하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-Howtofetchdataandstream" data-gatsby-head="true"/><meta name="twitter:title" content="Next.js 15에서 데이터 fetch하는 방법 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2025-04-22 01:13" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-8ded8b979ba73586.js" defer=""></script><script src="/TIL/_next/static/o6AmBAY_j9v9JmbaRA39X/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/o6AmBAY_j9v9JmbaRA39X/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Next.js 15에서 데이터 fetch하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Next.js 15에서 데이터 fetch하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Apr 22, 2025</span><span class="posts_reading_time__f7YPP">17<!-- --> min read</span></span></div></div></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>데이터 가져오기와 스트리밍하는 방법</h1>
<p>이번 글에서는 Next.js 같은 환경에서 서버 컴포넌트와 클라이언트 컴포넌트에서 데이터를 가져오는 방법을 알려드릴게요. 그리고 데이터를 기반으로 콘텐츠를 스트리밍하는 방법도 같이 살펴볼 거예요.</p>
<h2>데이터 가져오기</h2>
<h3>서버 컴포넌트에서 데이터 가져오기</h3>
<p>서버 컴포넌트(Server Components)는 서버에서 실행되기 때문에 데이터를 바로 fetch해서 렌더링할 수 있어요. 클라이언트에게는 이미 준비된 결과만 내려주기 때문에 성능도 좋고 보안상 이점도 있죠.</p>
<p>예를 들어, 이렇게 사용할 수 있어요:</p>
<pre><code class="hljs language-jsx"><span class="hljs-comment">// ServerComponent.jsx</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ServerComponent</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">"https://api.example.com/data"</span>);
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>();

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>서버에서 가져온 데이터<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>{data.message}<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">ServerComponent</span>;
</code></pre>
<p>서버 컴포넌트는 기본적으로 비동기 함수(async function)로 만들 수 있어서, 데이터를 기다렸다가 렌더링하는 것에 전혀 무리가 없답니다.</p>
<hr>
<p>추가 팁!</p>
<ul>
<li>fetch를 쓸 때는 캐싱과 관련된 옵션을 꼭 확인하세요. 예를 들어 Next.js에서는 <code>fetch('url', { next: { revalidate: 60 }})</code> 처럼 60초마다 다시 가져오게 설정할 수 있어요.</li>
<li>만약 API 호출이 오래 걸리는 경우, React 18 스트리밍 기능과 함께 쓰면 사용자에게 더 빠른 피드백을 줄 수 있어요. 이 부분도 곧 설명할게요!</li>
</ul>
<p>다음으로, 클라이언트 컴포넌트에서 데이터 가져오는 법과 스트리밍하는 예시를 이어서 다뤄볼게요.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>서버 컴포넌트(Server Components)에서 데이터를 가져올 때는 주로 이렇게 두 가지 방법을 사용해요:</p>
<ul>
<li>fetch API 활용하기</li>
<li>ORM이나 데이터베이스 직접 호출하기</li>
</ul>
<h4>fetch API 사용법</h4>
<p>fetch API를 쓰려면 컴포넌트를 비동기 함수(async function)로 만들고, fetch 호출 앞에 await를 붙여서 데이터를 받아오면 돼요. 예시를 살펴볼게요:</p>
<pre><code class="hljs language-jsx"><span class="hljs-comment">// 비동기 함수로 만든 서버 컴포넌트 예시</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">UserProfile</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">"https://api.example.com/user"</span>);

  <span class="hljs-comment">// 서버 컴포넌트에서 fetch할 때는 기본적으로 캐싱이 되는데,</span>
  <span class="hljs-comment">// 필요에 따라 cache 옵션을 조절할 수 있어요.</span>
  <span class="hljs-comment">// 예: await fetch(url, { cache: 'no-store' }) // 매번 새로 불러오기</span>

  <span class="hljs-keyword">if</span> (!res.<span class="hljs-property">ok</span>) {
    <span class="hljs-comment">// 에러 처리도 서버 컴포넌트 내에서 할 수 있답니다.</span>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"사용자 정보를 가져오는데 실패했습니다."</span>);
  }

  <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>();

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>{user.name}님 안녕하세요!<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>이메일: {user.email}<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
}
</code></pre>
<blockquote>
<p>여기서 중요한 팁! Server Components는 클라이언트와 달리 fetch API를 사용할 때 네트워크 요청이 서버에서 처리되기 때문에 API 키 같은 민감한 정보도 안전하게 다룰 수 있어요.</p>
</blockquote>
<p>다음 번에는 ORM이나 데이터베이스 직접 호출 방법도 같이 정리해볼게요! 컴포넌트에서 데이터 가져오는 게 이제 좀 감 잡히셨죠?</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이번에는 React의 Server Component에서 데이터 가져오는 방법에 대해 살펴보려고 해요. 특히 fetch API를 사용하거나 ORM을 통해 데이터베이스에서 직접 데이터를 불러오는 예제를 함께 보여드릴게요.</p>
<p>먼저, <code>fetch</code>를 사용해서 외부 API에서 블로그 글 목록을 가져오는 아주 기본적인 예제입니다.</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">"https://api.vercel.app/blog"</span>);
  <span class="hljs-keyword">const</span> posts = <span class="hljs-keyword">await</span> data.<span class="hljs-title function_">json</span>();

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">ul</span>></span>
      {posts.map((post) => (
        <span class="hljs-tag">&#x3C;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{post.id}</span>></span>{post.title}<span class="hljs-tag">&#x3C;/<span class="hljs-name">li</span>></span>
      ))}
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">ul</span>></span></span>
  );
}
</code></pre>
<p>서버 컴포넌트는 서버에서 렌더링되기 때문에 async 함수로 만들고 <code>await</code>로 데이터를 받아올 수 있는 게 큰 장점이에요. 이렇게 하면 클라이언트에서 별도로 데이터를 가져오는 로직을 짤 필요가 없고, 초기 렌더링 시점에 바로 데이터를 사용할 수 있죠.</p>
<hr>
<p>그리고 조금 더 고급 예제로, ORM이나 직접 데이터베이스 클라이언트를 사용해서 데이터베이스 쿼리를 하는 방법도 있는데요. 예를 들어, Prisma나 Drizzle ORM 같이 JavaScript/TypeScript에서 많이 사용하는 ORM을 쓸 때도 동일한 패턴입니다.</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">import</span> { db, posts } <span class="hljs-keyword">from</span> <span class="hljs-string">"@/lib/db"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> allPosts = <span class="hljs-keyword">await</span> db.<span class="hljs-title function_">select</span>().<span class="hljs-title function_">from</span>(posts);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">ul</span>></span>
      {allPosts.map((post) => (
        <span class="hljs-tag">&#x3C;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{post.id}</span>></span>{post.title}<span class="hljs-tag">&#x3C;/<span class="hljs-name">li</span>></span>
      ))}
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">ul</span>></span></span>
  );
}
</code></pre>
<p>이 경우 <code>db.select().from(posts)</code> 같은 쿼리문을 <code>await</code> 해서 서버에서 바로 데이터베이스를 조회하고, 그 결과를 UI로 바로 뿌려줄 수 있어요.</p>
<hr>
<h3>여기서 몇 가지 더 알려드릴 팁!</h3>
<ul>
<li>
<p><strong>서버 컴포넌트와 클라이언트 컴포넌트의 역할 분리!</strong><br>
서버 컴포넌트는 데이터를 불러오고, 클라이언트 컴포넌트는 사용자 상호작용(UI 이벤트 등)을 담당하는 식으로 분리하면 앱 구조가 더 깔끔해져요.</p>
</li>
<li>
<p><strong>fetch 캐싱 전략</strong><br>
<code>fetch</code> 호출할 때 <code>cache: 'no-store'</code> 옵션을 넣으면 항상 최신 데이터를 받아올 수 있고, 반대로 캐싱 옵션을 활용하면 퍼포먼스를 높일 수도 있어요.</p>
</li>
<li>
<p><strong>환경변수 사용하기</strong><br>
데이터베이스 연결이나 API 호출 시 민감한 정보(API 키 등)는 .env 파일에 숨기는 게 안전해요.</p>
</li>
</ul>
<hr>
<p>이번 글에서는 React 서버 컴포넌트 내에서 외부 API, ORM으로 데이터 가져오는 기본적인 방법을 정리해보았는데요. 실제 프로젝트에서 서버 사이드 렌더링을 하거나 Next.js와 같은 프레임워크를 사용할 때 꼭 알아두면 유용한 패턴이에요. 편하게 데이터를 다루고 싶을 때 async/await와 서버 컴포넌트를 적극 활용해보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>클라이언트 컴포넌트에서 데이터 가져오기</h3>
<p>클라이언트 컴포넌트에서 데이터를 가져오는 방법은 크게 두 가지가 있어요.</p>
<ul>
<li>React의 <code>use</code> 훅 사용하기</li>
<li>SWR, React Query 같은 커뮤니티 라이브러리 활용하기</li>
</ul>
<h4>1. React <code>use</code> 훅 사용하기</h4>
<p>React 18부터 도입된 <code>use</code> 훅을 사용하면 데이터 패칭을 조금 더 간결하게 할 수 있어요. 이 훅은 비동기 함수에서 데이터를 받아와서 컴포넌트가 렌더링되기 전에 데이터 로딩을 처리해주죠.</p>
<p>예를 들면 이렇게 사용할 수 있어요:</p>
<pre><code class="hljs language-jsx"><span class="hljs-string">"use client"</span>;

<span class="hljs-keyword">import</span> { use } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchUser</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">"/api/user"</span>);
  <span class="hljs-keyword">if</span> (!res.<span class="hljs-property">ok</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Failed to fetch user"</span>);
  <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">json</span>();
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">UserComponent</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> user = <span class="hljs-title function_">use</span>(<span class="hljs-title function_">fetchUser</span>());

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>Hello, {user.name}!<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>;
}
</code></pre>
<p><code>use</code> 훅은 서버 컴포넌트에서는 바로 사용할 수 없고 클라이언트 컴포넌트에서만 지원되니 참고하세요!</p>
<h4>2. SWR, React Query 같은 라이브러리 이용하기</h4>
<p><code>use</code> 훅이 꽤 편리하지만, 상태 관리, 캐싱, 리페치 같은 점에서 기능이 부족할 때는 SWR이나 React Query가 많이 쓰여요.</p>
<p>이들 라이브러리는 다음과 같은 이점이 있어요:</p>

























<table><thead><tr><th>장점</th><th>설명</th></tr></thead><tbody><tr><td>자동 캐싱</td><td>이전에 가져온 데이터를 캐시해서 빠르게 보여줘요.</td></tr><tr><td>배경 리페치</td><td>데이터를 최신 상태로 유지하기 위해 자동으로 재요청해요.</td></tr><tr><td>로딩과 에러 상태 처리</td><td>로딩 중인 상태나 에러를 쉽게 관리할 수 있어요.</td></tr><tr><td>폴링과 리프레시</td><td>정기적으로 데이터를 갱신하거나 수동으로 새로고침이 가능해요.</td></tr></tbody></table>
<p>예를 들어 SWR을 쓰면 이렇게 간단하게 데이터를 가져올 수 있죠:</p>
<pre><code class="hljs language-jsx"><span class="hljs-string">"use client"</span>;

<span class="hljs-keyword">import</span> useSWR <span class="hljs-keyword">from</span> <span class="hljs-string">"swr"</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">fetcher</span> = (<span class="hljs-params">url</span>) => <span class="hljs-title function_">fetch</span>(url).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =></span> res.<span class="hljs-title function_">json</span>());

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">UserComponent</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> { data, error } = <span class="hljs-title function_">useSWR</span>(<span class="hljs-string">"/api/user"</span>, fetcher);

  <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>에러 발생!<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>;
  <span class="hljs-keyword">if</span> (!data) <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>로딩 중...<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>;

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>Hello, {data.name}!<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>;
}
</code></pre>
<p>React Query 역시 비슷한 방식으로 동작하고, 복잡한 데이터 동기화 문제를 쉽게 해결할 수 있어서 대규모 프로젝트에 많이 사용돼요.</p>
<hr>
<p>데이터를 어떻게 패칭할지는 프로젝트 규모와 요구사항에 따라 선택하면 좋아요. 간단한 경우에는 React <code>use</code> 훅만으로도 충분하지만, 상태 관리가 복잡하거나 다양한 기능을 원한다면 SWR이나 React Query를 한 번 써보시길 추천해요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>React의 새로운 use hook을 활용해서 서버에서 클라이언트로 데이터를 스트리밍하는 방법을 소개할게요. 이걸 쓰면 데이터를 미리 기다리지 않고도 렌더링을 시작할 수 있어서 사용자 경험이 더 좋아져요.</p>
<p>먼저, 서버 컴포넌트에서 데이터를 가져오고, 그 Promise를 클라이언트 컴포넌트에 props로 넘겨줍니다:</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Posts</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"@/app/ui/posts"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Suspense</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 데이터 fetching 함수 호출, 여기서 await는 하지 않아요</span>
  <span class="hljs-keyword">const</span> posts = <span class="hljs-title function_">getPosts</span>();

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&#x3C;<span class="hljs-attr">div</span>></span>Loading...<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>}>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">Posts</span> <span class="hljs-attr">posts</span>=<span class="hljs-string">{posts}</span> /></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">Suspense</span>></span></span>
  );
}
</code></pre>
<p>여기서 중요한 점! getPosts() 의 Promise를 바로 넘겨주는 거예요. 아직 데이터가 준비되지 않았어도, Suspense로 감싸고 있기 때문에 로딩 UI가 보였다가 데이터가 준비되면 실제 내용이 렌더링됩니다.</p>
<p>그 다음, 클라이언트 컴포넌트에선 <code>use</code> hook을 이용해서 Promise를 읽을 수 있어요:</p>
<pre><code class="hljs language-jsx"><span class="hljs-string">"use client"</span>;
<span class="hljs-keyword">import</span> { use } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Posts</span>(<span class="hljs-params">{ posts }: { posts: <span class="hljs-built_in">Promise</span>&#x3C;{ id: string, title: string }[]> }</span>) {
  <span class="hljs-comment">// Promise가 끝날 때까지 기다렸다가 결과를 가져옵니다</span>
  <span class="hljs-keyword">const</span> allPosts = <span class="hljs-title function_">use</span>(posts);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">ul</span>></span>
      {allPosts.map((post) => (
        <span class="hljs-tag">&#x3C;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{post.id}</span>></span>{post.title}<span class="hljs-tag">&#x3C;/<span class="hljs-name">li</span>></span>
      ))}
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">ul</span>></span></span>
  );
}
</code></pre>
<p>이 방법의 장점은 서버 컴포넌트에서 데이터를 바로 넘겨주기 때문에 클라이언트에서 fetch 코드를 따로 작성할 필요가 없고, Suspense와 함께 쓰면 자연스럽게 로딩 상태도 처리할 수 있다는 점이에요.</p>
<blockquote>
<p>참고로 <code>use</code> hook은 React 18에서 도입된 기능이고 Next.js 13 같은 최신 프레임워크와 아주 잘 맞아요. 만약 여러분이 Next.js 같은 환경에서 작업한다면 적극 활용해보세요!</p>
</blockquote>
<p>요약하자면:</p>





















<table><thead><tr><th>단계</th><th>설명</th></tr></thead><tbody><tr><td>1. 서버 컴포넌트</td><td>데이터를 fetching하고 Promise를 props로 넘기기</td></tr><tr><td>2. 클라이언트 컴포넌트</td><td><code>use</code> hook으로 Promise 처리해서 데이터 사용하기</td></tr><tr><td>3. Suspense 적용</td><td>로딩 UI 관리해서 UX 향상</td></tr></tbody></table>
<p>이렇게 하면 fetch로 데이터를 직접 기다리지 않고도 부드러운 렌더링과 데이터 스트리밍 효과를 낼 수 있답니다. 한번 써보면 React의 새로운 가능성에 감탄하게 될 거예요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>위 예제에서 <code>Posts /</code> 컴포넌트를 <code>Suspense</code> 경계로 감싸줘야 합니다. 이렇게 하면 데이터 로딩 중일 때 fallback UI가 보여지면서 Promise가 해결될 때까지 기다릴 수 있어요. 스트리밍에 대해 더 알고 싶다면 실제 React 공식 문서나 관련 자료를 참고해보세요.</p>
<hr>
<h3>커뮤니티 라이브러리 활용하기</h3>
<p>React에서 클라이언트 컴포넌트 내 데이터를 가져올 때는 SWR이나 React Query 같은 커뮤니티 라이브러리를 많이 사용합니다. 이 라이브러리들은 캐싱, 스트리밍, 갱신 정책 등 다양한 기능을 제공해서 데이터 패칭을 훨씬 편리하게 만들어줘요.</p>
<p>예를 들어 SWR을 사용한 코드는 다음과 같습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-string">"use client"</span>;
<span class="hljs-keyword">import</span> useSWR <span class="hljs-keyword">from</span> <span class="hljs-string">"swr"</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">fetcher</span> = (<span class="hljs-params">url</span>) => <span class="hljs-title function_">fetch</span>(url).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">r</span>) =></span> r.<span class="hljs-title function_">json</span>());

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">BlogPage</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> { data, error, isLoading } = <span class="hljs-title function_">useSWR</span>(<span class="hljs-string">"https://api.vercel.app/blog"</span>, fetcher);

  <span class="hljs-keyword">if</span> (isLoading) <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>Loading...<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>;
  <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>Error: {error.message}<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>;

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">ul</span>></span>
      {data.map((post: { id: string, title: string }) => (
        <span class="hljs-tag">&#x3C;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{post.id}</span>></span>{post.title}<span class="hljs-tag">&#x3C;/<span class="hljs-name">li</span>></span>
      ))}
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">ul</span>></span></span>
  );
}
</code></pre>
<ul>
<li>여기서 <code>useSWR</code>은 데이터를 쉽게 가져오고 자동으로 캐싱해주며, 필요하면 재요청도 해줍니다.</li>
<li><code>isLoading</code>, <code>error</code> 상태도 관리해줘서 로딩중이나 에러가 났을 때 사용자에게 알기 쉽게 UI를 보여줄 수 있어요.</li>
<li><code>Suspense</code>를 직접 쓰는 대신 SWR이 내부적으로 비슷한 원리(loading 상태 관리)를 처리해준다고 생각하면 편합니다.</li>
</ul>
<hr>
<p>이 밖에도 React Query는 더 많은 기능과 옵션을 제공하니, 프로젝트 성격에 맞게 골라 써보시면 좋겠죠? 데이터를 클라이언트에서 관리할 때 편리한 도구들이 많으니 적극 활용해보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>스트리밍 (Streaming)</h2>
<blockquote>
<p>주의: 아래 내용은 Next.js 15 카나리 버전에서 도입된 dynamicIO 설정 옵션이 활성화되어 있다고 가정한 설명입니다.</p>
</blockquote>
<p>서버 컴포넌트(Server Components)에서 async/await를 사용할 때, Next.js는 자동으로 동적 렌더링(dynamic rendering)을 선택하게 돼요. 즉, 매번 사용자 요청이 들어올 때마다 서버에서 데이터를 가져오고 렌더링을 한다는 뜻이죠. 여기서 문제가 되는 점은, 만약 데이터 요청이 느리다면 그 경로 전체가 렌더링 되지 않고 기다리게 된다는 거예요.</p>
<p>이런 상황에서 사용자 경험과 초기 로딩 속도를 개선하기 위해 스트리밍(Streaming)을 사용할 수 있습니다. 스트리밍은 페이지의 HTML 내용을 작고 여러 개의 청크(chunk)로 나누고, 그 청크들을 서버에서 클라이언트로 점진적으로 보내는 방식을 말합니다. 이렇게 하면 사용자에게는 빠르게 일부 콘텐츠가 먼저 보이고, 나머지도 순차적으로 로딩되어 부드러운 경험을 제공할 수 있죠.</p>
<hr>
<h3>추가 팁: 스트리밍 적용 시 주의할 점</h3>
<ul>
<li>
<p><strong>콘텐츠 순서 보장</strong><br>
스트리밍은 HTML을 나누어 보내지만, 클라이언트는 리소스를 받는 순서대로 렌더링해요. 그래서 서버에서 청크를 보내는 순서를 적절히 관리하는 게 중요합니다.</p>
</li>
<li>
<p><strong>상태(state) 관리</strong><br>
서버에서 각 청크가 독립적으로 렌더링되므로, 상태 관리에 신경 써야 해요. React의 서버 컴포넌트 특성상 상태를 클라이언트와 분리해서 다뤄야 할 때도 있습니다.</p>
</li>
<li>
<p><strong>SEO 영향 고려</strong><br>
스트리밍은 SEO에도 긍정적입니다. 초기 콘텐츠를 빠르게 보여주기 때문에 검색엔진 크롤러가 콘텐츠를 더 잘 인식할 수 있어요.</p>
</li>
</ul>
<hr>
<p>스트리밍 덕분에 사용자들은 느린 데이터 로딩으로 인한 기다림이 줄어들고, 동시에 서버 자원을 효율적으로 사용할 수 있게 됩니다. Next.js의 스트리밍 기능, 꼭 활용해보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<img src="/TIL/assets/img/2025-04-22-Howtofetchdataandstream_0.png">
<p>애플리케이션에서 스트리밍(streaming)을 구현하는 방법은 크게 두 가지가 있어요:</p>
<ul>
<li><code>loading.js</code> 파일을 활용하는 방법</li>
<li>React의 <code>Suspense</code> 컴포넌트를 사용하는 방법</li>
</ul>
<h3>loading.js를 활용한 방법</h3>
<p>loading.js 파일을 이용하면 컴포넌트가 로딩 중일 때 보여줄 UI를 간단히 처리할 수 있는데요, 이것만 잘 활용해도 로딩 상태 관리가 훨씬 깔끔해집니다. React 18 이후로 서버 컴포넌트를 지원하면서 이 방식이 점점 많이 쓰이고 있죠.</p>
<p>다음에 React <code>Suspense</code> 컴포넌트를 활용하는 방법도 한번 살펴볼게요.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>여러분, Next.js에서 페이지 데이터를 가져올 때 로딩 상태를 어떻게 더 잘 보여줄 수 있을까요? 바로 <code>loading.js</code> 파일을 활용하는 방법입니다!</p>
<p>예를 들어, <code>app/blog/page.js</code> 파일과 같은 폴더(<code>app/blog</code>)에 <code>loading.js</code> 파일을 만들어주면, 페이지 데이터를 가져오는 동안 사용자가 기다리는 모습을 좀 더 깔끔하게 보여줄 수 있어요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Loading</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 여기서 로딩 화면 UI를 정의해주면 됩니다</span>
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>Loading...<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>;
}
</code></pre>
<p>이렇게 하면 사용자가 페이지로 이동할 때, 화면은 즉시 레이아웃과 이 로딩 UI를 보여주고, 데이터가 모두 준비되면 자동으로 실제 콘텐츠로 바뀌어요.</p>
<p>참고로, 이런 방식이 좋은 이유는 “빈 화면”이나 갑작스러운 깜빡임 없이 자연스럽게 사용자 경험이 이어진다는 점이에요. 실제로 프로젝트에 적용할 때는 단순 텍스트 대신 스피너 애니메이션이나 뼈대 UI(Skeleton UI)를 넣어주면 더 효과적이랍니다.</p>
<p>아래는 예시 이미지인데, 이런 식으로 로딩 중인 상태를 좀 더 친절하게 보여줄 수 있어요.</p>






<table><thead><tr><th><img src="https://yourdomain.com/assets/img/2025-04-22-Howtofetchdataandstream_1.png" alt="로딩 화면 예시"></th></tr></thead></table>
<p>나중에 <code>loading.js</code>에서 다양한 로딩 상태 구현을 고민해보면서, 사용자 경험을 한층 업그레이드 해보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<img src="/TIL/assets/img/2025-04-22-Howtofetchdataandstream_2.png">
<p>뒤에서 보면, <code>loading.js</code>는 <code>layout.js</code> 내부에 중첩되어 자동으로 <code>page.js</code> 파일과 그 아래 자식들을 <code>Suspense</code> 경계로 감싸게 돼요.</p>
<img src="/TIL/assets/img/2025-04-22-Howtofetchdataandstream_3.png">
<p>이 방식은 라우트 세그먼트(레이아웃과 페이지)에 잘 맞지만, 더 세밀한 스트리밍이 필요하다면 직접 <code>Suspense</code>를 활용하는 게 좋아요.</p>
<hr>
<p>여기서 잠깐! <code>Suspense</code>를 사용하면 리액트에서 비동기 데이터를 로딩하는 동안 그 자리를 대체하는 로딩 UI를 보여줄 수 있다는 점이 정말 편해요. 특히 Next.js 13처럼 서버 컴포넌트가 도입된 환경에서는 <code>loading.js</code> 같은 파일로 페이지 단위 로딩 처리를 자동으로 해주니까 개발이 훨씬 수월해지죠.</p>
<p>하지만, 한 단계 더 들어가서 페이지 일부만 따로 로딩하고 싶을 때(예를 들어, 큰 리스트 아이템 중 일부만 먼저 보여주고, 나머지는 천천히 로딩하고 싶을 때) <code>Suspense</code>를 직접 사용하는 것이 필요해집니다.</p>
<p>즉,</p>
<ul>
<li><code>loading.js</code> + <code>layout.js</code> = 페이지 단위 자동 로딩 UI 처리</li>
<li><code>Suspense</code> = 하위 컴포넌트 단위 세밀한 로딩 UI 제어</li>
</ul>
<p>이 두 가지를 적절하게 조합해 사용하는 게 개발 생산성을 높이는 좋은 팁이에요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3><code>Suspense</code>를 활용한 부분적 스트리밍</h3>
<p><code>Suspense</code>는 페이지의 특정 부분만 스트리밍할 수 있게 해줘서, 사용자 경험을 더 부드럽고 빠르게 만들어주는데요. 예를 들어, 전체 페이지 중에서 <code>Suspense</code> 경계 밖에 있는 내용은 바로 보여주고, 경계 안에 있는 블로그 목록 같은 무거운 컴포넌트만 나중에 스트리밍해서 로드할 수 있어요.</p>
<p>아래 예제를 보면, 제목과 인사말은 즉시 렌더링되고, 블로그 목록은 <code>Suspense</code> 안에서 비동기로 불러와집니다. 로딩 중일 때는 <code>BlogListSkeleton</code> 컴포넌트가 대신 보여지겠죠?</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Suspense</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">BlogList</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"@/components/BlogList"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">BlogListSkeleton</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"@/components/BlogListSkeleton"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">BlogPage</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      {/* 이 부분은 즉시 클라이언트에게 전송됩니다 */}
      <span class="hljs-tag">&#x3C;<span class="hljs-name">header</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>Welcome to the Blog<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>Read the latest posts below.<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">header</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">main</span>></span>
        {/* Suspense 경계 안의 컴포넌트는 스트리밍 되어 로드됩니다 */}
        <span class="hljs-tag">&#x3C;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&#x3C;<span class="hljs-attr">BlogListSkeleton</span> /></span>}>
          <span class="hljs-tag">&#x3C;<span class="hljs-name">BlogList</span> /></span>
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">Suspense</span>></span>
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">main</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
}
</code></pre>
<h3>의미 있는 로딩 상태 만들기</h3>
<p><code>Suspense</code>를 사용하면 단순히 "로딩 중" 텍스트만 보여주는 대신, 실제 콘텐츠 형태를 모방한 스켈레톤 UI를 보여줄 수 있는데요. 이는 사용자에게 페이지가 정말로 반응하고 있다는 느낌을 잘 줍니다. 예를 들어 블로그 목록이라면 개별 목록 아이템이 빈 카드처럼 보이는 스켈레톤 화면을 만드는 거죠.</p>
<p>이런 UX 테크닉을 적용하면, 페이지가 로딩될 때 사용자가 느끼는 대기시간이 훨씬 짧고 부드러워 보여 실제 체감 성능이 높아집니다.</p>
<p>더불어, <code>Suspense</code>를 적절히 활용하면 데이터가 준비되는 순서에 따라 UI를 부분별로 제어할 수 있어서, 복잡한 페이지도 단계적으로 로드할 수 있다는 점!</p>
<p>요약하자면,</p>
<ul>
<li>초기 콘텐츠는 지체 없이 보여주기</li>
<li>데이터를 불러오는 부분은 <code>Suspense</code>와 fallback UI로 감싸기</li>
<li>스켈레톤 UI 등 의미 있는 로딩 화면 제공하기</li>
</ul>
<p>이렇게만 해도 사용자 경험은 대폭 개선될 거예요! 😊</p>
<p>필요하다면 Suspense의 fallback 컴포넌트를 직접 커스터마이징해서 브랜드 느낌이나 스타일을 살리는 것도 추천드려요.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>즉시 로딩 상태란, 사용자가 페이지를 이동한 직후 바로 보여주는 대체 UI를 의미해요. 이게 왜 중요하냐면, 사용자가 앱이 반응하고 있다는 걸 바로 알 수 있게 해줘서 불안감을 줄이고 더 나은 사용자 경험을 제공할 수 있기 때문이죠.</p>
<p>가장 좋은 방법은 단순히 로딩 중이라는 표시만 보여주는 게 아니라, 의미 있는 로딩 상태를 디자인하는 거예요. 예를 들어, 뼈대 화면(skeleton)을 보여준다거나, 돌아가는 스피너(spinner)를 사용하는 게 대표적이고요. 좀 더 나아가서는 다음에 보여질 화면의 핵심 요소, 예를 들어 커버 사진이나 제목 같은 작은 부분을 먼저 보여주면 훨씬 자연스러운 느낌을 줄 수 있습니다.</p>
<p>개발 중에는 React Devtools를 활용하면 컴포넌트의 로딩 상태를 미리 보고, 어떻게 동작하는지 자세하게 확인할 수 있어요. 덕분에 사용자에게 완성도 높은 로딩 UI를 더 쉽게 만들 수 있답니다.</p>
<p>간단히 정리해볼게요.</p>





















<table><thead><tr><th>팁</th><th>설명</th></tr></thead><tbody><tr><td>즉시 로딩 상태</td><td>네비게이션 후 바로 보여지는 대체 UI</td></tr><tr><td>의미 있는 로딩 디자인</td><td>스켈레톤, 스피너, 다음 화면 일부 요소(제목, 이미지 등) 활용</td></tr><tr><td>개발 시 활용 도구</td><td>React Devtools로 로딩 상태 미리보기 및 검사</td></tr></tbody></table>
<p>이런 방식으로 사용자에게 앱이 멈추지 않고 잘 작동 중임을 자연스럽게 알릴 수 있어요. 여러분도 한 번 적용해보세요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Next.js 15에서 데이터 fetch하는 방법","description":"","date":"2025-04-22 01:13","slug":"2025-04-22-Howtofetchdataandstream","content":"\n# 데이터 가져오기와 스트리밍하는 방법\n\n이번 글에서는 Next.js 같은 환경에서 서버 컴포넌트와 클라이언트 컴포넌트에서 데이터를 가져오는 방법을 알려드릴게요. 그리고 데이터를 기반으로 콘텐츠를 스트리밍하는 방법도 같이 살펴볼 거예요.\n\n## 데이터 가져오기\n\n### 서버 컴포넌트에서 데이터 가져오기\n\n서버 컴포넌트(Server Components)는 서버에서 실행되기 때문에 데이터를 바로 fetch해서 렌더링할 수 있어요. 클라이언트에게는 이미 준비된 결과만 내려주기 때문에 성능도 좋고 보안상 이점도 있죠.\n\n예를 들어, 이렇게 사용할 수 있어요:\n\n```jsx\n// ServerComponent.jsx\nasync function ServerComponent() {\n  const res = await fetch(\"https://api.example.com/data\");\n  const data = await res.json();\n\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e서버에서 가져온 데이터\u003c/h1\u003e\n      \u003cp\u003e{data.message}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default ServerComponent;\n```\n\n서버 컴포넌트는 기본적으로 비동기 함수(async function)로 만들 수 있어서, 데이터를 기다렸다가 렌더링하는 것에 전혀 무리가 없답니다.\n\n---\n\n추가 팁!\n\n- fetch를 쓸 때는 캐싱과 관련된 옵션을 꼭 확인하세요. 예를 들어 Next.js에서는 `fetch('url', { next: { revalidate: 60 }})` 처럼 60초마다 다시 가져오게 설정할 수 있어요.\n- 만약 API 호출이 오래 걸리는 경우, React 18 스트리밍 기능과 함께 쓰면 사용자에게 더 빠른 피드백을 줄 수 있어요. 이 부분도 곧 설명할게요!\n\n다음으로, 클라이언트 컴포넌트에서 데이터 가져오는 법과 스트리밍하는 예시를 이어서 다뤄볼게요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n서버 컴포넌트(Server Components)에서 데이터를 가져올 때는 주로 이렇게 두 가지 방법을 사용해요:\n\n- fetch API 활용하기\n- ORM이나 데이터베이스 직접 호출하기\n\n#### fetch API 사용법\n\nfetch API를 쓰려면 컴포넌트를 비동기 함수(async function)로 만들고, fetch 호출 앞에 await를 붙여서 데이터를 받아오면 돼요. 예시를 살펴볼게요:\n\n```jsx\n// 비동기 함수로 만든 서버 컴포넌트 예시\nexport default async function UserProfile() {\n  const res = await fetch(\"https://api.example.com/user\");\n\n  // 서버 컴포넌트에서 fetch할 때는 기본적으로 캐싱이 되는데,\n  // 필요에 따라 cache 옵션을 조절할 수 있어요.\n  // 예: await fetch(url, { cache: 'no-store' }) // 매번 새로 불러오기\n\n  if (!res.ok) {\n    // 에러 처리도 서버 컴포넌트 내에서 할 수 있답니다.\n    throw new Error(\"사용자 정보를 가져오는데 실패했습니다.\");\n  }\n\n  const user = await res.json();\n\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e{user.name}님 안녕하세요!\u003c/h1\u003e\n      \u003cp\u003e이메일: {user.email}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n\u003e 여기서 중요한 팁! Server Components는 클라이언트와 달리 fetch API를 사용할 때 네트워크 요청이 서버에서 처리되기 때문에 API 키 같은 민감한 정보도 안전하게 다룰 수 있어요.\n\n다음 번에는 ORM이나 데이터베이스 직접 호출 방법도 같이 정리해볼게요! 컴포넌트에서 데이터 가져오는 게 이제 좀 감 잡히셨죠?\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번에는 React의 Server Component에서 데이터 가져오는 방법에 대해 살펴보려고 해요. 특히 fetch API를 사용하거나 ORM을 통해 데이터베이스에서 직접 데이터를 불러오는 예제를 함께 보여드릴게요.\n\n먼저, `fetch`를 사용해서 외부 API에서 블로그 글 목록을 가져오는 아주 기본적인 예제입니다.\n\n```jsx\nexport default async function Page() {\n  const data = await fetch(\"https://api.vercel.app/blog\");\n  const posts = await data.json();\n\n  return (\n    \u003cul\u003e\n      {posts.map((post) =\u003e (\n        \u003cli key={post.id}\u003e{post.title}\u003c/li\u003e\n      ))}\n    \u003c/ul\u003e\n  );\n}\n```\n\n서버 컴포넌트는 서버에서 렌더링되기 때문에 async 함수로 만들고 `await`로 데이터를 받아올 수 있는 게 큰 장점이에요. 이렇게 하면 클라이언트에서 별도로 데이터를 가져오는 로직을 짤 필요가 없고, 초기 렌더링 시점에 바로 데이터를 사용할 수 있죠.\n\n---\n\n그리고 조금 더 고급 예제로, ORM이나 직접 데이터베이스 클라이언트를 사용해서 데이터베이스 쿼리를 하는 방법도 있는데요. 예를 들어, Prisma나 Drizzle ORM 같이 JavaScript/TypeScript에서 많이 사용하는 ORM을 쓸 때도 동일한 패턴입니다.\n\n```jsx\nimport { db, posts } from \"@/lib/db\";\n\nexport default async function Page() {\n  const allPosts = await db.select().from(posts);\n\n  return (\n    \u003cul\u003e\n      {allPosts.map((post) =\u003e (\n        \u003cli key={post.id}\u003e{post.title}\u003c/li\u003e\n      ))}\n    \u003c/ul\u003e\n  );\n}\n```\n\n이 경우 `db.select().from(posts)` 같은 쿼리문을 `await` 해서 서버에서 바로 데이터베이스를 조회하고, 그 결과를 UI로 바로 뿌려줄 수 있어요.\n\n---\n\n### 여기서 몇 가지 더 알려드릴 팁!\n\n- **서버 컴포넌트와 클라이언트 컴포넌트의 역할 분리!**  \n  서버 컴포넌트는 데이터를 불러오고, 클라이언트 컴포넌트는 사용자 상호작용(UI 이벤트 등)을 담당하는 식으로 분리하면 앱 구조가 더 깔끔해져요.\n\n- **fetch 캐싱 전략**  \n  `fetch` 호출할 때 `cache: 'no-store'` 옵션을 넣으면 항상 최신 데이터를 받아올 수 있고, 반대로 캐싱 옵션을 활용하면 퍼포먼스를 높일 수도 있어요.\n\n- **환경변수 사용하기**  \n  데이터베이스 연결이나 API 호출 시 민감한 정보(API 키 등)는 .env 파일에 숨기는 게 안전해요.\n\n---\n\n이번 글에서는 React 서버 컴포넌트 내에서 외부 API, ORM으로 데이터 가져오는 기본적인 방법을 정리해보았는데요. 실제 프로젝트에서 서버 사이드 렌더링을 하거나 Next.js와 같은 프레임워크를 사용할 때 꼭 알아두면 유용한 패턴이에요. 편하게 데이터를 다루고 싶을 때 async/await와 서버 컴포넌트를 적극 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 클라이언트 컴포넌트에서 데이터 가져오기\n\n클라이언트 컴포넌트에서 데이터를 가져오는 방법은 크게 두 가지가 있어요.\n\n- React의 `use` 훅 사용하기\n- SWR, React Query 같은 커뮤니티 라이브러리 활용하기\n\n#### 1. React `use` 훅 사용하기\n\nReact 18부터 도입된 `use` 훅을 사용하면 데이터 패칭을 조금 더 간결하게 할 수 있어요. 이 훅은 비동기 함수에서 데이터를 받아와서 컴포넌트가 렌더링되기 전에 데이터 로딩을 처리해주죠.\n\n예를 들면 이렇게 사용할 수 있어요:\n\n```jsx\n\"use client\";\n\nimport { use } from \"react\";\n\nasync function fetchUser() {\n  const res = await fetch(\"/api/user\");\n  if (!res.ok) throw new Error(\"Failed to fetch user\");\n  return res.json();\n}\n\nexport default function UserComponent() {\n  const user = use(fetchUser());\n\n  return \u003cdiv\u003eHello, {user.name}!\u003c/div\u003e;\n}\n```\n\n`use` 훅은 서버 컴포넌트에서는 바로 사용할 수 없고 클라이언트 컴포넌트에서만 지원되니 참고하세요!\n\n#### 2. SWR, React Query 같은 라이브러리 이용하기\n\n`use` 훅이 꽤 편리하지만, 상태 관리, 캐싱, 리페치 같은 점에서 기능이 부족할 때는 SWR이나 React Query가 많이 쓰여요.\n\n이들 라이브러리는 다음과 같은 이점이 있어요:\n\n| 장점                  | 설명                                                         |\n| --------------------- | ------------------------------------------------------------ |\n| 자동 캐싱             | 이전에 가져온 데이터를 캐시해서 빠르게 보여줘요.             |\n| 배경 리페치           | 데이터를 최신 상태로 유지하기 위해 자동으로 재요청해요.      |\n| 로딩과 에러 상태 처리 | 로딩 중인 상태나 에러를 쉽게 관리할 수 있어요.               |\n| 폴링과 리프레시       | 정기적으로 데이터를 갱신하거나 수동으로 새로고침이 가능해요. |\n\n예를 들어 SWR을 쓰면 이렇게 간단하게 데이터를 가져올 수 있죠:\n\n```jsx\n\"use client\";\n\nimport useSWR from \"swr\";\n\nconst fetcher = (url) =\u003e fetch(url).then((res) =\u003e res.json());\n\nexport default function UserComponent() {\n  const { data, error } = useSWR(\"/api/user\", fetcher);\n\n  if (error) return \u003cdiv\u003e에러 발생!\u003c/div\u003e;\n  if (!data) return \u003cdiv\u003e로딩 중...\u003c/div\u003e;\n\n  return \u003cdiv\u003eHello, {data.name}!\u003c/div\u003e;\n}\n```\n\nReact Query 역시 비슷한 방식으로 동작하고, 복잡한 데이터 동기화 문제를 쉽게 해결할 수 있어서 대규모 프로젝트에 많이 사용돼요.\n\n---\n\n데이터를 어떻게 패칭할지는 프로젝트 규모와 요구사항에 따라 선택하면 좋아요. 간단한 경우에는 React `use` 훅만으로도 충분하지만, 상태 관리가 복잡하거나 다양한 기능을 원한다면 SWR이나 React Query를 한 번 써보시길 추천해요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nReact의 새로운 use hook을 활용해서 서버에서 클라이언트로 데이터를 스트리밍하는 방법을 소개할게요. 이걸 쓰면 데이터를 미리 기다리지 않고도 렌더링을 시작할 수 있어서 사용자 경험이 더 좋아져요.\n\n먼저, 서버 컴포넌트에서 데이터를 가져오고, 그 Promise를 클라이언트 컴포넌트에 props로 넘겨줍니다:\n\n```jsx\nimport Posts from \"@/app/ui/posts\";\nimport { Suspense } from \"react\";\n\nexport default function Page() {\n  // 데이터 fetching 함수 호출, 여기서 await는 하지 않아요\n  const posts = getPosts();\n\n  return (\n    \u003cSuspense fallback={\u003cdiv\u003eLoading...\u003c/div\u003e}\u003e\n      \u003cPosts posts={posts} /\u003e\n    \u003c/Suspense\u003e\n  );\n}\n```\n\n여기서 중요한 점! getPosts() 의 Promise를 바로 넘겨주는 거예요. 아직 데이터가 준비되지 않았어도, Suspense로 감싸고 있기 때문에 로딩 UI가 보였다가 데이터가 준비되면 실제 내용이 렌더링됩니다.\n\n그 다음, 클라이언트 컴포넌트에선 `use` hook을 이용해서 Promise를 읽을 수 있어요:\n\n```jsx\n\"use client\";\nimport { use } from \"react\";\n\nexport default function Posts({ posts }: { posts: Promise\u003c{ id: string, title: string }[]\u003e }) {\n  // Promise가 끝날 때까지 기다렸다가 결과를 가져옵니다\n  const allPosts = use(posts);\n\n  return (\n    \u003cul\u003e\n      {allPosts.map((post) =\u003e (\n        \u003cli key={post.id}\u003e{post.title}\u003c/li\u003e\n      ))}\n    \u003c/ul\u003e\n  );\n}\n```\n\n이 방법의 장점은 서버 컴포넌트에서 데이터를 바로 넘겨주기 때문에 클라이언트에서 fetch 코드를 따로 작성할 필요가 없고, Suspense와 함께 쓰면 자연스럽게 로딩 상태도 처리할 수 있다는 점이에요.\n\n\u003e 참고로 `use` hook은 React 18에서 도입된 기능이고 Next.js 13 같은 최신 프레임워크와 아주 잘 맞아요. 만약 여러분이 Next.js 같은 환경에서 작업한다면 적극 활용해보세요!\n\n요약하자면:\n\n| 단계                   | 설명                                            |\n| ---------------------- | ----------------------------------------------- |\n| 1. 서버 컴포넌트       | 데이터를 fetching하고 Promise를 props로 넘기기  |\n| 2. 클라이언트 컴포넌트 | `use` hook으로 Promise 처리해서 데이터 사용하기 |\n| 3. Suspense 적용       | 로딩 UI 관리해서 UX 향상                        |\n\n이렇게 하면 fetch로 데이터를 직접 기다리지 않고도 부드러운 렌더링과 데이터 스트리밍 효과를 낼 수 있답니다. 한번 써보면 React의 새로운 가능성에 감탄하게 될 거예요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 예제에서 `Posts /` 컴포넌트를 `Suspense` 경계로 감싸줘야 합니다. 이렇게 하면 데이터 로딩 중일 때 fallback UI가 보여지면서 Promise가 해결될 때까지 기다릴 수 있어요. 스트리밍에 대해 더 알고 싶다면 실제 React 공식 문서나 관련 자료를 참고해보세요.\n\n---\n\n### 커뮤니티 라이브러리 활용하기\n\nReact에서 클라이언트 컴포넌트 내 데이터를 가져올 때는 SWR이나 React Query 같은 커뮤니티 라이브러리를 많이 사용합니다. 이 라이브러리들은 캐싱, 스트리밍, 갱신 정책 등 다양한 기능을 제공해서 데이터 패칭을 훨씬 편리하게 만들어줘요.\n\n예를 들어 SWR을 사용한 코드는 다음과 같습니다:\n\n```js\n\"use client\";\nimport useSWR from \"swr\";\n\nconst fetcher = (url) =\u003e fetch(url).then((r) =\u003e r.json());\n\nexport default function BlogPage() {\n  const { data, error, isLoading } = useSWR(\"https://api.vercel.app/blog\", fetcher);\n\n  if (isLoading) return \u003cdiv\u003eLoading...\u003c/div\u003e;\n  if (error) return \u003cdiv\u003eError: {error.message}\u003c/div\u003e;\n\n  return (\n    \u003cul\u003e\n      {data.map((post: { id: string, title: string }) =\u003e (\n        \u003cli key={post.id}\u003e{post.title}\u003c/li\u003e\n      ))}\n    \u003c/ul\u003e\n  );\n}\n```\n\n- 여기서 `useSWR`은 데이터를 쉽게 가져오고 자동으로 캐싱해주며, 필요하면 재요청도 해줍니다.\n- `isLoading`, `error` 상태도 관리해줘서 로딩중이나 에러가 났을 때 사용자에게 알기 쉽게 UI를 보여줄 수 있어요.\n- `Suspense`를 직접 쓰는 대신 SWR이 내부적으로 비슷한 원리(loading 상태 관리)를 처리해준다고 생각하면 편합니다.\n\n---\n\n이 밖에도 React Query는 더 많은 기능과 옵션을 제공하니, 프로젝트 성격에 맞게 골라 써보시면 좋겠죠? 데이터를 클라이언트에서 관리할 때 편리한 도구들이 많으니 적극 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 스트리밍 (Streaming)\n\n\u003e 주의: 아래 내용은 Next.js 15 카나리 버전에서 도입된 dynamicIO 설정 옵션이 활성화되어 있다고 가정한 설명입니다.\n\n서버 컴포넌트(Server Components)에서 async/await를 사용할 때, Next.js는 자동으로 동적 렌더링(dynamic rendering)을 선택하게 돼요. 즉, 매번 사용자 요청이 들어올 때마다 서버에서 데이터를 가져오고 렌더링을 한다는 뜻이죠. 여기서 문제가 되는 점은, 만약 데이터 요청이 느리다면 그 경로 전체가 렌더링 되지 않고 기다리게 된다는 거예요.\n\n이런 상황에서 사용자 경험과 초기 로딩 속도를 개선하기 위해 스트리밍(Streaming)을 사용할 수 있습니다. 스트리밍은 페이지의 HTML 내용을 작고 여러 개의 청크(chunk)로 나누고, 그 청크들을 서버에서 클라이언트로 점진적으로 보내는 방식을 말합니다. 이렇게 하면 사용자에게는 빠르게 일부 콘텐츠가 먼저 보이고, 나머지도 순차적으로 로딩되어 부드러운 경험을 제공할 수 있죠.\n\n---\n\n### 추가 팁: 스트리밍 적용 시 주의할 점\n\n- **콘텐츠 순서 보장**  \n  스트리밍은 HTML을 나누어 보내지만, 클라이언트는 리소스를 받는 순서대로 렌더링해요. 그래서 서버에서 청크를 보내는 순서를 적절히 관리하는 게 중요합니다.\n\n- **상태(state) 관리**  \n  서버에서 각 청크가 독립적으로 렌더링되므로, 상태 관리에 신경 써야 해요. React의 서버 컴포넌트 특성상 상태를 클라이언트와 분리해서 다뤄야 할 때도 있습니다.\n\n- **SEO 영향 고려**  \n  스트리밍은 SEO에도 긍정적입니다. 초기 콘텐츠를 빠르게 보여주기 때문에 검색엔진 크롤러가 콘텐츠를 더 잘 인식할 수 있어요.\n\n---\n\n스트리밍 덕분에 사용자들은 느린 데이터 로딩으로 인한 기다림이 줄어들고, 동시에 서버 자원을 효율적으로 사용할 수 있게 됩니다. Next.js의 스트리밍 기능, 꼭 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2025-04-22-Howtofetchdataandstream_0.png\" /\u003e\n\n애플리케이션에서 스트리밍(streaming)을 구현하는 방법은 크게 두 가지가 있어요:\n\n- `loading.js` 파일을 활용하는 방법\n- React의 `Suspense` 컴포넌트를 사용하는 방법\n\n### loading.js를 활용한 방법\n\nloading.js 파일을 이용하면 컴포넌트가 로딩 중일 때 보여줄 UI를 간단히 처리할 수 있는데요, 이것만 잘 활용해도 로딩 상태 관리가 훨씬 깔끔해집니다. React 18 이후로 서버 컴포넌트를 지원하면서 이 방식이 점점 많이 쓰이고 있죠.\n\n다음에 React `Suspense` 컴포넌트를 활용하는 방법도 한번 살펴볼게요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러분, Next.js에서 페이지 데이터를 가져올 때 로딩 상태를 어떻게 더 잘 보여줄 수 있을까요? 바로 `loading.js` 파일을 활용하는 방법입니다!\n\n예를 들어, `app/blog/page.js` 파일과 같은 폴더(`app/blog`)에 `loading.js` 파일을 만들어주면, 페이지 데이터를 가져오는 동안 사용자가 기다리는 모습을 좀 더 깔끔하게 보여줄 수 있어요.\n\n```js\nexport default function Loading() {\n  // 여기서 로딩 화면 UI를 정의해주면 됩니다\n  return \u003cdiv\u003eLoading...\u003c/div\u003e;\n}\n```\n\n이렇게 하면 사용자가 페이지로 이동할 때, 화면은 즉시 레이아웃과 이 로딩 UI를 보여주고, 데이터가 모두 준비되면 자동으로 실제 콘텐츠로 바뀌어요.\n\n참고로, 이런 방식이 좋은 이유는 “빈 화면”이나 갑작스러운 깜빡임 없이 자연스럽게 사용자 경험이 이어진다는 점이에요. 실제로 프로젝트에 적용할 때는 단순 텍스트 대신 스피너 애니메이션이나 뼈대 UI(Skeleton UI)를 넣어주면 더 효과적이랍니다.\n\n아래는 예시 이미지인데, 이런 식으로 로딩 중인 상태를 좀 더 친절하게 보여줄 수 있어요.\n\n| ![로딩 화면 예시](https://yourdomain.com/assets/img/2025-04-22-Howtofetchdataandstream_1.png) |\n| --------------------------------------------------------------------------------------------- |\n\n나중에 `loading.js`에서 다양한 로딩 상태 구현을 고민해보면서, 사용자 경험을 한층 업그레이드 해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2025-04-22-Howtofetchdataandstream_2.png\" /\u003e\n\n뒤에서 보면, `loading.js`는 `layout.js` 내부에 중첩되어 자동으로 `page.js` 파일과 그 아래 자식들을 `Suspense` 경계로 감싸게 돼요.\n\n\u003cimg src=\"/TIL/assets/img/2025-04-22-Howtofetchdataandstream_3.png\" /\u003e\n\n이 방식은 라우트 세그먼트(레이아웃과 페이지)에 잘 맞지만, 더 세밀한 스트리밍이 필요하다면 직접 `Suspense`를 활용하는 게 좋아요.\n\n---\n\n여기서 잠깐! `Suspense`를 사용하면 리액트에서 비동기 데이터를 로딩하는 동안 그 자리를 대체하는 로딩 UI를 보여줄 수 있다는 점이 정말 편해요. 특히 Next.js 13처럼 서버 컴포넌트가 도입된 환경에서는 `loading.js` 같은 파일로 페이지 단위 로딩 처리를 자동으로 해주니까 개발이 훨씬 수월해지죠.\n\n하지만, 한 단계 더 들어가서 페이지 일부만 따로 로딩하고 싶을 때(예를 들어, 큰 리스트 아이템 중 일부만 먼저 보여주고, 나머지는 천천히 로딩하고 싶을 때) `Suspense`를 직접 사용하는 것이 필요해집니다.\n\n즉,\n\n- `loading.js` + `layout.js` = 페이지 단위 자동 로딩 UI 처리\n- `Suspense` = 하위 컴포넌트 단위 세밀한 로딩 UI 제어\n\n이 두 가지를 적절하게 조합해 사용하는 게 개발 생산성을 높이는 좋은 팁이에요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### `Suspense`를 활용한 부분적 스트리밍\n\n`Suspense`는 페이지의 특정 부분만 스트리밍할 수 있게 해줘서, 사용자 경험을 더 부드럽고 빠르게 만들어주는데요. 예를 들어, 전체 페이지 중에서 `Suspense` 경계 밖에 있는 내용은 바로 보여주고, 경계 안에 있는 블로그 목록 같은 무거운 컴포넌트만 나중에 스트리밍해서 로드할 수 있어요.\n\n아래 예제를 보면, 제목과 인사말은 즉시 렌더링되고, 블로그 목록은 `Suspense` 안에서 비동기로 불러와집니다. 로딩 중일 때는 `BlogListSkeleton` 컴포넌트가 대신 보여지겠죠?\n\n```jsx\nimport { Suspense } from \"react\";\nimport BlogList from \"@/components/BlogList\";\nimport BlogListSkeleton from \"@/components/BlogListSkeleton\";\n\nexport default function BlogPage() {\n  return (\n    \u003cdiv\u003e\n      {/* 이 부분은 즉시 클라이언트에게 전송됩니다 */}\n      \u003cheader\u003e\n        \u003ch1\u003eWelcome to the Blog\u003c/h1\u003e\n        \u003cp\u003eRead the latest posts below.\u003c/p\u003e\n      \u003c/header\u003e\n      \u003cmain\u003e\n        {/* Suspense 경계 안의 컴포넌트는 스트리밍 되어 로드됩니다 */}\n        \u003cSuspense fallback={\u003cBlogListSkeleton /\u003e}\u003e\n          \u003cBlogList /\u003e\n        \u003c/Suspense\u003e\n      \u003c/main\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n### 의미 있는 로딩 상태 만들기\n\n`Suspense`를 사용하면 단순히 \"로딩 중\" 텍스트만 보여주는 대신, 실제 콘텐츠 형태를 모방한 스켈레톤 UI를 보여줄 수 있는데요. 이는 사용자에게 페이지가 정말로 반응하고 있다는 느낌을 잘 줍니다. 예를 들어 블로그 목록이라면 개별 목록 아이템이 빈 카드처럼 보이는 스켈레톤 화면을 만드는 거죠.\n\n이런 UX 테크닉을 적용하면, 페이지가 로딩될 때 사용자가 느끼는 대기시간이 훨씬 짧고 부드러워 보여 실제 체감 성능이 높아집니다.\n\n더불어, `Suspense`를 적절히 활용하면 데이터가 준비되는 순서에 따라 UI를 부분별로 제어할 수 있어서, 복잡한 페이지도 단계적으로 로드할 수 있다는 점!\n\n요약하자면,\n\n- 초기 콘텐츠는 지체 없이 보여주기\n- 데이터를 불러오는 부분은 `Suspense`와 fallback UI로 감싸기\n- 스켈레톤 UI 등 의미 있는 로딩 화면 제공하기\n\n이렇게만 해도 사용자 경험은 대폭 개선될 거예요! 😊\n\n필요하다면 Suspense의 fallback 컴포넌트를 직접 커스터마이징해서 브랜드 느낌이나 스타일을 살리는 것도 추천드려요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n즉시 로딩 상태란, 사용자가 페이지를 이동한 직후 바로 보여주는 대체 UI를 의미해요. 이게 왜 중요하냐면, 사용자가 앱이 반응하고 있다는 걸 바로 알 수 있게 해줘서 불안감을 줄이고 더 나은 사용자 경험을 제공할 수 있기 때문이죠.\n\n가장 좋은 방법은 단순히 로딩 중이라는 표시만 보여주는 게 아니라, 의미 있는 로딩 상태를 디자인하는 거예요. 예를 들어, 뼈대 화면(skeleton)을 보여준다거나, 돌아가는 스피너(spinner)를 사용하는 게 대표적이고요. 좀 더 나아가서는 다음에 보여질 화면의 핵심 요소, 예를 들어 커버 사진이나 제목 같은 작은 부분을 먼저 보여주면 훨씬 자연스러운 느낌을 줄 수 있습니다.\n\n개발 중에는 React Devtools를 활용하면 컴포넌트의 로딩 상태를 미리 보고, 어떻게 동작하는지 자세하게 확인할 수 있어요. 덕분에 사용자에게 완성도 높은 로딩 UI를 더 쉽게 만들 수 있답니다.\n\n간단히 정리해볼게요.\n\n| 팁                    | 설명                                                        |\n| --------------------- | ----------------------------------------------------------- |\n| 즉시 로딩 상태        | 네비게이션 후 바로 보여지는 대체 UI                         |\n| 의미 있는 로딩 디자인 | 스켈레톤, 스피너, 다음 화면 일부 요소(제목, 이미지 등) 활용 |\n| 개발 시 활용 도구     | React Devtools로 로딩 상태 미리보기 및 검사                 |\n\n이런 방식으로 사용자에게 앱이 멈추지 않고 잘 작동 중임을 자연스럽게 알릴 수 있어요. 여러분도 한 번 적용해보세요!\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":17},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003e데이터 가져오기와 스트리밍하는 방법\u003c/h1\u003e\n\u003cp\u003e이번 글에서는 Next.js 같은 환경에서 서버 컴포넌트와 클라이언트 컴포넌트에서 데이터를 가져오는 방법을 알려드릴게요. 그리고 데이터를 기반으로 콘텐츠를 스트리밍하는 방법도 같이 살펴볼 거예요.\u003c/p\u003e\n\u003ch2\u003e데이터 가져오기\u003c/h2\u003e\n\u003ch3\u003e서버 컴포넌트에서 데이터 가져오기\u003c/h3\u003e\n\u003cp\u003e서버 컴포넌트(Server Components)는 서버에서 실행되기 때문에 데이터를 바로 fetch해서 렌더링할 수 있어요. 클라이언트에게는 이미 준비된 결과만 내려주기 때문에 성능도 좋고 보안상 이점도 있죠.\u003c/p\u003e\n\u003cp\u003e예를 들어, 이렇게 사용할 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-comment\"\u003e// ServerComponent.jsx\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eServerComponent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e res = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"https://api.example.com/data\"\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e data = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e res.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e서버에서 가져온 데이터\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e{data.message}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eServerComponent\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e서버 컴포넌트는 기본적으로 비동기 함수(async function)로 만들 수 있어서, 데이터를 기다렸다가 렌더링하는 것에 전혀 무리가 없답니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e추가 팁!\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003efetch를 쓸 때는 캐싱과 관련된 옵션을 꼭 확인하세요. 예를 들어 Next.js에서는 \u003ccode\u003efetch('url', { next: { revalidate: 60 }})\u003c/code\u003e 처럼 60초마다 다시 가져오게 설정할 수 있어요.\u003c/li\u003e\n\u003cli\u003e만약 API 호출이 오래 걸리는 경우, React 18 스트리밍 기능과 함께 쓰면 사용자에게 더 빠른 피드백을 줄 수 있어요. 이 부분도 곧 설명할게요!\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음으로, 클라이언트 컴포넌트에서 데이터 가져오는 법과 스트리밍하는 예시를 이어서 다뤄볼게요.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e서버 컴포넌트(Server Components)에서 데이터를 가져올 때는 주로 이렇게 두 가지 방법을 사용해요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003efetch API 활용하기\u003c/li\u003e\n\u003cli\u003eORM이나 데이터베이스 직접 호출하기\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003efetch API 사용법\u003c/h4\u003e\n\u003cp\u003efetch API를 쓰려면 컴포넌트를 비동기 함수(async function)로 만들고, fetch 호출 앞에 await를 붙여서 데이터를 받아오면 돼요. 예시를 살펴볼게요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 비동기 함수로 만든 서버 컴포넌트 예시\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eUserProfile\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e res = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"https://api.example.com/user\"\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-comment\"\u003e// 서버 컴포넌트에서 fetch할 때는 기본적으로 캐싱이 되는데,\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 필요에 따라 cache 옵션을 조절할 수 있어요.\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 예: await fetch(url, { cache: 'no-store' }) // 매번 새로 불러오기\u003c/span\u003e\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!res.\u003cspan class=\"hljs-property\"\u003eok\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 에러 처리도 서버 컴포넌트 내에서 할 수 있답니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"사용자 정보를 가져오는데 실패했습니다.\"\u003c/span\u003e);\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e user = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e res.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e{user.name}님 안녕하세요!\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e이메일: {user.email}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e여기서 중요한 팁! Server Components는 클라이언트와 달리 fetch API를 사용할 때 네트워크 요청이 서버에서 처리되기 때문에 API 키 같은 민감한 정보도 안전하게 다룰 수 있어요.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e다음 번에는 ORM이나 데이터베이스 직접 호출 방법도 같이 정리해볼게요! 컴포넌트에서 데이터 가져오는 게 이제 좀 감 잡히셨죠?\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이번에는 React의 Server Component에서 데이터 가져오는 방법에 대해 살펴보려고 해요. 특히 fetch API를 사용하거나 ORM을 통해 데이터베이스에서 직접 데이터를 불러오는 예제를 함께 보여드릴게요.\u003c/p\u003e\n\u003cp\u003e먼저, \u003ccode\u003efetch\u003c/code\u003e를 사용해서 외부 API에서 블로그 글 목록을 가져오는 아주 기본적인 예제입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e data = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"https://api.vercel.app/blog\"\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e posts = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e data.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eul\u003c/span\u003e\u003e\u003c/span\u003e\n      {posts.map((post) =\u003e (\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{post.id}\u003c/span\u003e\u003e\u003c/span\u003e{post.title}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e\u003e\u003c/span\u003e\n      ))}\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eul\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e서버 컴포넌트는 서버에서 렌더링되기 때문에 async 함수로 만들고 \u003ccode\u003eawait\u003c/code\u003e로 데이터를 받아올 수 있는 게 큰 장점이에요. 이렇게 하면 클라이언트에서 별도로 데이터를 가져오는 로직을 짤 필요가 없고, 초기 렌더링 시점에 바로 데이터를 사용할 수 있죠.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e그리고 조금 더 고급 예제로, ORM이나 직접 데이터베이스 클라이언트를 사용해서 데이터베이스 쿼리를 하는 방법도 있는데요. 예를 들어, Prisma나 Drizzle ORM 같이 JavaScript/TypeScript에서 많이 사용하는 ORM을 쓸 때도 동일한 패턴입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { db, posts } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"@/lib/db\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e allPosts = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e db.\u003cspan class=\"hljs-title function_\"\u003eselect\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003efrom\u003c/span\u003e(posts);\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eul\u003c/span\u003e\u003e\u003c/span\u003e\n      {allPosts.map((post) =\u003e (\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{post.id}\u003c/span\u003e\u003e\u003c/span\u003e{post.title}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e\u003e\u003c/span\u003e\n      ))}\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eul\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 경우 \u003ccode\u003edb.select().from(posts)\u003c/code\u003e 같은 쿼리문을 \u003ccode\u003eawait\u003c/code\u003e 해서 서버에서 바로 데이터베이스를 조회하고, 그 결과를 UI로 바로 뿌려줄 수 있어요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e여기서 몇 가지 더 알려드릴 팁!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e서버 컴포넌트와 클라이언트 컴포넌트의 역할 분리!\u003c/strong\u003e\u003cbr\u003e\n서버 컴포넌트는 데이터를 불러오고, 클라이언트 컴포넌트는 사용자 상호작용(UI 이벤트 등)을 담당하는 식으로 분리하면 앱 구조가 더 깔끔해져요.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003efetch 캐싱 전략\u003c/strong\u003e\u003cbr\u003e\n\u003ccode\u003efetch\u003c/code\u003e 호출할 때 \u003ccode\u003ecache: 'no-store'\u003c/code\u003e 옵션을 넣으면 항상 최신 데이터를 받아올 수 있고, 반대로 캐싱 옵션을 활용하면 퍼포먼스를 높일 수도 있어요.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e환경변수 사용하기\u003c/strong\u003e\u003cbr\u003e\n데이터베이스 연결이나 API 호출 시 민감한 정보(API 키 등)는 .env 파일에 숨기는 게 안전해요.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e이번 글에서는 React 서버 컴포넌트 내에서 외부 API, ORM으로 데이터 가져오는 기본적인 방법을 정리해보았는데요. 실제 프로젝트에서 서버 사이드 렌더링을 하거나 Next.js와 같은 프레임워크를 사용할 때 꼭 알아두면 유용한 패턴이에요. 편하게 데이터를 다루고 싶을 때 async/await와 서버 컴포넌트를 적극 활용해보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003e클라이언트 컴포넌트에서 데이터 가져오기\u003c/h3\u003e\n\u003cp\u003e클라이언트 컴포넌트에서 데이터를 가져오는 방법은 크게 두 가지가 있어요.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eReact의 \u003ccode\u003euse\u003c/code\u003e 훅 사용하기\u003c/li\u003e\n\u003cli\u003eSWR, React Query 같은 커뮤니티 라이브러리 활용하기\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e1. React \u003ccode\u003euse\u003c/code\u003e 훅 사용하기\u003c/h4\u003e\n\u003cp\u003eReact 18부터 도입된 \u003ccode\u003euse\u003c/code\u003e 훅을 사용하면 데이터 패칭을 조금 더 간결하게 할 수 있어요. 이 훅은 비동기 함수에서 데이터를 받아와서 컴포넌트가 렌더링되기 전에 데이터 로딩을 처리해주죠.\u003c/p\u003e\n\u003cp\u003e예를 들면 이렇게 사용할 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-string\"\u003e\"use client\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { use } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetchUser\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e res = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"/api/user\"\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!res.\u003cspan class=\"hljs-property\"\u003eok\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Failed to fetch user\"\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e res.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e();\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eUserComponent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e user = \u003cspan class=\"hljs-title function_\"\u003euse\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003efetchUser\u003c/span\u003e());\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003eHello, {user.name}!\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003euse\u003c/code\u003e 훅은 서버 컴포넌트에서는 바로 사용할 수 없고 클라이언트 컴포넌트에서만 지원되니 참고하세요!\u003c/p\u003e\n\u003ch4\u003e2. SWR, React Query 같은 라이브러리 이용하기\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003euse\u003c/code\u003e 훅이 꽤 편리하지만, 상태 관리, 캐싱, 리페치 같은 점에서 기능이 부족할 때는 SWR이나 React Query가 많이 쓰여요.\u003c/p\u003e\n\u003cp\u003e이들 라이브러리는 다음과 같은 이점이 있어요:\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e장점\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e자동 캐싱\u003c/td\u003e\u003ctd\u003e이전에 가져온 데이터를 캐시해서 빠르게 보여줘요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e배경 리페치\u003c/td\u003e\u003ctd\u003e데이터를 최신 상태로 유지하기 위해 자동으로 재요청해요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e로딩과 에러 상태 처리\u003c/td\u003e\u003ctd\u003e로딩 중인 상태나 에러를 쉽게 관리할 수 있어요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e폴링과 리프레시\u003c/td\u003e\u003ctd\u003e정기적으로 데이터를 갱신하거나 수동으로 새로고침이 가능해요.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e예를 들어 SWR을 쓰면 이렇게 간단하게 데이터를 가져올 수 있죠:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-string\"\u003e\"use client\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e useSWR \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"swr\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetcher\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003eurl\u003c/span\u003e) =\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(url).\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eres\u003c/span\u003e) =\u003e\u003c/span\u003e res.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e());\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eUserComponent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { data, error } = \u003cspan class=\"hljs-title function_\"\u003euseSWR\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"/api/user\"\u003c/span\u003e, fetcher);\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (error) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e에러 발생!\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!data) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e로딩 중...\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003eHello, {data.name}!\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eReact Query 역시 비슷한 방식으로 동작하고, 복잡한 데이터 동기화 문제를 쉽게 해결할 수 있어서 대규모 프로젝트에 많이 사용돼요.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e데이터를 어떻게 패칭할지는 프로젝트 규모와 요구사항에 따라 선택하면 좋아요. 간단한 경우에는 React \u003ccode\u003euse\u003c/code\u003e 훅만으로도 충분하지만, 상태 관리가 복잡하거나 다양한 기능을 원한다면 SWR이나 React Query를 한 번 써보시길 추천해요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eReact의 새로운 use hook을 활용해서 서버에서 클라이언트로 데이터를 스트리밍하는 방법을 소개할게요. 이걸 쓰면 데이터를 미리 기다리지 않고도 렌더링을 시작할 수 있어서 사용자 경험이 더 좋아져요.\u003c/p\u003e\n\u003cp\u003e먼저, 서버 컴포넌트에서 데이터를 가져오고, 그 Promise를 클라이언트 컴포넌트에 props로 넘겨줍니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePosts\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"@/app/ui/posts\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eSuspense\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 데이터 fetching 함수 호출, 여기서 await는 하지 않아요\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e posts = \u003cspan class=\"hljs-title function_\"\u003egetPosts\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eSuspense\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003efallback\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-attr\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003eLoading...\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e}\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ePosts\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eposts\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{posts}\u003c/span\u003e /\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eSuspense\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 중요한 점! getPosts() 의 Promise를 바로 넘겨주는 거예요. 아직 데이터가 준비되지 않았어도, Suspense로 감싸고 있기 때문에 로딩 UI가 보였다가 데이터가 준비되면 실제 내용이 렌더링됩니다.\u003c/p\u003e\n\u003cp\u003e그 다음, 클라이언트 컴포넌트에선 \u003ccode\u003euse\u003c/code\u003e hook을 이용해서 Promise를 읽을 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-string\"\u003e\"use client\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { use } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePosts\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ posts }: { posts: \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e\u0026#x3C;{ id: string, title: string }[]\u003e }\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// Promise가 끝날 때까지 기다렸다가 결과를 가져옵니다\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e allPosts = \u003cspan class=\"hljs-title function_\"\u003euse\u003c/span\u003e(posts);\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eul\u003c/span\u003e\u003e\u003c/span\u003e\n      {allPosts.map((post) =\u003e (\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{post.id}\u003c/span\u003e\u003e\u003c/span\u003e{post.title}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e\u003e\u003c/span\u003e\n      ))}\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eul\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 방법의 장점은 서버 컴포넌트에서 데이터를 바로 넘겨주기 때문에 클라이언트에서 fetch 코드를 따로 작성할 필요가 없고, Suspense와 함께 쓰면 자연스럽게 로딩 상태도 처리할 수 있다는 점이에요.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e참고로 \u003ccode\u003euse\u003c/code\u003e hook은 React 18에서 도입된 기능이고 Next.js 13 같은 최신 프레임워크와 아주 잘 맞아요. 만약 여러분이 Next.js 같은 환경에서 작업한다면 적극 활용해보세요!\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e요약하자면:\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e단계\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e1. 서버 컴포넌트\u003c/td\u003e\u003ctd\u003e데이터를 fetching하고 Promise를 props로 넘기기\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e2. 클라이언트 컴포넌트\u003c/td\u003e\u003ctd\u003e\u003ccode\u003euse\u003c/code\u003e hook으로 Promise 처리해서 데이터 사용하기\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e3. Suspense 적용\u003c/td\u003e\u003ctd\u003e로딩 UI 관리해서 UX 향상\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e이렇게 하면 fetch로 데이터를 직접 기다리지 않고도 부드러운 렌더링과 데이터 스트리밍 효과를 낼 수 있답니다. 한번 써보면 React의 새로운 가능성에 감탄하게 될 거예요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e위 예제에서 \u003ccode\u003ePosts /\u003c/code\u003e 컴포넌트를 \u003ccode\u003eSuspense\u003c/code\u003e 경계로 감싸줘야 합니다. 이렇게 하면 데이터 로딩 중일 때 fallback UI가 보여지면서 Promise가 해결될 때까지 기다릴 수 있어요. 스트리밍에 대해 더 알고 싶다면 실제 React 공식 문서나 관련 자료를 참고해보세요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e커뮤니티 라이브러리 활용하기\u003c/h3\u003e\n\u003cp\u003eReact에서 클라이언트 컴포넌트 내 데이터를 가져올 때는 SWR이나 React Query 같은 커뮤니티 라이브러리를 많이 사용합니다. 이 라이브러리들은 캐싱, 스트리밍, 갱신 정책 등 다양한 기능을 제공해서 데이터 패칭을 훨씬 편리하게 만들어줘요.\u003c/p\u003e\n\u003cp\u003e예를 들어 SWR을 사용한 코드는 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e\"use client\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e useSWR \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"swr\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetcher\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003eurl\u003c/span\u003e) =\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(url).\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003er\u003c/span\u003e) =\u003e\u003c/span\u003e r.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e());\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eBlogPage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { data, error, isLoading } = \u003cspan class=\"hljs-title function_\"\u003euseSWR\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"https://api.vercel.app/blog\"\u003c/span\u003e, fetcher);\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isLoading) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003eLoading...\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (error) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003eError: {error.message}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eul\u003c/span\u003e\u003e\u003c/span\u003e\n      {data.map((post: { id: string, title: string }) =\u003e (\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{post.id}\u003c/span\u003e\u003e\u003c/span\u003e{post.title}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e\u003e\u003c/span\u003e\n      ))}\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eul\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e여기서 \u003ccode\u003euseSWR\u003c/code\u003e은 데이터를 쉽게 가져오고 자동으로 캐싱해주며, 필요하면 재요청도 해줍니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eisLoading\u003c/code\u003e, \u003ccode\u003eerror\u003c/code\u003e 상태도 관리해줘서 로딩중이나 에러가 났을 때 사용자에게 알기 쉽게 UI를 보여줄 수 있어요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSuspense\u003c/code\u003e를 직접 쓰는 대신 SWR이 내부적으로 비슷한 원리(loading 상태 관리)를 처리해준다고 생각하면 편합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e이 밖에도 React Query는 더 많은 기능과 옵션을 제공하니, 프로젝트 성격에 맞게 골라 써보시면 좋겠죠? 데이터를 클라이언트에서 관리할 때 편리한 도구들이 많으니 적극 활용해보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e스트리밍 (Streaming)\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e주의: 아래 내용은 Next.js 15 카나리 버전에서 도입된 dynamicIO 설정 옵션이 활성화되어 있다고 가정한 설명입니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e서버 컴포넌트(Server Components)에서 async/await를 사용할 때, Next.js는 자동으로 동적 렌더링(dynamic rendering)을 선택하게 돼요. 즉, 매번 사용자 요청이 들어올 때마다 서버에서 데이터를 가져오고 렌더링을 한다는 뜻이죠. 여기서 문제가 되는 점은, 만약 데이터 요청이 느리다면 그 경로 전체가 렌더링 되지 않고 기다리게 된다는 거예요.\u003c/p\u003e\n\u003cp\u003e이런 상황에서 사용자 경험과 초기 로딩 속도를 개선하기 위해 스트리밍(Streaming)을 사용할 수 있습니다. 스트리밍은 페이지의 HTML 내용을 작고 여러 개의 청크(chunk)로 나누고, 그 청크들을 서버에서 클라이언트로 점진적으로 보내는 방식을 말합니다. 이렇게 하면 사용자에게는 빠르게 일부 콘텐츠가 먼저 보이고, 나머지도 순차적으로 로딩되어 부드러운 경험을 제공할 수 있죠.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e추가 팁: 스트리밍 적용 시 주의할 점\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e콘텐츠 순서 보장\u003c/strong\u003e\u003cbr\u003e\n스트리밍은 HTML을 나누어 보내지만, 클라이언트는 리소스를 받는 순서대로 렌더링해요. 그래서 서버에서 청크를 보내는 순서를 적절히 관리하는 게 중요합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e상태(state) 관리\u003c/strong\u003e\u003cbr\u003e\n서버에서 각 청크가 독립적으로 렌더링되므로, 상태 관리에 신경 써야 해요. React의 서버 컴포넌트 특성상 상태를 클라이언트와 분리해서 다뤄야 할 때도 있습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eSEO 영향 고려\u003c/strong\u003e\u003cbr\u003e\n스트리밍은 SEO에도 긍정적입니다. 초기 콘텐츠를 빠르게 보여주기 때문에 검색엔진 크롤러가 콘텐츠를 더 잘 인식할 수 있어요.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e스트리밍 덕분에 사용자들은 느린 데이터 로딩으로 인한 기다림이 줄어들고, 동시에 서버 자원을 효율적으로 사용할 수 있게 됩니다. Next.js의 스트리밍 기능, 꼭 활용해보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cimg src=\"/TIL/assets/img/2025-04-22-Howtofetchdataandstream_0.png\"\u003e\n\u003cp\u003e애플리케이션에서 스트리밍(streaming)을 구현하는 방법은 크게 두 가지가 있어요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eloading.js\u003c/code\u003e 파일을 활용하는 방법\u003c/li\u003e\n\u003cli\u003eReact의 \u003ccode\u003eSuspense\u003c/code\u003e 컴포넌트를 사용하는 방법\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eloading.js를 활용한 방법\u003c/h3\u003e\n\u003cp\u003eloading.js 파일을 이용하면 컴포넌트가 로딩 중일 때 보여줄 UI를 간단히 처리할 수 있는데요, 이것만 잘 활용해도 로딩 상태 관리가 훨씬 깔끔해집니다. React 18 이후로 서버 컴포넌트를 지원하면서 이 방식이 점점 많이 쓰이고 있죠.\u003c/p\u003e\n\u003cp\u003e다음에 React \u003ccode\u003eSuspense\u003c/code\u003e 컴포넌트를 활용하는 방법도 한번 살펴볼게요.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e여러분, Next.js에서 페이지 데이터를 가져올 때 로딩 상태를 어떻게 더 잘 보여줄 수 있을까요? 바로 \u003ccode\u003eloading.js\u003c/code\u003e 파일을 활용하는 방법입니다!\u003c/p\u003e\n\u003cp\u003e예를 들어, \u003ccode\u003eapp/blog/page.js\u003c/code\u003e 파일과 같은 폴더(\u003ccode\u003eapp/blog\u003c/code\u003e)에 \u003ccode\u003eloading.js\u003c/code\u003e 파일을 만들어주면, 페이지 데이터를 가져오는 동안 사용자가 기다리는 모습을 좀 더 깔끔하게 보여줄 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eLoading\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 여기서 로딩 화면 UI를 정의해주면 됩니다\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003eLoading...\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 사용자가 페이지로 이동할 때, 화면은 즉시 레이아웃과 이 로딩 UI를 보여주고, 데이터가 모두 준비되면 자동으로 실제 콘텐츠로 바뀌어요.\u003c/p\u003e\n\u003cp\u003e참고로, 이런 방식이 좋은 이유는 “빈 화면”이나 갑작스러운 깜빡임 없이 자연스럽게 사용자 경험이 이어진다는 점이에요. 실제로 프로젝트에 적용할 때는 단순 텍스트 대신 스피너 애니메이션이나 뼈대 UI(Skeleton UI)를 넣어주면 더 효과적이랍니다.\u003c/p\u003e\n\u003cp\u003e아래는 예시 이미지인데, 이런 식으로 로딩 중인 상태를 좀 더 친절하게 보여줄 수 있어요.\u003c/p\u003e\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e\u003cimg src=\"https://yourdomain.com/assets/img/2025-04-22-Howtofetchdataandstream_1.png\" alt=\"로딩 화면 예시\"\u003e\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003c/table\u003e\n\u003cp\u003e나중에 \u003ccode\u003eloading.js\u003c/code\u003e에서 다양한 로딩 상태 구현을 고민해보면서, 사용자 경험을 한층 업그레이드 해보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cimg src=\"/TIL/assets/img/2025-04-22-Howtofetchdataandstream_2.png\"\u003e\n\u003cp\u003e뒤에서 보면, \u003ccode\u003eloading.js\u003c/code\u003e는 \u003ccode\u003elayout.js\u003c/code\u003e 내부에 중첩되어 자동으로 \u003ccode\u003epage.js\u003c/code\u003e 파일과 그 아래 자식들을 \u003ccode\u003eSuspense\u003c/code\u003e 경계로 감싸게 돼요.\u003c/p\u003e\n\u003cimg src=\"/TIL/assets/img/2025-04-22-Howtofetchdataandstream_3.png\"\u003e\n\u003cp\u003e이 방식은 라우트 세그먼트(레이아웃과 페이지)에 잘 맞지만, 더 세밀한 스트리밍이 필요하다면 직접 \u003ccode\u003eSuspense\u003c/code\u003e를 활용하는 게 좋아요.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e여기서 잠깐! \u003ccode\u003eSuspense\u003c/code\u003e를 사용하면 리액트에서 비동기 데이터를 로딩하는 동안 그 자리를 대체하는 로딩 UI를 보여줄 수 있다는 점이 정말 편해요. 특히 Next.js 13처럼 서버 컴포넌트가 도입된 환경에서는 \u003ccode\u003eloading.js\u003c/code\u003e 같은 파일로 페이지 단위 로딩 처리를 자동으로 해주니까 개발이 훨씬 수월해지죠.\u003c/p\u003e\n\u003cp\u003e하지만, 한 단계 더 들어가서 페이지 일부만 따로 로딩하고 싶을 때(예를 들어, 큰 리스트 아이템 중 일부만 먼저 보여주고, 나머지는 천천히 로딩하고 싶을 때) \u003ccode\u003eSuspense\u003c/code\u003e를 직접 사용하는 것이 필요해집니다.\u003c/p\u003e\n\u003cp\u003e즉,\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eloading.js\u003c/code\u003e + \u003ccode\u003elayout.js\u003c/code\u003e = 페이지 단위 자동 로딩 UI 처리\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSuspense\u003c/code\u003e = 하위 컴포넌트 단위 세밀한 로딩 UI 제어\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 두 가지를 적절하게 조합해 사용하는 게 개발 생산성을 높이는 좋은 팁이에요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003e\u003ccode\u003eSuspense\u003c/code\u003e를 활용한 부분적 스트리밍\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eSuspense\u003c/code\u003e는 페이지의 특정 부분만 스트리밍할 수 있게 해줘서, 사용자 경험을 더 부드럽고 빠르게 만들어주는데요. 예를 들어, 전체 페이지 중에서 \u003ccode\u003eSuspense\u003c/code\u003e 경계 밖에 있는 내용은 바로 보여주고, 경계 안에 있는 블로그 목록 같은 무거운 컴포넌트만 나중에 스트리밍해서 로드할 수 있어요.\u003c/p\u003e\n\u003cp\u003e아래 예제를 보면, 제목과 인사말은 즉시 렌더링되고, 블로그 목록은 \u003ccode\u003eSuspense\u003c/code\u003e 안에서 비동기로 불러와집니다. 로딩 중일 때는 \u003ccode\u003eBlogListSkeleton\u003c/code\u003e 컴포넌트가 대신 보여지겠죠?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eSuspense\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBlogList\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"@/components/BlogList\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBlogListSkeleton\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"@/components/BlogListSkeleton\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eBlogPage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      {/* 이 부분은 즉시 클라이언트에게 전송됩니다 */}\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eheader\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003eWelcome to the Blog\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003eRead the latest posts below.\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eheader\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003emain\u003c/span\u003e\u003e\u003c/span\u003e\n        {/* Suspense 경계 안의 컴포넌트는 스트리밍 되어 로드됩니다 */}\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eSuspense\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003efallback\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-attr\"\u003eBlogListSkeleton\u003c/span\u003e /\u003e\u003c/span\u003e}\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eBlogList\u003c/span\u003e /\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eSuspense\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003emain\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e의미 있는 로딩 상태 만들기\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eSuspense\u003c/code\u003e를 사용하면 단순히 \"로딩 중\" 텍스트만 보여주는 대신, 실제 콘텐츠 형태를 모방한 스켈레톤 UI를 보여줄 수 있는데요. 이는 사용자에게 페이지가 정말로 반응하고 있다는 느낌을 잘 줍니다. 예를 들어 블로그 목록이라면 개별 목록 아이템이 빈 카드처럼 보이는 스켈레톤 화면을 만드는 거죠.\u003c/p\u003e\n\u003cp\u003e이런 UX 테크닉을 적용하면, 페이지가 로딩될 때 사용자가 느끼는 대기시간이 훨씬 짧고 부드러워 보여 실제 체감 성능이 높아집니다.\u003c/p\u003e\n\u003cp\u003e더불어, \u003ccode\u003eSuspense\u003c/code\u003e를 적절히 활용하면 데이터가 준비되는 순서에 따라 UI를 부분별로 제어할 수 있어서, 복잡한 페이지도 단계적으로 로드할 수 있다는 점!\u003c/p\u003e\n\u003cp\u003e요약하자면,\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e초기 콘텐츠는 지체 없이 보여주기\u003c/li\u003e\n\u003cli\u003e데이터를 불러오는 부분은 \u003ccode\u003eSuspense\u003c/code\u003e와 fallback UI로 감싸기\u003c/li\u003e\n\u003cli\u003e스켈레톤 UI 등 의미 있는 로딩 화면 제공하기\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이렇게만 해도 사용자 경험은 대폭 개선될 거예요! 😊\u003c/p\u003e\n\u003cp\u003e필요하다면 Suspense의 fallback 컴포넌트를 직접 커스터마이징해서 브랜드 느낌이나 스타일을 살리는 것도 추천드려요.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e즉시 로딩 상태란, 사용자가 페이지를 이동한 직후 바로 보여주는 대체 UI를 의미해요. 이게 왜 중요하냐면, 사용자가 앱이 반응하고 있다는 걸 바로 알 수 있게 해줘서 불안감을 줄이고 더 나은 사용자 경험을 제공할 수 있기 때문이죠.\u003c/p\u003e\n\u003cp\u003e가장 좋은 방법은 단순히 로딩 중이라는 표시만 보여주는 게 아니라, 의미 있는 로딩 상태를 디자인하는 거예요. 예를 들어, 뼈대 화면(skeleton)을 보여준다거나, 돌아가는 스피너(spinner)를 사용하는 게 대표적이고요. 좀 더 나아가서는 다음에 보여질 화면의 핵심 요소, 예를 들어 커버 사진이나 제목 같은 작은 부분을 먼저 보여주면 훨씬 자연스러운 느낌을 줄 수 있습니다.\u003c/p\u003e\n\u003cp\u003e개발 중에는 React Devtools를 활용하면 컴포넌트의 로딩 상태를 미리 보고, 어떻게 동작하는지 자세하게 확인할 수 있어요. 덕분에 사용자에게 완성도 높은 로딩 UI를 더 쉽게 만들 수 있답니다.\u003c/p\u003e\n\u003cp\u003e간단히 정리해볼게요.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e팁\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e즉시 로딩 상태\u003c/td\u003e\u003ctd\u003e네비게이션 후 바로 보여지는 대체 UI\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e의미 있는 로딩 디자인\u003c/td\u003e\u003ctd\u003e스켈레톤, 스피너, 다음 화면 일부 요소(제목, 이미지 등) 활용\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e개발 시 활용 도구\u003c/td\u003e\u003ctd\u003eReact Devtools로 로딩 상태 미리보기 및 검사\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e이런 방식으로 사용자에게 앱이 멈추지 않고 잘 작동 중임을 자연스럽게 알릴 수 있어요. 여러분도 한 번 적용해보세요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2025-04-22-Howtofetchdataandstream"},"buildId":"o6AmBAY_j9v9JmbaRA39X","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>