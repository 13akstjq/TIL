<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>유지보수성을 높이는 5가지 TypeScript 실천법 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2024-07-07-5TypescriptPracticesforImprovedMaintainability" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="유지보수성을 높이는 5가지 TypeScript 실천법 | TIL" data-gatsby-head="true"/><meta property="og:title" content="유지보수성을 높이는 5가지 TypeScript 실천법 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-07-07-5TypescriptPracticesforImprovedMaintainability_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2024-07-07-5TypescriptPracticesforImprovedMaintainability" data-gatsby-head="true"/><meta name="twitter:title" content="유지보수성을 높이는 5가지 TypeScript 실천법 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-07-07-5TypescriptPracticesforImprovedMaintainability_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-07 19:20" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-5ecfd58aae5a7e3d.js" defer=""></script><script src="/TIL/_next/static/jKAIrnIuHBv4ZHjiQbX6i/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/jKAIrnIuHBv4ZHjiQbX6i/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">유지보수성을 높이는 5가지 TypeScript 실천법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="유지보수성을 높이는 5가지 TypeScript 실천법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 7, 2024</span><span class="posts_reading_time__f7YPP">20<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-07-07-5TypescriptPracticesforImprovedMaintainability&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/TIL/assets/img/2024-07-07-5TypescriptPracticesforImprovedMaintainability_0.png" alt="이미지"></p>
<p>아래의 권장 사항은 Typescript를 사용하여 더 유지보수가 용이한 코드를 만드는 데 도움이 되었던 몇 가지 조언에 대한 것입니다. 이 조언들은 새로운 구성 요소에서 Typescript를 사용하고 기존 페이지에서는 여전히 순수 JavaScript를 사용하는 프런트엔드 코드 베이스에서 특히 유용했습니다. 여러분에게도 조금 도움이 되기를 바랍니다.</p>
<p>다음 섹션에서는 제가 제공하는 제안의 요약과 각 포인트가 더 유지보수가 용이한 코드를 만드는 데 왜 도움이 되는지에 대한 몇 가지 핵심 요점에 대해 설명한 후, 이러한 조언을 실제로 어떻게 실천할 수 있는지를 보여주는 몇 가지 예제를 제시할 것입니다.</p>
<h1>팁 #1: 난해한 API 값 해결 및 타입의 힘을 활용하여 이름 변경하기</h1>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>가끔 우리가 작업하는 API는 매우 약어화된 또는 난해한 값 이름을 포함한 데이터 본문을 제공할 수 있습니다. 백엔드와 프론트엔드 사이의 분리 정도에 따라, 이는 코드가 어떤 작업을 수행하고 어떻게 상호 작용해야 하는지 이해하는 데 문제가 될 수 있습니다. 이 문제를 해결하기 위해 API 데이터를 새 객체로 해석하고 더 나은 명명 규칙으로 유형을 지정할 수 있습니다.</p>
<h2>왜 해야 하나요?</h2>
<ul>
<li>다른 사람들과 미래의 자신이 코드를 읽고 이해하기 쉽게 만듭니다.</li>
<li>사용 사례를 명확히 설명합니다 (특히 난해한 이름을 가진 부울 값의 경우).</li>
<li>코드와 API 설명서 간을 계속 왔다갔다해야 하거나 과도한 콘솔 로깅을 하지 않아도 됩니다.</li>
</ul>
<h2>예시</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-comment">// API에서 수신된 데이터</span>
<span class="hljs-comment">// `f_n`은 `firstName`이 됩니다.</span>
<span class="hljs-comment">// `l_n`은 `lastName`이 됩니다.</span>
<span class="hljs-comment">// `users`는 `canEditUsers`가 됩니다.</span>
<span class="hljs-keyword">const</span> rawUserData = [
  {
    <span class="hljs-attr">id</span>: <span class="hljs-number">1654</span>,
    <span class="hljs-attr">f_n</span>: <span class="hljs-string">"Jose"</span>,
    <span class="hljs-attr">l_n</span>: <span class="hljs-string">"Sanchez"</span>,
    <span class="hljs-attr">users</span>: <span class="hljs-literal">true</span>,
  },
  {
    <span class="hljs-attr">id</span>: <span class="hljs-number">3297</span>,
    <span class="hljs-attr">f_n</span>: <span class="hljs-string">"Bob"</span>,
    <span class="hljs-attr">l_n</span>: <span class="hljs-string">"Richards"</span>,
    <span class="hljs-attr">users</span>: <span class="hljs-literal">false</span>,
  },
  {
    <span class="hljs-attr">id</span>: <span class="hljs-number">4572</span>,
    <span class="hljs-attr">f_n</span>: <span class="hljs-string">"Janet"</span>,
    <span class="hljs-attr">l_n</span>: <span class="hljs-string">"Wong"</span>,
    <span class="hljs-attr">users</span>: <span class="hljs-literal">true</span>,
  },
];

<span class="hljs-keyword">const</span> <span class="hljs-title function_">UsersPage</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-comment">// 원시 데이터 값을 더 쉽게 사용할 수 있는 키로 해석합니다.</span>
  <span class="hljs-keyword">const</span> resolvedUserData = rawUserData.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">userData</span>) =></span> ({
    <span class="hljs-attr">id</span>: userData.<span class="hljs-property">id</span>,
    <span class="hljs-attr">firstName</span>: userData.<span class="hljs-property">f_n</span> ?? <span class="hljs-string">""</span>,
    <span class="hljs-attr">lastName</span>: userData.<span class="hljs-property">l_n</span> ?? <span class="hljs-string">""</span>,
    <span class="hljs-attr">canEditUsers</span>: <span class="hljs-title class_">Boolean</span>(userData.<span class="hljs-property">users</span>),
  })) <span class="hljs-keyword">as</span> <span class="hljs-title class_">Users</span>[];

  <span class="hljs-comment">// 해석된 데이터로 UsersList를 렌더링합니다.</span>
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">UsersList</span> <span class="hljs-attr">users</span>=<span class="hljs-string">{resolvedUserData}</span> /></span></span>;
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">UsersPage</span>;

<span class="hljs-comment">// 다른 파일에서...</span>

<span class="hljs-comment">// API에서 원시 키 이름을 알려주는 JSDoc을 추가했음에 주목하세요.</span>
<span class="hljs-comment">// GraphQL 또는 Prisma와 같은 프론트엔드와 API 사이의 레이어가 있는 경우 특히 중요합니다.</span>
<span class="hljs-comment">/**
 * <span class="hljs-doctag">@type</span> firstName: Raw `f_n`
 * <span class="hljs-doctag">@type</span> lastName: Raw `l_n`
 * <span class="hljs-doctag">@type</span> canEditUsers: Raw `users`
 */</span>
type <span class="hljs-title class_">Users</span> = {
  <span class="hljs-attr">id</span>: number;
  <span class="hljs-attr">firstName</span>: string; <span class="hljs-comment">// 원시: f_n</span>
  <span class="hljs-attr">lastName</span>: string; <span class="hljs-comment">// 원시: l_n</span>
  <span class="hljs-attr">canEditUsers</span>: boolean; <span class="hljs-comment">// 원시: users</span>
};

<span class="hljs-comment">// 원시 API 키와 비교했을 때 가독성이 향상되는 점에 주목하세요.</span>
<span class="hljs-comment">// UsersList 구성 요소가 부모로부터 추상화되고 입력을 사용하여 사용자 데이터를 업데이트하기 시작할 때</span>
<span class="hljs-comment">// 이 사항은 점점 더 중요해집니다.</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">UsersList</span> = (<span class="hljs-params">{ users }: { users: Users[] }</span>) => {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      {users.map((user) => (
        <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{user.id}</span>></span>
          <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
            이름: {user.firstName} {user.lastName}
          <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
          <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>사용자 수정 가능? {`${user.canEditUsers}`}<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
          <span class="hljs-tag">&#x3C;<span class="hljs-name">br</span> /></span>
          <span class="hljs-tag">&#x3C;<span class="hljs-name">br</span> /></span>
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
      ))}
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
};
</code></pre>
<h1>팁 #2: 모든 하드코딩된 문자열 값을 enum, object 또는 string 리터럴 유니온으로 대체하세요 (사용 사례에 따라 다름)</h1>
<p>기능을 처음 구현할 때는 단순한 로직을 수행하기 위해 문자열 값과 같은 기본 유형을 하드코딩하는 것이 더 쉬울 수 있습니다.
그러나 코드베이스가 커지고 여러 컴포넌트로 분할되면, 이는 많은 중복을 야기하고 유지 관리의 어려움을 증가시킬 수 있습니다.
이 문제를 해결하기 위해 이러한 분산된 하드코딩된 문자열을 재사용 가능한 enum, object 또는 유니언으로 통합할 수 있습니다.</p>
<h2>왜 이렇게 해야 하나요?</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>코드 완성 기능을 사용하여 유형을 사용할 수 있게 해서 더 많이 추측할 필요가 없도록 합니다</li>
<li>구성 요소를 더 재사용 가능하게 만듭니다</li>
<li>리듀서와 컨텍스트 또는 상태 관리자와 유형을 사용하는 것을 더 간단하게 만듭니다</li>
<li>서로 다른 함수와 구성 요소 사이에서 상태를 전달하는 것을 간단하게 만듭니다</li>
<li>잘못된 입력 및 유형을 검출하는 데 도움이 됩니다</li>
<li>기본값으로 사용할 "unknown"과 같은 예외 유형을 추가할 수 있도록 합니다</li>
</ul>
<h2>예시</h2>
<pre><code class="hljs language-js"><span class="hljs-comment">/**
* 예시 1: 열거형
* 사용 시기:이 것을 사용할 모든 파일이 ts인 경우
* 장점: 변경할 수 없는 상수
  더 나은 형식 안전성, 유형으로 더 쉽게 작업할 수 있음
  사용자 정의 로직에 대한 switch 케이스 사용이 쉬움
* 단점: 바닐라 js와 사용할 수 없음
*/</span>
enum <span class="hljs-title class_">Fruits</span> {
  <span class="hljs-variable constant_">APPLE</span> = <span class="hljs-string">"Apple"</span>,
  <span class="hljs-variable constant_">ORANGE</span> = <span class="hljs-string">"Orange"</span>,
  <span class="hljs-variable constant_">BANANA</span> = <span class="hljs-string">"Banana"</span>,
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">FruitsFromEnumDropdown</span> = (<span class="hljs-params"></span>) => {
  type <span class="hljs-title class_">FruitOptionsFromEnum</span> = {
    <span class="hljs-attr">label</span>: <span class="hljs-title class_">Fruits</span>;
    <span class="hljs-attr">value</span>: keyof <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Fruits</span>;
  };

  <span class="hljs-keyword">const</span> fruitOptions = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(<span class="hljs-title class_">Fruits</span>).<span class="hljs-title function_">map</span>(
    <span class="hljs-function">(<span class="hljs-params">[value, label]</span>) =></span>
      ({
        <span class="hljs-attr">label</span>: label,
        <span class="hljs-attr">value</span>: value,
      } <span class="hljs-keyword">as</span> <span class="hljs-title class_">FruitOptionsFromEnum</span>)
  );

  <span class="hljs-keyword">const</span> [selectedFruit, setSelectedFruit] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(
    fruitOptions[<span class="hljs-number">0</span>].<span class="hljs-property">value</span>
  );

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onSelectFruit</span> = (<span class="hljs-params">selectedFruit: FruitOptionsFromEnum[<span class="hljs-string">"value"</span>]</span>) => {
    <span class="hljs-keyword">const</span> selectedOption = fruitOptions.<span class="hljs-title function_">find</span>(
      <span class="hljs-function">(<span class="hljs-params">fruit</span>) =></span> fruit.<span class="hljs-property">value</span> === selectedFruit
    );
    <span class="hljs-keyword">if</span> (selectedOption) {
      <span class="hljs-title function_">setSelectedFruit</span>(selectedOption?.<span class="hljs-property">value</span>);
    }
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>열거형에서 선택한 과일 : {selectedFruit}<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">select</span>
        <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =></span>
          onSelectFruit(e.target.value as FruitOptionsFromEnum["value"])
        }
      >
        {fruitOptions.map((fruit) => (
          <span class="hljs-tag">&#x3C;<span class="hljs-name">option</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{fruit.value}</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{fruit.value}</span>></span>
            {fruit.label}
          <span class="hljs-tag">&#x3C;/<span class="hljs-name">option</span>></span>
        ))}
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">select</span>></span>
    <span class="hljs-tag">&#x3C;/></span></span>
  );
};

<span class="hljs-comment">/**
* 예시 2: 객체 사용하기
* 사용 시기: 코드 베이스의 일부가 아직 바닐라 js를 사용하는 경우
* 장점: 복사하거나 'let' 및 'as const'가 아닌 경우 할당 가능
  ts 및 js 파일 간에 사용 가능
* 단점: enums보다 유형을 사용하기 어려울 수 있음, 'as const'조차도
*/</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">FruitsObject</span> = {
  <span class="hljs-attr">APPLE</span>: <span class="hljs-string">"Apple"</span>,
  <span class="hljs-attr">ORANGE</span>: <span class="hljs-string">"Orange"</span>,
  <span class="hljs-attr">BANANA</span>: <span class="hljs-string">"Banana"</span>,
} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">FruitsFromObjectDropdown</span> = (<span class="hljs-params"></span>) => {
  type <span class="hljs-title class_">FruitOptionsFromObject</span> = {
    <span class="hljs-attr">label</span>: (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">FruitsObject</span>)[keyof <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">FruitsObject</span>];
    <span class="hljs-attr">value</span>: keyof <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">FruitsObject</span>;
  };

  <span class="hljs-keyword">const</span> fruitOptions = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(<span class="hljs-title class_">FruitsObject</span>).<span class="hljs-title function_">map</span>(
    <span class="hljs-function">(<span class="hljs-params">[v, k]</span>) =></span>
      ({
        <span class="hljs-attr">label</span>: k,
        <span class="hljs-attr">value</span>: v,
      } <span class="hljs-keyword">as</span> <span class="hljs-title class_">FruitOptionsFromObject</span>)
  );

  <span class="hljs-keyword">const</span> [selectedFruit, setSelectedFruit] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(
    fruitOptions[<span class="hljs-number">0</span>].<span class="hljs-property">value</span>
  );

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onSelectFruit</span> = (<span class="hljs-params">selectedFruit: FruitOptionsFromObject[<span class="hljs-string">"value"</span>]</span>) => {
    <span class="hljs-keyword">const</span> selectedOption = fruitOptions.<span class="hljs-title function_">find</span>(
      <span class="hljs-function">(<span class="hljs-params">fruit</span>) =></span> fruit.<span class="hljs-property">value</span> === selectedFruit
    );
    <span class="hljs-keyword">if</span> (selectedOption) {
      <span class="hljs-title function_">setSelectedFruit</span>(selectedOption?.<span class="hljs-property">value</span>);
    }
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>객체에서 선택한 과일 : {selectedFruit}<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">select</span>
        <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =></span>
          onSelectFruit(e.target.value as FruitOptionsFromObject["value"])
        }
      >
        {fruitOptions.map((fruit) => (
          <span class="hljs-tag">&#x3C;<span class="hljs-name">option</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{fruit.value}</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{fruit.value}</span>></span>
            {fruit.label}
          <span class="hljs-tag">&#x3C;/<span class="hljs-name">option</span>></span>
        ))}
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">select</span>></span>
    <span class="hljs-tag">&#x3C;/></span></span>
  );
};

<span class="hljs-comment">/**
* 예시 3: 문자열 유니언
* 사용 시기: 백엔드에서 유형을 확장해야하거나 대안으로 enums를 대체해야할 때
* 장점: 쉽게 확장 가능
  ts 및 js 간에 재사용 가능
  사용자 정의 로직에 대한 switch 케이스 사용이 쉬움
* 단점: enums와 같이 할당할 수 없으며, 문자열은 순수한 리터럴임
*/</span>
type <span class="hljs-title class_">StatusStringUnion</span> = <span class="hljs-string">"saved"</span> | <span class="hljs-string">"saving"</span> | <span class="hljs-string">"standby"</span> | <span class="hljs-string">"error"</span> | <span class="hljs-string">"unknown"</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">FormStatus</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">const</span> [currentStatus, setCurrentStatus] =
    <span class="hljs-title class_">React</span>.<span class="hljs-property">useState</span>&#x3C;<span class="hljs-title class_">StatusStringUnion</span>>(<span class="hljs-string">"unknown"</span>);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">StatusRow</span>></span>
      상태: <span class="hljs-tag">&#x3C;<span class="hljs-name">Label</span>></span>{currentStatus}<span class="hljs-tag">&#x3C;/<span class="hljs-name">Label</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">Dot</span> <span class="hljs-attr">status</span>=<span class="hljs-string">{currentStatus}</span> /></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">StatusRow</span>></span></span>
  );
};

<span class="hljs-comment">//다른 파일에서는 ...</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">StatusRow</span> = styled.<span class="hljs-property">div</span><span class="hljs-string">`
  display: flex;
  justify-content: center;
  align-content: center;
`</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title class_">Label</span> = styled.<span class="hljs-property">div</span><span class="hljs-string">`
  margin-left: 0.25rem;
  font-size: 12pt;
  font-weight: 600;
`</span>;

<span class="hljs-comment">//사용자 정의 StyledComponents 로직 사용 예시</span>
<span class="hljs-comment">//enum 또는 문자열 유니언은 이러한 경우에 가장 적합합니다</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Dot</span> = styled.<span class="hljs-property">div</span>&#x3C;{ <span class="hljs-attr">status</span>: <span class="hljs-title class_">StatusStringUnion</span> }><span class="hljs-string">`
  display: flex;
  justify-content: center;
  align-content: start;
  clip-path: circle(5px);
  width: 1rem;
  background: <span class="hljs-subst">${({ status }) => {
    <span class="hljs-keyword">switch</span> (status) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">"saved"</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"green"</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">"saving"</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"yellow"</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">"error"</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"red"</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">"standby"</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"none"</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">"unknown"</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"gray"</span>;
      <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"gray"</span>;
    }
  };
  margin-left: <span class="hljs-number">0.</span>25rem;
<span class="hljs-string">`;



&#x3C;!-- TIL 수평 -->
&#x3C;ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-4877378276818686"
     data-ad-slot="1549334788"
     data-ad-format="auto"
     data-full-width-responsive="true">&#x3C;/ins>
&#x3C;script>
(adsbygoogle = window.adsbygoogle || []).push({});
&#x3C;/script>

내가 작업한 많은 코드에서, 유형은 일반적으로 변경할 수 없는 값을 나타내는 비-nullable로 기본 설정됩니다. 그러나 값은 때로 바뀔 수 있고, 앱의 내부 논리 구조가 복잡해지면 예기치 않은 null 또는 undefined 값이 발생하여 프로덕션 코드에서 유형 오류를 발생시키기 쉬워집니다. 이를 피하는 한 가지 방법은 다른 방향으로 기본값을 nullable 값으로 설정하는 것입니다. 기본적으로, 이 값이 어떤 상황에서 null 또는 undefined가 될 수 있는 경우(또는 확실하지 않은 경우), 선택 사항 유형으로 만드는 것입니다.

## 이유

- 백엔드와 프론트엔드가 강하게 결합되어 있지 않은 경우(즉, 풀스택 개발자가 아닌 경우), 두 계약 사이의 값 유형이 제대로 문서화되지 않을 수 있음
- 데이터베이스가 커지고 복잡해지면 예상치 못한 값(예: null 및 undefined)이 부정적으로 발생할 확률이 높아집니다
- 앱이 사용자 입력을 수락하는 경우, 프론트엔드와 백엔드의 유효성 검사 엣지 케이스가 데이터베이스에 이상한 값이 저장되도록 할 수 있음
- 나중에 요구 사항이 변경되어 null/undefined 값을 허용하는 경우가 생길 수 있음
- null/undefined이면 명시적으로 기본값을 설정할 수 있어, 문자열이 항상 " "와 같은 문자열이 되도록 보장할 수 있음
- 입력 값에 일부 값을 필수로 만들면, 유효성 검사의 추가 계층을 추가하고 부정적인 값이 백엔드로 전송되지 않도록 보장할 수 있음

## 예시

&#x3C;!-- TIL 수평 -->
&#x3C;ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-4877378276818686"
     data-ad-slot="1549334788"
     data-ad-format="auto"
     data-full-width-responsive="true">&#x3C;/ins>
&#x3C;script>
(adsbygoogle = window.adsbygoogle || []).push({});
&#x3C;/script>

/**
 * @type firstName: Raw `</span>f_n<span class="hljs-string">`
 * @type lastName: Raw `</span>l_n<span class="hljs-string">`
 * @type canEditUsers: Raw `</span>users<span class="hljs-string">`
 */
type Users = {
  id: number;
  firstName?: string; //Raw: f_n
  lastName?: string; //Raw: l_n
  canEditUsers?: boolean; //Raw: users
};

//만약 아래의 사용자(user)를 접근하려고 할 때 값 중 하나라도 null이 허용되지 않는
//즉, 필수값이면 타입 오류를 발생시키고 렌더를 충돌시킬 수 있습니다.
//이는 널 병합 연산자를 사용할 수 있게 하여 Typescript가
//해당 사용법을 강제하는 것을 가능하게 합니다.
const UsersList = ({ users }: { users: Users[] }) => {
  return (
    &#x3C;div>
      {users.map((user) => (
        &#x3C;div key={user.id}>
          &#x3C;div>
            Name: {user?.firstName} {user?.lastName}
          &#x3C;/div>
          &#x3C;div>Can edit users? {`</span>${user?.canEditUsers}<span class="hljs-string">`}&#x3C;/div>
          &#x3C;br />
          &#x3C;br />
        &#x3C;/div>
      ))}
    &#x3C;/div>
  );
};

# 팁 #4: 일반적으로 재사용되는 유형을 제네릭을 사용하여 유틸 파일에 저장하기

코드 베이스가 커지면 앱 전반에서 유사한 유형을 재사용해야 할 수 있습니다. 가장 일반적으로 재사용되는 유형을 제네릭의 힘을 이용하여 더 재사용할 수 있게 할 수 있으며, 이는 기본 유형이 완벽하게 일치하지 않을 때도 유형이 여러 컨텍스트에서 재사용될 수 있음을 의미합니다. 이러한 접근 방식을 사용하면 재사용 가능한 유틸 함수가 Typescript의 모든 기능을 최대한 활용할 수 있음을 의미합니다.

## 왜 이것을 하는가
</span></span></span></code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>수동으로 모든 사용법을 입력할 필요가 없다는 것을 의미합니다.</li>
<li>한 곳에서 유형을 업데이트하는 것이 더 쉽습니다.</li>
<li>재사용 가능하고 매우 복잡한 유형을 만들 수 있습니다.</li>
<li>코드 베이스의 라이브러리에서 기초로 하는 유형을 만들 수 있습니다(예: Relay).</li>
<li>해당 유형을 사용하는 구성 요소를 지저분하게 만들지 않고 찾기, 문서화, 사용하기가 더 쉽습니다.</li>
</ul>
<h2>예시</h2>
<pre><code class="hljs language-js"><span class="hljs-comment">/** Example 1: 제네릭을 사용한 재사용 가능한 유형 */</span>
<span class="hljs-comment">// `utils/reusableTypes.ts` 파일 내에서</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Disposable</span>, <span class="hljs-title class_">UseMutationConfig</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-relay"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">MutationParameters</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"relay-runtime"</span>;

<span class="hljs-comment">/**
 * <span class="hljs-doctag">@description</span> 주어진 유형에서 값을 가져오는 유형
 * <span class="hljs-doctag">@example</span> {<span class="hljs-type"> fieldName: FormProps, value: ValueOf&#x3C;FormProps> </span>}
 */</span>
<span class="hljs-keyword">export</span> type <span class="hljs-title class_">ValueOf</span>&#x3C;T> = T[keyof T];

<span class="hljs-comment">/**
 * <span class="hljs-doctag">@description</span> Relay 변경 사항으로부터 유형 만들기
 * <span class="hljs-doctag">@example</span> type UserContextTypes = {
 *   createUser: MutationTypeOf&#x3C;createUserMutation>
 * }
 */</span>
<span class="hljs-keyword">export</span> type <span class="hljs-title class_">MutationTypeOf</span>&#x3C;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MutationParameters</span>> = <span class="hljs-function">(<span class="hljs-params">
  config: UseMutationConfig&#x3C;T>
</span>) =></span> <span class="hljs-title class_">Disposable</span>;

<span class="hljs-comment">//다른 파일에서 ...</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ValueOf</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../utils/reusableTypes"</span>;

enum <span class="hljs-title class_">Fruits</span> {
  <span class="hljs-variable constant_">APPLE</span> = <span class="hljs-string">"Apple"</span>,
  <span class="hljs-variable constant_">ORANGE</span> = <span class="hljs-string">"Orange"</span>,
  <span class="hljs-variable constant_">BANANA</span> = <span class="hljs-string">"Banana"</span>,
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">GenericFruitsFromEnumDropdown</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">const</span> fruitOptions = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(<span class="hljs-title class_">Fruits</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">[value, label]</span>) =></span> ({
    <span class="hljs-attr">label</span>: label,
    <span class="hljs-attr">value</span>: value,
  }));

  <span class="hljs-keyword">const</span> [selectedFruit, setSelectedFruit] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(
    fruitOptions[<span class="hljs-number">0</span>].<span class="hljs-property">value</span>
  );

<span class="hljs-comment">//거의 모든 다른 데이터 유형과 함께`ValueOf`의 제네릭 유형을 사용할 수 있습니다.</span>
<span class="hljs-comment">//단, Fruits 열거형을 포함한다.</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onSelectFruit</span> = (<span class="hljs-params">selectedFruit: ValueOf&#x3C;Fruits></span>) => {
    <span class="hljs-keyword">const</span> selectedOption = fruitOptions.<span class="hljs-title function_">find</span>(
      <span class="hljs-function">(<span class="hljs-params">fruit</span>) =></span> fruit.<span class="hljs-property">value</span> === selectedFruit
    );
    <span class="hljs-keyword">if</span> (selectedOption) {
      <span class="hljs-title function_">setSelectedFruit</span>(selectedOption?.<span class="hljs-property">value</span>);
    }
  };

  <span class="hljs-comment">//ValueOf를 사용하면 열거형 값과의 비교를 수행할 수 있습니다.</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(selectedFruit === <span class="hljs-title class_">Fruits</span>.<span class="hljs-property">APPLE</span>);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>선택된 열거형 과일: {selectedFruit}<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">select</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =></span> onSelectFruit(e.target.value)}>
        {fruitOptions.map((fruit) => (
          <span class="hljs-tag">&#x3C;<span class="hljs-name">option</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{fruit.value}</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{fruit.value}</span>></span>
            {fruit.label}
          <span class="hljs-tag">&#x3C;/<span class="hljs-name">option</span>></span>
        ))}
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">select</span>></span>
    <span class="hljs-tag">&#x3C;/></span></span>
  );
};
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">/** Example 2: 제네릭을 사용한 재사용 가능한 함수 */</span>
<span class="hljs-comment">// `utils/reusableFunctions.ts` 파일 내에서</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-comment">/**
 * <span class="hljs-doctag">@description</span> 주어진 기본 값이 배열에서 중복되는지 여부를 확인합니다.
 * <span class="hljs-doctag">@example</span>
 * const myNumberArray = [4, 5, 5, 1, 6, 3];
 * primitiveIsDuplicatedInArray(3, myNumberArray); //false
 * primitiveIsDuplicatedInArray(5, myNumberArray); //true
 *
 * const myStringArray = ['z', 'b', 'b', 'a', 'f', 'd'];
 * const isADuplicated = primitiveIsDuplicatedInArray(3, myStringArray); //3은 숫자이므로 TypeScript 오류가 발생합니다.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> primitiveIsDuplicatedInArray = &#x3C;T><span class="hljs-function">(<span class="hljs-params">givenValue: T, arr: T[]</span>) =></span>
  arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =></span> value === givenValue).<span class="hljs-property">length</span> > <span class="hljs-number">1</span>;

<span class="hljs-comment">//다른 파일에서 ...</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> { primitiveIsDuplicatedInArray } <span class="hljs-keyword">from</span> <span class="hljs-string">"../utils/reusableFunctions"</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">GenericFunctions</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-comment">//`primitiveIsDuplicatedInArray`에서 제네릭 유형을 사용하면</span>
  <span class="hljs-comment">//숫자, 문자열 및 다른 기본 유형을 가진 배열에서 중복 항목을 찾을 수 있습니다.</span>
  <span class="hljs-keyword">const</span> myNumberArray = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>];
  <span class="hljs-keyword">const</span> isThreeDuplicated = <span class="hljs-title function_">primitiveIsDuplicatedInArray</span>(<span class="hljs-number">3</span>, myNumberArray);
  <span class="hljs-keyword">const</span> isFiveDuplicated = <span class="hljs-title function_">primitiveIsDuplicatedInArray</span>(<span class="hljs-number">5</span>, myNumberArray);

  <span class="hljs-keyword">const</span> myStringArray = [<span class="hljs-string">"z"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"a"</span>, <span class="hljs-string">"f"</span>, <span class="hljs-string">"d"</span>];
  <span class="hljs-keyword">const</span> isBDuplicated = <span class="hljs-title function_">primitiveIsDuplicatedInArray</span>(<span class="hljs-string">"b"</span>, myStringArray);
  <span class="hljs-keyword">const</span> isFDuplicated = <span class="hljs-title function_">primitiveIsDuplicatedInArray</span>(<span class="hljs-string">"f"</span>, myStringArray);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>내 숫자 배열: {`[${myNumberArray}]`}<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>3이 중복되었나요? {`${isThreeDuplicated}`}<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>5가 중복되었나요? {`${isFiveDuplicated}`}<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">br</span> /></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">br</span> /></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>내 문자열 배열: {`[${myStringArray}]`}<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>b가 중복되었나요? {`${isBDuplicated}`}<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>f가 중복되었나요? {`${isFDuplicated}`}<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">GenericFunctions</span>;
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>팁 #5: 암시적 타입 및 구조 분해에 의존하기보다 함수 props를 명시적으로 입력하세요</h1>
<p>함수와 컴포넌트에 props를 전달하는 방식은 최종적으로 개인의 선택이지만, 명시적 props를 사용하는 것이 동료들이 이해하기 쉽고 유지 보수하기 쉽도록 코드를 만드는 데 도움이 된다고 주장합니다. 기능적인 측면에서 컴포넌트와 함수를 이해하기 쉽게 만들며, 암시적 타입의 한계에서 발생하는 실제 버그를 줄여줍니다.</p>
<ul>
<li>암시적 타입은 함수나 컴포넌트를 검사하는 요구가 있지만, 명시적 타입은 최신 편집기에서 코드 완성을 제공합니다</li>
<li>여러 컴포넌트나 함수에 대한 재사용 가능한 타입을 만들 수 있으며 Partial 및 Omit과 같은 고급 타입을 사용할 수 있게 합니다</li>
<li>여러 파일을 통해 props를 추적하는 것이 훨씬 쉽습니다 (특히 다중 하위 컴포넌트로 prop을 전달하는 경우)</li>
<li>함수와 재사용 가능한 컴포넌트를 문서화하기가 훨씬 더 쉽습니다</li>
<li>props에 대한 암시적 타입은 함수로 전달된 props가 잘못된 순서로 전달되거나 prop이 생략될 때 버그를 발생시킵니다</li>
</ul>
<h2>예시들</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-comment">/** 예제 1: 컴포넌트에 속성(props) 전달하기 */</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

type <span class="hljs-title class_">FormStatus</span> = <span class="hljs-string">"saved"</span> | <span class="hljs-string">"saving"</span> | <span class="hljs-string">"standby"</span> | <span class="hljs-string">"error"</span> | <span class="hljs-string">"unknown"</span>;

type <span class="hljs-title class_">User</span> = {
  <span class="hljs-attr">id</span>: number;
  firstName?: string;
  lastName?: string;
};

<span class="hljs-comment">/** 예제 A: 속성(props) 구조 분해하기 */</span>
type <span class="hljs-title class_">DestructuringProps</span> = {
  <span class="hljs-attr">users</span>: <span class="hljs-title class_">User</span>[];
  <span class="hljs-attr">formStatus</span>: <span class="hljs-title class_">FormStatus</span>;
};

<span class="hljs-comment">// `props`를 그냥 전달하는 것은 특히 재사용되는 고도로 추상화된 컴포넌트에서 prop 추적을 매우 어렵게 만들 수 있습니다. 심지어 타입을 지정해도요</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">Destructuring</span> = (<span class="hljs-params">props: DestructuringProps</span>) => {
  <span class="hljs-comment">// 이렇게 구조 분해할 때, 이 prop들은 모두 널이 아니라는 것을 주목하세요</span>
  <span class="hljs-keyword">const</span> { users, formStatus } = props;

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>상태: {formStatus}<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
      {users.map((user) => (
        <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{user.id}</span>></span>
          {user.firstName} {user.lastName}
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
      ))}
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
};

<span class="hljs-comment">/** 예제 B: 명시적인 속성(props) */</span>
type <span class="hljs-title class_">ExplicitProps</span> = {
  <span class="hljs-attr">users</span>: <span class="hljs-title class_">User</span>[];
  <span class="hljs-attr">formStatus</span>: <span class="hljs-title class_">FormStatus</span>;
};

<span class="hljs-comment">// 속성을 명시적으로 전달하고 타입을 지정하는 것은 추적을 훨씬 간단하게 만듭니다</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">Explicit</span> = (<span class="hljs-params">{ users, formStatus }: ExplicitProps</span>) => {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>상태: {formStatus}<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
      {users.map((user) => (
        <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{user.id}</span>></span>
          {user.firstName} {user.lastName}
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
      ))}
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">DifferentPropTypes</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">const</span> users = [
    {
      <span class="hljs-attr">id</span>: <span class="hljs-number">1654</span>,
      <span class="hljs-attr">firstName</span>: <span class="hljs-string">"Jose"</span>,
      <span class="hljs-attr">lastName</span>: <span class="hljs-string">"Sanchez"</span>,
    },
    {
      <span class="hljs-attr">id</span>: <span class="hljs-number">3297</span>,
      <span class="hljs-attr">firstName</span>: <span class="hljs-string">"Bob"</span>,
      <span class="hljs-attr">lastName</span>: <span class="hljs-string">"Richards"</span>,
    },
    {
      <span class="hljs-attr">id</span>: <span class="hljs-number">4572</span>,
      <span class="hljs-attr">firstName</span>: <span class="hljs-string">"Janet"</span>,
      <span class="hljs-attr">lastName</span>: <span class="hljs-string">"Wong"</span>,
    },
  ];

  <span class="hljs-keyword">const</span> formStatus = <span class="hljs-string">"standby"</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">FormStatus</span>;

  <span class="hljs-keyword">const</span> props = {
    users,
    formStatus,
  };

<span class="hljs-comment">// 여기서 `props`가 상위 레벨에서 스프레드 연산자를 통해 전달되었다고 상상해보세요.</span>
<span class="hljs-comment">// 최상위 레벨까지 거슬러 올라가지 않고 그 당시의 props가 무엇인지 추적할 수 있을까요?</span>
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">Destructuring</span> {<span class="hljs-attr">...props</span>} /></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">br</span> /></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">br</span> /></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">Explicit</span> <span class="hljs-attr">users</span>=<span class="hljs-string">{users}</span> <span class="hljs-attr">formStatus</span>=<span class="hljs-string">{formStatus}</span> /></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">br</span> /></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">br</span> /></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">DifferentPropTypes</span>;
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">/** 예제 2: 함수에 속성(props) 전달하기 */</span>

<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-comment">// 예제 A: 구조 분해는 사용 방법을 애매하게 만들 수 있습니다</span>
type <span class="hljs-title class_">DestructuredProps</span> = {
  <span class="hljs-attr">userName</span>: string,
  <span class="hljs-attr">userNamesArray</span>: string[],
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">userNameIsDuplicatedDestructuredProps</span> = (<span class="hljs-params">props: DestructuredProps</span>) => {
  <span class="hljs-comment">// 이렇게 구조 분해할 때, 이 prop들은 모두 널이 아니라는 것을 주목하세요</span>
  <span class="hljs-keyword">const</span> { userName, userNamesArray } = props;
  <span class="hljs-keyword">return</span> userNamesArray.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =></span> value === userName).<span class="hljs-property">length</span> > <span class="hljs-number">1</span>;
};

<span class="hljs-comment">// 예제 B: 암시적인 속성은 전달 순서에 의존하고 타입 완성도가 낮아서 버그를 유발할 수 있습니다</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">userNameIsDuplicatedImplicitProps</span> = (<span class="hljs-params">userName: string, userNamesArray: string[]</span>) =>
  userNamesArray.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =></span> value === userName).<span class="hljs-property">length</span> > <span class="hljs-number">1</span>;

<span class="hljs-comment">// 예제 C: 명시적 속성은 속성 순서와 타입을 강제화합니다</span>
type <span class="hljs-title class_">ExplicitProps</span> = {
  <span class="hljs-attr">userName</span>: string,
  <span class="hljs-attr">userNamesArray</span>: string[],
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">userNameIsDuplicatedExplicitProps</span> = (<span class="hljs-params">{ userName, userNamesArray }: ExplicitProps</span>) =>
  userNamesArray.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =></span> value === userName).<span class="hljs-property">length</span> > <span class="hljs-number">1</span>;

<span class="hljs-comment">// 데이터</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">TypingFnProps</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">const</span> users = [
    {
      <span class="hljs-attr">id</span>: <span class="hljs-number">1654</span>,
      <span class="hljs-attr">firstName</span>: <span class="hljs-string">"Jose"</span>,
      <span class="hljs-attr">lastName</span>: <span class="hljs-string">"Sanchez"</span>,
    },
    {
      <span class="hljs-attr">id</span>: <span class="hljs-number">3297</span>,
      <span class="hljs-attr">firstName</span>: <span class="hljs-string">"Bob"</span>,
      <span class="hljs-attr">lastName</span>: <span class="hljs-string">"Richards"</span>,
    },
    {
      <span class="hljs-attr">id</span>: <span class="hljs-number">4572</span>,
      <span class="hljs-attr">firstName</span>: <span class="hljs-string">"Janet"</span>,
      <span class="hljs-attr">lastName</span>: <span class="hljs-string">"Wong"</span>,
    },
    {
      <span class="hljs-attr">id</span>: <span class="hljs-number">8725</span>,
      <span class="hljs-attr">firstName</span>: <span class="hljs-string">"Janet"</span>,
      <span class="hljs-attr">lastName</span>: <span class="hljs-string">"Wong"</span>,
    },
  ];

  <span class="hljs-keyword">const</span> userNamesArray = users.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">{ firstName, lastName }</span>) =></span> <span class="hljs-string">`<span class="hljs-subst">${firstName}</span> <span class="hljs-subst">${lastName}</span>`</span>);

  <span class="hljs-keyword">const</span> props = {
    userNamesArray,
    <span class="hljs-attr">userName</span>: <span class="hljs-string">"Janet Wong"</span>,
  };

  <span class="hljs-keyword">const</span> isJanetDuplicatedDestructuredProps = <span class="hljs-title function_">userNameIsDuplicatedDestructuredProps</span>(props);

  <span class="hljs-keyword">const</span> isJanetDuplicatedImplicitProps = <span class="hljs-title function_">userNameIsDuplicatedImplicitProps</span>(<span class="hljs-string">"Janet Wong"</span>, userNamesArray);

  <span class="hljs-keyword">const</span> isJanetDuplicatedExplicitProps = <span class="hljs-title function_">userNameIsDuplicatedExplicitProps</span>({
    <span class="hljs-attr">userName</span>: <span class="hljs-string">"Janet Wong"</span>,
    userNamesArray,
  });

  <span class="hljs-comment">// 이것을 변경해가며 출력과 타입 체크 차이를 관찰해보세요</span>
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>Janet이 중복되었나요? {`${isJanetDuplicatedDestructuredProps}`}<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">br</span> /></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">br</span> /></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>Janet이 중복되었나요? {`${isJanetDuplicatedImplicitProps}`}<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">br</span> /></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">br</span> /></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>Janet이 중복되었나요? {`${isJanetDuplicatedExplicitProps}`}<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">TypingFnProps</span>;
</code></pre>
<p>안내드린 내용 외에도 TypeScript로 유지보수 가능한 코드를 작성하는 더 많은 팁이 있지만, 이 중에서 저가 일반적으로 사용하는 팁들이었습니다.</p>
<p>전체 소스 코드: <a href="https://github.com/lbd1607/ts-blog" rel="nofollow" target="_blank">https://github.com/lbd1607/ts-blog</a></p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>행복한 코딩하세요 :)</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"유지보수성을 높이는 5가지 TypeScript 실천법","description":"","date":"2024-07-07 19:20","slug":"2024-07-07-5TypescriptPracticesforImprovedMaintainability","content":"\n![이미지](/TIL/assets/img/2024-07-07-5TypescriptPracticesforImprovedMaintainability_0.png)\n\n아래의 권장 사항은 Typescript를 사용하여 더 유지보수가 용이한 코드를 만드는 데 도움이 되었던 몇 가지 조언에 대한 것입니다. 이 조언들은 새로운 구성 요소에서 Typescript를 사용하고 기존 페이지에서는 여전히 순수 JavaScript를 사용하는 프런트엔드 코드 베이스에서 특히 유용했습니다. 여러분에게도 조금 도움이 되기를 바랍니다.\n\n다음 섹션에서는 제가 제공하는 제안의 요약과 각 포인트가 더 유지보수가 용이한 코드를 만드는 데 왜 도움이 되는지에 대한 몇 가지 핵심 요점에 대해 설명한 후, 이러한 조언을 실제로 어떻게 실천할 수 있는지를 보여주는 몇 가지 예제를 제시할 것입니다.\n\n# 팁 #1: 난해한 API 값 해결 및 타입의 힘을 활용하여 이름 변경하기\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가끔 우리가 작업하는 API는 매우 약어화된 또는 난해한 값 이름을 포함한 데이터 본문을 제공할 수 있습니다. 백엔드와 프론트엔드 사이의 분리 정도에 따라, 이는 코드가 어떤 작업을 수행하고 어떻게 상호 작용해야 하는지 이해하는 데 문제가 될 수 있습니다. 이 문제를 해결하기 위해 API 데이터를 새 객체로 해석하고 더 나은 명명 규칙으로 유형을 지정할 수 있습니다.\n\n## 왜 해야 하나요?\n\n- 다른 사람들과 미래의 자신이 코드를 읽고 이해하기 쉽게 만듭니다.\n- 사용 사례를 명확히 설명합니다 (특히 난해한 이름을 가진 부울 값의 경우).\n- 코드와 API 설명서 간을 계속 왔다갔다해야 하거나 과도한 콘솔 로깅을 하지 않아도 됩니다.\n\n## 예시\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n// API에서 수신된 데이터\n// `f_n`은 `firstName`이 됩니다.\n// `l_n`은 `lastName`이 됩니다.\n// `users`는 `canEditUsers`가 됩니다.\nconst rawUserData = [\n  {\n    id: 1654,\n    f_n: \"Jose\",\n    l_n: \"Sanchez\",\n    users: true,\n  },\n  {\n    id: 3297,\n    f_n: \"Bob\",\n    l_n: \"Richards\",\n    users: false,\n  },\n  {\n    id: 4572,\n    f_n: \"Janet\",\n    l_n: \"Wong\",\n    users: true,\n  },\n];\n\nconst UsersPage = () =\u003e {\n  // 원시 데이터 값을 더 쉽게 사용할 수 있는 키로 해석합니다.\n  const resolvedUserData = rawUserData.map((userData) =\u003e ({\n    id: userData.id,\n    firstName: userData.f_n ?? \"\",\n    lastName: userData.l_n ?? \"\",\n    canEditUsers: Boolean(userData.users),\n  })) as Users[];\n\n  // 해석된 데이터로 UsersList를 렌더링합니다.\n  return \u003cUsersList users={resolvedUserData} /\u003e;\n};\n\nexport default UsersPage;\n\n// 다른 파일에서...\n\n// API에서 원시 키 이름을 알려주는 JSDoc을 추가했음에 주목하세요.\n// GraphQL 또는 Prisma와 같은 프론트엔드와 API 사이의 레이어가 있는 경우 특히 중요합니다.\n/**\n * @type firstName: Raw `f_n`\n * @type lastName: Raw `l_n`\n * @type canEditUsers: Raw `users`\n */\ntype Users = {\n  id: number;\n  firstName: string; // 원시: f_n\n  lastName: string; // 원시: l_n\n  canEditUsers: boolean; // 원시: users\n};\n\n// 원시 API 키와 비교했을 때 가독성이 향상되는 점에 주목하세요.\n// UsersList 구성 요소가 부모로부터 추상화되고 입력을 사용하여 사용자 데이터를 업데이트하기 시작할 때\n// 이 사항은 점점 더 중요해집니다.\nconst UsersList = ({ users }: { users: Users[] }) =\u003e {\n  return (\n    \u003cdiv\u003e\n      {users.map((user) =\u003e (\n        \u003cdiv key={user.id}\u003e\n          \u003cdiv\u003e\n            이름: {user.firstName} {user.lastName}\n          \u003c/div\u003e\n          \u003cdiv\u003e사용자 수정 가능? {`${user.canEditUsers}`}\u003c/div\u003e\n          \u003cbr /\u003e\n          \u003cbr /\u003e\n        \u003c/div\u003e\n      ))}\n    \u003c/div\u003e\n  );\n};\n```\n\n# 팁 #2: 모든 하드코딩된 문자열 값을 enum, object 또는 string 리터럴 유니온으로 대체하세요 (사용 사례에 따라 다름)\n\n기능을 처음 구현할 때는 단순한 로직을 수행하기 위해 문자열 값과 같은 기본 유형을 하드코딩하는 것이 더 쉬울 수 있습니다.\n그러나 코드베이스가 커지고 여러 컴포넌트로 분할되면, 이는 많은 중복을 야기하고 유지 관리의 어려움을 증가시킬 수 있습니다.\n이 문제를 해결하기 위해 이러한 분산된 하드코딩된 문자열을 재사용 가능한 enum, object 또는 유니언으로 통합할 수 있습니다.\n\n## 왜 이렇게 해야 하나요?\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 코드 완성 기능을 사용하여 유형을 사용할 수 있게 해서 더 많이 추측할 필요가 없도록 합니다\n- 구성 요소를 더 재사용 가능하게 만듭니다\n- 리듀서와 컨텍스트 또는 상태 관리자와 유형을 사용하는 것을 더 간단하게 만듭니다\n- 서로 다른 함수와 구성 요소 사이에서 상태를 전달하는 것을 간단하게 만듭니다\n- 잘못된 입력 및 유형을 검출하는 데 도움이 됩니다\n- 기본값으로 사용할 \"unknown\"과 같은 예외 유형을 추가할 수 있도록 합니다\n\n## 예시\n\n```js\n/**\n* 예시 1: 열거형\n* 사용 시기:이 것을 사용할 모든 파일이 ts인 경우\n* 장점: 변경할 수 없는 상수\n  더 나은 형식 안전성, 유형으로 더 쉽게 작업할 수 있음\n  사용자 정의 로직에 대한 switch 케이스 사용이 쉬움\n* 단점: 바닐라 js와 사용할 수 없음\n*/\nenum Fruits {\n  APPLE = \"Apple\",\n  ORANGE = \"Orange\",\n  BANANA = \"Banana\",\n}\n\nexport const FruitsFromEnumDropdown = () =\u003e {\n  type FruitOptionsFromEnum = {\n    label: Fruits;\n    value: keyof typeof Fruits;\n  };\n\n  const fruitOptions = Object.entries(Fruits).map(\n    ([value, label]) =\u003e\n      ({\n        label: label,\n        value: value,\n      } as FruitOptionsFromEnum)\n  );\n\n  const [selectedFruit, setSelectedFruit] = React.useState(\n    fruitOptions[0].value\n  );\n\n  const onSelectFruit = (selectedFruit: FruitOptionsFromEnum[\"value\"]) =\u003e {\n    const selectedOption = fruitOptions.find(\n      (fruit) =\u003e fruit.value === selectedFruit\n    );\n    if (selectedOption) {\n      setSelectedFruit(selectedOption?.value);\n    }\n  };\n\n  return (\n    \u003c\u003e\n      \u003cdiv\u003e열거형에서 선택한 과일 : {selectedFruit}\u003c/div\u003e\n      \u003cselect\n        onChange={(e) =\u003e\n          onSelectFruit(e.target.value as FruitOptionsFromEnum[\"value\"])\n        }\n      \u003e\n        {fruitOptions.map((fruit) =\u003e (\n          \u003coption key={fruit.value} value={fruit.value}\u003e\n            {fruit.label}\n          \u003c/option\u003e\n        ))}\n      \u003c/select\u003e\n    \u003c/\u003e\n  );\n};\n\n/**\n* 예시 2: 객체 사용하기\n* 사용 시기: 코드 베이스의 일부가 아직 바닐라 js를 사용하는 경우\n* 장점: 복사하거나 'let' 및 'as const'가 아닌 경우 할당 가능\n  ts 및 js 파일 간에 사용 가능\n* 단점: enums보다 유형을 사용하기 어려울 수 있음, 'as const'조차도\n*/\nconst FruitsObject = {\n  APPLE: \"Apple\",\n  ORANGE: \"Orange\",\n  BANANA: \"Banana\",\n} as const;\n\nexport const FruitsFromObjectDropdown = () =\u003e {\n  type FruitOptionsFromObject = {\n    label: (typeof FruitsObject)[keyof typeof FruitsObject];\n    value: keyof typeof FruitsObject;\n  };\n\n  const fruitOptions = Object.entries(FruitsObject).map(\n    ([v, k]) =\u003e\n      ({\n        label: k,\n        value: v,\n      } as FruitOptionsFromObject)\n  );\n\n  const [selectedFruit, setSelectedFruit] = React.useState(\n    fruitOptions[0].value\n  );\n\n  const onSelectFruit = (selectedFruit: FruitOptionsFromObject[\"value\"]) =\u003e {\n    const selectedOption = fruitOptions.find(\n      (fruit) =\u003e fruit.value === selectedFruit\n    );\n    if (selectedOption) {\n      setSelectedFruit(selectedOption?.value);\n    }\n  };\n\n  return (\n    \u003c\u003e\n      \u003cdiv\u003e객체에서 선택한 과일 : {selectedFruit}\u003c/div\u003e\n      \u003cselect\n        onChange={(e) =\u003e\n          onSelectFruit(e.target.value as FruitOptionsFromObject[\"value\"])\n        }\n      \u003e\n        {fruitOptions.map((fruit) =\u003e (\n          \u003coption key={fruit.value} value={fruit.value}\u003e\n            {fruit.label}\n          \u003c/option\u003e\n        ))}\n      \u003c/select\u003e\n    \u003c/\u003e\n  );\n};\n\n/**\n* 예시 3: 문자열 유니언\n* 사용 시기: 백엔드에서 유형을 확장해야하거나 대안으로 enums를 대체해야할 때\n* 장점: 쉽게 확장 가능\n  ts 및 js 간에 재사용 가능\n  사용자 정의 로직에 대한 switch 케이스 사용이 쉬움\n* 단점: enums와 같이 할당할 수 없으며, 문자열은 순수한 리터럴임\n*/\ntype StatusStringUnion = \"saved\" | \"saving\" | \"standby\" | \"error\" | \"unknown\";\nexport const FormStatus = () =\u003e {\n  const [currentStatus, setCurrentStatus] =\n    React.useState\u003cStatusStringUnion\u003e(\"unknown\");\n\n  return (\n    \u003cStatusRow\u003e\n      상태: \u003cLabel\u003e{currentStatus}\u003c/Label\u003e\n      \u003cDot status={currentStatus} /\u003e\n    \u003c/StatusRow\u003e\n  );\n};\n\n//다른 파일에서는 ...\nconst StatusRow = styled.div`\n  display: flex;\n  justify-content: center;\n  align-content: center;\n`;\n\nconst Label = styled.div`\n  margin-left: 0.25rem;\n  font-size: 12pt;\n  font-weight: 600;\n`;\n\n//사용자 정의 StyledComponents 로직 사용 예시\n//enum 또는 문자열 유니언은 이러한 경우에 가장 적합합니다\nconst Dot = styled.div\u003c{ status: StatusStringUnion }\u003e`\n  display: flex;\n  justify-content: center;\n  align-content: start;\n  clip-path: circle(5px);\n  width: 1rem;\n  background: ${({ status }) =\u003e {\n    switch (status) {\n      case \"saved\":\n        return \"green\";\n      case \"saving\":\n        return \"yellow\";\n      case \"error\":\n        return \"red\";\n      case \"standby\":\n        return \"none\";\n      case \"unknown\":\n        return \"gray\";\n      default:\n        return \"gray\";\n    }\n  };\n  margin-left: 0.25rem;\n`;\n\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n내가 작업한 많은 코드에서, 유형은 일반적으로 변경할 수 없는 값을 나타내는 비-nullable로 기본 설정됩니다. 그러나 값은 때로 바뀔 수 있고, 앱의 내부 논리 구조가 복잡해지면 예기치 않은 null 또는 undefined 값이 발생하여 프로덕션 코드에서 유형 오류를 발생시키기 쉬워집니다. 이를 피하는 한 가지 방법은 다른 방향으로 기본값을 nullable 값으로 설정하는 것입니다. 기본적으로, 이 값이 어떤 상황에서 null 또는 undefined가 될 수 있는 경우(또는 확실하지 않은 경우), 선택 사항 유형으로 만드는 것입니다.\n\n## 이유\n\n- 백엔드와 프론트엔드가 강하게 결합되어 있지 않은 경우(즉, 풀스택 개발자가 아닌 경우), 두 계약 사이의 값 유형이 제대로 문서화되지 않을 수 있음\n- 데이터베이스가 커지고 복잡해지면 예상치 못한 값(예: null 및 undefined)이 부정적으로 발생할 확률이 높아집니다\n- 앱이 사용자 입력을 수락하는 경우, 프론트엔드와 백엔드의 유효성 검사 엣지 케이스가 데이터베이스에 이상한 값이 저장되도록 할 수 있음\n- 나중에 요구 사항이 변경되어 null/undefined 값을 허용하는 경우가 생길 수 있음\n- null/undefined이면 명시적으로 기본값을 설정할 수 있어, 문자열이 항상 \" \"와 같은 문자열이 되도록 보장할 수 있음\n- 입력 값에 일부 값을 필수로 만들면, 유효성 검사의 추가 계층을 추가하고 부정적인 값이 백엔드로 전송되지 않도록 보장할 수 있음\n\n## 예시\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n/**\n * @type firstName: Raw `f_n`\n * @type lastName: Raw `l_n`\n * @type canEditUsers: Raw `users`\n */\ntype Users = {\n  id: number;\n  firstName?: string; //Raw: f_n\n  lastName?: string; //Raw: l_n\n  canEditUsers?: boolean; //Raw: users\n};\n\n//만약 아래의 사용자(user)를 접근하려고 할 때 값 중 하나라도 null이 허용되지 않는\n//즉, 필수값이면 타입 오류를 발생시키고 렌더를 충돌시킬 수 있습니다.\n//이는 널 병합 연산자를 사용할 수 있게 하여 Typescript가\n//해당 사용법을 강제하는 것을 가능하게 합니다.\nconst UsersList = ({ users }: { users: Users[] }) =\u003e {\n  return (\n    \u003cdiv\u003e\n      {users.map((user) =\u003e (\n        \u003cdiv key={user.id}\u003e\n          \u003cdiv\u003e\n            Name: {user?.firstName} {user?.lastName}\n          \u003c/div\u003e\n          \u003cdiv\u003eCan edit users? {`${user?.canEditUsers}`}\u003c/div\u003e\n          \u003cbr /\u003e\n          \u003cbr /\u003e\n        \u003c/div\u003e\n      ))}\n    \u003c/div\u003e\n  );\n};\n\n# 팁 #4: 일반적으로 재사용되는 유형을 제네릭을 사용하여 유틸 파일에 저장하기\n\n코드 베이스가 커지면 앱 전반에서 유사한 유형을 재사용해야 할 수 있습니다. 가장 일반적으로 재사용되는 유형을 제네릭의 힘을 이용하여 더 재사용할 수 있게 할 수 있으며, 이는 기본 유형이 완벽하게 일치하지 않을 때도 유형이 여러 컨텍스트에서 재사용될 수 있음을 의미합니다. 이러한 접근 방식을 사용하면 재사용 가능한 유틸 함수가 Typescript의 모든 기능을 최대한 활용할 수 있음을 의미합니다.\n\n## 왜 이것을 하는가\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 수동으로 모든 사용법을 입력할 필요가 없다는 것을 의미합니다.\n- 한 곳에서 유형을 업데이트하는 것이 더 쉽습니다.\n- 재사용 가능하고 매우 복잡한 유형을 만들 수 있습니다.\n- 코드 베이스의 라이브러리에서 기초로 하는 유형을 만들 수 있습니다(예: Relay).\n- 해당 유형을 사용하는 구성 요소를 지저분하게 만들지 않고 찾기, 문서화, 사용하기가 더 쉽습니다.\n\n## 예시\n\n```js\n/** Example 1: 제네릭을 사용한 재사용 가능한 유형 */\n// `utils/reusableTypes.ts` 파일 내에서\nimport React from \"react\";\nimport { Disposable, UseMutationConfig } from \"react-relay\";\nimport { MutationParameters } from \"relay-runtime\";\n\n/**\n * @description 주어진 유형에서 값을 가져오는 유형\n * @example { fieldName: FormProps, value: ValueOf\u003cFormProps\u003e }\n */\nexport type ValueOf\u003cT\u003e = T[keyof T];\n\n/**\n * @description Relay 변경 사항으로부터 유형 만들기\n * @example type UserContextTypes = {\n *   createUser: MutationTypeOf\u003ccreateUserMutation\u003e\n * }\n */\nexport type MutationTypeOf\u003cT extends MutationParameters\u003e = (\n  config: UseMutationConfig\u003cT\u003e\n) =\u003e Disposable;\n\n//다른 파일에서 ...\nimport React from \"react\";\nimport { ValueOf } from \"../utils/reusableTypes\";\n\nenum Fruits {\n  APPLE = \"Apple\",\n  ORANGE = \"Orange\",\n  BANANA = \"Banana\",\n}\n\nexport const GenericFruitsFromEnumDropdown = () =\u003e {\n  const fruitOptions = Object.entries(Fruits).map(([value, label]) =\u003e ({\n    label: label,\n    value: value,\n  }));\n\n  const [selectedFruit, setSelectedFruit] = React.useState(\n    fruitOptions[0].value\n  );\n\n//거의 모든 다른 데이터 유형과 함께`ValueOf`의 제네릭 유형을 사용할 수 있습니다.\n//단, Fruits 열거형을 포함한다.\n  const onSelectFruit = (selectedFruit: ValueOf\u003cFruits\u003e) =\u003e {\n    const selectedOption = fruitOptions.find(\n      (fruit) =\u003e fruit.value === selectedFruit\n    );\n    if (selectedOption) {\n      setSelectedFruit(selectedOption?.value);\n    }\n  };\n\n  //ValueOf를 사용하면 열거형 값과의 비교를 수행할 수 있습니다.\n  console.log(selectedFruit === Fruits.APPLE);\n\n  return (\n    \u003c\u003e\n      \u003cdiv\u003e선택된 열거형 과일: {selectedFruit}\u003c/div\u003e\n      \u003cselect onChange={(e) =\u003e onSelectFruit(e.target.value)}\u003e\n        {fruitOptions.map((fruit) =\u003e (\n          \u003coption key={fruit.value} value={fruit.value}\u003e\n            {fruit.label}\n          \u003c/option\u003e\n        ))}\n      \u003c/select\u003e\n    \u003c/\u003e\n  );\n};\n```\n\n```js\n/** Example 2: 제네릭을 사용한 재사용 가능한 함수 */\n// `utils/reusableFunctions.ts` 파일 내에서\nimport React from \"react\";\n\n/**\n * @description 주어진 기본 값이 배열에서 중복되는지 여부를 확인합니다.\n * @example\n * const myNumberArray = [4, 5, 5, 1, 6, 3];\n * primitiveIsDuplicatedInArray(3, myNumberArray); //false\n * primitiveIsDuplicatedInArray(5, myNumberArray); //true\n *\n * const myStringArray = ['z', 'b', 'b', 'a', 'f', 'd'];\n * const isADuplicated = primitiveIsDuplicatedInArray(3, myStringArray); //3은 숫자이므로 TypeScript 오류가 발생합니다.\n */\nexport const primitiveIsDuplicatedInArray = \u003cT\u003e(givenValue: T, arr: T[]) =\u003e\n  arr.filter((value) =\u003e value === givenValue).length \u003e 1;\n\n//다른 파일에서 ...\nimport React from \"react\";\nimport { primitiveIsDuplicatedInArray } from \"../utils/reusableFunctions\";\n\nconst GenericFunctions = () =\u003e {\n  //`primitiveIsDuplicatedInArray`에서 제네릭 유형을 사용하면\n  //숫자, 문자열 및 다른 기본 유형을 가진 배열에서 중복 항목을 찾을 수 있습니다.\n  const myNumberArray = [4, 5, 5, 1, 6, 3];\n  const isThreeDuplicated = primitiveIsDuplicatedInArray(3, myNumberArray);\n  const isFiveDuplicated = primitiveIsDuplicatedInArray(5, myNumberArray);\n\n  const myStringArray = [\"z\", \"b\", \"b\", \"a\", \"f\", \"d\"];\n  const isBDuplicated = primitiveIsDuplicatedInArray(\"b\", myStringArray);\n  const isFDuplicated = primitiveIsDuplicatedInArray(\"f\", myStringArray);\n\n  return (\n    \u003cdiv\u003e\n      \u003cdiv\u003e내 숫자 배열: {`[${myNumberArray}]`}\u003c/div\u003e\n      \u003cdiv\u003e3이 중복되었나요? {`${isThreeDuplicated}`}\u003c/div\u003e\n      \u003cdiv\u003e5가 중복되었나요? {`${isFiveDuplicated}`}\u003c/div\u003e\n      \u003cbr /\u003e\n      \u003cbr /\u003e\n      \u003cdiv\u003e내 문자열 배열: {`[${myStringArray}]`}\u003c/div\u003e\n      \u003cdiv\u003eb가 중복되었나요? {`${isBDuplicated}`}\u003c/div\u003e\n      \u003cdiv\u003ef가 중복되었나요? {`${isFDuplicated}`}\u003c/div\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport default GenericFunctions;\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 팁 #5: 암시적 타입 및 구조 분해에 의존하기보다 함수 props를 명시적으로 입력하세요\n\n함수와 컴포넌트에 props를 전달하는 방식은 최종적으로 개인의 선택이지만, 명시적 props를 사용하는 것이 동료들이 이해하기 쉽고 유지 보수하기 쉽도록 코드를 만드는 데 도움이 된다고 주장합니다. 기능적인 측면에서 컴포넌트와 함수를 이해하기 쉽게 만들며, 암시적 타입의 한계에서 발생하는 실제 버그를 줄여줍니다.\n\n- 암시적 타입은 함수나 컴포넌트를 검사하는 요구가 있지만, 명시적 타입은 최신 편집기에서 코드 완성을 제공합니다\n- 여러 컴포넌트나 함수에 대한 재사용 가능한 타입을 만들 수 있으며 Partial 및 Omit과 같은 고급 타입을 사용할 수 있게 합니다\n- 여러 파일을 통해 props를 추적하는 것이 훨씬 쉽습니다 (특히 다중 하위 컴포넌트로 prop을 전달하는 경우)\n- 함수와 재사용 가능한 컴포넌트를 문서화하기가 훨씬 더 쉽습니다\n- props에 대한 암시적 타입은 함수로 전달된 props가 잘못된 순서로 전달되거나 prop이 생략될 때 버그를 발생시킵니다\n\n## 예시들\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n/** 예제 1: 컴포넌트에 속성(props) 전달하기 */\nimport React from \"react\";\n\ntype FormStatus = \"saved\" | \"saving\" | \"standby\" | \"error\" | \"unknown\";\n\ntype User = {\n  id: number;\n  firstName?: string;\n  lastName?: string;\n};\n\n/** 예제 A: 속성(props) 구조 분해하기 */\ntype DestructuringProps = {\n  users: User[];\n  formStatus: FormStatus;\n};\n\n// `props`를 그냥 전달하는 것은 특히 재사용되는 고도로 추상화된 컴포넌트에서 prop 추적을 매우 어렵게 만들 수 있습니다. 심지어 타입을 지정해도요\nconst Destructuring = (props: DestructuringProps) =\u003e {\n  // 이렇게 구조 분해할 때, 이 prop들은 모두 널이 아니라는 것을 주목하세요\n  const { users, formStatus } = props;\n\n  return (\n    \u003cdiv\u003e\n      \u003cdiv\u003e상태: {formStatus}\u003c/div\u003e\n      {users.map((user) =\u003e (\n        \u003cdiv key={user.id}\u003e\n          {user.firstName} {user.lastName}\n        \u003c/div\u003e\n      ))}\n    \u003c/div\u003e\n  );\n};\n\n/** 예제 B: 명시적인 속성(props) */\ntype ExplicitProps = {\n  users: User[];\n  formStatus: FormStatus;\n};\n\n// 속성을 명시적으로 전달하고 타입을 지정하는 것은 추적을 훨씬 간단하게 만듭니다\nconst Explicit = ({ users, formStatus }: ExplicitProps) =\u003e {\n  return (\n    \u003cdiv\u003e\n      \u003cdiv\u003e상태: {formStatus}\u003c/div\u003e\n      {users.map((user) =\u003e (\n        \u003cdiv key={user.id}\u003e\n          {user.firstName} {user.lastName}\n        \u003c/div\u003e\n      ))}\n    \u003c/div\u003e\n  );\n};\n\nconst DifferentPropTypes = () =\u003e {\n  const users = [\n    {\n      id: 1654,\n      firstName: \"Jose\",\n      lastName: \"Sanchez\",\n    },\n    {\n      id: 3297,\n      firstName: \"Bob\",\n      lastName: \"Richards\",\n    },\n    {\n      id: 4572,\n      firstName: \"Janet\",\n      lastName: \"Wong\",\n    },\n  ];\n\n  const formStatus = \"standby\" as FormStatus;\n\n  const props = {\n    users,\n    formStatus,\n  };\n\n// 여기서 `props`가 상위 레벨에서 스프레드 연산자를 통해 전달되었다고 상상해보세요.\n// 최상위 레벨까지 거슬러 올라가지 않고 그 당시의 props가 무엇인지 추적할 수 있을까요?\n  return (\n    \u003cdiv\u003e\n      \u003cDestructuring {...props} /\u003e\n      \u003cbr /\u003e\n      \u003cbr /\u003e\n      \u003cExplicit users={users} formStatus={formStatus} /\u003e\n      \u003cbr /\u003e\n      \u003cbr /\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport default DifferentPropTypes;\n```\n\n```js\n/** 예제 2: 함수에 속성(props) 전달하기 */\n\nimport React from \"react\";\n\n// 예제 A: 구조 분해는 사용 방법을 애매하게 만들 수 있습니다\ntype DestructuredProps = {\n  userName: string,\n  userNamesArray: string[],\n};\n\nexport const userNameIsDuplicatedDestructuredProps = (props: DestructuredProps) =\u003e {\n  // 이렇게 구조 분해할 때, 이 prop들은 모두 널이 아니라는 것을 주목하세요\n  const { userName, userNamesArray } = props;\n  return userNamesArray.filter((value) =\u003e value === userName).length \u003e 1;\n};\n\n// 예제 B: 암시적인 속성은 전달 순서에 의존하고 타입 완성도가 낮아서 버그를 유발할 수 있습니다\nexport const userNameIsDuplicatedImplicitProps = (userName: string, userNamesArray: string[]) =\u003e\n  userNamesArray.filter((value) =\u003e value === userName).length \u003e 1;\n\n// 예제 C: 명시적 속성은 속성 순서와 타입을 강제화합니다\ntype ExplicitProps = {\n  userName: string,\n  userNamesArray: string[],\n};\n\nexport const userNameIsDuplicatedExplicitProps = ({ userName, userNamesArray }: ExplicitProps) =\u003e\n  userNamesArray.filter((value) =\u003e value === userName).length \u003e 1;\n\n// 데이터\nexport const TypingFnProps = () =\u003e {\n  const users = [\n    {\n      id: 1654,\n      firstName: \"Jose\",\n      lastName: \"Sanchez\",\n    },\n    {\n      id: 3297,\n      firstName: \"Bob\",\n      lastName: \"Richards\",\n    },\n    {\n      id: 4572,\n      firstName: \"Janet\",\n      lastName: \"Wong\",\n    },\n    {\n      id: 8725,\n      firstName: \"Janet\",\n      lastName: \"Wong\",\n    },\n  ];\n\n  const userNamesArray = users.map(({ firstName, lastName }) =\u003e `${firstName} ${lastName}`);\n\n  const props = {\n    userNamesArray,\n    userName: \"Janet Wong\",\n  };\n\n  const isJanetDuplicatedDestructuredProps = userNameIsDuplicatedDestructuredProps(props);\n\n  const isJanetDuplicatedImplicitProps = userNameIsDuplicatedImplicitProps(\"Janet Wong\", userNamesArray);\n\n  const isJanetDuplicatedExplicitProps = userNameIsDuplicatedExplicitProps({\n    userName: \"Janet Wong\",\n    userNamesArray,\n  });\n\n  // 이것을 변경해가며 출력과 타입 체크 차이를 관찰해보세요\n  return (\n    \u003cdiv\u003e\n      \u003cdiv\u003eJanet이 중복되었나요? {`${isJanetDuplicatedDestructuredProps}`}\u003c/div\u003e\n      \u003cbr /\u003e\n      \u003cbr /\u003e\n      \u003cdiv\u003eJanet이 중복되었나요? {`${isJanetDuplicatedImplicitProps}`}\u003c/div\u003e\n      \u003cbr /\u003e\n      \u003cbr /\u003e\n      \u003cdiv\u003eJanet이 중복되었나요? {`${isJanetDuplicatedExplicitProps}`}\u003c/div\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport default TypingFnProps;\n```\n\n안내드린 내용 외에도 TypeScript로 유지보수 가능한 코드를 작성하는 더 많은 팁이 있지만, 이 중에서 저가 일반적으로 사용하는 팁들이었습니다.\n\n전체 소스 코드: [https://github.com/lbd1607/ts-blog](https://github.com/lbd1607/ts-blog)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n행복한 코딩하세요 :)\n","ogImage":{"url":"/assets/img/2024-07-07-5TypescriptPracticesforImprovedMaintainability_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-5TypescriptPracticesforImprovedMaintainability_0.png","tag":["Tech"],"readingTime":20},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-07-5TypescriptPracticesforImprovedMaintainability_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e아래의 권장 사항은 Typescript를 사용하여 더 유지보수가 용이한 코드를 만드는 데 도움이 되었던 몇 가지 조언에 대한 것입니다. 이 조언들은 새로운 구성 요소에서 Typescript를 사용하고 기존 페이지에서는 여전히 순수 JavaScript를 사용하는 프런트엔드 코드 베이스에서 특히 유용했습니다. 여러분에게도 조금 도움이 되기를 바랍니다.\u003c/p\u003e\n\u003cp\u003e다음 섹션에서는 제가 제공하는 제안의 요약과 각 포인트가 더 유지보수가 용이한 코드를 만드는 데 왜 도움이 되는지에 대한 몇 가지 핵심 요점에 대해 설명한 후, 이러한 조언을 실제로 어떻게 실천할 수 있는지를 보여주는 몇 가지 예제를 제시할 것입니다.\u003c/p\u003e\n\u003ch1\u003e팁 #1: 난해한 API 값 해결 및 타입의 힘을 활용하여 이름 변경하기\u003c/h1\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e가끔 우리가 작업하는 API는 매우 약어화된 또는 난해한 값 이름을 포함한 데이터 본문을 제공할 수 있습니다. 백엔드와 프론트엔드 사이의 분리 정도에 따라, 이는 코드가 어떤 작업을 수행하고 어떻게 상호 작용해야 하는지 이해하는 데 문제가 될 수 있습니다. 이 문제를 해결하기 위해 API 데이터를 새 객체로 해석하고 더 나은 명명 규칙으로 유형을 지정할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e왜 해야 하나요?\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e다른 사람들과 미래의 자신이 코드를 읽고 이해하기 쉽게 만듭니다.\u003c/li\u003e\n\u003cli\u003e사용 사례를 명확히 설명합니다 (특히 난해한 이름을 가진 부울 값의 경우).\u003c/li\u003e\n\u003cli\u003e코드와 API 설명서 간을 계속 왔다갔다해야 하거나 과도한 콘솔 로깅을 하지 않아도 됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e예시\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// API에서 수신된 데이터\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// `f_n`은 `firstName`이 됩니다.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// `l_n`은 `lastName`이 됩니다.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// `users`는 `canEditUsers`가 됩니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e rawUserData = [\n  {\n    \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1654\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003ef_n\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Jose\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003el_n\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Sanchez\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eusers\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  },\n  {\n    \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3297\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003ef_n\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Bob\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003el_n\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Richards\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eusers\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n  },\n  {\n    \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e4572\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003ef_n\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Janet\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003el_n\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Wong\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eusers\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  },\n];\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eUsersPage\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// 원시 데이터 값을 더 쉽게 사용할 수 있는 키로 해석합니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e resolvedUserData = rawUserData.\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003euserData\u003c/span\u003e) =\u003e\u003c/span\u003e ({\n    \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: userData.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003efirstName\u003c/span\u003e: userData.\u003cspan class=\"hljs-property\"\u003ef_n\u003c/span\u003e ?? \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003elastName\u003c/span\u003e: userData.\u003cspan class=\"hljs-property\"\u003el_n\u003c/span\u003e ?? \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003ecanEditUsers\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eBoolean\u003c/span\u003e(userData.\u003cspan class=\"hljs-property\"\u003eusers\u003c/span\u003e),\n  })) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUsers\u003c/span\u003e[];\n\n  \u003cspan class=\"hljs-comment\"\u003e// 해석된 데이터로 UsersList를 렌더링합니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eUsersList\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eusers\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{resolvedUserData}\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e;\n};\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUsersPage\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// 다른 파일에서...\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// API에서 원시 키 이름을 알려주는 JSDoc을 추가했음에 주목하세요.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// GraphQL 또는 Prisma와 같은 프론트엔드와 API 사이의 레이어가 있는 경우 특히 중요합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e/**\n * \u003cspan class=\"hljs-doctag\"\u003e@type\u003c/span\u003e firstName: Raw `f_n`\n * \u003cspan class=\"hljs-doctag\"\u003e@type\u003c/span\u003e lastName: Raw `l_n`\n * \u003cspan class=\"hljs-doctag\"\u003e@type\u003c/span\u003e canEditUsers: Raw `users`\n */\u003c/span\u003e\ntype \u003cspan class=\"hljs-title class_\"\u003eUsers\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: number;\n  \u003cspan class=\"hljs-attr\"\u003efirstName\u003c/span\u003e: string; \u003cspan class=\"hljs-comment\"\u003e// 원시: f_n\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003elastName\u003c/span\u003e: string; \u003cspan class=\"hljs-comment\"\u003e// 원시: l_n\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ecanEditUsers\u003c/span\u003e: boolean; \u003cspan class=\"hljs-comment\"\u003e// 원시: users\u003c/span\u003e\n};\n\n\u003cspan class=\"hljs-comment\"\u003e// 원시 API 키와 비교했을 때 가독성이 향상되는 점에 주목하세요.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// UsersList 구성 요소가 부모로부터 추상화되고 입력을 사용하여 사용자 데이터를 업데이트하기 시작할 때\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 이 사항은 점점 더 중요해집니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eUsersList\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e{ users }: { users: Users[] }\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      {users.map((user) =\u003e (\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{user.id}\u003c/span\u003e\u003e\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n            이름: {user.firstName} {user.lastName}\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e사용자 수정 가능? {`${user.canEditUsers}`}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebr\u003c/span\u003e /\u003e\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebr\u003c/span\u003e /\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      ))}\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e팁 #2: 모든 하드코딩된 문자열 값을 enum, object 또는 string 리터럴 유니온으로 대체하세요 (사용 사례에 따라 다름)\u003c/h1\u003e\n\u003cp\u003e기능을 처음 구현할 때는 단순한 로직을 수행하기 위해 문자열 값과 같은 기본 유형을 하드코딩하는 것이 더 쉬울 수 있습니다.\n그러나 코드베이스가 커지고 여러 컴포넌트로 분할되면, 이는 많은 중복을 야기하고 유지 관리의 어려움을 증가시킬 수 있습니다.\n이 문제를 해결하기 위해 이러한 분산된 하드코딩된 문자열을 재사용 가능한 enum, object 또는 유니언으로 통합할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e왜 이렇게 해야 하나요?\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e코드 완성 기능을 사용하여 유형을 사용할 수 있게 해서 더 많이 추측할 필요가 없도록 합니다\u003c/li\u003e\n\u003cli\u003e구성 요소를 더 재사용 가능하게 만듭니다\u003c/li\u003e\n\u003cli\u003e리듀서와 컨텍스트 또는 상태 관리자와 유형을 사용하는 것을 더 간단하게 만듭니다\u003c/li\u003e\n\u003cli\u003e서로 다른 함수와 구성 요소 사이에서 상태를 전달하는 것을 간단하게 만듭니다\u003c/li\u003e\n\u003cli\u003e잘못된 입력 및 유형을 검출하는 데 도움이 됩니다\u003c/li\u003e\n\u003cli\u003e기본값으로 사용할 \"unknown\"과 같은 예외 유형을 추가할 수 있도록 합니다\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e예시\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/**\n* 예시 1: 열거형\n* 사용 시기:이 것을 사용할 모든 파일이 ts인 경우\n* 장점: 변경할 수 없는 상수\n  더 나은 형식 안전성, 유형으로 더 쉽게 작업할 수 있음\n  사용자 정의 로직에 대한 switch 케이스 사용이 쉬움\n* 단점: 바닐라 js와 사용할 수 없음\n*/\u003c/span\u003e\nenum \u003cspan class=\"hljs-title class_\"\u003eFruits\u003c/span\u003e {\n  \u003cspan class=\"hljs-variable constant_\"\u003eAPPLE\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"Apple\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-variable constant_\"\u003eORANGE\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"Orange\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-variable constant_\"\u003eBANANA\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"Banana\"\u003c/span\u003e,\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eFruitsFromEnumDropdown\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  type \u003cspan class=\"hljs-title class_\"\u003eFruitOptionsFromEnum\u003c/span\u003e = {\n    \u003cspan class=\"hljs-attr\"\u003elabel\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eFruits\u003c/span\u003e;\n    \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: keyof \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFruits\u003c/span\u003e;\n  };\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fruitOptions = \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eentries\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eFruits\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(\n    \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e[value, label]\u003c/span\u003e) =\u003e\u003c/span\u003e\n      ({\n        \u003cspan class=\"hljs-attr\"\u003elabel\u003c/span\u003e: label,\n        \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: value,\n      } \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFruitOptionsFromEnum\u003c/span\u003e)\n  );\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [selectedFruit, setSelectedFruit] = \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\n    fruitOptions[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e].\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e\n  );\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eonSelectFruit\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003eselectedFruit: FruitOptionsFromEnum[\u003cspan class=\"hljs-string\"\u003e\"value\"\u003c/span\u003e]\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e selectedOption = fruitOptions.\u003cspan class=\"hljs-title function_\"\u003efind\u003c/span\u003e(\n      \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003efruit\u003c/span\u003e) =\u003e\u003c/span\u003e fruit.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e === selectedFruit\n    );\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (selectedOption) {\n      \u003cspan class=\"hljs-title function_\"\u003esetSelectedFruit\u003c/span\u003e(selectedOption?.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e);\n    }\n  };\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e열거형에서 선택한 과일 : {selectedFruit}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eselect\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eonChange\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{(e)\u003c/span\u003e =\u003e\u003c/span\u003e\n          onSelectFruit(e.target.value as FruitOptionsFromEnum[\"value\"])\n        }\n      \u003e\n        {fruitOptions.map((fruit) =\u003e (\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eoption\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{fruit.value}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{fruit.value}\u003c/span\u003e\u003e\u003c/span\u003e\n            {fruit.label}\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eoption\u003c/span\u003e\u003e\u003c/span\u003e\n        ))}\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eselect\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n};\n\n\u003cspan class=\"hljs-comment\"\u003e/**\n* 예시 2: 객체 사용하기\n* 사용 시기: 코드 베이스의 일부가 아직 바닐라 js를 사용하는 경우\n* 장점: 복사하거나 'let' 및 'as const'가 아닌 경우 할당 가능\n  ts 및 js 파일 간에 사용 가능\n* 단점: enums보다 유형을 사용하기 어려울 수 있음, 'as const'조차도\n*/\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFruitsObject\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eAPPLE\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Apple\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eORANGE\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Orange\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eBANANA\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Banana\"\u003c/span\u003e,\n} \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eFruitsFromObjectDropdown\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  type \u003cspan class=\"hljs-title class_\"\u003eFruitOptionsFromObject\u003c/span\u003e = {\n    \u003cspan class=\"hljs-attr\"\u003elabel\u003c/span\u003e: (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFruitsObject\u003c/span\u003e)[keyof \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFruitsObject\u003c/span\u003e];\n    \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: keyof \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFruitsObject\u003c/span\u003e;\n  };\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fruitOptions = \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eentries\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eFruitsObject\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(\n    \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e[v, k]\u003c/span\u003e) =\u003e\u003c/span\u003e\n      ({\n        \u003cspan class=\"hljs-attr\"\u003elabel\u003c/span\u003e: k,\n        \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: v,\n      } \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFruitOptionsFromObject\u003c/span\u003e)\n  );\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [selectedFruit, setSelectedFruit] = \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\n    fruitOptions[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e].\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e\n  );\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eonSelectFruit\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003eselectedFruit: FruitOptionsFromObject[\u003cspan class=\"hljs-string\"\u003e\"value\"\u003c/span\u003e]\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e selectedOption = fruitOptions.\u003cspan class=\"hljs-title function_\"\u003efind\u003c/span\u003e(\n      \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003efruit\u003c/span\u003e) =\u003e\u003c/span\u003e fruit.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e === selectedFruit\n    );\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (selectedOption) {\n      \u003cspan class=\"hljs-title function_\"\u003esetSelectedFruit\u003c/span\u003e(selectedOption?.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e);\n    }\n  };\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e객체에서 선택한 과일 : {selectedFruit}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eselect\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eonChange\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{(e)\u003c/span\u003e =\u003e\u003c/span\u003e\n          onSelectFruit(e.target.value as FruitOptionsFromObject[\"value\"])\n        }\n      \u003e\n        {fruitOptions.map((fruit) =\u003e (\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eoption\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{fruit.value}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{fruit.value}\u003c/span\u003e\u003e\u003c/span\u003e\n            {fruit.label}\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eoption\u003c/span\u003e\u003e\u003c/span\u003e\n        ))}\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eselect\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n};\n\n\u003cspan class=\"hljs-comment\"\u003e/**\n* 예시 3: 문자열 유니언\n* 사용 시기: 백엔드에서 유형을 확장해야하거나 대안으로 enums를 대체해야할 때\n* 장점: 쉽게 확장 가능\n  ts 및 js 간에 재사용 가능\n  사용자 정의 로직에 대한 switch 케이스 사용이 쉬움\n* 단점: enums와 같이 할당할 수 없으며, 문자열은 순수한 리터럴임\n*/\u003c/span\u003e\ntype \u003cspan class=\"hljs-title class_\"\u003eStatusStringUnion\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"saved\"\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e\"saving\"\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e\"standby\"\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e\"error\"\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e\"unknown\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eFormStatus\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [currentStatus, setCurrentStatus] =\n    \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003euseState\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eStatusStringUnion\u003c/span\u003e\u003e(\u003cspan class=\"hljs-string\"\u003e\"unknown\"\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eStatusRow\u003c/span\u003e\u003e\u003c/span\u003e\n      상태: \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eLabel\u003c/span\u003e\u003e\u003c/span\u003e{currentStatus}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eLabel\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eDot\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estatus\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{currentStatus}\u003c/span\u003e /\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eStatusRow\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n};\n\n\u003cspan class=\"hljs-comment\"\u003e//다른 파일에서는 ...\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eStatusRow\u003c/span\u003e = styled.\u003cspan class=\"hljs-property\"\u003ediv\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e`\n  display: flex;\n  justify-content: center;\n  align-content: center;\n`\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLabel\u003c/span\u003e = styled.\u003cspan class=\"hljs-property\"\u003ediv\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e`\n  margin-left: 0.25rem;\n  font-size: 12pt;\n  font-weight: 600;\n`\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e//사용자 정의 StyledComponents 로직 사용 예시\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e//enum 또는 문자열 유니언은 이러한 경우에 가장 적합합니다\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDot\u003c/span\u003e = styled.\u003cspan class=\"hljs-property\"\u003ediv\u003c/span\u003e\u0026#x3C;{ \u003cspan class=\"hljs-attr\"\u003estatus\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eStatusStringUnion\u003c/span\u003e }\u003e\u003cspan class=\"hljs-string\"\u003e`\n  display: flex;\n  justify-content: center;\n  align-content: start;\n  clip-path: circle(5px);\n  width: 1rem;\n  background: \u003cspan class=\"hljs-subst\"\u003e${({ status }) =\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (status) {\n      \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"saved\"\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"green\"\u003c/span\u003e;\n      \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"saving\"\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"yellow\"\u003c/span\u003e;\n      \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"error\"\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"red\"\u003c/span\u003e;\n      \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"standby\"\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"none\"\u003c/span\u003e;\n      \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"unknown\"\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"gray\"\u003c/span\u003e;\n      \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"gray\"\u003c/span\u003e;\n    }\n  };\n  margin-left: \u003cspan class=\"hljs-number\"\u003e0.\u003c/span\u003e25rem;\n\u003cspan class=\"hljs-string\"\u003e`;\n\n\n\n\u0026#x3C;!-- TIL 수평 --\u003e\n\u0026#x3C;ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u0026#x3C;/ins\u003e\n\u0026#x3C;script\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u0026#x3C;/script\u003e\n\n내가 작업한 많은 코드에서, 유형은 일반적으로 변경할 수 없는 값을 나타내는 비-nullable로 기본 설정됩니다. 그러나 값은 때로 바뀔 수 있고, 앱의 내부 논리 구조가 복잡해지면 예기치 않은 null 또는 undefined 값이 발생하여 프로덕션 코드에서 유형 오류를 발생시키기 쉬워집니다. 이를 피하는 한 가지 방법은 다른 방향으로 기본값을 nullable 값으로 설정하는 것입니다. 기본적으로, 이 값이 어떤 상황에서 null 또는 undefined가 될 수 있는 경우(또는 확실하지 않은 경우), 선택 사항 유형으로 만드는 것입니다.\n\n## 이유\n\n- 백엔드와 프론트엔드가 강하게 결합되어 있지 않은 경우(즉, 풀스택 개발자가 아닌 경우), 두 계약 사이의 값 유형이 제대로 문서화되지 않을 수 있음\n- 데이터베이스가 커지고 복잡해지면 예상치 못한 값(예: null 및 undefined)이 부정적으로 발생할 확률이 높아집니다\n- 앱이 사용자 입력을 수락하는 경우, 프론트엔드와 백엔드의 유효성 검사 엣지 케이스가 데이터베이스에 이상한 값이 저장되도록 할 수 있음\n- 나중에 요구 사항이 변경되어 null/undefined 값을 허용하는 경우가 생길 수 있음\n- null/undefined이면 명시적으로 기본값을 설정할 수 있어, 문자열이 항상 \" \"와 같은 문자열이 되도록 보장할 수 있음\n- 입력 값에 일부 값을 필수로 만들면, 유효성 검사의 추가 계층을 추가하고 부정적인 값이 백엔드로 전송되지 않도록 보장할 수 있음\n\n## 예시\n\n\u0026#x3C;!-- TIL 수평 --\u003e\n\u0026#x3C;ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u0026#x3C;/ins\u003e\n\u0026#x3C;script\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u0026#x3C;/script\u003e\n\n/**\n * @type firstName: Raw `\u003c/span\u003ef_n\u003cspan class=\"hljs-string\"\u003e`\n * @type lastName: Raw `\u003c/span\u003el_n\u003cspan class=\"hljs-string\"\u003e`\n * @type canEditUsers: Raw `\u003c/span\u003eusers\u003cspan class=\"hljs-string\"\u003e`\n */\ntype Users = {\n  id: number;\n  firstName?: string; //Raw: f_n\n  lastName?: string; //Raw: l_n\n  canEditUsers?: boolean; //Raw: users\n};\n\n//만약 아래의 사용자(user)를 접근하려고 할 때 값 중 하나라도 null이 허용되지 않는\n//즉, 필수값이면 타입 오류를 발생시키고 렌더를 충돌시킬 수 있습니다.\n//이는 널 병합 연산자를 사용할 수 있게 하여 Typescript가\n//해당 사용법을 강제하는 것을 가능하게 합니다.\nconst UsersList = ({ users }: { users: Users[] }) =\u003e {\n  return (\n    \u0026#x3C;div\u003e\n      {users.map((user) =\u003e (\n        \u0026#x3C;div key={user.id}\u003e\n          \u0026#x3C;div\u003e\n            Name: {user?.firstName} {user?.lastName}\n          \u0026#x3C;/div\u003e\n          \u0026#x3C;div\u003eCan edit users? {`\u003c/span\u003e${user?.canEditUsers}\u003cspan class=\"hljs-string\"\u003e`}\u0026#x3C;/div\u003e\n          \u0026#x3C;br /\u003e\n          \u0026#x3C;br /\u003e\n        \u0026#x3C;/div\u003e\n      ))}\n    \u0026#x3C;/div\u003e\n  );\n};\n\n# 팁 #4: 일반적으로 재사용되는 유형을 제네릭을 사용하여 유틸 파일에 저장하기\n\n코드 베이스가 커지면 앱 전반에서 유사한 유형을 재사용해야 할 수 있습니다. 가장 일반적으로 재사용되는 유형을 제네릭의 힘을 이용하여 더 재사용할 수 있게 할 수 있으며, 이는 기본 유형이 완벽하게 일치하지 않을 때도 유형이 여러 컨텍스트에서 재사용될 수 있음을 의미합니다. 이러한 접근 방식을 사용하면 재사용 가능한 유틸 함수가 Typescript의 모든 기능을 최대한 활용할 수 있음을 의미합니다.\n\n## 왜 이것을 하는가\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e수동으로 모든 사용법을 입력할 필요가 없다는 것을 의미합니다.\u003c/li\u003e\n\u003cli\u003e한 곳에서 유형을 업데이트하는 것이 더 쉽습니다.\u003c/li\u003e\n\u003cli\u003e재사용 가능하고 매우 복잡한 유형을 만들 수 있습니다.\u003c/li\u003e\n\u003cli\u003e코드 베이스의 라이브러리에서 기초로 하는 유형을 만들 수 있습니다(예: Relay).\u003c/li\u003e\n\u003cli\u003e해당 유형을 사용하는 구성 요소를 지저분하게 만들지 않고 찾기, 문서화, 사용하기가 더 쉽습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e예시\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/** Example 1: 제네릭을 사용한 재사용 가능한 유형 */\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// `utils/reusableTypes.ts` 파일 내에서\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eDisposable\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eUseMutationConfig\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react-relay\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eMutationParameters\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"relay-runtime\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e/**\n * \u003cspan class=\"hljs-doctag\"\u003e@description\u003c/span\u003e 주어진 유형에서 값을 가져오는 유형\n * \u003cspan class=\"hljs-doctag\"\u003e@example\u003c/span\u003e {\u003cspan class=\"hljs-type\"\u003e fieldName: FormProps, value: ValueOf\u0026#x3C;FormProps\u003e \u003c/span\u003e}\n */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e type \u003cspan class=\"hljs-title class_\"\u003eValueOf\u003c/span\u003e\u0026#x3C;T\u003e = T[keyof T];\n\n\u003cspan class=\"hljs-comment\"\u003e/**\n * \u003cspan class=\"hljs-doctag\"\u003e@description\u003c/span\u003e Relay 변경 사항으로부터 유형 만들기\n * \u003cspan class=\"hljs-doctag\"\u003e@example\u003c/span\u003e type UserContextTypes = {\n *   createUser: MutationTypeOf\u0026#x3C;createUserMutation\u003e\n * }\n */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e type \u003cspan class=\"hljs-title class_\"\u003eMutationTypeOf\u003c/span\u003e\u0026#x3C;T \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMutationParameters\u003c/span\u003e\u003e = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e\n  config: UseMutationConfig\u0026#x3C;T\u003e\n\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDisposable\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e//다른 파일에서 ...\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eValueOf\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"../utils/reusableTypes\"\u003c/span\u003e;\n\nenum \u003cspan class=\"hljs-title class_\"\u003eFruits\u003c/span\u003e {\n  \u003cspan class=\"hljs-variable constant_\"\u003eAPPLE\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"Apple\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-variable constant_\"\u003eORANGE\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"Orange\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-variable constant_\"\u003eBANANA\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"Banana\"\u003c/span\u003e,\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eGenericFruitsFromEnumDropdown\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fruitOptions = \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eentries\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eFruits\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e[value, label]\u003c/span\u003e) =\u003e\u003c/span\u003e ({\n    \u003cspan class=\"hljs-attr\"\u003elabel\u003c/span\u003e: label,\n    \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: value,\n  }));\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [selectedFruit, setSelectedFruit] = \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\n    fruitOptions[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e].\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e\n  );\n\n\u003cspan class=\"hljs-comment\"\u003e//거의 모든 다른 데이터 유형과 함께`ValueOf`의 제네릭 유형을 사용할 수 있습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e//단, Fruits 열거형을 포함한다.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eonSelectFruit\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003eselectedFruit: ValueOf\u0026#x3C;Fruits\u003e\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e selectedOption = fruitOptions.\u003cspan class=\"hljs-title function_\"\u003efind\u003c/span\u003e(\n      \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003efruit\u003c/span\u003e) =\u003e\u003c/span\u003e fruit.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e === selectedFruit\n    );\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (selectedOption) {\n      \u003cspan class=\"hljs-title function_\"\u003esetSelectedFruit\u003c/span\u003e(selectedOption?.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e);\n    }\n  };\n\n  \u003cspan class=\"hljs-comment\"\u003e//ValueOf를 사용하면 열거형 값과의 비교를 수행할 수 있습니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(selectedFruit === \u003cspan class=\"hljs-title class_\"\u003eFruits\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eAPPLE\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e선택된 열거형 과일: {selectedFruit}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eselect\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonChange\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{(e)\u003c/span\u003e =\u003e\u003c/span\u003e onSelectFruit(e.target.value)}\u003e\n        {fruitOptions.map((fruit) =\u003e (\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eoption\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{fruit.value}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{fruit.value}\u003c/span\u003e\u003e\u003c/span\u003e\n            {fruit.label}\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eoption\u003c/span\u003e\u003e\u003c/span\u003e\n        ))}\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eselect\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/** Example 2: 제네릭을 사용한 재사용 가능한 함수 */\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// `utils/reusableFunctions.ts` 파일 내에서\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e/**\n * \u003cspan class=\"hljs-doctag\"\u003e@description\u003c/span\u003e 주어진 기본 값이 배열에서 중복되는지 여부를 확인합니다.\n * \u003cspan class=\"hljs-doctag\"\u003e@example\u003c/span\u003e\n * const myNumberArray = [4, 5, 5, 1, 6, 3];\n * primitiveIsDuplicatedInArray(3, myNumberArray); //false\n * primitiveIsDuplicatedInArray(5, myNumberArray); //true\n *\n * const myStringArray = ['z', 'b', 'b', 'a', 'f', 'd'];\n * const isADuplicated = primitiveIsDuplicatedInArray(3, myStringArray); //3은 숫자이므로 TypeScript 오류가 발생합니다.\n */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e primitiveIsDuplicatedInArray = \u0026#x3C;T\u003e\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003egivenValue: T, arr: T[]\u003c/span\u003e) =\u003e\u003c/span\u003e\n  arr.\u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003evalue\u003c/span\u003e) =\u003e\u003c/span\u003e value === givenValue).\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e \u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e//다른 파일에서 ...\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { primitiveIsDuplicatedInArray } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"../utils/reusableFunctions\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eGenericFunctions\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e//`primitiveIsDuplicatedInArray`에서 제네릭 유형을 사용하면\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e//숫자, 문자열 및 다른 기본 유형을 가진 배열에서 중복 항목을 찾을 수 있습니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e myNumberArray = [\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e];\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isThreeDuplicated = \u003cspan class=\"hljs-title function_\"\u003eprimitiveIsDuplicatedInArray\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, myNumberArray);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isFiveDuplicated = \u003cspan class=\"hljs-title function_\"\u003eprimitiveIsDuplicatedInArray\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, myNumberArray);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e myStringArray = [\u003cspan class=\"hljs-string\"\u003e\"z\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"b\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"b\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"a\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"f\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"d\"\u003c/span\u003e];\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isBDuplicated = \u003cspan class=\"hljs-title function_\"\u003eprimitiveIsDuplicatedInArray\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"b\"\u003c/span\u003e, myStringArray);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isFDuplicated = \u003cspan class=\"hljs-title function_\"\u003eprimitiveIsDuplicatedInArray\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"f\"\u003c/span\u003e, myStringArray);\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e내 숫자 배열: {`[${myNumberArray}]`}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e3이 중복되었나요? {`${isThreeDuplicated}`}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e5가 중복되었나요? {`${isFiveDuplicated}`}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebr\u003c/span\u003e /\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebr\u003c/span\u003e /\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e내 문자열 배열: {`[${myStringArray}]`}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003eb가 중복되었나요? {`${isBDuplicated}`}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003ef가 중복되었나요? {`${isFDuplicated}`}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n};\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eGenericFunctions\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e팁 #5: 암시적 타입 및 구조 분해에 의존하기보다 함수 props를 명시적으로 입력하세요\u003c/h1\u003e\n\u003cp\u003e함수와 컴포넌트에 props를 전달하는 방식은 최종적으로 개인의 선택이지만, 명시적 props를 사용하는 것이 동료들이 이해하기 쉽고 유지 보수하기 쉽도록 코드를 만드는 데 도움이 된다고 주장합니다. 기능적인 측면에서 컴포넌트와 함수를 이해하기 쉽게 만들며, 암시적 타입의 한계에서 발생하는 실제 버그를 줄여줍니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e암시적 타입은 함수나 컴포넌트를 검사하는 요구가 있지만, 명시적 타입은 최신 편집기에서 코드 완성을 제공합니다\u003c/li\u003e\n\u003cli\u003e여러 컴포넌트나 함수에 대한 재사용 가능한 타입을 만들 수 있으며 Partial 및 Omit과 같은 고급 타입을 사용할 수 있게 합니다\u003c/li\u003e\n\u003cli\u003e여러 파일을 통해 props를 추적하는 것이 훨씬 쉽습니다 (특히 다중 하위 컴포넌트로 prop을 전달하는 경우)\u003c/li\u003e\n\u003cli\u003e함수와 재사용 가능한 컴포넌트를 문서화하기가 훨씬 더 쉽습니다\u003c/li\u003e\n\u003cli\u003eprops에 대한 암시적 타입은 함수로 전달된 props가 잘못된 순서로 전달되거나 prop이 생략될 때 버그를 발생시킵니다\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e예시들\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/** 예제 1: 컴포넌트에 속성(props) 전달하기 */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react\"\u003c/span\u003e;\n\ntype \u003cspan class=\"hljs-title class_\"\u003eFormStatus\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"saved\"\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e\"saving\"\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e\"standby\"\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e\"error\"\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e\"unknown\"\u003c/span\u003e;\n\ntype \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: number;\n  firstName?: string;\n  lastName?: string;\n};\n\n\u003cspan class=\"hljs-comment\"\u003e/** 예제 A: 속성(props) 구조 분해하기 */\u003c/span\u003e\ntype \u003cspan class=\"hljs-title class_\"\u003eDestructuringProps\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eusers\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e[];\n  \u003cspan class=\"hljs-attr\"\u003eformStatus\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eFormStatus\u003c/span\u003e;\n};\n\n\u003cspan class=\"hljs-comment\"\u003e// `props`를 그냥 전달하는 것은 특히 재사용되는 고도로 추상화된 컴포넌트에서 prop 추적을 매우 어렵게 만들 수 있습니다. 심지어 타입을 지정해도요\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eDestructuring\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003eprops: DestructuringProps\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// 이렇게 구조 분해할 때, 이 prop들은 모두 널이 아니라는 것을 주목하세요\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { users, formStatus } = props;\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e상태: {formStatus}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      {users.map((user) =\u003e (\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{user.id}\u003c/span\u003e\u003e\u003c/span\u003e\n          {user.firstName} {user.lastName}\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      ))}\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n};\n\n\u003cspan class=\"hljs-comment\"\u003e/** 예제 B: 명시적인 속성(props) */\u003c/span\u003e\ntype \u003cspan class=\"hljs-title class_\"\u003eExplicitProps\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eusers\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e[];\n  \u003cspan class=\"hljs-attr\"\u003eformStatus\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eFormStatus\u003c/span\u003e;\n};\n\n\u003cspan class=\"hljs-comment\"\u003e// 속성을 명시적으로 전달하고 타입을 지정하는 것은 추적을 훨씬 간단하게 만듭니다\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eExplicit\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e{ users, formStatus }: ExplicitProps\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e상태: {formStatus}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      {users.map((user) =\u003e (\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{user.id}\u003c/span\u003e\u003e\u003c/span\u003e\n          {user.firstName} {user.lastName}\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      ))}\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n};\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eDifferentPropTypes\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e users = [\n    {\n      \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1654\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003efirstName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Jose\"\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003elastName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Sanchez\"\u003c/span\u003e,\n    },\n    {\n      \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3297\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003efirstName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Bob\"\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003elastName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Richards\"\u003c/span\u003e,\n    },\n    {\n      \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e4572\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003efirstName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Janet\"\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003elastName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Wong\"\u003c/span\u003e,\n    },\n  ];\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e formStatus = \u003cspan class=\"hljs-string\"\u003e\"standby\"\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFormStatus\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e props = {\n    users,\n    formStatus,\n  };\n\n\u003cspan class=\"hljs-comment\"\u003e// 여기서 `props`가 상위 레벨에서 스프레드 연산자를 통해 전달되었다고 상상해보세요.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 최상위 레벨까지 거슬러 올라가지 않고 그 당시의 props가 무엇인지 추적할 수 있을까요?\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eDestructuring\u003c/span\u003e {\u003cspan class=\"hljs-attr\"\u003e...props\u003c/span\u003e} /\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebr\u003c/span\u003e /\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebr\u003c/span\u003e /\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eExplicit\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eusers\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{users}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eformStatus\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{formStatus}\u003c/span\u003e /\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebr\u003c/span\u003e /\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebr\u003c/span\u003e /\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n};\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDifferentPropTypes\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/** 예제 2: 함수에 속성(props) 전달하기 */\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// 예제 A: 구조 분해는 사용 방법을 애매하게 만들 수 있습니다\u003c/span\u003e\ntype \u003cspan class=\"hljs-title class_\"\u003eDestructuredProps\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003euserName\u003c/span\u003e: string,\n  \u003cspan class=\"hljs-attr\"\u003euserNamesArray\u003c/span\u003e: string[],\n};\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003euserNameIsDuplicatedDestructuredProps\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003eprops: DestructuredProps\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// 이렇게 구조 분해할 때, 이 prop들은 모두 널이 아니라는 것을 주목하세요\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { userName, userNamesArray } = props;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e userNamesArray.\u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003evalue\u003c/span\u003e) =\u003e\u003c/span\u003e value === userName).\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e \u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n};\n\n\u003cspan class=\"hljs-comment\"\u003e// 예제 B: 암시적인 속성은 전달 순서에 의존하고 타입 완성도가 낮아서 버그를 유발할 수 있습니다\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003euserNameIsDuplicatedImplicitProps\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003euserName: string, userNamesArray: string[]\u003c/span\u003e) =\u003e\n  userNamesArray.\u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003evalue\u003c/span\u003e) =\u003e\u003c/span\u003e value === userName).\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e \u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// 예제 C: 명시적 속성은 속성 순서와 타입을 강제화합니다\u003c/span\u003e\ntype \u003cspan class=\"hljs-title class_\"\u003eExplicitProps\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003euserName\u003c/span\u003e: string,\n  \u003cspan class=\"hljs-attr\"\u003euserNamesArray\u003c/span\u003e: string[],\n};\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003euserNameIsDuplicatedExplicitProps\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e{ userName, userNamesArray }: ExplicitProps\u003c/span\u003e) =\u003e\n  userNamesArray.\u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003evalue\u003c/span\u003e) =\u003e\u003c/span\u003e value === userName).\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e \u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// 데이터\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eTypingFnProps\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e users = [\n    {\n      \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1654\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003efirstName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Jose\"\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003elastName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Sanchez\"\u003c/span\u003e,\n    },\n    {\n      \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3297\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003efirstName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Bob\"\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003elastName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Richards\"\u003c/span\u003e,\n    },\n    {\n      \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e4572\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003efirstName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Janet\"\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003elastName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Wong\"\u003c/span\u003e,\n    },\n    {\n      \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e8725\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003efirstName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Janet\"\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003elastName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Wong\"\u003c/span\u003e,\n    },\n  ];\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e userNamesArray = users.\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e{ firstName, lastName }\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${firstName}\u003c/span\u003e \u003cspan class=\"hljs-subst\"\u003e${lastName}\u003c/span\u003e`\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e props = {\n    userNamesArray,\n    \u003cspan class=\"hljs-attr\"\u003euserName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Janet Wong\"\u003c/span\u003e,\n  };\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isJanetDuplicatedDestructuredProps = \u003cspan class=\"hljs-title function_\"\u003euserNameIsDuplicatedDestructuredProps\u003c/span\u003e(props);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isJanetDuplicatedImplicitProps = \u003cspan class=\"hljs-title function_\"\u003euserNameIsDuplicatedImplicitProps\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Janet Wong\"\u003c/span\u003e, userNamesArray);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isJanetDuplicatedExplicitProps = \u003cspan class=\"hljs-title function_\"\u003euserNameIsDuplicatedExplicitProps\u003c/span\u003e({\n    \u003cspan class=\"hljs-attr\"\u003euserName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Janet Wong\"\u003c/span\u003e,\n    userNamesArray,\n  });\n\n  \u003cspan class=\"hljs-comment\"\u003e// 이것을 변경해가며 출력과 타입 체크 차이를 관찰해보세요\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003eJanet이 중복되었나요? {`${isJanetDuplicatedDestructuredProps}`}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebr\u003c/span\u003e /\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebr\u003c/span\u003e /\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003eJanet이 중복되었나요? {`${isJanetDuplicatedImplicitProps}`}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebr\u003c/span\u003e /\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebr\u003c/span\u003e /\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003eJanet이 중복되었나요? {`${isJanetDuplicatedExplicitProps}`}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n};\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTypingFnProps\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e안내드린 내용 외에도 TypeScript로 유지보수 가능한 코드를 작성하는 더 많은 팁이 있지만, 이 중에서 저가 일반적으로 사용하는 팁들이었습니다.\u003c/p\u003e\n\u003cp\u003e전체 소스 코드: \u003ca href=\"https://github.com/lbd1607/ts-blog\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/lbd1607/ts-blog\u003c/a\u003e\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e행복한 코딩하세요 :)\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-07-5TypescriptPracticesforImprovedMaintainability"},"buildId":"jKAIrnIuHBv4ZHjiQbX6i","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>