<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Next.js 15에서 cacheTag 사용해서 효율적으로 캐시 관리하는 방법 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-cacheTag" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Next.js 15에서 cacheTag 사용해서 효율적으로 캐시 관리하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:title" content="Next.js 15에서 cacheTag 사용해서 효율적으로 캐시 관리하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-cacheTag" data-gatsby-head="true"/><meta name="twitter:title" content="Next.js 15에서 cacheTag 사용해서 효율적으로 캐시 관리하는 방법 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2025-04-22 02:59" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/0eef537492fed77a.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/0eef537492fed77a.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-8ded8b979ba73586.js" defer=""></script><script src="/TIL/_next/static/olPs1cVezSGTqD7OaewDI/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/olPs1cVezSGTqD7OaewDI/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Next.js 15에서 cacheTag 사용해서 효율적으로 캐시 관리하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Next.js 15에서 cacheTag 사용해서 효율적으로 캐시 관리하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Apr 22, 2025</span><span class="posts_reading_time__f7YPP">9<!-- --> min read</span></span></div></div></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>cacheTag</h1>
<p>cacheTag 함수는 캐시된 데이터를 태그로 관리해서 필요한 순간에만 캐시를 지우거나 갱신할 수 있게 도와줘요. 태그를 캐시 항목에 붙여두면, 전체 캐시를 지우는 대신 특정 태그가 붙은 데이터만 골라서 재검증하거나 삭제할 수 있답니다. 이 기능 덕분에 캐시 관리가 훨씬 스마트해지고 효율적이죠!</p>
<h2>사용 방법</h2>
<p>cacheTag를 사용하려면, 먼저 프로젝트의 <code>next.config.js</code> 파일에서 <code>dynamicIO</code> 플래그를 활성화해야 해요. 이렇게요:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// next.config.js</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">experimental</span>: {
    <span class="hljs-attr">dynamicIO</span>: <span class="hljs-literal">true</span>,
  },
};
</code></pre>
<blockquote>
<p><code>dynamicIO</code> 옵션은 아직 실험적인 기능이라, 안정성이 필요한 프로젝트에서는 신중하게 적용하는 게 좋아요.</p>
</blockquote>
<p>이 설정을 한 다음, 원하는 캐시 데이터에 태그를 달아서 관리할 수 있습니다.</p>
<hr>
<h3>참고로 더!</h3>
<ul>
<li>태그 관리 덕분에 특정 부분만 업데이트해야 할 때, 서버 성능과 사용자 경험이 크게 개선됩니다.</li>
<li>이 기능은 특히 데이터가 자주 바뀌면서도 전체를 다시 로드하는 건 비효율적인 서비스(예: 뉴스 피드, 실시간 데이터 보여주는 앱 등)에 유용해요.</li>
<li><code>cacheTag</code>를 사용하면서 동시에 어떻게 캐시 무효화 전략을 세울지 고민해보면 프로젝트의 퍼포먼스 최적화에 큰 도움이 됩니다.</li>
</ul>
<p>필요하면 다음에 캐시 사용 예제에 대해서도 알려줄게요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Next.js에서 새롭게 제공하는 캐시 태그(cacheTag) 기능을 재미있게 활용해볼까요? 이번에 소개할 코드는 캐시를 더 세밀하게 관리할 수 있게 도와주는 설정과 함수예요.</p>
<h3>1. next.config.js 설정</h3>
<p>먼저 <code>next.config.js</code> 파일에서 실험적 기능인 <code>dynamicIO</code>를 활성화해야 해요. 이 옵션을 켜면 Next.js가 새로운 캐시 태그 기능을 사용할 수 있도록 준비된답니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> type { <span class="hljs-title class_">NextConfig</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"next"</span>;

<span class="hljs-keyword">const</span> <span class="hljs-attr">nextConfig</span>: <span class="hljs-title class_">NextConfig</span> = {
  <span class="hljs-attr">experimental</span>: {
    <span class="hljs-attr">dynamicIO</span>: <span class="hljs-literal">true</span>,
  },
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> nextConfig;
</code></pre>
<p>여기서 <code>dynamicIO</code>는 아직 완전히 안정화된 기능은 아니지만, 캐시 제어나 데이터 페칭에 좀 더 유연한 방식으로 접근할 수 있게 해줘요.</p>
<hr>
<h3>2. 캐시 태그 지정하기 - <code>cacheTag</code></h3>
<p>이제 함수 안에서 <code>cacheTag</code> 함수를 써보죠! 이 함수는 하나의 문자열 태그, 혹은 문자열 배열로 캐시 태그를 지정할 수 있어요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { unstable_cacheTag <span class="hljs-keyword">as</span> cacheTag } <span class="hljs-keyword">from</span> <span class="hljs-string">"next/cache"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getData</span>(<span class="hljs-params"></span>) {
  <span class="hljs-string">"use cache"</span>;
  <span class="hljs-title function_">cacheTag</span>(<span class="hljs-string">"my-data"</span>);
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">"/api/data"</span>);
  <span class="hljs-keyword">return</span> data;
}
</code></pre>
<ul>
<li>먼저 함수 최상단 <code>'use cache'</code> 디렉티브를 호출해 캐시 기능을 활성화해줍니다.</li>
<li><code>cacheTag('my-data')</code>로 해당 함수가 사용하는 캐시 태그를 지정하죠.</li>
<li>이렇게 하면 <code>my-data</code>라는 태그를 기준으로 캐싱되고, 이 태그만 선택적으로 무효화할 수 있습니다.</li>
</ul>
<p>이게 뭐가 좋느냐면, 데이터를 전체 페이지가 아니라 세부 단위별로 새로고침할 수 있다는 점이에요. 예를 들어, 특정 API 데이터를 업데이트해야 할 때 전체 페이지를 빌드할 필요 없이 해당 데이터만 캐시를 지우고 재생성할 수 있게 되는 거죠.</p>
<hr>
<h3>3. 캐시 무효화 (Cache Purge) - <code>revalidateTag</code></h3>
<p>캐시가 오래되었거나, 데이터를 리프레시하려면 태그 단위로 캐시를 무효화하는 게 중요한데요. Next.js는 <code>revalidateTag</code> API로 이걸 쉽게 지원합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { revalidateTag } <span class="hljs-keyword">from</span> <span class="hljs-string">"next/cache"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">POST</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 예: API 라우트에서 데이터가 변경될 때 해당 캐시 태그를 무효화</span>
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">doDataUpdate</span>();
  <span class="hljs-title function_">revalidateTag</span>(<span class="hljs-string">"my-data"</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(<span class="hljs-string">'Cache cleared for "my-data" tag'</span>);
}
</code></pre>
<ul>
<li>위 예시처럼, 서버측 함수에서 데이터 수정 후 <code>revalidateTag('my-data')</code>를 호출하면 <code>'my-data'</code> 관련된 캐시가 모두 무효화됩니다.</li>
<li>그러면 다음 요청 시점에 다시 최신 데이터를 받아서 캐쉬를 갱신하게 되죠.</li>
</ul>
<hr>
<h2>요약</h2>





















<table><thead><tr><th>기능</th><th>설명</th></tr></thead><tbody><tr><td><code>experimental.dynamicIO</code></td><td>Next.js에서 캐시 태그 사용을 위한 실험적 설정</td></tr><tr><td><code>cacheTag</code></td><td>함수 내에서 캐시 태그를 지정, 데이터 단위별 캐시 제어 가능</td></tr><tr><td><code>revalidateTag</code></td><td>특정 태그에 해당하는 캐시를 서버에서 강제로 무효화</td></tr></tbody></table>
<hr>
<h2>한마디</h2>
<p>이번에 소개한 캐시 태그 기능은 특히 데이터가 자주 업데이트되는 상황에서 유용해요. API 응답이나 UI 컴포넌트의 일부를 효과적으로 갱신할 수 있으니, 무조건 페이지 전체를 다시 빌드하는 구조에서 벗어나고 싶다면 한 번 꼭 시도해보세요. 실험적이라 공식 문서와 버전이 바뀌는지는 꾸준히 체크하는 것도 잊지 마시고요!</p>
<p>더 궁금한 점 있으면 언제든 댓글로 남겨주세요. 같이 공부해봐요! 😊</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>위 코드는 Next.js의 서버 컴포넌트에서 캐시를 제어할 때 사용하는 예제입니다. 여기서 핵심은 revalidateTag라는 함수로 특정 캐시 태그를 재검증(revalidate)해서, 데이터가 바뀌었을 때 최신 상태로 유지하게 만드는 거예요.</p>
<pre><code class="hljs language-js"><span class="hljs-string">"use server"</span>;

<span class="hljs-keyword">import</span> { revalidateTag } <span class="hljs-keyword">from</span> <span class="hljs-string">"next/cache"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">submit</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">addPost</span>(); <span class="hljs-comment">// 새로운 포스트를 추가하는 비동기 함수</span>
  <span class="hljs-title function_">revalidateTag</span>(<span class="hljs-string">"my-data"</span>); <span class="hljs-comment">// 'my-data'라는 태그가 붙은 캐시를 재검증해서 최신으로 업데이트</span>
}
</code></pre>
<p>위 코드에서 addPost()가 끝나면, 'my-data'라는 태그를 가진 캐시는 재검증돼서 이전 데이터가 아닌 새 데이터를 가져오도록 만드는 역할이에요.</p>
<hr>
<h2>알아두면 좋은 팁</h2>

















<table><thead><tr><th>내용</th><th>설명</th></tr></thead><tbody><tr><td>Idempotent Tags</td><td>동일한 태그를 여러 번 적용해도 추가적인 효과가 없어요. 중복 적용해도 무방해요.</td></tr><tr><td>Multiple Tags</td><td>한 캐시 엔트리에 여러 태그를 붙일 수 있어요. 배열 형태로 태그들을 넘겨주면 됩니다.</td></tr></tbody></table>
<p>예를 들어 이렇게 사용해요:</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">cacheTag</span>(<span class="hljs-string">"tag-one"</span>, <span class="hljs-string">"tag-two"</span>);
</code></pre>
<p>위와 같이 여러 태그를 한 번에 붙이면, 이 캐시 항목이 두 가지 태그에 묶여서 둘 중 하나라도 변경될 경우 재검증됩니다.</p>
<hr>
<h3>개인적으로 추가로 알려드릴 점!</h3>
<p>캐시 태그를 이렇게 사용하면 무조건 캐시 무효화(invalidation)를 하느니, 필요한 부분만 선별적으로 업데이트하는 '스마트 캐싱' 전략을 세우기 좋아요. 데이터가 자주 변하는 서비스에서는 서버 성능과 유저 경험을 둘 다 잡기 위해 꼭 익혀야 하는 기능입니다.</p>
<p>Next.js 13+ 버전에서 제공하는 이 기능을 잘 활용하면, SSR(Server Side Rendering) 혹은 ISR(Incremental Static Regeneration) 환경에서도 원하는 타이밍에 효율적으로 데이터를 업데이트할 수 있어요. 번거로운 캐시 조작을 줄이고, 최신 데이터도 놓치지 않게 해주는 아주 쓸모 있는 기능이죠!</p>
<p>필요하시면 addPost() 같은 함수 내부 구현도 같이 다뤄볼테니, 언제든 질문 주세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>예제</h2>
<h3>컴포넌트나 함수에 태그 달기</h3>
<p>캐시된 함수나 컴포넌트 안에서 <code>cacheTag</code>를 호출해서 캐시 데이터를 태그할 수 있어요. 이렇게 하면 캐시 관리가 좀 더 편리해지고, 특정 태그를 기준으로 캐시를 재검증하거나 삭제할 수 있답니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { unstable_cacheTag <span class="hljs-keyword">as</span> cacheTag } <span class="hljs-keyword">from</span> <span class="hljs-string">"next/cache"</span>;

interface <span class="hljs-title class_">BookingsProps</span> {
  <span class="hljs-attr">type</span>: string;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Bookings</span>(<span class="hljs-params">{ type = <span class="hljs-string">"haircut"</span> }: BookingsProps</span>) {
  <span class="hljs-string">"use cache"</span>;
  <span class="hljs-title function_">cacheTag</span>(<span class="hljs-string">"bookings-data"</span>);

  <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getBookingsData</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/bookings?type=<span class="hljs-subst">${<span class="hljs-built_in">encodeURIComponent</span>(type)}</span>`</span>);
    <span class="hljs-keyword">return</span> data;
  }

  <span class="hljs-keyword">return</span>; <span class="hljs-comment">//...</span>
}
</code></pre>
<hr>
<p>여기서 중요한 포인트는 <code>'use cache'</code>라는 디렉티브를 함수 최상단에 써서 이 함수가 캐싱 기능을 사용할 거라고 알려준다는 점이에요. 그리고 <code>cacheTag('bookings-data')</code>를 호출해서 이 함수가 반환하는 데이터에 <code>bookings-data</code>라는 태그를 붙이는 거죠.</p>
<p>이렇게 태그를 달아두면, 나중에 <code>bookings-data</code> 태그가 붙은 캐시들을 한꺼번에 무효화하거나 업데이트할 때 훨씬 편리해져요.</p>
<p>또한 참고할 점은, 이 기능이 아직 불안정(<code>unstable</code>)한 API이므로, 앞으로 변경될 가능성이 있다는 점이에요. 그래도 Next.js 같은 최신 프레임워크에서 제공하는 기능을 미리 써보면서 경험해보는 것도 좋겠죠?</p>
<p>추가로, 만약 다양한 타입의 예약 데이터를 관리해야 한다면 태그 이름을 <code>bookings-data:${type}</code> 같은 식으로 동적으로 생성하는 것도 좋은 방법이에요. 이렇게 하면 특정 타입만 골라서 캐시를 제어할 수 있거든요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>외부 데이터로부터 태그 만들기</h3>
<p>비동기 함수(async function)에서 반환된 데이터를 이용해서 캐시 항목에 태그를 붙일 수 있어요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { unstable_cacheTag <span class="hljs-keyword">as</span> cacheTag } <span class="hljs-keyword">from</span> <span class="hljs-string">"next/cache"</span>;

interface <span class="hljs-title class_">BookingsProps</span> {
  <span class="hljs-attr">type</span>: string;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Bookings</span>(<span class="hljs-params">{ type = <span class="hljs-string">"haircut"</span> }: BookingsProps</span>) {
  <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getBookingsData</span>(<span class="hljs-params"></span>) {
    <span class="hljs-string">"use cache"</span>; <span class="hljs-comment">// 캐시 활용을 위한 지시어</span>
    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/bookings?type=<span class="hljs-subst">${<span class="hljs-built_in">encodeURIComponent</span>(type)}</span>`</span>);
    <span class="hljs-title function_">cacheTag</span>(<span class="hljs-string">"bookings-data"</span>, data.<span class="hljs-property">id</span>); <span class="hljs-comment">// 받은 데이터의 id를 태그값으로 지정</span>
    <span class="hljs-keyword">return</span> data;
  }
  <span class="hljs-keyword">return</span>; <span class="hljs-comment">//...</span>
}
</code></pre>
<p>여기서 중요한 포인트는 <code>cacheTag</code>를 사용해 데이터를 태그함으로써 특정 조건에 따라 캐시를 더 정밀하게 관리할 수 있다는 거예요. 예를 들어, 예약 타입별로 캐시를 구분하거나 데이터 ID별로 캐시 무효화를 쉽게 할 수 있죠.</p>
<p>그리고 <code>use cache</code>라는 키워드가 보이죠? 이건 Next.js가 이 함수 결과를 캐싱하도록 알려주는 역할을 합니다. 실제 프로젝트에서는 이렇게 재사용 가능한 데이터를 효율적으로 다룰 때 꼭 활용해보세요!</p>
<h3>태그된 캐시 무효화하기</h3>
<p>작성한 태그를 기반으로 캐시를 무효화해 특정 데이터가 변경되었을 때 최신 상태를 유지할 수 있어요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { unstable_invalidateCacheTag <span class="hljs-keyword">as</span> invalidateCacheTag } <span class="hljs-keyword">from</span> <span class="hljs-string">"next/cache"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">invalidateBookingCache</span>(<span class="hljs-params">id: string</span>) {
  <span class="hljs-comment">// 'bookings-data'라는 태그에 id 값으로 붙인 캐시를 무효화합니다.</span>
  <span class="hljs-title function_">invalidateCacheTag</span>(<span class="hljs-string">"bookings-data"</span>, id);
}
</code></pre>
<p>이렇게 태그 단위로 캐시를 무효화하면, 불필요한 전체 캐시 초기화 없이 원하는 부분만 갱신 가능해져서 효율적이에요. 만약 데이터 변경 이벤트가 발생하면 이 함수를 호출해 관련 캐시를 리프레시하는 방식으로 활용하면 됩니다.</p>
<p>캐시 태그 활용법은 Next.js 13버전 이후의 캐시 전략에서 굉장히 강력한 기능 중 하나이니 꼭 익혀두세요! 개발하며 때때로 캐시 데이터가 꼬일 때 이 방법으로 깔끔하게 관리할 수 있습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>'revalidateTag'를 사용하면 필요한 시점에 특정 태그의 캐시를 무효화해서 최신 데이터를 반영할 수 있어요. 예를 들어, 아래 코드처럼 'bookings-data'라는 태그에 달려있는 캐시를 갱신해줄 수 있죠.</p>
<pre><code class="hljs language-js"><span class="hljs-string">"use server"</span>;

<span class="hljs-keyword">import</span> { revalidateTag } <span class="hljs-keyword">from</span> <span class="hljs-string">"next/cache"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateBookings</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">updateBookingData</span>();
  <span class="hljs-title function_">revalidateTag</span>(<span class="hljs-string">"bookings-data"</span>);
}
</code></pre>
<p>간단히 말해, updateBookingData() 함수가 예약 데이터를 업데이트한 뒤에 revalidateTag('bookings-data')를 호출하면, Next.js가 그 태그에 연결된 캐시를 무효화해서 사용자들에게 최신 정보를 보여주게 됩니다.</p>
<p>여기서 중요한 점은, 캐시 무효화를 태그 단위로 관리할 수 있다는 거예요. 덕분에 전체 페이지 캐시를 다 날리지 않고도, 특정 데이터 부분만 신속하게 업데이트할 수 있으니 효율적이죠!</p>
<p>추가로, revalidateTag는 서버 컴포넌트나 API 라우트 등 서버 측 코드에서만 사용 가능하다는 점도 기억해 주세요. 클라이언트 측에서는 사용할 수 없고, 반드시 'use server' directive가 있어야 합니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Next.js 15에서 cacheTag 사용해서 효율적으로 캐시 관리하는 방법","description":"","date":"2025-04-22 02:59","slug":"2025-04-22-cacheTag","content":"\n# cacheTag\n\ncacheTag 함수는 캐시된 데이터를 태그로 관리해서 필요한 순간에만 캐시를 지우거나 갱신할 수 있게 도와줘요. 태그를 캐시 항목에 붙여두면, 전체 캐시를 지우는 대신 특정 태그가 붙은 데이터만 골라서 재검증하거나 삭제할 수 있답니다. 이 기능 덕분에 캐시 관리가 훨씬 스마트해지고 효율적이죠!\n\n## 사용 방법\n\ncacheTag를 사용하려면, 먼저 프로젝트의 `next.config.js` 파일에서 `dynamicIO` 플래그를 활성화해야 해요. 이렇게요:\n\n```js\n// next.config.js\nmodule.exports = {\n  experimental: {\n    dynamicIO: true,\n  },\n};\n```\n\n\u003e `dynamicIO` 옵션은 아직 실험적인 기능이라, 안정성이 필요한 프로젝트에서는 신중하게 적용하는 게 좋아요.\n\n이 설정을 한 다음, 원하는 캐시 데이터에 태그를 달아서 관리할 수 있습니다.\n\n---\n\n### 참고로 더!\n\n- 태그 관리 덕분에 특정 부분만 업데이트해야 할 때, 서버 성능과 사용자 경험이 크게 개선됩니다.\n- 이 기능은 특히 데이터가 자주 바뀌면서도 전체를 다시 로드하는 건 비효율적인 서비스(예: 뉴스 피드, 실시간 데이터 보여주는 앱 등)에 유용해요.\n- `cacheTag`를 사용하면서 동시에 어떻게 캐시 무효화 전략을 세울지 고민해보면 프로젝트의 퍼포먼스 최적화에 큰 도움이 됩니다.\n\n필요하면 다음에 캐시 사용 예제에 대해서도 알려줄게요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 새롭게 제공하는 캐시 태그(cacheTag) 기능을 재미있게 활용해볼까요? 이번에 소개할 코드는 캐시를 더 세밀하게 관리할 수 있게 도와주는 설정과 함수예요.\n\n### 1. next.config.js 설정\n\n먼저 `next.config.js` 파일에서 실험적 기능인 `dynamicIO`를 활성화해야 해요. 이 옵션을 켜면 Next.js가 새로운 캐시 태그 기능을 사용할 수 있도록 준비된답니다.\n\n```js\nimport type { NextConfig } from \"next\";\n\nconst nextConfig: NextConfig = {\n  experimental: {\n    dynamicIO: true,\n  },\n};\n\nexport default nextConfig;\n```\n\n여기서 `dynamicIO`는 아직 완전히 안정화된 기능은 아니지만, 캐시 제어나 데이터 페칭에 좀 더 유연한 방식으로 접근할 수 있게 해줘요.\n\n---\n\n### 2. 캐시 태그 지정하기 - `cacheTag`\n\n이제 함수 안에서 `cacheTag` 함수를 써보죠! 이 함수는 하나의 문자열 태그, 혹은 문자열 배열로 캐시 태그를 지정할 수 있어요.\n\n```js\nimport { unstable_cacheTag as cacheTag } from \"next/cache\";\n\nexport async function getData() {\n  \"use cache\";\n  cacheTag(\"my-data\");\n  const data = await fetch(\"/api/data\");\n  return data;\n}\n```\n\n- 먼저 함수 최상단 `'use cache'` 디렉티브를 호출해 캐시 기능을 활성화해줍니다.\n- `cacheTag('my-data')`로 해당 함수가 사용하는 캐시 태그를 지정하죠.\n- 이렇게 하면 `my-data`라는 태그를 기준으로 캐싱되고, 이 태그만 선택적으로 무효화할 수 있습니다.\n\n이게 뭐가 좋느냐면, 데이터를 전체 페이지가 아니라 세부 단위별로 새로고침할 수 있다는 점이에요. 예를 들어, 특정 API 데이터를 업데이트해야 할 때 전체 페이지를 빌드할 필요 없이 해당 데이터만 캐시를 지우고 재생성할 수 있게 되는 거죠.\n\n---\n\n### 3. 캐시 무효화 (Cache Purge) - `revalidateTag`\n\n캐시가 오래되었거나, 데이터를 리프레시하려면 태그 단위로 캐시를 무효화하는 게 중요한데요. Next.js는 `revalidateTag` API로 이걸 쉽게 지원합니다.\n\n```js\nimport { revalidateTag } from \"next/cache\";\n\nexport async function POST() {\n  // 예: API 라우트에서 데이터가 변경될 때 해당 캐시 태그를 무효화\n  await doDataUpdate();\n  revalidateTag(\"my-data\");\n  return new Response('Cache cleared for \"my-data\" tag');\n}\n```\n\n- 위 예시처럼, 서버측 함수에서 데이터 수정 후 `revalidateTag('my-data')`를 호출하면 `'my-data'` 관련된 캐시가 모두 무효화됩니다.\n- 그러면 다음 요청 시점에 다시 최신 데이터를 받아서 캐쉬를 갱신하게 되죠.\n\n---\n\n## 요약\n\n| 기능                     | 설명                                                       |\n| ------------------------ | ---------------------------------------------------------- |\n| `experimental.dynamicIO` | Next.js에서 캐시 태그 사용을 위한 실험적 설정              |\n| `cacheTag`               | 함수 내에서 캐시 태그를 지정, 데이터 단위별 캐시 제어 가능 |\n| `revalidateTag`          | 특정 태그에 해당하는 캐시를 서버에서 강제로 무효화         |\n\n---\n\n## 한마디\n\n이번에 소개한 캐시 태그 기능은 특히 데이터가 자주 업데이트되는 상황에서 유용해요. API 응답이나 UI 컴포넌트의 일부를 효과적으로 갱신할 수 있으니, 무조건 페이지 전체를 다시 빌드하는 구조에서 벗어나고 싶다면 한 번 꼭 시도해보세요. 실험적이라 공식 문서와 버전이 바뀌는지는 꾸준히 체크하는 것도 잊지 마시고요!\n\n더 궁금한 점 있으면 언제든 댓글로 남겨주세요. 같이 공부해봐요! 😊\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 코드는 Next.js의 서버 컴포넌트에서 캐시를 제어할 때 사용하는 예제입니다. 여기서 핵심은 revalidateTag라는 함수로 특정 캐시 태그를 재검증(revalidate)해서, 데이터가 바뀌었을 때 최신 상태로 유지하게 만드는 거예요.\n\n```js\n\"use server\";\n\nimport { revalidateTag } from \"next/cache\";\n\nexport default async function submit() {\n  await addPost(); // 새로운 포스트를 추가하는 비동기 함수\n  revalidateTag(\"my-data\"); // 'my-data'라는 태그가 붙은 캐시를 재검증해서 최신으로 업데이트\n}\n```\n\n위 코드에서 addPost()가 끝나면, 'my-data'라는 태그를 가진 캐시는 재검증돼서 이전 데이터가 아닌 새 데이터를 가져오도록 만드는 역할이에요.\n\n---\n\n## 알아두면 좋은 팁\n\n| 내용            | 설명                                                                               |\n| --------------- | ---------------------------------------------------------------------------------- |\n| Idempotent Tags | 동일한 태그를 여러 번 적용해도 추가적인 효과가 없어요. 중복 적용해도 무방해요.     |\n| Multiple Tags   | 한 캐시 엔트리에 여러 태그를 붙일 수 있어요. 배열 형태로 태그들을 넘겨주면 됩니다. |\n\n예를 들어 이렇게 사용해요:\n\n```js\ncacheTag(\"tag-one\", \"tag-two\");\n```\n\n위와 같이 여러 태그를 한 번에 붙이면, 이 캐시 항목이 두 가지 태그에 묶여서 둘 중 하나라도 변경될 경우 재검증됩니다.\n\n---\n\n### 개인적으로 추가로 알려드릴 점!\n\n캐시 태그를 이렇게 사용하면 무조건 캐시 무효화(invalidation)를 하느니, 필요한 부분만 선별적으로 업데이트하는 '스마트 캐싱' 전략을 세우기 좋아요. 데이터가 자주 변하는 서비스에서는 서버 성능과 유저 경험을 둘 다 잡기 위해 꼭 익혀야 하는 기능입니다.\n\nNext.js 13+ 버전에서 제공하는 이 기능을 잘 활용하면, SSR(Server Side Rendering) 혹은 ISR(Incremental Static Regeneration) 환경에서도 원하는 타이밍에 효율적으로 데이터를 업데이트할 수 있어요. 번거로운 캐시 조작을 줄이고, 최신 데이터도 놓치지 않게 해주는 아주 쓸모 있는 기능이죠!\n\n필요하시면 addPost() 같은 함수 내부 구현도 같이 다뤄볼테니, 언제든 질문 주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 예제\n\n### 컴포넌트나 함수에 태그 달기\n\n캐시된 함수나 컴포넌트 안에서 `cacheTag`를 호출해서 캐시 데이터를 태그할 수 있어요. 이렇게 하면 캐시 관리가 좀 더 편리해지고, 특정 태그를 기준으로 캐시를 재검증하거나 삭제할 수 있답니다.\n\n```js\nimport { unstable_cacheTag as cacheTag } from \"next/cache\";\n\ninterface BookingsProps {\n  type: string;\n}\n\nexport async function Bookings({ type = \"haircut\" }: BookingsProps) {\n  \"use cache\";\n  cacheTag(\"bookings-data\");\n\n  async function getBookingsData() {\n    const data = await fetch(`/api/bookings?type=${encodeURIComponent(type)}`);\n    return data;\n  }\n\n  return; //...\n}\n```\n\n---\n\n여기서 중요한 포인트는 `'use cache'`라는 디렉티브를 함수 최상단에 써서 이 함수가 캐싱 기능을 사용할 거라고 알려준다는 점이에요. 그리고 `cacheTag('bookings-data')`를 호출해서 이 함수가 반환하는 데이터에 `bookings-data`라는 태그를 붙이는 거죠.\n\n이렇게 태그를 달아두면, 나중에 `bookings-data` 태그가 붙은 캐시들을 한꺼번에 무효화하거나 업데이트할 때 훨씬 편리해져요.\n\n또한 참고할 점은, 이 기능이 아직 불안정(`unstable`)한 API이므로, 앞으로 변경될 가능성이 있다는 점이에요. 그래도 Next.js 같은 최신 프레임워크에서 제공하는 기능을 미리 써보면서 경험해보는 것도 좋겠죠?\n\n추가로, 만약 다양한 타입의 예약 데이터를 관리해야 한다면 태그 이름을 `bookings-data:${type}` 같은 식으로 동적으로 생성하는 것도 좋은 방법이에요. 이렇게 하면 특정 타입만 골라서 캐시를 제어할 수 있거든요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 외부 데이터로부터 태그 만들기\n\n비동기 함수(async function)에서 반환된 데이터를 이용해서 캐시 항목에 태그를 붙일 수 있어요.\n\n```js\nimport { unstable_cacheTag as cacheTag } from \"next/cache\";\n\ninterface BookingsProps {\n  type: string;\n}\n\nexport async function Bookings({ type = \"haircut\" }: BookingsProps) {\n  async function getBookingsData() {\n    \"use cache\"; // 캐시 활용을 위한 지시어\n    const data = await fetch(`/api/bookings?type=${encodeURIComponent(type)}`);\n    cacheTag(\"bookings-data\", data.id); // 받은 데이터의 id를 태그값으로 지정\n    return data;\n  }\n  return; //...\n}\n```\n\n여기서 중요한 포인트는 `cacheTag`를 사용해 데이터를 태그함으로써 특정 조건에 따라 캐시를 더 정밀하게 관리할 수 있다는 거예요. 예를 들어, 예약 타입별로 캐시를 구분하거나 데이터 ID별로 캐시 무효화를 쉽게 할 수 있죠.\n\n그리고 `use cache`라는 키워드가 보이죠? 이건 Next.js가 이 함수 결과를 캐싱하도록 알려주는 역할을 합니다. 실제 프로젝트에서는 이렇게 재사용 가능한 데이터를 효율적으로 다룰 때 꼭 활용해보세요!\n\n### 태그된 캐시 무효화하기\n\n작성한 태그를 기반으로 캐시를 무효화해 특정 데이터가 변경되었을 때 최신 상태를 유지할 수 있어요.\n\n```js\nimport { unstable_invalidateCacheTag as invalidateCacheTag } from \"next/cache\";\n\nexport async function invalidateBookingCache(id: string) {\n  // 'bookings-data'라는 태그에 id 값으로 붙인 캐시를 무효화합니다.\n  invalidateCacheTag(\"bookings-data\", id);\n}\n```\n\n이렇게 태그 단위로 캐시를 무효화하면, 불필요한 전체 캐시 초기화 없이 원하는 부분만 갱신 가능해져서 효율적이에요. 만약 데이터 변경 이벤트가 발생하면 이 함수를 호출해 관련 캐시를 리프레시하는 방식으로 활용하면 됩니다.\n\n캐시 태그 활용법은 Next.js 13버전 이후의 캐시 전략에서 굉장히 강력한 기능 중 하나이니 꼭 익혀두세요! 개발하며 때때로 캐시 데이터가 꼬일 때 이 방법으로 깔끔하게 관리할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n'revalidateTag'를 사용하면 필요한 시점에 특정 태그의 캐시를 무효화해서 최신 데이터를 반영할 수 있어요. 예를 들어, 아래 코드처럼 'bookings-data'라는 태그에 달려있는 캐시를 갱신해줄 수 있죠.\n\n```js\n\"use server\";\n\nimport { revalidateTag } from \"next/cache\";\n\nexport async function updateBookings() {\n  await updateBookingData();\n  revalidateTag(\"bookings-data\");\n}\n```\n\n간단히 말해, updateBookingData() 함수가 예약 데이터를 업데이트한 뒤에 revalidateTag('bookings-data')를 호출하면, Next.js가 그 태그에 연결된 캐시를 무효화해서 사용자들에게 최신 정보를 보여주게 됩니다.\n\n여기서 중요한 점은, 캐시 무효화를 태그 단위로 관리할 수 있다는 거예요. 덕분에 전체 페이지 캐시를 다 날리지 않고도, 특정 데이터 부분만 신속하게 업데이트할 수 있으니 효율적이죠!\n\n추가로, revalidateTag는 서버 컴포넌트나 API 라우트 등 서버 측 코드에서만 사용 가능하다는 점도 기억해 주세요. 클라이언트 측에서는 사용할 수 없고, 반드시 'use server' directive가 있어야 합니다.\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":9},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003ecacheTag\u003c/h1\u003e\n\u003cp\u003ecacheTag 함수는 캐시된 데이터를 태그로 관리해서 필요한 순간에만 캐시를 지우거나 갱신할 수 있게 도와줘요. 태그를 캐시 항목에 붙여두면, 전체 캐시를 지우는 대신 특정 태그가 붙은 데이터만 골라서 재검증하거나 삭제할 수 있답니다. 이 기능 덕분에 캐시 관리가 훨씬 스마트해지고 효율적이죠!\u003c/p\u003e\n\u003ch2\u003e사용 방법\u003c/h2\u003e\n\u003cp\u003ecacheTag를 사용하려면, 먼저 프로젝트의 \u003ccode\u003enext.config.js\u003c/code\u003e 파일에서 \u003ccode\u003edynamicIO\u003c/code\u003e 플래그를 활성화해야 해요. 이렇게요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// next.config.js\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eexperimental\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003edynamicIO\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  },\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003edynamicIO\u003c/code\u003e 옵션은 아직 실험적인 기능이라, 안정성이 필요한 프로젝트에서는 신중하게 적용하는 게 좋아요.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e이 설정을 한 다음, 원하는 캐시 데이터에 태그를 달아서 관리할 수 있습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e참고로 더!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e태그 관리 덕분에 특정 부분만 업데이트해야 할 때, 서버 성능과 사용자 경험이 크게 개선됩니다.\u003c/li\u003e\n\u003cli\u003e이 기능은 특히 데이터가 자주 바뀌면서도 전체를 다시 로드하는 건 비효율적인 서비스(예: 뉴스 피드, 실시간 데이터 보여주는 앱 등)에 유용해요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecacheTag\u003c/code\u003e를 사용하면서 동시에 어떻게 캐시 무효화 전략을 세울지 고민해보면 프로젝트의 퍼포먼스 최적화에 큰 도움이 됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e필요하면 다음에 캐시 사용 예제에 대해서도 알려줄게요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eNext.js에서 새롭게 제공하는 캐시 태그(cacheTag) 기능을 재미있게 활용해볼까요? 이번에 소개할 코드는 캐시를 더 세밀하게 관리할 수 있게 도와주는 설정과 함수예요.\u003c/p\u003e\n\u003ch3\u003e1. next.config.js 설정\u003c/h3\u003e\n\u003cp\u003e먼저 \u003ccode\u003enext.config.js\u003c/code\u003e 파일에서 실험적 기능인 \u003ccode\u003edynamicIO\u003c/code\u003e를 활성화해야 해요. 이 옵션을 켜면 Next.js가 새로운 캐시 태그 기능을 사용할 수 있도록 준비된답니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e type { \u003cspan class=\"hljs-title class_\"\u003eNextConfig\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"next\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003enextConfig\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eNextConfig\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eexperimental\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003edynamicIO\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  },\n};\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e nextConfig;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 \u003ccode\u003edynamicIO\u003c/code\u003e는 아직 완전히 안정화된 기능은 아니지만, 캐시 제어나 데이터 페칭에 좀 더 유연한 방식으로 접근할 수 있게 해줘요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e2. 캐시 태그 지정하기 - \u003ccode\u003ecacheTag\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e이제 함수 안에서 \u003ccode\u003ecacheTag\u003c/code\u003e 함수를 써보죠! 이 함수는 하나의 문자열 태그, 혹은 문자열 배열로 캐시 태그를 지정할 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { unstable_cacheTag \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e cacheTag } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"next/cache\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetData\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-string\"\u003e\"use cache\"\u003c/span\u003e;\n  \u003cspan class=\"hljs-title function_\"\u003ecacheTag\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"my-data\"\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e data = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"/api/data\"\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e data;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e먼저 함수 최상단 \u003ccode\u003e'use cache'\u003c/code\u003e 디렉티브를 호출해 캐시 기능을 활성화해줍니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecacheTag('my-data')\u003c/code\u003e로 해당 함수가 사용하는 캐시 태그를 지정하죠.\u003c/li\u003e\n\u003cli\u003e이렇게 하면 \u003ccode\u003emy-data\u003c/code\u003e라는 태그를 기준으로 캐싱되고, 이 태그만 선택적으로 무효화할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이게 뭐가 좋느냐면, 데이터를 전체 페이지가 아니라 세부 단위별로 새로고침할 수 있다는 점이에요. 예를 들어, 특정 API 데이터를 업데이트해야 할 때 전체 페이지를 빌드할 필요 없이 해당 데이터만 캐시를 지우고 재생성할 수 있게 되는 거죠.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e3. 캐시 무효화 (Cache Purge) - \u003ccode\u003erevalidateTag\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e캐시가 오래되었거나, 데이터를 리프레시하려면 태그 단위로 캐시를 무효화하는 게 중요한데요. Next.js는 \u003ccode\u003erevalidateTag\u003c/code\u003e API로 이걸 쉽게 지원합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { revalidateTag } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"next/cache\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePOST\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 예: API 라우트에서 데이터가 변경될 때 해당 캐시 태그를 무효화\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edoDataUpdate\u003c/span\u003e();\n  \u003cspan class=\"hljs-title function_\"\u003erevalidateTag\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"my-data\"\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eResponse\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Cache cleared for \"my-data\" tag'\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e위 예시처럼, 서버측 함수에서 데이터 수정 후 \u003ccode\u003erevalidateTag('my-data')\u003c/code\u003e를 호출하면 \u003ccode\u003e'my-data'\u003c/code\u003e 관련된 캐시가 모두 무효화됩니다.\u003c/li\u003e\n\u003cli\u003e그러면 다음 요청 시점에 다시 최신 데이터를 받아서 캐쉬를 갱신하게 되죠.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003e요약\u003c/h2\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e기능\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eexperimental.dynamicIO\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eNext.js에서 캐시 태그 사용을 위한 실험적 설정\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ecacheTag\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e함수 내에서 캐시 태그를 지정, 데이터 단위별 캐시 제어 가능\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003erevalidateTag\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e특정 태그에 해당하는 캐시를 서버에서 강제로 무효화\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003ch2\u003e한마디\u003c/h2\u003e\n\u003cp\u003e이번에 소개한 캐시 태그 기능은 특히 데이터가 자주 업데이트되는 상황에서 유용해요. API 응답이나 UI 컴포넌트의 일부를 효과적으로 갱신할 수 있으니, 무조건 페이지 전체를 다시 빌드하는 구조에서 벗어나고 싶다면 한 번 꼭 시도해보세요. 실험적이라 공식 문서와 버전이 바뀌는지는 꾸준히 체크하는 것도 잊지 마시고요!\u003c/p\u003e\n\u003cp\u003e더 궁금한 점 있으면 언제든 댓글로 남겨주세요. 같이 공부해봐요! 😊\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e위 코드는 Next.js의 서버 컴포넌트에서 캐시를 제어할 때 사용하는 예제입니다. 여기서 핵심은 revalidateTag라는 함수로 특정 캐시 태그를 재검증(revalidate)해서, 데이터가 바뀌었을 때 최신 상태로 유지하게 만드는 거예요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e\"use server\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { revalidateTag } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"next/cache\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esubmit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eaddPost\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 새로운 포스트를 추가하는 비동기 함수\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003erevalidateTag\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"my-data\"\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 'my-data'라는 태그가 붙은 캐시를 재검증해서 최신으로 업데이트\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드에서 addPost()가 끝나면, 'my-data'라는 태그를 가진 캐시는 재검증돼서 이전 데이터가 아닌 새 데이터를 가져오도록 만드는 역할이에요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e알아두면 좋은 팁\u003c/h2\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e내용\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eIdempotent Tags\u003c/td\u003e\u003ctd\u003e동일한 태그를 여러 번 적용해도 추가적인 효과가 없어요. 중복 적용해도 무방해요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eMultiple Tags\u003c/td\u003e\u003ctd\u003e한 캐시 엔트리에 여러 태그를 붙일 수 있어요. 배열 형태로 태그들을 넘겨주면 됩니다.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e예를 들어 이렇게 사용해요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003ecacheTag\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"tag-one\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"tag-two\"\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위와 같이 여러 태그를 한 번에 붙이면, 이 캐시 항목이 두 가지 태그에 묶여서 둘 중 하나라도 변경될 경우 재검증됩니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e개인적으로 추가로 알려드릴 점!\u003c/h3\u003e\n\u003cp\u003e캐시 태그를 이렇게 사용하면 무조건 캐시 무효화(invalidation)를 하느니, 필요한 부분만 선별적으로 업데이트하는 '스마트 캐싱' 전략을 세우기 좋아요. 데이터가 자주 변하는 서비스에서는 서버 성능과 유저 경험을 둘 다 잡기 위해 꼭 익혀야 하는 기능입니다.\u003c/p\u003e\n\u003cp\u003eNext.js 13+ 버전에서 제공하는 이 기능을 잘 활용하면, SSR(Server Side Rendering) 혹은 ISR(Incremental Static Regeneration) 환경에서도 원하는 타이밍에 효율적으로 데이터를 업데이트할 수 있어요. 번거로운 캐시 조작을 줄이고, 최신 데이터도 놓치지 않게 해주는 아주 쓸모 있는 기능이죠!\u003c/p\u003e\n\u003cp\u003e필요하시면 addPost() 같은 함수 내부 구현도 같이 다뤄볼테니, 언제든 질문 주세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e예제\u003c/h2\u003e\n\u003ch3\u003e컴포넌트나 함수에 태그 달기\u003c/h3\u003e\n\u003cp\u003e캐시된 함수나 컴포넌트 안에서 \u003ccode\u003ecacheTag\u003c/code\u003e를 호출해서 캐시 데이터를 태그할 수 있어요. 이렇게 하면 캐시 관리가 좀 더 편리해지고, 특정 태그를 기준으로 캐시를 재검증하거나 삭제할 수 있답니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { unstable_cacheTag \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e cacheTag } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"next/cache\"\u003c/span\u003e;\n\ninterface \u003cspan class=\"hljs-title class_\"\u003eBookingsProps\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: string;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eBookings\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ type = \u003cspan class=\"hljs-string\"\u003e\"haircut\"\u003c/span\u003e }: BookingsProps\u003c/span\u003e) {\n  \u003cspan class=\"hljs-string\"\u003e\"use cache\"\u003c/span\u003e;\n  \u003cspan class=\"hljs-title function_\"\u003ecacheTag\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"bookings-data\"\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetBookingsData\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e data = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`/api/bookings?type=\u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-built_in\"\u003eencodeURIComponent\u003c/span\u003e(type)}\u003c/span\u003e`\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e data;\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e//...\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003cp\u003e여기서 중요한 포인트는 \u003ccode\u003e'use cache'\u003c/code\u003e라는 디렉티브를 함수 최상단에 써서 이 함수가 캐싱 기능을 사용할 거라고 알려준다는 점이에요. 그리고 \u003ccode\u003ecacheTag('bookings-data')\u003c/code\u003e를 호출해서 이 함수가 반환하는 데이터에 \u003ccode\u003ebookings-data\u003c/code\u003e라는 태그를 붙이는 거죠.\u003c/p\u003e\n\u003cp\u003e이렇게 태그를 달아두면, 나중에 \u003ccode\u003ebookings-data\u003c/code\u003e 태그가 붙은 캐시들을 한꺼번에 무효화하거나 업데이트할 때 훨씬 편리해져요.\u003c/p\u003e\n\u003cp\u003e또한 참고할 점은, 이 기능이 아직 불안정(\u003ccode\u003eunstable\u003c/code\u003e)한 API이므로, 앞으로 변경될 가능성이 있다는 점이에요. 그래도 Next.js 같은 최신 프레임워크에서 제공하는 기능을 미리 써보면서 경험해보는 것도 좋겠죠?\u003c/p\u003e\n\u003cp\u003e추가로, 만약 다양한 타입의 예약 데이터를 관리해야 한다면 태그 이름을 \u003ccode\u003ebookings-data:${type}\u003c/code\u003e 같은 식으로 동적으로 생성하는 것도 좋은 방법이에요. 이렇게 하면 특정 타입만 골라서 캐시를 제어할 수 있거든요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003e외부 데이터로부터 태그 만들기\u003c/h3\u003e\n\u003cp\u003e비동기 함수(async function)에서 반환된 데이터를 이용해서 캐시 항목에 태그를 붙일 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { unstable_cacheTag \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e cacheTag } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"next/cache\"\u003c/span\u003e;\n\ninterface \u003cspan class=\"hljs-title class_\"\u003eBookingsProps\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: string;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eBookings\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ type = \u003cspan class=\"hljs-string\"\u003e\"haircut\"\u003c/span\u003e }: BookingsProps\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetBookingsData\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-string\"\u003e\"use cache\"\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 캐시 활용을 위한 지시어\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e data = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`/api/bookings?type=\u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-built_in\"\u003eencodeURIComponent\u003c/span\u003e(type)}\u003c/span\u003e`\u003c/span\u003e);\n    \u003cspan class=\"hljs-title function_\"\u003ecacheTag\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"bookings-data\"\u003c/span\u003e, data.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 받은 데이터의 id를 태그값으로 지정\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e data;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e//...\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 중요한 포인트는 \u003ccode\u003ecacheTag\u003c/code\u003e를 사용해 데이터를 태그함으로써 특정 조건에 따라 캐시를 더 정밀하게 관리할 수 있다는 거예요. 예를 들어, 예약 타입별로 캐시를 구분하거나 데이터 ID별로 캐시 무효화를 쉽게 할 수 있죠.\u003c/p\u003e\n\u003cp\u003e그리고 \u003ccode\u003euse cache\u003c/code\u003e라는 키워드가 보이죠? 이건 Next.js가 이 함수 결과를 캐싱하도록 알려주는 역할을 합니다. 실제 프로젝트에서는 이렇게 재사용 가능한 데이터를 효율적으로 다룰 때 꼭 활용해보세요!\u003c/p\u003e\n\u003ch3\u003e태그된 캐시 무효화하기\u003c/h3\u003e\n\u003cp\u003e작성한 태그를 기반으로 캐시를 무효화해 특정 데이터가 변경되었을 때 최신 상태를 유지할 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { unstable_invalidateCacheTag \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e invalidateCacheTag } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"next/cache\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003einvalidateBookingCache\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eid: string\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 'bookings-data'라는 태그에 id 값으로 붙인 캐시를 무효화합니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003einvalidateCacheTag\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"bookings-data\"\u003c/span\u003e, id);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 태그 단위로 캐시를 무효화하면, 불필요한 전체 캐시 초기화 없이 원하는 부분만 갱신 가능해져서 효율적이에요. 만약 데이터 변경 이벤트가 발생하면 이 함수를 호출해 관련 캐시를 리프레시하는 방식으로 활용하면 됩니다.\u003c/p\u003e\n\u003cp\u003e캐시 태그 활용법은 Next.js 13버전 이후의 캐시 전략에서 굉장히 강력한 기능 중 하나이니 꼭 익혀두세요! 개발하며 때때로 캐시 데이터가 꼬일 때 이 방법으로 깔끔하게 관리할 수 있습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e'revalidateTag'를 사용하면 필요한 시점에 특정 태그의 캐시를 무효화해서 최신 데이터를 반영할 수 있어요. 예를 들어, 아래 코드처럼 'bookings-data'라는 태그에 달려있는 캐시를 갱신해줄 수 있죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e\"use server\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { revalidateTag } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"next/cache\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eupdateBookings\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eupdateBookingData\u003c/span\u003e();\n  \u003cspan class=\"hljs-title function_\"\u003erevalidateTag\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"bookings-data\"\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e간단히 말해, updateBookingData() 함수가 예약 데이터를 업데이트한 뒤에 revalidateTag('bookings-data')를 호출하면, Next.js가 그 태그에 연결된 캐시를 무효화해서 사용자들에게 최신 정보를 보여주게 됩니다.\u003c/p\u003e\n\u003cp\u003e여기서 중요한 점은, 캐시 무효화를 태그 단위로 관리할 수 있다는 거예요. 덕분에 전체 페이지 캐시를 다 날리지 않고도, 특정 데이터 부분만 신속하게 업데이트할 수 있으니 효율적이죠!\u003c/p\u003e\n\u003cp\u003e추가로, revalidateTag는 서버 컴포넌트나 API 라우트 등 서버 측 코드에서만 사용 가능하다는 점도 기억해 주세요. 클라이언트 측에서는 사용할 수 없고, 반드시 'use server' directive가 있어야 합니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2025-04-22-cacheTag"},"buildId":"olPs1cVezSGTqD7OaewDI","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>