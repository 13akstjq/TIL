<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Nextjs 15에서 unauthorized 함수 권한 처리하는 방법 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-unauthorized" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Nextjs 15에서 unauthorized 함수 권한 처리하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:title" content="Nextjs 15에서 unauthorized 함수 권한 처리하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-unauthorized" data-gatsby-head="true"/><meta name="twitter:title" content="Nextjs 15에서 unauthorized 함수 권한 처리하는 방법 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2025-04-22 12:47" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-8ded8b979ba73586.js" defer=""></script><script src="/TIL/_next/static/X4OrKfmLtU3-3BijwfHe6/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/X4OrKfmLtU3-3BijwfHe6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Nextjs 15에서 unauthorized 함수 권한 처리하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Nextjs 15에서 unauthorized 함수 권한 처리하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Apr 22, 2025</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>unauthorized 함수 사용법</h1>
<p>Next.js에서 <code>unauthorized</code> 함수는 권한 문제가 발생했을 때 401 에러 페이지를 보여주는 역할을 해요. 즉, 사용자가 인증되지 않았을 경우에 적절히 오류를 처리할 수 있게 도와주는 거죠. 특히 인증 오류가 생겼을 때 기본으로 제공되는 UI 말고, 직접 <code>unauthorized.js</code> 파일을 만들어서 커스텀 디자인으로 바꿔줄 수도 있어요!</p>
<h3>사용 준비: experimental 옵션 켜기</h3>
<p>이 <code>unauthorized</code> 함수 기능을 사용하려면, <code>next.config.js</code> 파일에 실험적 기능인 <code>authInterrupts</code> 옵션을 활성화해줘야 해요. 설정 방법은 간단해요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> type { <span class="hljs-title class_">NextConfig</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'next'</span>

<span class="hljs-keyword">const</span> <span class="hljs-attr">nextConfig</span>: <span class="hljs-title class_">NextConfig</span> = {
  <span class="hljs-attr">experimental</span>: {
    <span class="hljs-attr">authInterrupts</span>: <span class="hljs-literal">true</span>,
  },
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> nextConfig
</code></pre>
<p>이 옵션을 켜면 Next.js가 인증 관련 오류를 감지하고 자동으로 401 페이지를 렌더링해줘서, 훨씬 깔끔하게 권한 문제를 관리할 수 있습니다.</p>
<hr>
<h3>조금 더 알아보기</h3>
<ul>
<li><code>unauthorized.js</code> 파일을 통해 원하는 스타일이나 메시지로 401 페이지를 커스터마이징할 수 있으니, 사용자 경험에 맞게 꼭 만들어보세요!</li>
<li>이 기능은 Next.js 최신 버전에서 실험적으로 제공되고 있으니, 업데이트 내용과 안정성은 공식 문서를 계속 체크하는 게 좋아요.</li>
<li>만약 인증이 필수인 페이지에서 <code>unauthorized()</code>를 호출하면, 자동으로 401 페이지로 넘어가므로 별도의 라우팅 처리가 필요 없답니다.</li>
</ul>
<p>이제 <code>unauthorized</code> 함수로 인증 이슈를 더 쉽게 처리할 수 있으니, 다음 프로젝트에 바로 적용해 보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이번에는 Next.js에서 인증 처리를 할 때 유용한 <code>unauthorized</code> 함수 사용법에 대해 살펴볼게요.</p>
<hr>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { verifySession } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/app/lib/dal'</span>
<span class="hljs-keyword">import</span> { unauthorized } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/navigation'</span>
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">DashboardPage</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> session = <span class="hljs-keyword">await</span> <span class="hljs-title function_">verifySession</span>()
 
  <span class="hljs-keyword">if</span> (!session) {
    <span class="hljs-title function_">unauthorized</span>()
  }
 
  <span class="hljs-comment">// 로그인 된 사용자에게 대시보드 보여주기</span>
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">main</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>Welcome to the Dashboard<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>Hi, {session.user.name}.<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">main</span>></span></span>
  )
}
</code></pre>
<p>위 코드는 서버 컴포넌트(Server Component)에서 세션을 확인하고, 인증된 사용자가 아니라면 <code>unauthorized()</code> 함수를 호출해서 접근을 차단하는 예제입니다. <code>unauthorized()</code>가 호출되면 보통 401 Unauthorized 상태 코드가 리턴되면서 페이지가 차단돼요.</p>
<p>여기서 중요한 점은 <code>unauthorized</code> 함수가 <strong>Server Components, Server Actions, Route Handlers에서만 호출 가능하다</strong>는 거예요. 그래서 클라이언트 컴포넌트나 루트 레이아웃(root layout) 같은 데서는 사용할 수 없으니 참고하세요!</p>
<hr>
<h3>조금 더 알아보기</h3>
<ul>
<li><code>unauthorized()</code> 함수는 Next.js의 라우팅 시스템과 자연스럽게 연동돼서 인증되지 않은 사용자를 즉시 차단해줍니다.</li>
<li>서버쪽에서 인증 로직을 처리하면 클라이언트로 불필요한 데이터가 노출되는 걸 막을 수 있어서 보안이 강화돼요.</li>
<li>루트 레이아웃에서는 인증 처리 로직 대신, 페이지별로 인증 컴포넌트를 따로 구분해서 사용하는 게 일반적입니다.</li>
</ul>
<hr>
<p>이처럼 서버 컴포넌트에서 인증 제어를 하면서 사용자 경험도 자연스럽게 유지할 수 있으니, Next.js에서 인증 문제를 다룰 땐 이 방법을 꼭 활용해보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>예제들</h2>
<h3>로그인하지 않은 사용자에게 로그인 UI 보여주기</h3>
<p>로그인하지 않은 사용자에게 로그인 UI를 보여주고 싶을 때는 <code>unauthorized</code> 함수를 활용할 수 있어요. 이 함수는 <code>unauthorized.js</code> 파일을 렌더링하는 역할을 하죠.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { verifySession } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/app/lib/dal'</span>
<span class="hljs-keyword">import</span> { unauthorized } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/navigation'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">DashboardPage</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> session = <span class="hljs-keyword">await</span> <span class="hljs-title function_">verifySession</span>()

  <span class="hljs-keyword">if</span> (!session) {
    <span class="hljs-title function_">unauthorized</span>()
  }

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>Dashboard<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}
</code></pre>
<p>위 코드에서 <code>verifySession()</code>은 사용자의 세션을 확인하는 함수에요. 세션이 없으면(즉, 로그인하지 않은 상태면) <code>unauthorized()</code>를 호출해서 로그인 페이지 같은 별도의 UI를 보여줍니다.</p>
<hr>
<p>조금 덧붙이자면, <code>unauthorized()</code>를 호출하면 보통 Next.js 앱에서 미리 정의해둔 로그인 화면으로 리다이렉트하거나 특정 컴포넌트를 렌더링하도록 설정해둔 경우가 많아요. 따라서 이 함수를 통해 인증되지 않은 사용자의 접근을 깔끔하게 차단하고, 친절한 로그인 유도 화면을 보여줄 수 있죠.</p>
<p>더불어, <code>verifySession</code> 같은 인증 관련 함수는 보통 서버 측에서 세션이나 토큰을 확인해서 로그인 상태를 판단하는데, Next.js의 서버 컴포넌트나 API 라우트에서 많이 사용됩니다. 만약 클라이언트 측에서 인증 상태를 확인해야 한다면, React의 상태 관리나 Context API와 같은 방법도 함께 사용하곤 합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이번 글에서는 Next.js에서 인증되지 않은 사용자에게 401 Unauthorized 페이지를 보여주고, 서버 액션(Server Actions)에서 인증 검증을 하는 방법을 다뤄볼게요.</p>
<h2>401 Unauthorized 페이지 만들기</h2>
<p>먼저, 인증되지 않은 사용자가 접근했을 때 보여줄 페이지를 만들어볼게요. <code>UnauthorizedPage</code> 컴포넌트는 이렇게 생겼어요.</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Login</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'@/app/components/Login'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">UnauthorizedPage</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">main</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>401 - Unauthorized<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>이 페이지에 접근하려면 로그인이 필요해요.<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">Login</span> /></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">main</span>></span></span>
  )
}
</code></pre>
<p>여기서 중요한 점은 <code>Login</code> 컴포넌트를 함께 렌더링해서, 사용자가 바로 로그인할 수 있는 UI를 제공하는 거예요. 사용자 경험이 훨씬 좋아지겠죠? 만약 로그인 UI가 별도로 없다면, 간단한 로그인 버튼이나 링크를 만들어도 괜찮아요.</p>
<h2>서버 액션에서 인증 검사하기</h2>
<p>이제 조금 더 심화된 내용으로, Next.js의 서버 액션(Server Actions)을 활용해 인증된 사용자만 특정 작업(예: 프로필 업데이트)을 할 수 있도록 제한하는 코드를 알아볼게요.</p>
<pre><code class="hljs language-js"><span class="hljs-string">'use server'</span>

<span class="hljs-keyword">import</span> { verifySession } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/app/lib/dal'</span>
<span class="hljs-keyword">import</span> { unauthorized } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/navigation'</span>
<span class="hljs-keyword">import</span> db <span class="hljs-keyword">from</span> <span class="hljs-string">'@/app/lib/db'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateProfile</span>(<span class="hljs-params">data: FormData</span>) {
  <span class="hljs-keyword">const</span> session = <span class="hljs-keyword">await</span> <span class="hljs-title function_">verifySession</span>()

  <span class="hljs-comment">// 인증되지 않은 경우 401 에러로 처리</span>
  <span class="hljs-keyword">if</span> (!session) {
    <span class="hljs-title function_">unauthorized</span>()
  }

  <span class="hljs-comment">// 인증된 경우 mutation 로직 진행</span>
  <span class="hljs-comment">// 실제 업데이트 로직 작성</span>
}
</code></pre>
<h3>여기서 주목할 점!</h3>
<ul>
<li><code>verifySession()</code> 함수는 사용자의 세션 정보를 확인해주는 커스텀 함수예요. 일반적으로 토큰이나 쿠키 정보를 검증해서 로그인 상태를 판단합니다.</li>
<li><code>unauthorized()</code> 함수는 Next.js 내장 네비게이션 함수로, 호출 시 401 Unauthorized 상태를 반환하고 해당 페이지로 리다이렉트해줍니다.</li>
<li>이렇게 하면 클라이언트 사이드에서 무작정 요청이 들어오는 걸 방지하고, 서버단에서 확실하게 검증할 수 있겠죠?</li>
</ul>
<hr>
<h3>추가 팁</h3>
<ul>
<li>서버 액션은 React Server Components와 매우 잘 어울립니다. 서버에서 바로 데이터를 검증하고 변경할 수 있어 보안성을 높일 수 있어요.</li>
<li>만약 더 복잡한 인증 로직(예: 권한 레벨, 역할 기반 접근 제어 등)을 추가해야 한다면, <code>verifySession()</code> 함수 확장과 함께 별도의 미들웨어를 만들어 관리하는 걸 추천합니다.</li>
<li>에러 페이지 UI를 꾸밀 때는 사용자가 왜 접근이 제한됐는지 명확히 알 수 있도록 친절한 메시지를 넣는 게 좋아요.</li>
</ul>
<hr>
<p>이번 포스트를 통해 Next.js 13+에서 인증 관련 에러 핸들링과 서버 액션 내 인증 체크를 어떻게 구현하는지 감 잡으셨으면 좋겠네요! 실제로 적용해보면서 필요한 부분을 커스터마이즈해 보세요. 궁금한 점 있으면 댓글로 남겨주세요 :)</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>Route Handlers에서 데이터 가져오기</h3>
<p>Next.js에서 Route Handlers를 사용하면 인증된 사용자만 특정 API 엔드포인트에 접근하도록 쉽게 제한할 수 있어요. 특히, <code>unauthorized</code> 함수를 활용하면 인증이 안 된 사용자는 자동으로 401 에러 페이지를 보여주도록 할 수 있답니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">NextRequest</span>, <span class="hljs-title class_">NextResponse</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/server'</span>
<span class="hljs-keyword">import</span> { verifySession } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/app/lib/dal'</span>
<span class="hljs-keyword">import</span> { unauthorized } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/navigation'</span>
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">GET</span>(<span class="hljs-params">req: NextRequest</span>): <span class="hljs-title class_">Promise</span>&#x3C;<span class="hljs-title class_">NextResponse</span>> {
  <span class="hljs-comment">// 사용자의 세션을 검증합니다.</span>
  <span class="hljs-keyword">const</span> session = <span class="hljs-keyword">await</span> <span class="hljs-title function_">verifySession</span>()
 
  <span class="hljs-comment">// 세션이 없으면 401 상태 코드를 반환하면서 unauthorized.tsx 컴포넌트를 렌더링합니다.</span>
  <span class="hljs-keyword">if</span> (!session) {
    <span class="hljs-title function_">unauthorized</span>()
  }
 
  <span class="hljs-comment">// 필요한 데이터를 가져오는 로직을 작성하세요.</span>
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>이렇게 하면 인증이 되어야만 GET 요청에 접근할 수 있죠. <code>unauthorized()</code>를 호출하면 Next.js가 자동으로 401 상태와 함께 지정한 <code>unauthorized.tsx</code> 페이지를 보여주니까, 사용자 경험도 좋고 보안도 챙길 수 있어요.</p>
<p>추가로, <code>verifySession()</code> 같은 함수는 여러분 프로젝트 상황에 맞게 세션 검증 로직을 작성해야 하는데, 보통은 JWT 토큰 검사, 쿠키 확인, 데이터베이스 조회 같은 작업이 포함될 수 있어요. 인증 체크 로직이 서버 사이드에서 확실히 구동되니 클라이언트보다 훨씬 안전하답니다.</p>
<p><strong>참고:</strong> <code>unauthorized()</code>는 라우트 핸들러에서 사용 가능한 함수로, 이 함수 호출 이후에는 응답을 작성하지 않아도 Next.js가 알아서 401 응답을 처리해 줘요.</p>
<hr>
<p>다음에는 이 기능이 어떤 버전부터 지원되는지, 그리고 더 복잡한 인증 시나리오들에 대해 이야기해볼게요. 개발하면서 궁금한 점이 있으면 언제든 질문해 주세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>













<table><thead><tr><th>Version</th><th>Changes</th></tr></thead><tbody><tr><td><code>v15.1.0</code></td><td><code>unauthorized</code> introduced.</td></tr></tbody></table>
<p>여기서 <code>unauthorized</code>라는 게 새로 추가됐다고 해요. 보통 웹 개발이나 API 쪽에서 <code>unauthorized</code>는 인증이 필요한 리소스에 대해 권한이 없을 때 발생하는 상태를 말하는데요. 이번 버전(<code>v15.1.0</code>)에 이 기능이나 상태가 새로 추가된 듯해요. API를 다루다 보면 401 Unauthorized 상태 코드를 다루는 일이 많으니, 이 부분을 참고해두면 좋아요! 만약 이 변화가 특정 라이브러리나 프레임워크에 관한 거라면, 공식 문서를 한 번 확인해서 구체적인 사용법도 알아두면 도움이 될 거예요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Nextjs 15에서 unauthorized 함수 권한 처리하는 방법","description":"","date":"2025-04-22 12:47","slug":"2025-04-22-unauthorized","content":"\n\n# unauthorized 함수 사용법\n\nNext.js에서 `unauthorized` 함수는 권한 문제가 발생했을 때 401 에러 페이지를 보여주는 역할을 해요. 즉, 사용자가 인증되지 않았을 경우에 적절히 오류를 처리할 수 있게 도와주는 거죠. 특히 인증 오류가 생겼을 때 기본으로 제공되는 UI 말고, 직접 `unauthorized.js` 파일을 만들어서 커스텀 디자인으로 바꿔줄 수도 있어요!\n\n### 사용 준비: experimental 옵션 켜기\n\n이 `unauthorized` 함수 기능을 사용하려면, `next.config.js` 파일에 실험적 기능인 `authInterrupts` 옵션을 활성화해줘야 해요. 설정 방법은 간단해요:\n\n```js\nimport type { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  experimental: {\n    authInterrupts: true,\n  },\n}\n\nexport default nextConfig\n```\n\n이 옵션을 켜면 Next.js가 인증 관련 오류를 감지하고 자동으로 401 페이지를 렌더링해줘서, 훨씬 깔끔하게 권한 문제를 관리할 수 있습니다.\n\n---\n\n### 조금 더 알아보기\n\n- `unauthorized.js` 파일을 통해 원하는 스타일이나 메시지로 401 페이지를 커스터마이징할 수 있으니, 사용자 경험에 맞게 꼭 만들어보세요!\n- 이 기능은 Next.js 최신 버전에서 실험적으로 제공되고 있으니, 업데이트 내용과 안정성은 공식 문서를 계속 체크하는 게 좋아요.\n- 만약 인증이 필수인 페이지에서 `unauthorized()`를 호출하면, 자동으로 401 페이지로 넘어가므로 별도의 라우팅 처리가 필요 없답니다.\n\n이제 `unauthorized` 함수로 인증 이슈를 더 쉽게 처리할 수 있으니, 다음 프로젝트에 바로 적용해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번에는 Next.js에서 인증 처리를 할 때 유용한 `unauthorized` 함수 사용법에 대해 살펴볼게요.\n\n---\n\n```js\nimport { verifySession } from '@/app/lib/dal'\nimport { unauthorized } from 'next/navigation'\n \nexport default async function DashboardPage() {\n  const session = await verifySession()\n \n  if (!session) {\n    unauthorized()\n  }\n \n  // 로그인 된 사용자에게 대시보드 보여주기\n  return (\n    \u003cmain\u003e\n      \u003ch1\u003eWelcome to the Dashboard\u003c/h1\u003e\n      \u003cp\u003eHi, {session.user.name}.\u003c/p\u003e\n    \u003c/main\u003e\n  )\n}\n```\n\n위 코드는 서버 컴포넌트(Server Component)에서 세션을 확인하고, 인증된 사용자가 아니라면 `unauthorized()` 함수를 호출해서 접근을 차단하는 예제입니다. `unauthorized()`가 호출되면 보통 401 Unauthorized 상태 코드가 리턴되면서 페이지가 차단돼요.\n\n여기서 중요한 점은 `unauthorized` 함수가 **Server Components, Server Actions, Route Handlers에서만 호출 가능하다**는 거예요. 그래서 클라이언트 컴포넌트나 루트 레이아웃(root layout) 같은 데서는 사용할 수 없으니 참고하세요!\n\n---\n\n### 조금 더 알아보기\n\n- `unauthorized()` 함수는 Next.js의 라우팅 시스템과 자연스럽게 연동돼서 인증되지 않은 사용자를 즉시 차단해줍니다.\n- 서버쪽에서 인증 로직을 처리하면 클라이언트로 불필요한 데이터가 노출되는 걸 막을 수 있어서 보안이 강화돼요.\n- 루트 레이아웃에서는 인증 처리 로직 대신, 페이지별로 인증 컴포넌트를 따로 구분해서 사용하는 게 일반적입니다.\n\n---\n\n이처럼 서버 컴포넌트에서 인증 제어를 하면서 사용자 경험도 자연스럽게 유지할 수 있으니, Next.js에서 인증 문제를 다룰 땐 이 방법을 꼭 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 예제들\n\n### 로그인하지 않은 사용자에게 로그인 UI 보여주기\n\n로그인하지 않은 사용자에게 로그인 UI를 보여주고 싶을 때는 `unauthorized` 함수를 활용할 수 있어요. 이 함수는 `unauthorized.js` 파일을 렌더링하는 역할을 하죠.\n\n```js\nimport { verifySession } from '@/app/lib/dal'\nimport { unauthorized } from 'next/navigation'\n\nexport default async function DashboardPage() {\n  const session = await verifySession()\n\n  if (!session) {\n    unauthorized()\n  }\n\n  return \u003cdiv\u003eDashboard\u003c/div\u003e\n}\n```\n\n위 코드에서 `verifySession()`은 사용자의 세션을 확인하는 함수에요. 세션이 없으면(즉, 로그인하지 않은 상태면) `unauthorized()`를 호출해서 로그인 페이지 같은 별도의 UI를 보여줍니다.\n\n---\n\n조금 덧붙이자면, `unauthorized()`를 호출하면 보통 Next.js 앱에서 미리 정의해둔 로그인 화면으로 리다이렉트하거나 특정 컴포넌트를 렌더링하도록 설정해둔 경우가 많아요. 따라서 이 함수를 통해 인증되지 않은 사용자의 접근을 깔끔하게 차단하고, 친절한 로그인 유도 화면을 보여줄 수 있죠.\n\n더불어, `verifySession` 같은 인증 관련 함수는 보통 서버 측에서 세션이나 토큰을 확인해서 로그인 상태를 판단하는데, Next.js의 서버 컴포넌트나 API 라우트에서 많이 사용됩니다. 만약 클라이언트 측에서 인증 상태를 확인해야 한다면, React의 상태 관리나 Context API와 같은 방법도 함께 사용하곤 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번 글에서는 Next.js에서 인증되지 않은 사용자에게 401 Unauthorized 페이지를 보여주고, 서버 액션(Server Actions)에서 인증 검증을 하는 방법을 다뤄볼게요.\n\n## 401 Unauthorized 페이지 만들기\n\n먼저, 인증되지 않은 사용자가 접근했을 때 보여줄 페이지를 만들어볼게요. `UnauthorizedPage` 컴포넌트는 이렇게 생겼어요.\n\n```jsx\nimport Login from '@/app/components/Login'\n\nexport default function UnauthorizedPage() {\n  return (\n    \u003cmain\u003e\n      \u003ch1\u003e401 - Unauthorized\u003c/h1\u003e\n      \u003cp\u003e이 페이지에 접근하려면 로그인이 필요해요.\u003c/p\u003e\n      \u003cLogin /\u003e\n    \u003c/main\u003e\n  )\n}\n```\n\n여기서 중요한 점은 `Login` 컴포넌트를 함께 렌더링해서, 사용자가 바로 로그인할 수 있는 UI를 제공하는 거예요. 사용자 경험이 훨씬 좋아지겠죠? 만약 로그인 UI가 별도로 없다면, 간단한 로그인 버튼이나 링크를 만들어도 괜찮아요.\n\n## 서버 액션에서 인증 검사하기\n\n이제 조금 더 심화된 내용으로, Next.js의 서버 액션(Server Actions)을 활용해 인증된 사용자만 특정 작업(예: 프로필 업데이트)을 할 수 있도록 제한하는 코드를 알아볼게요.\n\n```js\n'use server'\n\nimport { verifySession } from '@/app/lib/dal'\nimport { unauthorized } from 'next/navigation'\nimport db from '@/app/lib/db'\n\nexport async function updateProfile(data: FormData) {\n  const session = await verifySession()\n\n  // 인증되지 않은 경우 401 에러로 처리\n  if (!session) {\n    unauthorized()\n  }\n\n  // 인증된 경우 mutation 로직 진행\n  // 실제 업데이트 로직 작성\n}\n```\n\n### 여기서 주목할 점!\n\n- `verifySession()` 함수는 사용자의 세션 정보를 확인해주는 커스텀 함수예요. 일반적으로 토큰이나 쿠키 정보를 검증해서 로그인 상태를 판단합니다.\n- `unauthorized()` 함수는 Next.js 내장 네비게이션 함수로, 호출 시 401 Unauthorized 상태를 반환하고 해당 페이지로 리다이렉트해줍니다.\n- 이렇게 하면 클라이언트 사이드에서 무작정 요청이 들어오는 걸 방지하고, 서버단에서 확실하게 검증할 수 있겠죠?\n\n---\n\n### 추가 팁\n\n- 서버 액션은 React Server Components와 매우 잘 어울립니다. 서버에서 바로 데이터를 검증하고 변경할 수 있어 보안성을 높일 수 있어요.\n- 만약 더 복잡한 인증 로직(예: 권한 레벨, 역할 기반 접근 제어 등)을 추가해야 한다면, `verifySession()` 함수 확장과 함께 별도의 미들웨어를 만들어 관리하는 걸 추천합니다.\n- 에러 페이지 UI를 꾸밀 때는 사용자가 왜 접근이 제한됐는지 명확히 알 수 있도록 친절한 메시지를 넣는 게 좋아요.\n\n---\n\n이번 포스트를 통해 Next.js 13+에서 인증 관련 에러 핸들링과 서버 액션 내 인증 체크를 어떻게 구현하는지 감 잡으셨으면 좋겠네요! 실제로 적용해보면서 필요한 부분을 커스터마이즈해 보세요. 궁금한 점 있으면 댓글로 남겨주세요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Route Handlers에서 데이터 가져오기\n\nNext.js에서 Route Handlers를 사용하면 인증된 사용자만 특정 API 엔드포인트에 접근하도록 쉽게 제한할 수 있어요. 특히, `unauthorized` 함수를 활용하면 인증이 안 된 사용자는 자동으로 401 에러 페이지를 보여주도록 할 수 있답니다.\n\n```js\nimport { NextRequest, NextResponse } from 'next/server'\nimport { verifySession } from '@/app/lib/dal'\nimport { unauthorized } from 'next/navigation'\n \nexport async function GET(req: NextRequest): Promise\u003cNextResponse\u003e {\n  // 사용자의 세션을 검증합니다.\n  const session = await verifySession()\n \n  // 세션이 없으면 401 상태 코드를 반환하면서 unauthorized.tsx 컴포넌트를 렌더링합니다.\n  if (!session) {\n    unauthorized()\n  }\n \n  // 필요한 데이터를 가져오는 로직을 작성하세요.\n  // ...\n}\n```\n\n이렇게 하면 인증이 되어야만 GET 요청에 접근할 수 있죠. `unauthorized()`를 호출하면 Next.js가 자동으로 401 상태와 함께 지정한 `unauthorized.tsx` 페이지를 보여주니까, 사용자 경험도 좋고 보안도 챙길 수 있어요.\n\n추가로, `verifySession()` 같은 함수는 여러분 프로젝트 상황에 맞게 세션 검증 로직을 작성해야 하는데, 보통은 JWT 토큰 검사, 쿠키 확인, 데이터베이스 조회 같은 작업이 포함될 수 있어요. 인증 체크 로직이 서버 사이드에서 확실히 구동되니 클라이언트보다 훨씬 안전하답니다.\n\n**참고:** `unauthorized()`는 라우트 핸들러에서 사용 가능한 함수로, 이 함수 호출 이후에는 응답을 작성하지 않아도 Next.js가 알아서 401 응답을 처리해 줘요.\n\n---\n\n다음에는 이 기능이 어떤 버전부터 지원되는지, 그리고 더 복잡한 인증 시나리오들에 대해 이야기해볼게요. 개발하면서 궁금한 점이 있으면 언제든 질문해 주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n| Version   | Changes                 |\n|-----------|-------------------------|\n| `v15.1.0` | `unauthorized` introduced. |\n\n여기서 `unauthorized`라는 게 새로 추가됐다고 해요. 보통 웹 개발이나 API 쪽에서 `unauthorized`는 인증이 필요한 리소스에 대해 권한이 없을 때 발생하는 상태를 말하는데요. 이번 버전(`v15.1.0`)에 이 기능이나 상태가 새로 추가된 듯해요. API를 다루다 보면 401 Unauthorized 상태 코드를 다루는 일이 많으니, 이 부분을 참고해두면 좋아요! 만약 이 변화가 특정 라이브러리나 프레임워크에 관한 거라면, 공식 문서를 한 번 확인해서 구체적인 사용법도 알아두면 도움이 될 거예요.","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":8},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003eunauthorized 함수 사용법\u003c/h1\u003e\n\u003cp\u003eNext.js에서 \u003ccode\u003eunauthorized\u003c/code\u003e 함수는 권한 문제가 발생했을 때 401 에러 페이지를 보여주는 역할을 해요. 즉, 사용자가 인증되지 않았을 경우에 적절히 오류를 처리할 수 있게 도와주는 거죠. 특히 인증 오류가 생겼을 때 기본으로 제공되는 UI 말고, 직접 \u003ccode\u003eunauthorized.js\u003c/code\u003e 파일을 만들어서 커스텀 디자인으로 바꿔줄 수도 있어요!\u003c/p\u003e\n\u003ch3\u003e사용 준비: experimental 옵션 켜기\u003c/h3\u003e\n\u003cp\u003e이 \u003ccode\u003eunauthorized\u003c/code\u003e 함수 기능을 사용하려면, \u003ccode\u003enext.config.js\u003c/code\u003e 파일에 실험적 기능인 \u003ccode\u003eauthInterrupts\u003c/code\u003e 옵션을 활성화해줘야 해요. 설정 방법은 간단해요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e type { \u003cspan class=\"hljs-title class_\"\u003eNextConfig\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003enextConfig\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eNextConfig\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eexperimental\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003eauthInterrupts\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  },\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e nextConfig\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 옵션을 켜면 Next.js가 인증 관련 오류를 감지하고 자동으로 401 페이지를 렌더링해줘서, 훨씬 깔끔하게 권한 문제를 관리할 수 있습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e조금 더 알아보기\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eunauthorized.js\u003c/code\u003e 파일을 통해 원하는 스타일이나 메시지로 401 페이지를 커스터마이징할 수 있으니, 사용자 경험에 맞게 꼭 만들어보세요!\u003c/li\u003e\n\u003cli\u003e이 기능은 Next.js 최신 버전에서 실험적으로 제공되고 있으니, 업데이트 내용과 안정성은 공식 문서를 계속 체크하는 게 좋아요.\u003c/li\u003e\n\u003cli\u003e만약 인증이 필수인 페이지에서 \u003ccode\u003eunauthorized()\u003c/code\u003e를 호출하면, 자동으로 401 페이지로 넘어가므로 별도의 라우팅 처리가 필요 없답니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이제 \u003ccode\u003eunauthorized\u003c/code\u003e 함수로 인증 이슈를 더 쉽게 처리할 수 있으니, 다음 프로젝트에 바로 적용해 보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이번에는 Next.js에서 인증 처리를 할 때 유용한 \u003ccode\u003eunauthorized\u003c/code\u003e 함수 사용법에 대해 살펴볼게요.\u003c/p\u003e\n\u003chr\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { verifySession } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@/app/lib/dal'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { unauthorized } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/navigation'\u003c/span\u003e\n \n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eDashboardPage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e session = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003everifySession\u003c/span\u003e()\n \n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!session) {\n    \u003cspan class=\"hljs-title function_\"\u003eunauthorized\u003c/span\u003e()\n  }\n \n  \u003cspan class=\"hljs-comment\"\u003e// 로그인 된 사용자에게 대시보드 보여주기\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003emain\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003eWelcome to the Dashboard\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003eHi, {session.user.name}.\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003emain\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드는 서버 컴포넌트(Server Component)에서 세션을 확인하고, 인증된 사용자가 아니라면 \u003ccode\u003eunauthorized()\u003c/code\u003e 함수를 호출해서 접근을 차단하는 예제입니다. \u003ccode\u003eunauthorized()\u003c/code\u003e가 호출되면 보통 401 Unauthorized 상태 코드가 리턴되면서 페이지가 차단돼요.\u003c/p\u003e\n\u003cp\u003e여기서 중요한 점은 \u003ccode\u003eunauthorized\u003c/code\u003e 함수가 \u003cstrong\u003eServer Components, Server Actions, Route Handlers에서만 호출 가능하다\u003c/strong\u003e는 거예요. 그래서 클라이언트 컴포넌트나 루트 레이아웃(root layout) 같은 데서는 사용할 수 없으니 참고하세요!\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e조금 더 알아보기\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eunauthorized()\u003c/code\u003e 함수는 Next.js의 라우팅 시스템과 자연스럽게 연동돼서 인증되지 않은 사용자를 즉시 차단해줍니다.\u003c/li\u003e\n\u003cli\u003e서버쪽에서 인증 로직을 처리하면 클라이언트로 불필요한 데이터가 노출되는 걸 막을 수 있어서 보안이 강화돼요.\u003c/li\u003e\n\u003cli\u003e루트 레이아웃에서는 인증 처리 로직 대신, 페이지별로 인증 컴포넌트를 따로 구분해서 사용하는 게 일반적입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e이처럼 서버 컴포넌트에서 인증 제어를 하면서 사용자 경험도 자연스럽게 유지할 수 있으니, Next.js에서 인증 문제를 다룰 땐 이 방법을 꼭 활용해보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e예제들\u003c/h2\u003e\n\u003ch3\u003e로그인하지 않은 사용자에게 로그인 UI 보여주기\u003c/h3\u003e\n\u003cp\u003e로그인하지 않은 사용자에게 로그인 UI를 보여주고 싶을 때는 \u003ccode\u003eunauthorized\u003c/code\u003e 함수를 활용할 수 있어요. 이 함수는 \u003ccode\u003eunauthorized.js\u003c/code\u003e 파일을 렌더링하는 역할을 하죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { verifySession } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@/app/lib/dal'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { unauthorized } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/navigation'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eDashboardPage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e session = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003everifySession\u003c/span\u003e()\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!session) {\n    \u003cspan class=\"hljs-title function_\"\u003eunauthorized\u003c/span\u003e()\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003eDashboard\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드에서 \u003ccode\u003everifySession()\u003c/code\u003e은 사용자의 세션을 확인하는 함수에요. 세션이 없으면(즉, 로그인하지 않은 상태면) \u003ccode\u003eunauthorized()\u003c/code\u003e를 호출해서 로그인 페이지 같은 별도의 UI를 보여줍니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e조금 덧붙이자면, \u003ccode\u003eunauthorized()\u003c/code\u003e를 호출하면 보통 Next.js 앱에서 미리 정의해둔 로그인 화면으로 리다이렉트하거나 특정 컴포넌트를 렌더링하도록 설정해둔 경우가 많아요. 따라서 이 함수를 통해 인증되지 않은 사용자의 접근을 깔끔하게 차단하고, 친절한 로그인 유도 화면을 보여줄 수 있죠.\u003c/p\u003e\n\u003cp\u003e더불어, \u003ccode\u003everifySession\u003c/code\u003e 같은 인증 관련 함수는 보통 서버 측에서 세션이나 토큰을 확인해서 로그인 상태를 판단하는데, Next.js의 서버 컴포넌트나 API 라우트에서 많이 사용됩니다. 만약 클라이언트 측에서 인증 상태를 확인해야 한다면, React의 상태 관리나 Context API와 같은 방법도 함께 사용하곤 합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이번 글에서는 Next.js에서 인증되지 않은 사용자에게 401 Unauthorized 페이지를 보여주고, 서버 액션(Server Actions)에서 인증 검증을 하는 방법을 다뤄볼게요.\u003c/p\u003e\n\u003ch2\u003e401 Unauthorized 페이지 만들기\u003c/h2\u003e\n\u003cp\u003e먼저, 인증되지 않은 사용자가 접근했을 때 보여줄 페이지를 만들어볼게요. \u003ccode\u003eUnauthorizedPage\u003c/code\u003e 컴포넌트는 이렇게 생겼어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLogin\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@/app/components/Login'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eUnauthorizedPage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003emain\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e401 - Unauthorized\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e이 페이지에 접근하려면 로그인이 필요해요.\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eLogin\u003c/span\u003e /\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003emain\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 중요한 점은 \u003ccode\u003eLogin\u003c/code\u003e 컴포넌트를 함께 렌더링해서, 사용자가 바로 로그인할 수 있는 UI를 제공하는 거예요. 사용자 경험이 훨씬 좋아지겠죠? 만약 로그인 UI가 별도로 없다면, 간단한 로그인 버튼이나 링크를 만들어도 괜찮아요.\u003c/p\u003e\n\u003ch2\u003e서버 액션에서 인증 검사하기\u003c/h2\u003e\n\u003cp\u003e이제 조금 더 심화된 내용으로, Next.js의 서버 액션(Server Actions)을 활용해 인증된 사용자만 특정 작업(예: 프로필 업데이트)을 할 수 있도록 제한하는 코드를 알아볼게요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e'use server'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { verifySession } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@/app/lib/dal'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { unauthorized } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/navigation'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e db \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@/app/lib/db'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eupdateProfile\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edata: FormData\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e session = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003everifySession\u003c/span\u003e()\n\n  \u003cspan class=\"hljs-comment\"\u003e// 인증되지 않은 경우 401 에러로 처리\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!session) {\n    \u003cspan class=\"hljs-title function_\"\u003eunauthorized\u003c/span\u003e()\n  }\n\n  \u003cspan class=\"hljs-comment\"\u003e// 인증된 경우 mutation 로직 진행\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 실제 업데이트 로직 작성\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e여기서 주목할 점!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003everifySession()\u003c/code\u003e 함수는 사용자의 세션 정보를 확인해주는 커스텀 함수예요. 일반적으로 토큰이나 쿠키 정보를 검증해서 로그인 상태를 판단합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eunauthorized()\u003c/code\u003e 함수는 Next.js 내장 네비게이션 함수로, 호출 시 401 Unauthorized 상태를 반환하고 해당 페이지로 리다이렉트해줍니다.\u003c/li\u003e\n\u003cli\u003e이렇게 하면 클라이언트 사이드에서 무작정 요청이 들어오는 걸 방지하고, 서버단에서 확실하게 검증할 수 있겠죠?\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003e추가 팁\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e서버 액션은 React Server Components와 매우 잘 어울립니다. 서버에서 바로 데이터를 검증하고 변경할 수 있어 보안성을 높일 수 있어요.\u003c/li\u003e\n\u003cli\u003e만약 더 복잡한 인증 로직(예: 권한 레벨, 역할 기반 접근 제어 등)을 추가해야 한다면, \u003ccode\u003everifySession()\u003c/code\u003e 함수 확장과 함께 별도의 미들웨어를 만들어 관리하는 걸 추천합니다.\u003c/li\u003e\n\u003cli\u003e에러 페이지 UI를 꾸밀 때는 사용자가 왜 접근이 제한됐는지 명확히 알 수 있도록 친절한 메시지를 넣는 게 좋아요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e이번 포스트를 통해 Next.js 13+에서 인증 관련 에러 핸들링과 서버 액션 내 인증 체크를 어떻게 구현하는지 감 잡으셨으면 좋겠네요! 실제로 적용해보면서 필요한 부분을 커스터마이즈해 보세요. 궁금한 점 있으면 댓글로 남겨주세요 :)\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003eRoute Handlers에서 데이터 가져오기\u003c/h3\u003e\n\u003cp\u003eNext.js에서 Route Handlers를 사용하면 인증된 사용자만 특정 API 엔드포인트에 접근하도록 쉽게 제한할 수 있어요. 특히, \u003ccode\u003eunauthorized\u003c/code\u003e 함수를 활용하면 인증이 안 된 사용자는 자동으로 401 에러 페이지를 보여주도록 할 수 있답니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eNextRequest\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/server'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { verifySession } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@/app/lib/dal'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { unauthorized } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/navigation'\u003c/span\u003e\n \n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eGET\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ereq: NextRequest\u003c/span\u003e): \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// 사용자의 세션을 검증합니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e session = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003everifySession\u003c/span\u003e()\n \n  \u003cspan class=\"hljs-comment\"\u003e// 세션이 없으면 401 상태 코드를 반환하면서 unauthorized.tsx 컴포넌트를 렌더링합니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!session) {\n    \u003cspan class=\"hljs-title function_\"\u003eunauthorized\u003c/span\u003e()\n  }\n \n  \u003cspan class=\"hljs-comment\"\u003e// 필요한 데이터를 가져오는 로직을 작성하세요.\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 인증이 되어야만 GET 요청에 접근할 수 있죠. \u003ccode\u003eunauthorized()\u003c/code\u003e를 호출하면 Next.js가 자동으로 401 상태와 함께 지정한 \u003ccode\u003eunauthorized.tsx\u003c/code\u003e 페이지를 보여주니까, 사용자 경험도 좋고 보안도 챙길 수 있어요.\u003c/p\u003e\n\u003cp\u003e추가로, \u003ccode\u003everifySession()\u003c/code\u003e 같은 함수는 여러분 프로젝트 상황에 맞게 세션 검증 로직을 작성해야 하는데, 보통은 JWT 토큰 검사, 쿠키 확인, 데이터베이스 조회 같은 작업이 포함될 수 있어요. 인증 체크 로직이 서버 사이드에서 확실히 구동되니 클라이언트보다 훨씬 안전하답니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e참고:\u003c/strong\u003e \u003ccode\u003eunauthorized()\u003c/code\u003e는 라우트 핸들러에서 사용 가능한 함수로, 이 함수 호출 이후에는 응답을 작성하지 않아도 Next.js가 알아서 401 응답을 처리해 줘요.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e다음에는 이 기능이 어떤 버전부터 지원되는지, 그리고 더 복잡한 인증 시나리오들에 대해 이야기해볼게요. 개발하면서 궁금한 점이 있으면 언제든 질문해 주세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eVersion\u003c/th\u003e\u003cth\u003eChanges\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev15.1.0\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eunauthorized\u003c/code\u003e introduced.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e여기서 \u003ccode\u003eunauthorized\u003c/code\u003e라는 게 새로 추가됐다고 해요. 보통 웹 개발이나 API 쪽에서 \u003ccode\u003eunauthorized\u003c/code\u003e는 인증이 필요한 리소스에 대해 권한이 없을 때 발생하는 상태를 말하는데요. 이번 버전(\u003ccode\u003ev15.1.0\u003c/code\u003e)에 이 기능이나 상태가 새로 추가된 듯해요. API를 다루다 보면 401 Unauthorized 상태 코드를 다루는 일이 많으니, 이 부분을 참고해두면 좋아요! 만약 이 변화가 특정 라이브러리나 프레임워크에 관한 거라면, 공식 문서를 한 번 확인해서 구체적인 사용법도 알아두면 도움이 될 거예요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2025-04-22-unauthorized"},"buildId":"X4OrKfmLtU3-3BijwfHe6","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>