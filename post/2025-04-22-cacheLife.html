<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Next.js 15에서 cacheLife 설정하는 방법 및 캐시 수명 관리 방법 정리 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-cacheLife" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Next.js 15에서 cacheLife 설정하는 방법 및 캐시 수명 관리 방법 정리 | TIL" data-gatsby-head="true"/><meta property="og:title" content="Next.js 15에서 cacheLife 설정하는 방법 및 캐시 수명 관리 방법 정리 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-cacheLife" data-gatsby-head="true"/><meta name="twitter:title" content="Next.js 15에서 cacheLife 설정하는 방법 및 캐시 수명 관리 방법 정리 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2025-04-22 02:57" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/0eef537492fed77a.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/0eef537492fed77a.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-8ded8b979ba73586.js" defer=""></script><script src="/TIL/_next/static/M7pU9hOcx8u_ZIFMf95sd/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/M7pU9hOcx8u_ZIFMf95sd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Next.js 15에서 cacheLife 설정하는 방법 및 캐시 수명 관리 방법 정리</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Next.js 15에서 cacheLife 설정하는 방법 및 캐시 수명 관리 방법 정리" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Apr 22, 2025</span><span class="posts_reading_time__f7YPP">17<!-- --> min read</span></span></div></div></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>cacheLife 함수 알아보기</h1>
<p>안녕하세요, 개발 블로거입니다! 오늘은 <code>cacheLife</code>라는 함수에 대해 이야기해보려고 해요. 이 함수는 함수나 컴포넌트의 캐시 수명을 설정하는 데 쓰여요. 캐시 수명이란, 쉽게 말해 '데이터를 얼마나 오래 저장해서 재사용할지'를 결정하는 시간이죠.</p>
<p>이 <code>cacheLife</code> 함수는 <code>use cache</code> 지시어와 함께 사용해야 하며, 반드시 함수나 컴포넌트의 범위 안에서 호출해야 한다는 점 기억하세요.</p>
<h2>사용법</h2>
<p><code>cacheLife</code>를 사용하려면 우선 프로젝트 설정 파일인 <code>next.config.js</code>에 <code>dynamicIO</code> 플래그를 활성화해야 합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// next.config.js</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">experimental</span>: {
    <span class="hljs-attr">dynamicIO</span>: <span class="hljs-literal">true</span>,
  },
};
</code></pre>
<p>왜 이렇게 설정해야 하냐면, <code>dynamicIO</code> 플래그가 켜져야 동적인 입출력 처리와 캐싱 기능이 제대로 작동하기 때문이에요.</p>
<h3>참고로!</h3>
<p>만약 캐시를 너무 오래 유지하면 데이터가 오래된 상태일 수 있으니, 적절한 캐시 수명을 설정하는 게 중요해요. 반대로 너무 짧게 설정하면 캐시 효과가 떨어지고 서버 부하가 늘 수 있답니다.</p>
<p>추가로, React나 Next.js와 같은 프레임워크를 사용 중이라면, <code>cacheLife</code> 설정과 <code>use cache</code> 관련 지시어를 적절히 조합해 컴포넌트 렌더링 최적화를 도모할 수 있습니다.</p>
<p>다음에 좀 더 구체적인 사용 예제와 실전 팁을 공유할게요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이번에 Next.js에서 소개된 새로운 기능 중 하나인 <code>dynamicIO</code>와 <code>cacheLife</code>에 대해 간단히 살펴볼게요. 직접 써보고 정리한 내용이니 참고해서 프로젝트에 적용해봐도 좋을 것 같아요!</p>
<hr>
<h3><code>dynamicIO</code> Experimental 옵션 설정하기</h3>
<p>Next.js는 계속 발전 중이라 실험적인 기능도 종종 나옵니다. <code>dynamicIO</code>는 그중 하나인데, 이걸 켜면 IO 작업을 더 동적으로 처리할 수 있는 환경을 만들어줍니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> type { <span class="hljs-title class_">NextConfig</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"next"</span>;

<span class="hljs-keyword">const</span> <span class="hljs-attr">nextConfig</span>: <span class="hljs-title class_">NextConfig</span> = {
  <span class="hljs-attr">experimental</span>: {
    <span class="hljs-attr">dynamicIO</span>: <span class="hljs-literal">true</span>,
  },
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> nextConfig;
</code></pre>
<ul>
<li>위처럼 <code>next.config.js</code> 혹은 <code>next.config.ts</code>에서 <code>experimental.dynamicIO</code> 옵션을 <code>true</code>로 설정하면 돼요.</li>
<li>공식 문서에서는 이 옵션이 아직 실험 단계라서, 실제 서비스에서는 좀 더 안정화될 때까지 조심스럽게 사용하는 걸 권장합니다.</li>
</ul>
<hr>
<h3><code>cacheLife</code> 함수 사용하기</h3>
<p><code>cacheLife</code>는 Next.js에서 새롭게 제공하는 캐싱 관련 유틸리티예요. 특히 서버 컴포넌트나 함수 내에서 캐싱 수명을 관리할 때 유용하죠.</p>
<pre><code class="hljs language-js"><span class="hljs-string">"use cache"</span>;
<span class="hljs-keyword">import</span> { unstable_cacheLife <span class="hljs-keyword">as</span> cacheLife } <span class="hljs-keyword">from</span> <span class="hljs-string">"next/cache"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// cacheLife를 이용해 캐시 수명을 조절하는 로직 구현 가능</span>
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>Page<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>;
}
</code></pre>
<ul>
<li>여기서 <code>use cache</code>라는 디렉티브도 눈에 띄는데, 이건 Next.js가 해당 모듈을 캐싱 대상으로 인식하게 해줘요.</li>
<li><code>unstable_cacheLife</code>는 아직 실험적인 API라는 뜻이라, 이름 앞에 <code>unstable_</code>가 붙어 있어요.</li>
<li>이 함수를 활용하면, 필요한 부분의 캐시 유지 시간을 섬세하게 조절할 수 있어요. 예를 들어, 데이터 페칭 결과를 일정 시간 동안만 캐싱하고 싶을 때 유용하답니다.</li>
</ul>
<hr>
<h3>참고사항 및 팁</h3>

























<table><thead><tr><th>내용</th><th>설명</th></tr></thead><tbody><tr><td><code>dynamicIO</code> 기능의 목적</td><td>I/O 작업을 더 동적으로 처리하여 효율적인 데이터 페칭과 렌더링 가능</td></tr><tr><td><code>cacheLife</code> 활용법</td><td>캐시 수명을 직접 설정해 보다 세밀한 리소스 관리 가능</td></tr><tr><td>'unstable_' 접두사 의미</td><td>아직 안정화되지 않은 API, 앞으로 변경될 가능성 있음</td></tr><tr><td>Next.js 실험적 기능 활용시 주의사항</td><td>실제 서비스에 적용할 때는 충분한 테스트 후 사용하는 것이 좋음</td></tr></tbody></table>
<p>혹시 이 기능들을 실제로 프로젝트에 적용해보고 어려운 점이나 궁금한 점이 있으면 댓글로 남겨주세요! 저도 더 공부해서 좋은 팁들 공유할게요. Next.js 계속 발전하는 만큼, 우리도 함께 성장해보자구요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>기본 캐시 프로필 소개</h3>
<p>Next.js에서는 다양한 시간대에 맞춘 이름 있는 캐시 프로필 세트를 제공해요. 만약 <code>use cache</code> 디렉티브와 함께 <code>cacheLife</code> 함수에 캐시 프로필을 지정하지 않으면, Next.js가 기본 캐시 프로필을 자동으로 적용해줍니다.</p>
<p>하지만 저는 항상 <code>use cache</code>를 사용할 때는 명시적으로 캐시 프로필을 지정해주는 걸 추천해요. 그래야 내가 원하는 캐싱 동작을 확실히 정의할 수 있거든요!</p>
<p>아래는 Next.js가 제공하는 기본 캐시 프로필들의 종류와 각 프로필이 가진 <code>stale</code>, <code>revalidate</code>, <code>expire</code> 타임라인, 그리고 설명입니다.</p>





























































<table><thead><tr><th>프로필</th><th>stale</th><th>revalidate</th><th>expire</th><th>설명</th></tr></thead><tbody><tr><td><code>default</code></td><td>5분</td><td>15분</td><td>1년</td><td>자주 업데이트 필요 없는 콘텐츠에 적합한 기본 프로필</td></tr><tr><td><code>seconds</code></td><td>0</td><td>1초</td><td>1초</td><td>거의 실시간 업데이트가 필요한 빠르게 변하는 콘텐츠에 적합</td></tr><tr><td><code>minutes</code></td><td>5분</td><td>1분</td><td>1시간</td><td>한 시간 내 자주 업데이트되는 콘텐츠에 적합</td></tr><tr><td><code>hours</code></td><td>5분</td><td>1시간</td><td>1일</td><td>하루 단위로 업데이트되며 약간 오래된 캐시가 허용되는 콘텐츠에 적합</td></tr><tr><td><code>days</code></td><td>5분</td><td>1일</td><td>1주일</td><td>주 단위로 업데이트되며 하루 정도 오래된 캐시 정도 괜찮은 콘텐츠에 적합</td></tr><tr><td><code>weeks</code></td><td>5분</td><td>1주일</td><td>30일</td><td>월 단위 업데이트이며 일주일 정도 캐시가 오래돼도 괜찮은 콘텐츠에 적합</td></tr><tr><td><code>max</code></td><td>5분</td><td>30일</td><td>1년</td><td>거의 변경되지 않는 매우 안정적인 콘텐츠에 적합</td></tr></tbody></table>
<hr>
<h3>덧붙여서...</h3>
<ul>
<li><code>stale</code> 기간이란, 캐시된 데이터가 구식(stale)으로 간주되기 전까지의 시간입니다. 이 기간 동안은 캐시된 데이터를 사용하지만, <code>revalidate</code> 시점에는 백그라운드에서 새로운 데이터를 받아와서 캐시를 갱신하게 돼요.</li>
<li><code>revalidate</code>는 백그라운드에서 데이터를 다시 요청하는 시기를 뜻해요. 이때 응답은 즉시 캐시된 값으로 처리하고, 서버에서 신규 데이터를 받아 업데이트합니다.</li>
<li><code>expire</code>는 캐시가 완전히 만료되어 더 이상 사용할 수 없는 시점을 의미합니다.</li>
</ul>
<p>만약 자주 업데이트가 필요한 뉴스 사이트나 주식 시세, 실시간 스포츠 결과 같은 데이터라면 <code>seconds</code>나 <code>minutes</code> 프로필을, 변화가 거의 없는 블로그 포스트나 정적인 이미지 리소스라면 <code>max</code> 프로필 같은 장기 캐싱을 선택하는 게 효율적이에요.</p>
<p>Next.js 캐시 기능은 이렇게 시간 기반 프로필을 잘 활용하면 사용자 경험도 개선하고 서버 부하도 줄일 수 있으니, 꼭 적절하게 설정해서 활용해 보시길 바랍니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>캐시 프로필을 참조할 때 사용하는 문자열 값들은 그 자체로 특별한 의미를 가지기보다는, 코드 내에서 의미를 부여하는 라벨 역할을 해요. 덕분에 캐시된 콘텐츠를 더 쉽고 직관적으로 관리할 수 있답니다.</p>
<blockquote>
<p>참고할 점: staleTimes와 expireTime 설정을 변경하면 기본 캐시 프로필의 stale과 expire 속성도 함께 업데이트돼요. 즉, 일관성 있게 캐시 설정을 관리할 수 있다는 뜻이죠.</p>
</blockquote>
<h3>커스텀 캐시 프로필 만들기</h3>
<p>Next.js 프로젝트에서 커스텀 캐시 프로필을 만들어 사용하고 싶다면, <code>next.config.ts</code> 파일 내의 <code>cacheLife</code> 옵션에 직접 추가하면 돼요. 이렇게 하면 프로젝트 요구사항에 맞게 캐시 정책을 세밀하게 조정할 수 있답니다.</p>
<p>아래는 <code>cacheLife</code> 옵션을 활용해 여러 캐시 프로필을 정의하는 예시입니다:</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// next.config.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">experimental</span>: {
    <span class="hljs-attr">cacheLife</span>: {
      <span class="hljs-attr">shortCache</span>: { <span class="hljs-attr">staleTime</span>: <span class="hljs-number">60</span>, <span class="hljs-attr">expireTime</span>: <span class="hljs-number">120</span> }, <span class="hljs-comment">// 짧게 유지되는 캐시 예시 (초단위)</span>
      <span class="hljs-attr">longCache</span>: { <span class="hljs-attr">staleTime</span>: <span class="hljs-number">3600</span>, <span class="hljs-attr">expireTime</span>: <span class="hljs-number">7200</span> }, <span class="hljs-comment">// 오래 유지되는 캐시 예시</span>
      <span class="hljs-attr">noCache</span>: { <span class="hljs-attr">staleTime</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">expireTime</span>: <span class="hljs-number">0</span> }, <span class="hljs-comment">// 캐시를 사용하지 않는 프로필</span>
    },
  },
};
</code></pre>
<p>이렇게 프로필을 만들고 나면, 데이터 요청이나 페이지 캐싱 시에 해당 프로필 이름(<code>shortCache</code>, <code>longCache</code> 등)을 참조해 필요한 캐시 정책을 간편하게 적용할 수 있죠.</p>
<blockquote>
<p>팁! 캐시를 적절히 활용하면 서버 부하도 줄이고, 사용자 경험도 크게 향상시킬 수 있어요. 하지만 너무 오래된 캐시는 오히려 구버전 콘텐츠를 보여줄 수 있으니, 상황에 따라 적절한 <code>staleTime</code>과 <code>expireTime</code> 설정이 중요하답니다.</p>
</blockquote>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Cache profiles는 캐시와 관련된 몇 가지 속성을 담고 있는 객체입니다. 각 속성은 캐시가 어떻게 동작하는지 세밀하게 조절할 수 있게 도와주죠. 아래 표를 보면서 살펴볼게요.</p>





























<table><thead><tr><th>Property</th><th>Value</th><th>Description</th><th>Requirement</th></tr></thead><tbody><tr><td><code>stale</code></td><td>number</td><td>클라이언트가 서버에 확인하지 않고 값을 캐시에 저장해두는 기간입니다.</td><td>선택 사항</td></tr><tr><td><code>revalidate</code></td><td>number</td><td>서버에서 캐시를 새로 고칠 주기입니다. 리밸리데이트 중에는 오래된 값(stale)을 보여줄 수 있어요.</td><td>선택 사항</td></tr><tr><td><code>expire</code></td><td>number</td><td>값이 오래된 상태(stale)로 유지될 수 있는 최대 기간입니다. 이 기간이 지나면 동적(fetch)으로 전환됩니다. 반드시 <code>revalidate</code>보다 길어야 합니다.</td><td>선택 사항 – <code>revalidate</code>보다 커야 함</td></tr></tbody></table>
<hr>
<p>여기서 조금 혼동될 수 있는 부분이 <code>stale</code> 속성과 <code>staleTimes</code> 설정인데요, 간단히 말씀드리면:</p>
<ul>
<li><code>stale</code>은 클라이언트 사이드 라우터 쪽 캐시만 제어합니다. 즉, 특정 함수나 경로(route)별로 직접 '얼마 동안 캐싱할지'를 정할 수 있다는 거죠.</li>
<li>반면에 <code>staleTimes</code>는 전역(globa) 설정으로, 동적(dynamic) 데이터와 정적(static) 데이터 모두에 영향을 미칩니다.</li>
</ul>
<hr>
<p>그리고 한 가지 팁!<br>
<code>stale</code> 속성은 <strong>Cache-control: max-age</strong> HTTP 헤더 값을 설정하는 게 아닙니다. 이건 서버에서 보내는 캐시 지시자(header)이지만, <code>stale</code>은 오로지 클라이언트 라우터의 로컬 캐시 관리를 위한 설정이라는 점, 꼭 기억하세요.</p>
<p>이런 캐시 컨트롤 방법은 앱을 더 빠르게 만들면서도 최신 데이터를 적절히 유지하는 데 아주 유용해요. 각 상황에 맞게 잘 조절해보면서 퍼포먼스 최적화에 활용해보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>예시</h2>
<h3>재사용 가능한 캐시 프로필 정의하기</h3>
<p>next.config.ts 파일에서 재사용 가능한 캐시 프로필을 정의할 수 있어요. 프로필 이름은 사용 목적에 맞게 지정하고, <code>stale</code>, <code>revalidate</code>, <code>expire</code> 속성들을 설정해주면 됩니다. 필요한 만큼 여러 개의 커스텀 캐시 프로필을 만들어 사용할 수 있어요. 각 프로필은 이름을 문자열로 <code>cacheLife</code> 함수에 전달해서 참조할 수 있답니다.</p>
<p>아래 예시는 14일간 캐시를 유지하고, 1일마다 재검증을 수행하는 <code>biweekly</code>라는 캐시 프로필을 정의한 코드입니다.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { <span class="hljs-title class_">NextConfig</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"next"</span>;

<span class="hljs-keyword">const</span> <span class="hljs-attr">nextConfig</span>: <span class="hljs-title class_">NextConfig</span> = {
  <span class="hljs-attr">experimental</span>: {
    <span class="hljs-attr">dynamicIO</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">cacheLife</span>: {
      <span class="hljs-attr">biweekly</span>: {
        <span class="hljs-attr">stale</span>: <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">14</span>, <span class="hljs-comment">// 14일 동안 stale 상태 유지</span>
        <span class="hljs-attr">revalidate</span>: <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span>, <span class="hljs-comment">// 1일 간격으로 재검증</span>
        <span class="hljs-attr">expire</span>: <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">14</span>, <span class="hljs-comment">// 14일 후 캐시 만료</span>
      },
    },
  },
};

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = nextConfig;
</code></pre>
<hr>
<p><strong>참고로 캐시 관련 설정을 잘 해두면, 페이지 로딩 속도가 크게 향상되고 서버 부하도 줄일 수 있어요.</strong> 특히 자주 변하지 않는 데이터라면 이런 캐시 프로필을 적극 활용해서 효율적인 서비스 운영을 할 수 있답니다.</p>
<p>단, <code>stale</code>, <code>revalidate</code>, <code>expire</code> 값은 상황에 맞게 조절해야 해요. 예측 가능한 사용자 트래픽, 데이터 갱신 빈도 등을 고려해 보세요. 너무 길게 설정하면 오래된 데이터가 노출될 수도 있으니까 주의가 필요해요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>위 예시는 14일 동안 캐시를 유지하고, 매일 업데이트를 확인하며, 14일이 지나면 캐시가 만료되도록 설정한 거예요. 이렇게 만든 캐시 프로필은 애플리케이션 전반에서 이름으로 참조해서 사용할 수 있답니다.</p>
<pre><code class="hljs language-js"><span class="hljs-string">"use cache"</span>;
<span class="hljs-keyword">import</span> { unstable_cacheLife <span class="hljs-keyword">as</span> cacheLife } <span class="hljs-keyword">from</span> <span class="hljs-string">"next/cache"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>Page<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>;
}
</code></pre>
<h3>기본 캐시 프로필 덮어쓰기(오버라이딩)</h3>
<p>Next.js에서 제공하는 기본 캐시 프로필은 캐시된 데이터가 얼마나 신선한지, 혹은 얼마나 오래된 것인지를 결정하는 데 도움을 줘요. 그런데 어떤 애플리케이션은 기본 프로필보다 더 세분화된 캐싱 전략이 필요할 수 있죠. 이럴 때는 내 입맛에 맞게 이름이 붙은(즉, 커스텀) 캐시 프로필을 만들어서 쓸 수 있어요.</p>
<p>예를 들어, 자주 업데이트되는 뉴스 섹션엔 'shortCache', 변경이 거의 없는 공지사항엔 'longCache' 같은 이름을 붙여서 관리하면 더 효율적이고 관리하기도 편하답니다. 이렇게 하면 빠른 캐시 만료가 필요한 곳과 오래 두어도 무방한 부분을 명확히 구분할 수 있어요.</p>
<blockquote>
<p><strong>참고 팁:</strong> 캐시 프로필을 세밀하게 관리하면, 서버 부담을 줄이면서도 사용자에게 항상 신선한 콘텐츠를 제공할 수 있어요. 너무 보수적으로 캐시 기간을 설정하면 빈번한 요청 처리로 서버에 부담이 갈 수 있으니, 애플리케이션 특성에 맞게 적절히 조절하는 게 중요합니다!</p>
</blockquote>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>next.js에서 기본으로 제공하는 캐시 프로필(named cache profiles)을 커스텀하고 싶을 때, 같은 이름으로 새 설정을 만들어서 덮어쓸 수 있다는 점, 알고 계셨나요? 기본 프로필을 그대로 쓰는 것도 좋지만, 프로젝트 상황에 맞게 적절히 조정하면 효율적인 캐시 관리가 가능해집니다.</p>
<p>예를 들어, 기본 “days” 캐시 프로필을 이렇게 오버라이딩할 수 있어요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> nextConfig = {
  <span class="hljs-attr">experimental</span>: {
    <span class="hljs-attr">dynamicIO</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">cacheLife</span>: {
      <span class="hljs-attr">days</span>: {
        <span class="hljs-attr">stale</span>: <span class="hljs-number">3600</span>, <span class="hljs-comment">// 1시간 동안 stale 상태 유지</span>
        <span class="hljs-attr">revalidate</span>: <span class="hljs-number">900</span>, <span class="hljs-comment">// 15분마다 재검증</span>
        <span class="hljs-attr">expire</span>: <span class="hljs-number">86400</span>, <span class="hljs-comment">// 1일 후 만료</span>
      },
    },
  },
};

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = nextConfig;
</code></pre>
<p>여기서 좀 더 설명을 드리자면,</p>
<ul>
<li><code>stale</code>: 캐시된 데이터가 조금 오래됐어도 바로 폐기하지 않고, 이 시간만큼은 stale 상태로 허용합니다. (즉, 약간 낡은 데이터도 사용할 수 있게끔 시간을 설정하는 거예요.)</li>
<li><code>revalidate</code>: 재검증(interval) 주기로, 이 시간이 지나면 캐시를 백그라운드에서 새로고침합니다.</li>
<li><code>expire</code>: 캐시가 완전히 만료되는 시간으로, 이 시간이 지나면 캐시를 폐기하고 새 데이터를 받아옵니다.</li>
</ul>
<p>이런 설정 덕분에 데이터를 너무 자주 다시 받느라 리소스를 낭비하지 않고, 살짝 오래된 데이터도 쓸 수 있게 해서 효율성을 높일 수 있답니다.</p>
<h3>캐시 프로필 직접 정의하기 (Defining cache profiles inline)</h3>
<p>기본 프로필이 아니라 완전히 새롭게 캐시 프로필을 정의하고 싶을 때도 있습니다. 예를 들어, 'hours'라는 이름으로 6시간 단위의 캐시 전략을 직접 만들어볼 수 있죠.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> nextConfig = {
  <span class="hljs-attr">experimental</span>: {
    <span class="hljs-attr">dynamicIO</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">cacheLife</span>: {
      <span class="hljs-attr">hours</span>: {
        <span class="hljs-attr">stale</span>: <span class="hljs-number">600</span>, <span class="hljs-comment">// 10분간 stale 허용</span>
        <span class="hljs-attr">revalidate</span>: <span class="hljs-number">300</span>, <span class="hljs-comment">// 5분마다 재검증</span>
        <span class="hljs-attr">expire</span>: <span class="hljs-number">21600</span>, <span class="hljs-comment">// 6시간 후 만료</span>
      },
    },
  },
};

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = nextConfig;
</code></pre>
<p>이렇게 나만의 캐시 전략을 만들어두면, 복잡한 프로젝트에서 여러 페이지나 API에 맞게 캐시 설정을 다양하게 적용할 수 있어서 매우 유용해요.</p>
<blockquote>
<p><strong>팁:</strong> 캐싱 전략을 짤 때, 너무 짧은 expire는 서버 부담을 늘리고, 너무 긴 expire는 사용자에게 오래된 데이터를 보여줄 위험이 생기므로 적절한 균형이 중요합니다!</p>
</blockquote>
<p>필요에 따라 값들을 튜닝하면서 최적의 캐시 전략을 찾아가 보세요. 앞으로도 이런 유용한 실전 팁 계속 소개할게요! 궁금한 점 있으면 언제든 물어봐 주세요 :)</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이번에는 Next.js에서 캐싱을 좀 더 세밀하게 제어하는 방법에 대해 이야기해볼게요. 특히 <code>cacheLife</code> 함수를 사용해서 원하는 캐시 프로필을 직접 설정하는 방법을 다뤄보겠습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-string">"use cache"</span>;
<span class="hljs-keyword">import</span> { unstable_cacheLife <span class="hljs-keyword">as</span> cacheLife } <span class="hljs-keyword">from</span> <span class="hljs-string">"next/cache"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>Page<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>;
}
</code></pre>
<p>위 코드는 기본적인 캐시 설정 예시예요. 여기서 <code>cacheLife</code> 함수에 객체 형태의 설정값을 넘기면 내가 원하는 캐시 정책을 직접 만들 수 있어요. 그런데 중요한 점은 이렇게 만든 캐시 프로필은 해당 함수나 파일에 한해서만 적용된다는 거예요.</p>
<p>만약 여러분의 앱 전체에서 같은 캐시 정책을 반복해서 쓰고 싶다면, 매번 이렇게 작성하는 대신 <code>next.config.ts</code> 파일 안에 <code>cacheLife</code> 속성을 추가하는 게 좋은 방법입니다. 그러면 전역적으로 일관된 캐싱 전략을 관리할 수 있거든요.</p>
<hr>
<h3>좀 더 살펴보는 <code>use cache</code>와 <code>cacheLife</code>의 중첩 사용법</h3>
<p><code>'use cache'</code>는 Next.js에서 함수가 캐시 가능하다는 걸 알려주는 지시문이고, <code>cacheLife</code>는 그 캐시의 수명과 동작 정책을 좀 더 구체적으로 설정해주는 역할을 해요.</p>
<pre><code class="hljs language-js"><span class="hljs-string">"use cache"</span>;
<span class="hljs-keyword">import</span> { unstable_cacheLife <span class="hljs-keyword">as</span> cacheLife } <span class="hljs-keyword">from</span> <span class="hljs-string">"next/cache"</span>;

<span class="hljs-comment">// 예를 들어, 캐시 수명을 60초로 지정하고 싶을 때</span>
<span class="hljs-keyword">const</span> myCacheConfig = <span class="hljs-title function_">cacheLife</span>({ <span class="hljs-attr">maxAge</span>: <span class="hljs-number">60</span> });

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">myCacheConfig</span>(<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>캐시가 60초 동안 유지됩니다.<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>;
});
</code></pre>
<p>위처럼 <code>cacheLife</code>가 반환하는 함수로 래핑하면, 그 안 함수는 해당 캐시 정책을 따르게 됩니다.</p>
<hr>
<h3>추가 팁!</h3>
<ul>
<li><strong>maxAge</strong>: 캐시 데이터가 얼마동안 살아있을지 초 단위로 지정해요.</li>
<li><strong>staleWhileRevalidate</strong>: 캐시가 만료되더라도 새 데이터를 받아올 때까지 옛날 캐시를 계속 보여주는 설정이에요.</li>
<li><strong>캐시 무효화</strong>: 필요할 땐 특정 조건이나 API 호출 시 캐시를 초기화해줄 수도 있는데, 이 부분도 꼭 체크해보시면 좋아요.</li>
</ul>
<p>React 컴포넌트나 API 라우트에서 잘 활용하면, 불필요한 데이터 재요청을 줄이고 사용자 경험을 개선할 수 있답니다.</p>
<p>필요하면 다음에 더 자세한 캐시 전략이나 예제도 정리해서 소개할게요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>같은 경로나 컴포넌트 트리 안에서 여러 캐싱 동작(caching behavior)을 정의할 때, 안쪽(내부) 캐시가 자신만의 cacheLife 프로필을 지정하면, 바깥쪽(외부) 캐시는 그 중 가장 짧은 캐시 지속시간을 자동으로 따르게 돼요. 단, 이건 바깥쪽 캐시가 명시적으로 cacheLife 프로필을 지정하지 않은 경우에만 적용됩니다.</p>
<p>예를 들어, 페이지에 <code>use cache</code> 지시어를 붙이면서 별도로 캐시 프로필을 지정하지 않으면, 기본값인 <code>cacheLife("default")</code>가 암묵적으로 적용돼요. 그런데 이 페이지에 불러오는 컴포넌트가 자체 캐시 프로필을 가진 <code>use cache</code>를 사용한다면, 내부와 외부 캐시 프로필이 비교되어서, 가장 짧은 시간이 적용됩니다.</p>
<p>간단히 말해, 여러 레이어의 캐시가 있으면 "가장 짧은 시간 기준"으로 캐싱 기간을 설정해서, 데이터를 너무 오래 쓰지 않도록 조절해 준다는 거죠.</p>
<hr>
<p>예를 들어서 본 부모 컴포넌트 코드를 한번 보면:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// Parent component</span>
<span class="hljs-keyword">import</span> { unstable_cacheLife <span class="hljs-keyword">as</span> cacheLife } <span class="hljs-keyword">from</span> <span class="hljs-string">"next/cache"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ChildComponent</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./child"</span>;

<span class="hljs-title function_">cacheLife</span>(<span class="hljs-string">"days"</span>); <span class="hljs-comment">// "days" 기준 캐싱 지속시간 지정</span>

<span class="hljs-keyword">return</span> (
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">ChildComponent</span> /></span>
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
);
</code></pre>
<p>그리고 별도의 파일에서 임포트한 자식 컴포넌트는 다음처럼 정의해요.</p>
<p>(자식 컴포넌트 코드는 다음에 나올 거랍니다!)</p>
<hr>
<h3>추가 팁!</h3>
<ul>
<li>캐시 지속 시간을 지정할 때는 <code>"hours"</code>, <code>"minutes"</code>, <code>"seconds"</code>처럼 구체적으로 설정하셔도 되고, 직접 숫자 단위(예: <code>cacheLife(60 * 60 * 24)</code>)로 초 단위 값을 줄 수도 있습니다.</li>
<li>내부 컴포넌트의 캐시가 더 짧으면, 전체적으로 데이터 최신성이 더 잘 유지되기 때문에 업데이트 반영 속도가 빨라지죠.</li>
<li>반대로 외부에서 명시적으로 긴 cacheLife를 지정하면 내부 캐시는 무시되고 외부 걸린 시간 기준으로 유지돼요. 따라서 캐시가 꼬이지 않도록 캐시 설정을 꼼꼼하게 관리하는 게 중요합니다.</li>
</ul>
<p>다음 메시지에 자식 컴포넌트 코드를 소개할게요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>안녕하세요! 오늘은 Next.js에서 제공하는 <code>unstable_cacheLife</code> 함수에 대해 살펴볼게요. 이 함수는 캐시 수명을 설정할 때 사용되는데, 아직 공식적으로 안정화되지 않은 기능이라 <code>unstable_</code> 접두사가 붙어 있답니다.</p>
<p>예시 코드가 주어졌는데, 쉽게 설명해볼게요.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// Child 컴포넌트에서</span>
<span class="hljs-keyword">import</span> { unstable_cacheLife <span class="hljs-keyword">as</span> cacheLife } <span class="hljs-keyword">from</span> <span class="hljs-string">"next/cache"</span>;

<span class="hljs-title function_">cacheLife</span>(<span class="hljs-string">"hours"</span>);
<span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>Child Content<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>;

<span class="hljs-comment">// 이 컴포넌트의 캐시는 'hours' 프로필 기준으로 관리됩니다.</span>
</code></pre>
<p>여기서 <code>cacheLife('hours')</code>라고 설정하면, 이 컴포넌트는 상대적으로 짧은 시간 단위인 'hours' 기준으로 캐시가 유지돼요. 즉, 더 빨리 캐시가 만료된다는 뜻이죠.</p>
<h3>참고할 점!</h3>
<ul>
<li><code>cacheLife</code> 안에 들어갈 수 있는 프로필은 보통 'seconds', 'minutes', 'hours', 'days' 등이 있어요.</li>
<li>이 기능은 아직 실험 단계라 문서가 계속 업데이트되고, API도 바뀔 수 있어요.</li>
<li>캐시 수명을 적절히 조정하면 사용자 경험을 향상시키면서 서버 부하도 줄일 수 있다는 점에서 유용해요!</li>
</ul>
<h3>마치며</h3>
<p>Next.js에서 캐시를 더 세밀하게 제어하고 싶을 때 <code>unstable_cacheLife</code>를 써볼 수 있지만, 아직 완전 안정적이지 않은 점을 기억하세요. 프로덕션에서는 주의해서 사용하고, 공식 문서 업데이트를 꾸준히 확인하는 걸 추천드립니다!</p>
<p>도움이 되셨다면 좋겠네요. 다음에도 유용한 팁으로 찾아올게요! 😊</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Next.js 15에서 cacheLife 설정하는 방법 및 캐시 수명 관리 방법 정리","description":"","date":"2025-04-22 02:57","slug":"2025-04-22-cacheLife","content":"\n# cacheLife 함수 알아보기\n\n안녕하세요, 개발 블로거입니다! 오늘은 `cacheLife`라는 함수에 대해 이야기해보려고 해요. 이 함수는 함수나 컴포넌트의 캐시 수명을 설정하는 데 쓰여요. 캐시 수명이란, 쉽게 말해 '데이터를 얼마나 오래 저장해서 재사용할지'를 결정하는 시간이죠.\n\n이 `cacheLife` 함수는 `use cache` 지시어와 함께 사용해야 하며, 반드시 함수나 컴포넌트의 범위 안에서 호출해야 한다는 점 기억하세요.\n\n## 사용법\n\n`cacheLife`를 사용하려면 우선 프로젝트 설정 파일인 `next.config.js`에 `dynamicIO` 플래그를 활성화해야 합니다:\n\n```js\n// next.config.js\nmodule.exports = {\n  experimental: {\n    dynamicIO: true,\n  },\n};\n```\n\n왜 이렇게 설정해야 하냐면, `dynamicIO` 플래그가 켜져야 동적인 입출력 처리와 캐싱 기능이 제대로 작동하기 때문이에요.\n\n### 참고로!\n\n만약 캐시를 너무 오래 유지하면 데이터가 오래된 상태일 수 있으니, 적절한 캐시 수명을 설정하는 게 중요해요. 반대로 너무 짧게 설정하면 캐시 효과가 떨어지고 서버 부하가 늘 수 있답니다.\n\n추가로, React나 Next.js와 같은 프레임워크를 사용 중이라면, `cacheLife` 설정과 `use cache` 관련 지시어를 적절히 조합해 컴포넌트 렌더링 최적화를 도모할 수 있습니다.\n\n다음에 좀 더 구체적인 사용 예제와 실전 팁을 공유할게요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번에 Next.js에서 소개된 새로운 기능 중 하나인 `dynamicIO`와 `cacheLife`에 대해 간단히 살펴볼게요. 직접 써보고 정리한 내용이니 참고해서 프로젝트에 적용해봐도 좋을 것 같아요!\n\n---\n\n### `dynamicIO` Experimental 옵션 설정하기\n\nNext.js는 계속 발전 중이라 실험적인 기능도 종종 나옵니다. `dynamicIO`는 그중 하나인데, 이걸 켜면 IO 작업을 더 동적으로 처리할 수 있는 환경을 만들어줍니다.\n\n```js\nimport type { NextConfig } from \"next\";\n\nconst nextConfig: NextConfig = {\n  experimental: {\n    dynamicIO: true,\n  },\n};\n\nexport default nextConfig;\n```\n\n- 위처럼 `next.config.js` 혹은 `next.config.ts`에서 `experimental.dynamicIO` 옵션을 `true`로 설정하면 돼요.\n- 공식 문서에서는 이 옵션이 아직 실험 단계라서, 실제 서비스에서는 좀 더 안정화될 때까지 조심스럽게 사용하는 걸 권장합니다.\n\n---\n\n### `cacheLife` 함수 사용하기\n\n`cacheLife`는 Next.js에서 새롭게 제공하는 캐싱 관련 유틸리티예요. 특히 서버 컴포넌트나 함수 내에서 캐싱 수명을 관리할 때 유용하죠.\n\n```js\n\"use cache\";\nimport { unstable_cacheLife as cacheLife } from \"next/cache\";\n\nexport default async function Page() {\n  // cacheLife를 이용해 캐시 수명을 조절하는 로직 구현 가능\n  return \u003cdiv\u003ePage\u003c/div\u003e;\n}\n```\n\n- 여기서 `use cache`라는 디렉티브도 눈에 띄는데, 이건 Next.js가 해당 모듈을 캐싱 대상으로 인식하게 해줘요.\n- `unstable_cacheLife`는 아직 실험적인 API라는 뜻이라, 이름 앞에 `unstable_`가 붙어 있어요.\n- 이 함수를 활용하면, 필요한 부분의 캐시 유지 시간을 섬세하게 조절할 수 있어요. 예를 들어, 데이터 페칭 결과를 일정 시간 동안만 캐싱하고 싶을 때 유용하답니다.\n\n---\n\n### 참고사항 및 팁\n\n| 내용                                | 설명                                                               |\n| ----------------------------------- | ------------------------------------------------------------------ |\n| `dynamicIO` 기능의 목적             | I/O 작업을 더 동적으로 처리하여 효율적인 데이터 페칭과 렌더링 가능 |\n| `cacheLife` 활용법                  | 캐시 수명을 직접 설정해 보다 세밀한 리소스 관리 가능               |\n| 'unstable\\_' 접두사 의미            | 아직 안정화되지 않은 API, 앞으로 변경될 가능성 있음                |\n| Next.js 실험적 기능 활용시 주의사항 | 실제 서비스에 적용할 때는 충분한 테스트 후 사용하는 것이 좋음      |\n\n혹시 이 기능들을 실제로 프로젝트에 적용해보고 어려운 점이나 궁금한 점이 있으면 댓글로 남겨주세요! 저도 더 공부해서 좋은 팁들 공유할게요. Next.js 계속 발전하는 만큼, 우리도 함께 성장해보자구요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 기본 캐시 프로필 소개\n\nNext.js에서는 다양한 시간대에 맞춘 이름 있는 캐시 프로필 세트를 제공해요. 만약 `use cache` 디렉티브와 함께 `cacheLife` 함수에 캐시 프로필을 지정하지 않으면, Next.js가 기본 캐시 프로필을 자동으로 적용해줍니다.\n\n하지만 저는 항상 `use cache`를 사용할 때는 명시적으로 캐시 프로필을 지정해주는 걸 추천해요. 그래야 내가 원하는 캐싱 동작을 확실히 정의할 수 있거든요!\n\n아래는 Next.js가 제공하는 기본 캐시 프로필들의 종류와 각 프로필이 가진 `stale`, `revalidate`, `expire` 타임라인, 그리고 설명입니다.\n\n| 프로필    | stale | revalidate | expire | 설명                                                                   |\n| --------- | ----- | ---------- | ------ | ---------------------------------------------------------------------- |\n| `default` | 5분   | 15분       | 1년    | 자주 업데이트 필요 없는 콘텐츠에 적합한 기본 프로필                    |\n| `seconds` | 0     | 1초        | 1초    | 거의 실시간 업데이트가 필요한 빠르게 변하는 콘텐츠에 적합              |\n| `minutes` | 5분   | 1분        | 1시간  | 한 시간 내 자주 업데이트되는 콘텐츠에 적합                             |\n| `hours`   | 5분   | 1시간      | 1일    | 하루 단위로 업데이트되며 약간 오래된 캐시가 허용되는 콘텐츠에 적합     |\n| `days`    | 5분   | 1일        | 1주일  | 주 단위로 업데이트되며 하루 정도 오래된 캐시 정도 괜찮은 콘텐츠에 적합 |\n| `weeks`   | 5분   | 1주일      | 30일   | 월 단위 업데이트이며 일주일 정도 캐시가 오래돼도 괜찮은 콘텐츠에 적합  |\n| `max`     | 5분   | 30일       | 1년    | 거의 변경되지 않는 매우 안정적인 콘텐츠에 적합                         |\n\n---\n\n### 덧붙여서...\n\n- `stale` 기간이란, 캐시된 데이터가 구식(stale)으로 간주되기 전까지의 시간입니다. 이 기간 동안은 캐시된 데이터를 사용하지만, `revalidate` 시점에는 백그라운드에서 새로운 데이터를 받아와서 캐시를 갱신하게 돼요.\n- `revalidate`는 백그라운드에서 데이터를 다시 요청하는 시기를 뜻해요. 이때 응답은 즉시 캐시된 값으로 처리하고, 서버에서 신규 데이터를 받아 업데이트합니다.\n- `expire`는 캐시가 완전히 만료되어 더 이상 사용할 수 없는 시점을 의미합니다.\n\n만약 자주 업데이트가 필요한 뉴스 사이트나 주식 시세, 실시간 스포츠 결과 같은 데이터라면 `seconds`나 `minutes` 프로필을, 변화가 거의 없는 블로그 포스트나 정적인 이미지 리소스라면 `max` 프로필 같은 장기 캐싱을 선택하는 게 효율적이에요.\n\nNext.js 캐시 기능은 이렇게 시간 기반 프로필을 잘 활용하면 사용자 경험도 개선하고 서버 부하도 줄일 수 있으니, 꼭 적절하게 설정해서 활용해 보시길 바랍니다!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n캐시 프로필을 참조할 때 사용하는 문자열 값들은 그 자체로 특별한 의미를 가지기보다는, 코드 내에서 의미를 부여하는 라벨 역할을 해요. 덕분에 캐시된 콘텐츠를 더 쉽고 직관적으로 관리할 수 있답니다.\n\n\u003e 참고할 점: staleTimes와 expireTime 설정을 변경하면 기본 캐시 프로필의 stale과 expire 속성도 함께 업데이트돼요. 즉, 일관성 있게 캐시 설정을 관리할 수 있다는 뜻이죠.\n\n### 커스텀 캐시 프로필 만들기\n\nNext.js 프로젝트에서 커스텀 캐시 프로필을 만들어 사용하고 싶다면, `next.config.ts` 파일 내의 `cacheLife` 옵션에 직접 추가하면 돼요. 이렇게 하면 프로젝트 요구사항에 맞게 캐시 정책을 세밀하게 조정할 수 있답니다.\n\n아래는 `cacheLife` 옵션을 활용해 여러 캐시 프로필을 정의하는 예시입니다:\n\n```typescript\n// next.config.ts\nexport default {\n  experimental: {\n    cacheLife: {\n      shortCache: { staleTime: 60, expireTime: 120 }, // 짧게 유지되는 캐시 예시 (초단위)\n      longCache: { staleTime: 3600, expireTime: 7200 }, // 오래 유지되는 캐시 예시\n      noCache: { staleTime: 0, expireTime: 0 }, // 캐시를 사용하지 않는 프로필\n    },\n  },\n};\n```\n\n이렇게 프로필을 만들고 나면, 데이터 요청이나 페이지 캐싱 시에 해당 프로필 이름(`shortCache`, `longCache` 등)을 참조해 필요한 캐시 정책을 간편하게 적용할 수 있죠.\n\n\u003e 팁! 캐시를 적절히 활용하면 서버 부하도 줄이고, 사용자 경험도 크게 향상시킬 수 있어요. 하지만 너무 오래된 캐시는 오히려 구버전 콘텐츠를 보여줄 수 있으니, 상황에 따라 적절한 `staleTime`과 `expireTime` 설정이 중요하답니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nCache profiles는 캐시와 관련된 몇 가지 속성을 담고 있는 객체입니다. 각 속성은 캐시가 어떻게 동작하는지 세밀하게 조절할 수 있게 도와주죠. 아래 표를 보면서 살펴볼게요.\n\n| Property     | Value  | Description                                                                                                                                   | Requirement                          |\n| ------------ | ------ | --------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------ |\n| `stale`      | number | 클라이언트가 서버에 확인하지 않고 값을 캐시에 저장해두는 기간입니다.                                                                          | 선택 사항                            |\n| `revalidate` | number | 서버에서 캐시를 새로 고칠 주기입니다. 리밸리데이트 중에는 오래된 값(stale)을 보여줄 수 있어요.                                                | 선택 사항                            |\n| `expire`     | number | 값이 오래된 상태(stale)로 유지될 수 있는 최대 기간입니다. 이 기간이 지나면 동적(fetch)으로 전환됩니다. 반드시 `revalidate`보다 길어야 합니다. | 선택 사항 – `revalidate`보다 커야 함 |\n\n---\n\n여기서 조금 혼동될 수 있는 부분이 `stale` 속성과 `staleTimes` 설정인데요, 간단히 말씀드리면:\n\n- `stale`은 클라이언트 사이드 라우터 쪽 캐시만 제어합니다. 즉, 특정 함수나 경로(route)별로 직접 '얼마 동안 캐싱할지'를 정할 수 있다는 거죠.\n- 반면에 `staleTimes`는 전역(globa) 설정으로, 동적(dynamic) 데이터와 정적(static) 데이터 모두에 영향을 미칩니다.\n\n---\n\n그리고 한 가지 팁!  \n`stale` 속성은 **Cache-control: max-age** HTTP 헤더 값을 설정하는 게 아닙니다. 이건 서버에서 보내는 캐시 지시자(header)이지만, `stale`은 오로지 클라이언트 라우터의 로컬 캐시 관리를 위한 설정이라는 점, 꼭 기억하세요.\n\n이런 캐시 컨트롤 방법은 앱을 더 빠르게 만들면서도 최신 데이터를 적절히 유지하는 데 아주 유용해요. 각 상황에 맞게 잘 조절해보면서 퍼포먼스 최적화에 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 예시\n\n### 재사용 가능한 캐시 프로필 정의하기\n\nnext.config.ts 파일에서 재사용 가능한 캐시 프로필을 정의할 수 있어요. 프로필 이름은 사용 목적에 맞게 지정하고, `stale`, `revalidate`, `expire` 속성들을 설정해주면 됩니다. 필요한 만큼 여러 개의 커스텀 캐시 프로필을 만들어 사용할 수 있어요. 각 프로필은 이름을 문자열로 `cacheLife` 함수에 전달해서 참조할 수 있답니다.\n\n아래 예시는 14일간 캐시를 유지하고, 1일마다 재검증을 수행하는 `biweekly`라는 캐시 프로필을 정의한 코드입니다.\n\n```typescript\nimport type { NextConfig } from \"next\";\n\nconst nextConfig: NextConfig = {\n  experimental: {\n    dynamicIO: true,\n    cacheLife: {\n      biweekly: {\n        stale: 60 * 60 * 24 * 14, // 14일 동안 stale 상태 유지\n        revalidate: 60 * 60 * 24, // 1일 간격으로 재검증\n        expire: 60 * 60 * 24 * 14, // 14일 후 캐시 만료\n      },\n    },\n  },\n};\n\nmodule.exports = nextConfig;\n```\n\n---\n\n**참고로 캐시 관련 설정을 잘 해두면, 페이지 로딩 속도가 크게 향상되고 서버 부하도 줄일 수 있어요.** 특히 자주 변하지 않는 데이터라면 이런 캐시 프로필을 적극 활용해서 효율적인 서비스 운영을 할 수 있답니다.\n\n단, `stale`, `revalidate`, `expire` 값은 상황에 맞게 조절해야 해요. 예측 가능한 사용자 트래픽, 데이터 갱신 빈도 등을 고려해 보세요. 너무 길게 설정하면 오래된 데이터가 노출될 수도 있으니까 주의가 필요해요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 예시는 14일 동안 캐시를 유지하고, 매일 업데이트를 확인하며, 14일이 지나면 캐시가 만료되도록 설정한 거예요. 이렇게 만든 캐시 프로필은 애플리케이션 전반에서 이름으로 참조해서 사용할 수 있답니다.\n\n```js\n\"use cache\";\nimport { unstable_cacheLife as cacheLife } from \"next/cache\";\n\nexport default async function Page() {\n  return \u003cdiv\u003ePage\u003c/div\u003e;\n}\n```\n\n### 기본 캐시 프로필 덮어쓰기(오버라이딩)\n\nNext.js에서 제공하는 기본 캐시 프로필은 캐시된 데이터가 얼마나 신선한지, 혹은 얼마나 오래된 것인지를 결정하는 데 도움을 줘요. 그런데 어떤 애플리케이션은 기본 프로필보다 더 세분화된 캐싱 전략이 필요할 수 있죠. 이럴 때는 내 입맛에 맞게 이름이 붙은(즉, 커스텀) 캐시 프로필을 만들어서 쓸 수 있어요.\n\n예를 들어, 자주 업데이트되는 뉴스 섹션엔 'shortCache', 변경이 거의 없는 공지사항엔 'longCache' 같은 이름을 붙여서 관리하면 더 효율적이고 관리하기도 편하답니다. 이렇게 하면 빠른 캐시 만료가 필요한 곳과 오래 두어도 무방한 부분을 명확히 구분할 수 있어요.\n\n\u003e **참고 팁:** 캐시 프로필을 세밀하게 관리하면, 서버 부담을 줄이면서도 사용자에게 항상 신선한 콘텐츠를 제공할 수 있어요. 너무 보수적으로 캐시 기간을 설정하면 빈번한 요청 처리로 서버에 부담이 갈 수 있으니, 애플리케이션 특성에 맞게 적절히 조절하는 게 중요합니다!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nnext.js에서 기본으로 제공하는 캐시 프로필(named cache profiles)을 커스텀하고 싶을 때, 같은 이름으로 새 설정을 만들어서 덮어쓸 수 있다는 점, 알고 계셨나요? 기본 프로필을 그대로 쓰는 것도 좋지만, 프로젝트 상황에 맞게 적절히 조정하면 효율적인 캐시 관리가 가능해집니다.\n\n예를 들어, 기본 “days” 캐시 프로필을 이렇게 오버라이딩할 수 있어요:\n\n```js\nconst nextConfig = {\n  experimental: {\n    dynamicIO: true,\n    cacheLife: {\n      days: {\n        stale: 3600, // 1시간 동안 stale 상태 유지\n        revalidate: 900, // 15분마다 재검증\n        expire: 86400, // 1일 후 만료\n      },\n    },\n  },\n};\n\nmodule.exports = nextConfig;\n```\n\n여기서 좀 더 설명을 드리자면,\n\n- `stale`: 캐시된 데이터가 조금 오래됐어도 바로 폐기하지 않고, 이 시간만큼은 stale 상태로 허용합니다. (즉, 약간 낡은 데이터도 사용할 수 있게끔 시간을 설정하는 거예요.)\n- `revalidate`: 재검증(interval) 주기로, 이 시간이 지나면 캐시를 백그라운드에서 새로고침합니다.\n- `expire`: 캐시가 완전히 만료되는 시간으로, 이 시간이 지나면 캐시를 폐기하고 새 데이터를 받아옵니다.\n\n이런 설정 덕분에 데이터를 너무 자주 다시 받느라 리소스를 낭비하지 않고, 살짝 오래된 데이터도 쓸 수 있게 해서 효율성을 높일 수 있답니다.\n\n### 캐시 프로필 직접 정의하기 (Defining cache profiles inline)\n\n기본 프로필이 아니라 완전히 새롭게 캐시 프로필을 정의하고 싶을 때도 있습니다. 예를 들어, 'hours'라는 이름으로 6시간 단위의 캐시 전략을 직접 만들어볼 수 있죠.\n\n```js\nconst nextConfig = {\n  experimental: {\n    dynamicIO: true,\n    cacheLife: {\n      hours: {\n        stale: 600, // 10분간 stale 허용\n        revalidate: 300, // 5분마다 재검증\n        expire: 21600, // 6시간 후 만료\n      },\n    },\n  },\n};\n\nmodule.exports = nextConfig;\n```\n\n이렇게 나만의 캐시 전략을 만들어두면, 복잡한 프로젝트에서 여러 페이지나 API에 맞게 캐시 설정을 다양하게 적용할 수 있어서 매우 유용해요.\n\n\u003e **팁:** 캐싱 전략을 짤 때, 너무 짧은 expire는 서버 부담을 늘리고, 너무 긴 expire는 사용자에게 오래된 데이터를 보여줄 위험이 생기므로 적절한 균형이 중요합니다!\n\n필요에 따라 값들을 튜닝하면서 최적의 캐시 전략을 찾아가 보세요. 앞으로도 이런 유용한 실전 팁 계속 소개할게요! 궁금한 점 있으면 언제든 물어봐 주세요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번에는 Next.js에서 캐싱을 좀 더 세밀하게 제어하는 방법에 대해 이야기해볼게요. 특히 `cacheLife` 함수를 사용해서 원하는 캐시 프로필을 직접 설정하는 방법을 다뤄보겠습니다.\n\n```js\n\"use cache\";\nimport { unstable_cacheLife as cacheLife } from \"next/cache\";\n\nexport default async function Page() {\n  return \u003cdiv\u003ePage\u003c/div\u003e;\n}\n```\n\n위 코드는 기본적인 캐시 설정 예시예요. 여기서 `cacheLife` 함수에 객체 형태의 설정값을 넘기면 내가 원하는 캐시 정책을 직접 만들 수 있어요. 그런데 중요한 점은 이렇게 만든 캐시 프로필은 해당 함수나 파일에 한해서만 적용된다는 거예요.\n\n만약 여러분의 앱 전체에서 같은 캐시 정책을 반복해서 쓰고 싶다면, 매번 이렇게 작성하는 대신 `next.config.ts` 파일 안에 `cacheLife` 속성을 추가하는 게 좋은 방법입니다. 그러면 전역적으로 일관된 캐싱 전략을 관리할 수 있거든요.\n\n---\n\n### 좀 더 살펴보는 `use cache`와 `cacheLife`의 중첩 사용법\n\n`'use cache'`는 Next.js에서 함수가 캐시 가능하다는 걸 알려주는 지시문이고, `cacheLife`는 그 캐시의 수명과 동작 정책을 좀 더 구체적으로 설정해주는 역할을 해요.\n\n```js\n\"use cache\";\nimport { unstable_cacheLife as cacheLife } from \"next/cache\";\n\n// 예를 들어, 캐시 수명을 60초로 지정하고 싶을 때\nconst myCacheConfig = cacheLife({ maxAge: 60 });\n\nexport default myCacheConfig(async function Page() {\n  return \u003cdiv\u003e캐시가 60초 동안 유지됩니다.\u003c/div\u003e;\n});\n```\n\n위처럼 `cacheLife`가 반환하는 함수로 래핑하면, 그 안 함수는 해당 캐시 정책을 따르게 됩니다.\n\n---\n\n### 추가 팁!\n\n- **maxAge**: 캐시 데이터가 얼마동안 살아있을지 초 단위로 지정해요.\n- **staleWhileRevalidate**: 캐시가 만료되더라도 새 데이터를 받아올 때까지 옛날 캐시를 계속 보여주는 설정이에요.\n- **캐시 무효화**: 필요할 땐 특정 조건이나 API 호출 시 캐시를 초기화해줄 수도 있는데, 이 부분도 꼭 체크해보시면 좋아요.\n\nReact 컴포넌트나 API 라우트에서 잘 활용하면, 불필요한 데이터 재요청을 줄이고 사용자 경험을 개선할 수 있답니다.\n\n필요하면 다음에 더 자세한 캐시 전략이나 예제도 정리해서 소개할게요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n같은 경로나 컴포넌트 트리 안에서 여러 캐싱 동작(caching behavior)을 정의할 때, 안쪽(내부) 캐시가 자신만의 cacheLife 프로필을 지정하면, 바깥쪽(외부) 캐시는 그 중 가장 짧은 캐시 지속시간을 자동으로 따르게 돼요. 단, 이건 바깥쪽 캐시가 명시적으로 cacheLife 프로필을 지정하지 않은 경우에만 적용됩니다.\n\n예를 들어, 페이지에 `use cache` 지시어를 붙이면서 별도로 캐시 프로필을 지정하지 않으면, 기본값인 `cacheLife(\"default\")`가 암묵적으로 적용돼요. 그런데 이 페이지에 불러오는 컴포넌트가 자체 캐시 프로필을 가진 `use cache`를 사용한다면, 내부와 외부 캐시 프로필이 비교되어서, 가장 짧은 시간이 적용됩니다.\n\n간단히 말해, 여러 레이어의 캐시가 있으면 \"가장 짧은 시간 기준\"으로 캐싱 기간을 설정해서, 데이터를 너무 오래 쓰지 않도록 조절해 준다는 거죠.\n\n---\n\n예를 들어서 본 부모 컴포넌트 코드를 한번 보면:\n\n```js\n// Parent component\nimport { unstable_cacheLife as cacheLife } from \"next/cache\";\nimport { ChildComponent } from \"./child\";\n\ncacheLife(\"days\"); // \"days\" 기준 캐싱 지속시간 지정\n\nreturn (\n  \u003cdiv\u003e\n    \u003cChildComponent /\u003e\n  \u003c/div\u003e\n);\n```\n\n그리고 별도의 파일에서 임포트한 자식 컴포넌트는 다음처럼 정의해요.\n\n(자식 컴포넌트 코드는 다음에 나올 거랍니다!)\n\n---\n\n### 추가 팁!\n\n- 캐시 지속 시간을 지정할 때는 `\"hours\"`, `\"minutes\"`, `\"seconds\"`처럼 구체적으로 설정하셔도 되고, 직접 숫자 단위(예: `cacheLife(60 * 60 * 24)`)로 초 단위 값을 줄 수도 있습니다.\n- 내부 컴포넌트의 캐시가 더 짧으면, 전체적으로 데이터 최신성이 더 잘 유지되기 때문에 업데이트 반영 속도가 빨라지죠.\n- 반대로 외부에서 명시적으로 긴 cacheLife를 지정하면 내부 캐시는 무시되고 외부 걸린 시간 기준으로 유지돼요. 따라서 캐시가 꼬이지 않도록 캐시 설정을 꼼꼼하게 관리하는 게 중요합니다.\n\n다음 메시지에 자식 컴포넌트 코드를 소개할게요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! 오늘은 Next.js에서 제공하는 `unstable_cacheLife` 함수에 대해 살펴볼게요. 이 함수는 캐시 수명을 설정할 때 사용되는데, 아직 공식적으로 안정화되지 않은 기능이라 `unstable_` 접두사가 붙어 있답니다.\n\n예시 코드가 주어졌는데, 쉽게 설명해볼게요.\n\n```js\n// Child 컴포넌트에서\nimport { unstable_cacheLife as cacheLife } from \"next/cache\";\n\ncacheLife(\"hours\");\nreturn \u003cdiv\u003eChild Content\u003c/div\u003e;\n\n// 이 컴포넌트의 캐시는 'hours' 프로필 기준으로 관리됩니다.\n```\n\n여기서 `cacheLife('hours')`라고 설정하면, 이 컴포넌트는 상대적으로 짧은 시간 단위인 'hours' 기준으로 캐시가 유지돼요. 즉, 더 빨리 캐시가 만료된다는 뜻이죠.\n\n### 참고할 점!\n\n- `cacheLife` 안에 들어갈 수 있는 프로필은 보통 'seconds', 'minutes', 'hours', 'days' 등이 있어요.\n- 이 기능은 아직 실험 단계라 문서가 계속 업데이트되고, API도 바뀔 수 있어요.\n- 캐시 수명을 적절히 조정하면 사용자 경험을 향상시키면서 서버 부하도 줄일 수 있다는 점에서 유용해요!\n\n### 마치며\n\nNext.js에서 캐시를 더 세밀하게 제어하고 싶을 때 `unstable_cacheLife`를 써볼 수 있지만, 아직 완전 안정적이지 않은 점을 기억하세요. 프로덕션에서는 주의해서 사용하고, 공식 문서 업데이트를 꾸준히 확인하는 걸 추천드립니다!\n\n도움이 되셨다면 좋겠네요. 다음에도 유용한 팁으로 찾아올게요! 😊\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":17},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003ecacheLife 함수 알아보기\u003c/h1\u003e\n\u003cp\u003e안녕하세요, 개발 블로거입니다! 오늘은 \u003ccode\u003ecacheLife\u003c/code\u003e라는 함수에 대해 이야기해보려고 해요. 이 함수는 함수나 컴포넌트의 캐시 수명을 설정하는 데 쓰여요. 캐시 수명이란, 쉽게 말해 '데이터를 얼마나 오래 저장해서 재사용할지'를 결정하는 시간이죠.\u003c/p\u003e\n\u003cp\u003e이 \u003ccode\u003ecacheLife\u003c/code\u003e 함수는 \u003ccode\u003euse cache\u003c/code\u003e 지시어와 함께 사용해야 하며, 반드시 함수나 컴포넌트의 범위 안에서 호출해야 한다는 점 기억하세요.\u003c/p\u003e\n\u003ch2\u003e사용법\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ecacheLife\u003c/code\u003e를 사용하려면 우선 프로젝트 설정 파일인 \u003ccode\u003enext.config.js\u003c/code\u003e에 \u003ccode\u003edynamicIO\u003c/code\u003e 플래그를 활성화해야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// next.config.js\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eexperimental\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003edynamicIO\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  },\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e왜 이렇게 설정해야 하냐면, \u003ccode\u003edynamicIO\u003c/code\u003e 플래그가 켜져야 동적인 입출력 처리와 캐싱 기능이 제대로 작동하기 때문이에요.\u003c/p\u003e\n\u003ch3\u003e참고로!\u003c/h3\u003e\n\u003cp\u003e만약 캐시를 너무 오래 유지하면 데이터가 오래된 상태일 수 있으니, 적절한 캐시 수명을 설정하는 게 중요해요. 반대로 너무 짧게 설정하면 캐시 효과가 떨어지고 서버 부하가 늘 수 있답니다.\u003c/p\u003e\n\u003cp\u003e추가로, React나 Next.js와 같은 프레임워크를 사용 중이라면, \u003ccode\u003ecacheLife\u003c/code\u003e 설정과 \u003ccode\u003euse cache\u003c/code\u003e 관련 지시어를 적절히 조합해 컴포넌트 렌더링 최적화를 도모할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e다음에 좀 더 구체적인 사용 예제와 실전 팁을 공유할게요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이번에 Next.js에서 소개된 새로운 기능 중 하나인 \u003ccode\u003edynamicIO\u003c/code\u003e와 \u003ccode\u003ecacheLife\u003c/code\u003e에 대해 간단히 살펴볼게요. 직접 써보고 정리한 내용이니 참고해서 프로젝트에 적용해봐도 좋을 것 같아요!\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003ccode\u003edynamicIO\u003c/code\u003e Experimental 옵션 설정하기\u003c/h3\u003e\n\u003cp\u003eNext.js는 계속 발전 중이라 실험적인 기능도 종종 나옵니다. \u003ccode\u003edynamicIO\u003c/code\u003e는 그중 하나인데, 이걸 켜면 IO 작업을 더 동적으로 처리할 수 있는 환경을 만들어줍니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e type { \u003cspan class=\"hljs-title class_\"\u003eNextConfig\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"next\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003enextConfig\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eNextConfig\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eexperimental\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003edynamicIO\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  },\n};\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e nextConfig;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e위처럼 \u003ccode\u003enext.config.js\u003c/code\u003e 혹은 \u003ccode\u003enext.config.ts\u003c/code\u003e에서 \u003ccode\u003eexperimental.dynamicIO\u003c/code\u003e 옵션을 \u003ccode\u003etrue\u003c/code\u003e로 설정하면 돼요.\u003c/li\u003e\n\u003cli\u003e공식 문서에서는 이 옵션이 아직 실험 단계라서, 실제 서비스에서는 좀 더 안정화될 때까지 조심스럽게 사용하는 걸 권장합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003ccode\u003ecacheLife\u003c/code\u003e 함수 사용하기\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003ecacheLife\u003c/code\u003e는 Next.js에서 새롭게 제공하는 캐싱 관련 유틸리티예요. 특히 서버 컴포넌트나 함수 내에서 캐싱 수명을 관리할 때 유용하죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e\"use cache\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { unstable_cacheLife \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e cacheLife } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"next/cache\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// cacheLife를 이용해 캐시 수명을 조절하는 로직 구현 가능\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003ePage\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e여기서 \u003ccode\u003euse cache\u003c/code\u003e라는 디렉티브도 눈에 띄는데, 이건 Next.js가 해당 모듈을 캐싱 대상으로 인식하게 해줘요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eunstable_cacheLife\u003c/code\u003e는 아직 실험적인 API라는 뜻이라, 이름 앞에 \u003ccode\u003eunstable_\u003c/code\u003e가 붙어 있어요.\u003c/li\u003e\n\u003cli\u003e이 함수를 활용하면, 필요한 부분의 캐시 유지 시간을 섬세하게 조절할 수 있어요. 예를 들어, 데이터 페칭 결과를 일정 시간 동안만 캐싱하고 싶을 때 유용하답니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003e참고사항 및 팁\u003c/h3\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e내용\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003edynamicIO\u003c/code\u003e 기능의 목적\u003c/td\u003e\u003ctd\u003eI/O 작업을 더 동적으로 처리하여 효율적인 데이터 페칭과 렌더링 가능\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ecacheLife\u003c/code\u003e 활용법\u003c/td\u003e\u003ctd\u003e캐시 수명을 직접 설정해 보다 세밀한 리소스 관리 가능\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e'unstable_' 접두사 의미\u003c/td\u003e\u003ctd\u003e아직 안정화되지 않은 API, 앞으로 변경될 가능성 있음\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eNext.js 실험적 기능 활용시 주의사항\u003c/td\u003e\u003ctd\u003e실제 서비스에 적용할 때는 충분한 테스트 후 사용하는 것이 좋음\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e혹시 이 기능들을 실제로 프로젝트에 적용해보고 어려운 점이나 궁금한 점이 있으면 댓글로 남겨주세요! 저도 더 공부해서 좋은 팁들 공유할게요. Next.js 계속 발전하는 만큼, 우리도 함께 성장해보자구요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003e기본 캐시 프로필 소개\u003c/h3\u003e\n\u003cp\u003eNext.js에서는 다양한 시간대에 맞춘 이름 있는 캐시 프로필 세트를 제공해요. 만약 \u003ccode\u003euse cache\u003c/code\u003e 디렉티브와 함께 \u003ccode\u003ecacheLife\u003c/code\u003e 함수에 캐시 프로필을 지정하지 않으면, Next.js가 기본 캐시 프로필을 자동으로 적용해줍니다.\u003c/p\u003e\n\u003cp\u003e하지만 저는 항상 \u003ccode\u003euse cache\u003c/code\u003e를 사용할 때는 명시적으로 캐시 프로필을 지정해주는 걸 추천해요. 그래야 내가 원하는 캐싱 동작을 확실히 정의할 수 있거든요!\u003c/p\u003e\n\u003cp\u003e아래는 Next.js가 제공하는 기본 캐시 프로필들의 종류와 각 프로필이 가진 \u003ccode\u003estale\u003c/code\u003e, \u003ccode\u003erevalidate\u003c/code\u003e, \u003ccode\u003eexpire\u003c/code\u003e 타임라인, 그리고 설명입니다.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e프로필\u003c/th\u003e\u003cth\u003estale\u003c/th\u003e\u003cth\u003erevalidate\u003c/th\u003e\u003cth\u003eexpire\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003edefault\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e5분\u003c/td\u003e\u003ctd\u003e15분\u003c/td\u003e\u003ctd\u003e1년\u003c/td\u003e\u003ctd\u003e자주 업데이트 필요 없는 콘텐츠에 적합한 기본 프로필\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eseconds\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e0\u003c/td\u003e\u003ctd\u003e1초\u003c/td\u003e\u003ctd\u003e1초\u003c/td\u003e\u003ctd\u003e거의 실시간 업데이트가 필요한 빠르게 변하는 콘텐츠에 적합\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eminutes\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e5분\u003c/td\u003e\u003ctd\u003e1분\u003c/td\u003e\u003ctd\u003e1시간\u003c/td\u003e\u003ctd\u003e한 시간 내 자주 업데이트되는 콘텐츠에 적합\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ehours\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e5분\u003c/td\u003e\u003ctd\u003e1시간\u003c/td\u003e\u003ctd\u003e1일\u003c/td\u003e\u003ctd\u003e하루 단위로 업데이트되며 약간 오래된 캐시가 허용되는 콘텐츠에 적합\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003edays\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e5분\u003c/td\u003e\u003ctd\u003e1일\u003c/td\u003e\u003ctd\u003e1주일\u003c/td\u003e\u003ctd\u003e주 단위로 업데이트되며 하루 정도 오래된 캐시 정도 괜찮은 콘텐츠에 적합\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eweeks\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e5분\u003c/td\u003e\u003ctd\u003e1주일\u003c/td\u003e\u003ctd\u003e30일\u003c/td\u003e\u003ctd\u003e월 단위 업데이트이며 일주일 정도 캐시가 오래돼도 괜찮은 콘텐츠에 적합\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003emax\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e5분\u003c/td\u003e\u003ctd\u003e30일\u003c/td\u003e\u003ctd\u003e1년\u003c/td\u003e\u003ctd\u003e거의 변경되지 않는 매우 안정적인 콘텐츠에 적합\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003ch3\u003e덧붙여서...\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003estale\u003c/code\u003e 기간이란, 캐시된 데이터가 구식(stale)으로 간주되기 전까지의 시간입니다. 이 기간 동안은 캐시된 데이터를 사용하지만, \u003ccode\u003erevalidate\u003c/code\u003e 시점에는 백그라운드에서 새로운 데이터를 받아와서 캐시를 갱신하게 돼요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erevalidate\u003c/code\u003e는 백그라운드에서 데이터를 다시 요청하는 시기를 뜻해요. 이때 응답은 즉시 캐시된 값으로 처리하고, 서버에서 신규 데이터를 받아 업데이트합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eexpire\u003c/code\u003e는 캐시가 완전히 만료되어 더 이상 사용할 수 없는 시점을 의미합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e만약 자주 업데이트가 필요한 뉴스 사이트나 주식 시세, 실시간 스포츠 결과 같은 데이터라면 \u003ccode\u003eseconds\u003c/code\u003e나 \u003ccode\u003eminutes\u003c/code\u003e 프로필을, 변화가 거의 없는 블로그 포스트나 정적인 이미지 리소스라면 \u003ccode\u003emax\u003c/code\u003e 프로필 같은 장기 캐싱을 선택하는 게 효율적이에요.\u003c/p\u003e\n\u003cp\u003eNext.js 캐시 기능은 이렇게 시간 기반 프로필을 잘 활용하면 사용자 경험도 개선하고 서버 부하도 줄일 수 있으니, 꼭 적절하게 설정해서 활용해 보시길 바랍니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e캐시 프로필을 참조할 때 사용하는 문자열 값들은 그 자체로 특별한 의미를 가지기보다는, 코드 내에서 의미를 부여하는 라벨 역할을 해요. 덕분에 캐시된 콘텐츠를 더 쉽고 직관적으로 관리할 수 있답니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e참고할 점: staleTimes와 expireTime 설정을 변경하면 기본 캐시 프로필의 stale과 expire 속성도 함께 업데이트돼요. 즉, 일관성 있게 캐시 설정을 관리할 수 있다는 뜻이죠.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3\u003e커스텀 캐시 프로필 만들기\u003c/h3\u003e\n\u003cp\u003eNext.js 프로젝트에서 커스텀 캐시 프로필을 만들어 사용하고 싶다면, \u003ccode\u003enext.config.ts\u003c/code\u003e 파일 내의 \u003ccode\u003ecacheLife\u003c/code\u003e 옵션에 직접 추가하면 돼요. 이렇게 하면 프로젝트 요구사항에 맞게 캐시 정책을 세밀하게 조정할 수 있답니다.\u003c/p\u003e\n\u003cp\u003e아래는 \u003ccode\u003ecacheLife\u003c/code\u003e 옵션을 활용해 여러 캐시 프로필을 정의하는 예시입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-typescript\"\u003e\u003cspan class=\"hljs-comment\"\u003e// next.config.ts\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003eexperimental\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003ecacheLife\u003c/span\u003e: {\n      \u003cspan class=\"hljs-attr\"\u003eshortCache\u003c/span\u003e: { \u003cspan class=\"hljs-attr\"\u003estaleTime\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eexpireTime\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e120\u003c/span\u003e }, \u003cspan class=\"hljs-comment\"\u003e// 짧게 유지되는 캐시 예시 (초단위)\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003elongCache\u003c/span\u003e: { \u003cspan class=\"hljs-attr\"\u003estaleTime\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3600\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eexpireTime\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e7200\u003c/span\u003e }, \u003cspan class=\"hljs-comment\"\u003e// 오래 유지되는 캐시 예시\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003enoCache\u003c/span\u003e: { \u003cspan class=\"hljs-attr\"\u003estaleTime\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eexpireTime\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e }, \u003cspan class=\"hljs-comment\"\u003e// 캐시를 사용하지 않는 프로필\u003c/span\u003e\n    },\n  },\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 프로필을 만들고 나면, 데이터 요청이나 페이지 캐싱 시에 해당 프로필 이름(\u003ccode\u003eshortCache\u003c/code\u003e, \u003ccode\u003elongCache\u003c/code\u003e 등)을 참조해 필요한 캐시 정책을 간편하게 적용할 수 있죠.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e팁! 캐시를 적절히 활용하면 서버 부하도 줄이고, 사용자 경험도 크게 향상시킬 수 있어요. 하지만 너무 오래된 캐시는 오히려 구버전 콘텐츠를 보여줄 수 있으니, 상황에 따라 적절한 \u003ccode\u003estaleTime\u003c/code\u003e과 \u003ccode\u003eexpireTime\u003c/code\u003e 설정이 중요하답니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eCache profiles는 캐시와 관련된 몇 가지 속성을 담고 있는 객체입니다. 각 속성은 캐시가 어떻게 동작하는지 세밀하게 조절할 수 있게 도와주죠. 아래 표를 보면서 살펴볼게요.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eProperty\u003c/th\u003e\u003cth\u003eValue\u003c/th\u003e\u003cth\u003eDescription\u003c/th\u003e\u003cth\u003eRequirement\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003estale\u003c/code\u003e\u003c/td\u003e\u003ctd\u003enumber\u003c/td\u003e\u003ctd\u003e클라이언트가 서버에 확인하지 않고 값을 캐시에 저장해두는 기간입니다.\u003c/td\u003e\u003ctd\u003e선택 사항\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003erevalidate\u003c/code\u003e\u003c/td\u003e\u003ctd\u003enumber\u003c/td\u003e\u003ctd\u003e서버에서 캐시를 새로 고칠 주기입니다. 리밸리데이트 중에는 오래된 값(stale)을 보여줄 수 있어요.\u003c/td\u003e\u003ctd\u003e선택 사항\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eexpire\u003c/code\u003e\u003c/td\u003e\u003ctd\u003enumber\u003c/td\u003e\u003ctd\u003e값이 오래된 상태(stale)로 유지될 수 있는 최대 기간입니다. 이 기간이 지나면 동적(fetch)으로 전환됩니다. 반드시 \u003ccode\u003erevalidate\u003c/code\u003e보다 길어야 합니다.\u003c/td\u003e\u003ctd\u003e선택 사항 – \u003ccode\u003erevalidate\u003c/code\u003e보다 커야 함\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003cp\u003e여기서 조금 혼동될 수 있는 부분이 \u003ccode\u003estale\u003c/code\u003e 속성과 \u003ccode\u003estaleTimes\u003c/code\u003e 설정인데요, 간단히 말씀드리면:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003estale\u003c/code\u003e은 클라이언트 사이드 라우터 쪽 캐시만 제어합니다. 즉, 특정 함수나 경로(route)별로 직접 '얼마 동안 캐싱할지'를 정할 수 있다는 거죠.\u003c/li\u003e\n\u003cli\u003e반면에 \u003ccode\u003estaleTimes\u003c/code\u003e는 전역(globa) 설정으로, 동적(dynamic) 데이터와 정적(static) 데이터 모두에 영향을 미칩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e그리고 한 가지 팁!\u003cbr\u003e\n\u003ccode\u003estale\u003c/code\u003e 속성은 \u003cstrong\u003eCache-control: max-age\u003c/strong\u003e HTTP 헤더 값을 설정하는 게 아닙니다. 이건 서버에서 보내는 캐시 지시자(header)이지만, \u003ccode\u003estale\u003c/code\u003e은 오로지 클라이언트 라우터의 로컬 캐시 관리를 위한 설정이라는 점, 꼭 기억하세요.\u003c/p\u003e\n\u003cp\u003e이런 캐시 컨트롤 방법은 앱을 더 빠르게 만들면서도 최신 데이터를 적절히 유지하는 데 아주 유용해요. 각 상황에 맞게 잘 조절해보면서 퍼포먼스 최적화에 활용해보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e예시\u003c/h2\u003e\n\u003ch3\u003e재사용 가능한 캐시 프로필 정의하기\u003c/h3\u003e\n\u003cp\u003enext.config.ts 파일에서 재사용 가능한 캐시 프로필을 정의할 수 있어요. 프로필 이름은 사용 목적에 맞게 지정하고, \u003ccode\u003estale\u003c/code\u003e, \u003ccode\u003erevalidate\u003c/code\u003e, \u003ccode\u003eexpire\u003c/code\u003e 속성들을 설정해주면 됩니다. 필요한 만큼 여러 개의 커스텀 캐시 프로필을 만들어 사용할 수 있어요. 각 프로필은 이름을 문자열로 \u003ccode\u003ecacheLife\u003c/code\u003e 함수에 전달해서 참조할 수 있답니다.\u003c/p\u003e\n\u003cp\u003e아래 예시는 14일간 캐시를 유지하고, 1일마다 재검증을 수행하는 \u003ccode\u003ebiweekly\u003c/code\u003e라는 캐시 프로필을 정의한 코드입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-typescript\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eNextConfig\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"next\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003enextConfig\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eNextConfig\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eexperimental\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003edynamicIO\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003ecacheLife\u003c/span\u003e: {\n      \u003cspan class=\"hljs-attr\"\u003ebiweekly\u003c/span\u003e: {\n        \u003cspan class=\"hljs-attr\"\u003estale\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e24\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e14\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 14일 동안 stale 상태 유지\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003erevalidate\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e24\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 1일 간격으로 재검증\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eexpire\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e24\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e14\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 14일 후 캐시 만료\u003c/span\u003e\n      },\n    },\n  },\n};\n\n\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = nextConfig;\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e참고로 캐시 관련 설정을 잘 해두면, 페이지 로딩 속도가 크게 향상되고 서버 부하도 줄일 수 있어요.\u003c/strong\u003e 특히 자주 변하지 않는 데이터라면 이런 캐시 프로필을 적극 활용해서 효율적인 서비스 운영을 할 수 있답니다.\u003c/p\u003e\n\u003cp\u003e단, \u003ccode\u003estale\u003c/code\u003e, \u003ccode\u003erevalidate\u003c/code\u003e, \u003ccode\u003eexpire\u003c/code\u003e 값은 상황에 맞게 조절해야 해요. 예측 가능한 사용자 트래픽, 데이터 갱신 빈도 등을 고려해 보세요. 너무 길게 설정하면 오래된 데이터가 노출될 수도 있으니까 주의가 필요해요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e위 예시는 14일 동안 캐시를 유지하고, 매일 업데이트를 확인하며, 14일이 지나면 캐시가 만료되도록 설정한 거예요. 이렇게 만든 캐시 프로필은 애플리케이션 전반에서 이름으로 참조해서 사용할 수 있답니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e\"use cache\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { unstable_cacheLife \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e cacheLife } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"next/cache\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003ePage\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e기본 캐시 프로필 덮어쓰기(오버라이딩)\u003c/h3\u003e\n\u003cp\u003eNext.js에서 제공하는 기본 캐시 프로필은 캐시된 데이터가 얼마나 신선한지, 혹은 얼마나 오래된 것인지를 결정하는 데 도움을 줘요. 그런데 어떤 애플리케이션은 기본 프로필보다 더 세분화된 캐싱 전략이 필요할 수 있죠. 이럴 때는 내 입맛에 맞게 이름이 붙은(즉, 커스텀) 캐시 프로필을 만들어서 쓸 수 있어요.\u003c/p\u003e\n\u003cp\u003e예를 들어, 자주 업데이트되는 뉴스 섹션엔 'shortCache', 변경이 거의 없는 공지사항엔 'longCache' 같은 이름을 붙여서 관리하면 더 효율적이고 관리하기도 편하답니다. 이렇게 하면 빠른 캐시 만료가 필요한 곳과 오래 두어도 무방한 부분을 명확히 구분할 수 있어요.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e참고 팁:\u003c/strong\u003e 캐시 프로필을 세밀하게 관리하면, 서버 부담을 줄이면서도 사용자에게 항상 신선한 콘텐츠를 제공할 수 있어요. 너무 보수적으로 캐시 기간을 설정하면 빈번한 요청 처리로 서버에 부담이 갈 수 있으니, 애플리케이션 특성에 맞게 적절히 조절하는 게 중요합니다!\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003enext.js에서 기본으로 제공하는 캐시 프로필(named cache profiles)을 커스텀하고 싶을 때, 같은 이름으로 새 설정을 만들어서 덮어쓸 수 있다는 점, 알고 계셨나요? 기본 프로필을 그대로 쓰는 것도 좋지만, 프로젝트 상황에 맞게 적절히 조정하면 효율적인 캐시 관리가 가능해집니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 기본 “days” 캐시 프로필을 이렇게 오버라이딩할 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e nextConfig = {\n  \u003cspan class=\"hljs-attr\"\u003eexperimental\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003edynamicIO\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003ecacheLife\u003c/span\u003e: {\n      \u003cspan class=\"hljs-attr\"\u003edays\u003c/span\u003e: {\n        \u003cspan class=\"hljs-attr\"\u003estale\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3600\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 1시간 동안 stale 상태 유지\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003erevalidate\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e900\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 15분마다 재검증\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eexpire\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e86400\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 1일 후 만료\u003c/span\u003e\n      },\n    },\n  },\n};\n\n\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = nextConfig;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 좀 더 설명을 드리자면,\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003estale\u003c/code\u003e: 캐시된 데이터가 조금 오래됐어도 바로 폐기하지 않고, 이 시간만큼은 stale 상태로 허용합니다. (즉, 약간 낡은 데이터도 사용할 수 있게끔 시간을 설정하는 거예요.)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erevalidate\u003c/code\u003e: 재검증(interval) 주기로, 이 시간이 지나면 캐시를 백그라운드에서 새로고침합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eexpire\u003c/code\u003e: 캐시가 완전히 만료되는 시간으로, 이 시간이 지나면 캐시를 폐기하고 새 데이터를 받아옵니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이런 설정 덕분에 데이터를 너무 자주 다시 받느라 리소스를 낭비하지 않고, 살짝 오래된 데이터도 쓸 수 있게 해서 효율성을 높일 수 있답니다.\u003c/p\u003e\n\u003ch3\u003e캐시 프로필 직접 정의하기 (Defining cache profiles inline)\u003c/h3\u003e\n\u003cp\u003e기본 프로필이 아니라 완전히 새롭게 캐시 프로필을 정의하고 싶을 때도 있습니다. 예를 들어, 'hours'라는 이름으로 6시간 단위의 캐시 전략을 직접 만들어볼 수 있죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e nextConfig = {\n  \u003cspan class=\"hljs-attr\"\u003eexperimental\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003edynamicIO\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003ecacheLife\u003c/span\u003e: {\n      \u003cspan class=\"hljs-attr\"\u003ehours\u003c/span\u003e: {\n        \u003cspan class=\"hljs-attr\"\u003estale\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e600\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 10분간 stale 허용\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003erevalidate\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e300\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 5분마다 재검증\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eexpire\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e21600\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 6시간 후 만료\u003c/span\u003e\n      },\n    },\n  },\n};\n\n\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = nextConfig;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 나만의 캐시 전략을 만들어두면, 복잡한 프로젝트에서 여러 페이지나 API에 맞게 캐시 설정을 다양하게 적용할 수 있어서 매우 유용해요.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e팁:\u003c/strong\u003e 캐싱 전략을 짤 때, 너무 짧은 expire는 서버 부담을 늘리고, 너무 긴 expire는 사용자에게 오래된 데이터를 보여줄 위험이 생기므로 적절한 균형이 중요합니다!\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e필요에 따라 값들을 튜닝하면서 최적의 캐시 전략을 찾아가 보세요. 앞으로도 이런 유용한 실전 팁 계속 소개할게요! 궁금한 점 있으면 언제든 물어봐 주세요 :)\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이번에는 Next.js에서 캐싱을 좀 더 세밀하게 제어하는 방법에 대해 이야기해볼게요. 특히 \u003ccode\u003ecacheLife\u003c/code\u003e 함수를 사용해서 원하는 캐시 프로필을 직접 설정하는 방법을 다뤄보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e\"use cache\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { unstable_cacheLife \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e cacheLife } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"next/cache\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003ePage\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드는 기본적인 캐시 설정 예시예요. 여기서 \u003ccode\u003ecacheLife\u003c/code\u003e 함수에 객체 형태의 설정값을 넘기면 내가 원하는 캐시 정책을 직접 만들 수 있어요. 그런데 중요한 점은 이렇게 만든 캐시 프로필은 해당 함수나 파일에 한해서만 적용된다는 거예요.\u003c/p\u003e\n\u003cp\u003e만약 여러분의 앱 전체에서 같은 캐시 정책을 반복해서 쓰고 싶다면, 매번 이렇게 작성하는 대신 \u003ccode\u003enext.config.ts\u003c/code\u003e 파일 안에 \u003ccode\u003ecacheLife\u003c/code\u003e 속성을 추가하는 게 좋은 방법입니다. 그러면 전역적으로 일관된 캐싱 전략을 관리할 수 있거든요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e좀 더 살펴보는 \u003ccode\u003euse cache\u003c/code\u003e와 \u003ccode\u003ecacheLife\u003c/code\u003e의 중첩 사용법\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e'use cache'\u003c/code\u003e는 Next.js에서 함수가 캐시 가능하다는 걸 알려주는 지시문이고, \u003ccode\u003ecacheLife\u003c/code\u003e는 그 캐시의 수명과 동작 정책을 좀 더 구체적으로 설정해주는 역할을 해요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e\"use cache\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { unstable_cacheLife \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e cacheLife } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"next/cache\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// 예를 들어, 캐시 수명을 60초로 지정하고 싶을 때\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e myCacheConfig = \u003cspan class=\"hljs-title function_\"\u003ecacheLife\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003emaxAge\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e });\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emyCacheConfig\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e캐시가 60초 동안 유지됩니다.\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e;\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위처럼 \u003ccode\u003ecacheLife\u003c/code\u003e가 반환하는 함수로 래핑하면, 그 안 함수는 해당 캐시 정책을 따르게 됩니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e추가 팁!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003emaxAge\u003c/strong\u003e: 캐시 데이터가 얼마동안 살아있을지 초 단위로 지정해요.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003estaleWhileRevalidate\u003c/strong\u003e: 캐시가 만료되더라도 새 데이터를 받아올 때까지 옛날 캐시를 계속 보여주는 설정이에요.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e캐시 무효화\u003c/strong\u003e: 필요할 땐 특정 조건이나 API 호출 시 캐시를 초기화해줄 수도 있는데, 이 부분도 꼭 체크해보시면 좋아요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eReact 컴포넌트나 API 라우트에서 잘 활용하면, 불필요한 데이터 재요청을 줄이고 사용자 경험을 개선할 수 있답니다.\u003c/p\u003e\n\u003cp\u003e필요하면 다음에 더 자세한 캐시 전략이나 예제도 정리해서 소개할게요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e같은 경로나 컴포넌트 트리 안에서 여러 캐싱 동작(caching behavior)을 정의할 때, 안쪽(내부) 캐시가 자신만의 cacheLife 프로필을 지정하면, 바깥쪽(외부) 캐시는 그 중 가장 짧은 캐시 지속시간을 자동으로 따르게 돼요. 단, 이건 바깥쪽 캐시가 명시적으로 cacheLife 프로필을 지정하지 않은 경우에만 적용됩니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 페이지에 \u003ccode\u003euse cache\u003c/code\u003e 지시어를 붙이면서 별도로 캐시 프로필을 지정하지 않으면, 기본값인 \u003ccode\u003ecacheLife(\"default\")\u003c/code\u003e가 암묵적으로 적용돼요. 그런데 이 페이지에 불러오는 컴포넌트가 자체 캐시 프로필을 가진 \u003ccode\u003euse cache\u003c/code\u003e를 사용한다면, 내부와 외부 캐시 프로필이 비교되어서, 가장 짧은 시간이 적용됩니다.\u003c/p\u003e\n\u003cp\u003e간단히 말해, 여러 레이어의 캐시가 있으면 \"가장 짧은 시간 기준\"으로 캐싱 기간을 설정해서, 데이터를 너무 오래 쓰지 않도록 조절해 준다는 거죠.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e예를 들어서 본 부모 컴포넌트 코드를 한번 보면:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// Parent component\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { unstable_cacheLife \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e cacheLife } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"next/cache\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eChildComponent\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"./child\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-title function_\"\u003ecacheLife\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"days\"\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// \"days\" 기준 캐싱 지속시간 지정\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eChildComponent\u003c/span\u003e /\u003e\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 별도의 파일에서 임포트한 자식 컴포넌트는 다음처럼 정의해요.\u003c/p\u003e\n\u003cp\u003e(자식 컴포넌트 코드는 다음에 나올 거랍니다!)\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e추가 팁!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e캐시 지속 시간을 지정할 때는 \u003ccode\u003e\"hours\"\u003c/code\u003e, \u003ccode\u003e\"minutes\"\u003c/code\u003e, \u003ccode\u003e\"seconds\"\u003c/code\u003e처럼 구체적으로 설정하셔도 되고, 직접 숫자 단위(예: \u003ccode\u003ecacheLife(60 * 60 * 24)\u003c/code\u003e)로 초 단위 값을 줄 수도 있습니다.\u003c/li\u003e\n\u003cli\u003e내부 컴포넌트의 캐시가 더 짧으면, 전체적으로 데이터 최신성이 더 잘 유지되기 때문에 업데이트 반영 속도가 빨라지죠.\u003c/li\u003e\n\u003cli\u003e반대로 외부에서 명시적으로 긴 cacheLife를 지정하면 내부 캐시는 무시되고 외부 걸린 시간 기준으로 유지돼요. 따라서 캐시가 꼬이지 않도록 캐시 설정을 꼼꼼하게 관리하는 게 중요합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음 메시지에 자식 컴포넌트 코드를 소개할게요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e안녕하세요! 오늘은 Next.js에서 제공하는 \u003ccode\u003eunstable_cacheLife\u003c/code\u003e 함수에 대해 살펴볼게요. 이 함수는 캐시 수명을 설정할 때 사용되는데, 아직 공식적으로 안정화되지 않은 기능이라 \u003ccode\u003eunstable_\u003c/code\u003e 접두사가 붙어 있답니다.\u003c/p\u003e\n\u003cp\u003e예시 코드가 주어졌는데, 쉽게 설명해볼게요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// Child 컴포넌트에서\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { unstable_cacheLife \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e cacheLife } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"next/cache\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-title function_\"\u003ecacheLife\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"hours\"\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003eChild Content\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// 이 컴포넌트의 캐시는 'hours' 프로필 기준으로 관리됩니다.\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 \u003ccode\u003ecacheLife('hours')\u003c/code\u003e라고 설정하면, 이 컴포넌트는 상대적으로 짧은 시간 단위인 'hours' 기준으로 캐시가 유지돼요. 즉, 더 빨리 캐시가 만료된다는 뜻이죠.\u003c/p\u003e\n\u003ch3\u003e참고할 점!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ecacheLife\u003c/code\u003e 안에 들어갈 수 있는 프로필은 보통 'seconds', 'minutes', 'hours', 'days' 등이 있어요.\u003c/li\u003e\n\u003cli\u003e이 기능은 아직 실험 단계라 문서가 계속 업데이트되고, API도 바뀔 수 있어요.\u003c/li\u003e\n\u003cli\u003e캐시 수명을 적절히 조정하면 사용자 경험을 향상시키면서 서버 부하도 줄일 수 있다는 점에서 유용해요!\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e마치며\u003c/h3\u003e\n\u003cp\u003eNext.js에서 캐시를 더 세밀하게 제어하고 싶을 때 \u003ccode\u003eunstable_cacheLife\u003c/code\u003e를 써볼 수 있지만, 아직 완전 안정적이지 않은 점을 기억하세요. 프로덕션에서는 주의해서 사용하고, 공식 문서 업데이트를 꾸준히 확인하는 걸 추천드립니다!\u003c/p\u003e\n\u003cp\u003e도움이 되셨다면 좋겠네요. 다음에도 유용한 팁으로 찾아올게요! 😊\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2025-04-22-cacheLife"},"buildId":"M7pU9hOcx8u_ZIFMf95sd","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>