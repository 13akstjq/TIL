<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Nextjs 15 에서 reactCompiler 사용하는 방법 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-reactCompiler" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Nextjs 15 에서 reactCompiler 사용하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:title" content="Nextjs 15 에서 reactCompiler 사용하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-reactCompiler" data-gatsby-head="true"/><meta name="twitter:title" content="Nextjs 15 에서 reactCompiler 사용하는 방법 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2025-04-22 13:18" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/0eef537492fed77a.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/0eef537492fed77a.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-8ded8b979ba73586.js" defer=""></script><script src="/TIL/_next/static/KUC9M_yIlA1Ugo01xmkHL/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/KUC9M_yIlA1Ugo01xmkHL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Nextjs 15 에서 reactCompiler 사용하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Nextjs 15 에서 reactCompiler 사용하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Apr 22, 2025</span><span class="posts_reading_time__f7YPP">5<!-- --> min read</span></span></div></div></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>reactCompiler</h1>
<p>Next.js 15에서는 React Compiler를 공식 지원하기 시작했어요. 이 컴파일러는 성능을 쑥 올려주는 마법 같은 역할을 하는데요, 컴포넌트 렌더링을 자동으로 최적화해줘서 개발자가 직접 useMemo나 useCallback 같은 API를 통해 메모이제이션을 신경 쓸 필요가 훨씬 줄어들게 되었답니다.</p>
<p>사용 방법도 간단해요! Next.js 15 버전으로 업그레이드한 뒤, <code>babel-plugin-react-compiler</code>를 설치하면 끝!<br>
설치 명령어는 다음과 같아요:</p>
<pre><code class="hljs language-bash">npm install babel-plugin-react-compiler
</code></pre>
<blockquote>
<p>참고로, 이 컴파일러는 특히 복잡한 상태 로직을 가진 대규모 애플리케이션에서 효과가 크게 나타나요. 기존에 매번 리렌더링 때문에 고민했던 부분들이 자연스럽게 해소될 수 있으니 꼭 활용해보세요.</p>
</blockquote>
<p>또 한 가지, babel 플러그인을 설정하는 부분은 <code>babel.config.js</code>나 <code>.babelrc</code> 파일에 다음과 같이 추가해주시면 돼요:</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">plugins</span>: [<span class="hljs-string">"babel-plugin-react-compiler"</span>],
};
</code></pre>
<p>이렇게만 해주면 Next.js 15와 함께 더욱 빠르고 깔끔한 React 앱을 만들 준비가 끝난 거예요! 앞으로는 불필요한 렌더링 걱정 없이 개발에 집중할 수 있겠네요 :)</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그럼 next.config.js 파일에 experimental.reactCompiler 옵션을 추가해볼게요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> type { <span class="hljs-title class_">NextConfig</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'next'</span>

<span class="hljs-keyword">const</span> <span class="hljs-attr">nextConfig</span>: <span class="hljs-title class_">NextConfig</span> = {
  <span class="hljs-attr">experimental</span>: {
    <span class="hljs-attr">reactCompiler</span>: <span class="hljs-literal">true</span>,
  },
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> nextConfig
</code></pre>
<blockquote>
<p>참고: React Compiler는 현재 Next.js에서 Babel 플러그인을 통해서만 사용할 수 있어요. 이 옵션을 켜면 Next.js 기본 Rust 기반 컴파일러를 사용하지 않게 되어서, 빌드 시간이 조금 더 길어질 수 있어요. 하지만 Next.js 팀에서 앞으로 React Compiler를 기본 컴파일러로 지원할 계획이라고 하니 기대해도 좋습니다!</p>
</blockquote>
<h2>주석(Annotations)</h2>
<p>'Annotations'는 코드나 설정 등에 부가적인 설명이나 메타데이터를 달아주는 역할을 해요. 예를 들면, 함수나 컴포넌트 위에 달리는 주석들이나 TypeScript의 데코레이터(@) 같은 것도 일종의 애노테이션이죠. Next.js에서는 여러 실험적 옵션들에 대해 주석이나 문서화 작업을 통해 개발자를 돕고 있답니다.</p>
<p>추가로, React Compiler를 통해 얻을 수 있는 장점은 다음과 같아요:</p>
<ul>
<li>더 빠른 렌더링 속도</li>
<li>중간 빌드 산출물 감소</li>
<li>향상된 개발자 경험(에러 메시지 개선 등)</li>
</ul>
<p>하지만 아직은 실험 단계라서 호환성 문제나 빌드 속도 저하가 생길 수 있으니, 프로덕션 환경에서는 신중하게 테스트해보는 걸 추천해요.</p>
<p>필요하면 이 옵션을 켜고 끄면서 빌드 성능과 동작 안정성을 직접 체험해보는 것도 좋은 공부가 될 거예요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이번에는 Next.js에서 컴파일러를 'opt-in' 모드로 설정하는 방법을 공유할게요. 이 설정을 통해 필요한 컴포넌트나 훅에만 React의 메모이제이션(캐싱)을 적용할 수 있는데요, 크게 두 단계가 있어요.</p>
<h3>1. Next.js 설정 변경하기</h3>
<p>먼저 <code>next.config.js</code> 혹은 <code>next.config.ts</code> 파일에서 컴파일러의 <code>compilationMode</code>를 <code>'annotation'</code>으로 설정해줘야 해요. 이렇게 하면 코드 내 특정 위치에만 메모이제이션을 활성화할 수 있게 돼요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> type { <span class="hljs-title class_">NextConfig</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'next'</span>

<span class="hljs-keyword">const</span> <span class="hljs-attr">nextConfig</span>: <span class="hljs-title class_">NextConfig</span> = {
  <span class="hljs-attr">experimental</span>: {
    <span class="hljs-attr">reactCompiler</span>: {
      <span class="hljs-attr">compilationMode</span>: <span class="hljs-string">'annotation'</span>,
    },
  },
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> nextConfig
</code></pre>
<p><code>experimental</code> 아래에 있는 설정이라 아직 완전히 안정화된 기능은 아닐 수 있으니, 프로젝트 상황에 맞게 테스트해보는 걸 추천합니다.</p>
<h3>2. 특정 컴포넌트에 메모이제이션 적용하기</h3>
<p>설정이 끝나면, 메모이제이션을 적용하고 싶은 컴포넌트나 훅에 <code>'use memo'</code>라는 디렉티브를 추가하세요. 아래처럼 컴포넌트 함수 최상단에 문자열로 선언하면 됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {
  <span class="hljs-string">'use memo'</span>
  <span class="hljs-comment">// 이 컴포넌트는 React 메모이제이션의 혜택을 받게 돼요.</span>
}
</code></pre>
<p>이걸 붙이는 순간, React 컴파일러가 이 컴포넌트를 최적화 대상으로 인식해 불필요한 리렌더링을 줄일 수 있어요.</p>
<hr>
<h3>추가 팁!</h3>
<ul>
<li><code>compilationMode</code>에 <code>'annotation'</code> 외에도 <code>'global'</code> 모드가 있는데, 이건 모든 컴포넌트에 자동으로 최적화를 적용하는 방식이에요. 하지만, 상황에 따라 부작용이 있을 수 있으니 꼭 필요한 부분에만 최적화를 적용하려면 <code>'annotation'</code> 모드를 추천합니다.</li>
<li>React의 이와 같은 실험적인 최적화 기능은 프로젝트 규모가 크거나 복잡한 상태일 때 성능에 도움이 될 수 있어요. 하지만 작거나 단순한 프로젝트에서는 오히려 디버깅이 복잡해질 수 있으니 신중히 적용하세요.</li>
</ul>
<p>이상으로 Next.js에서 React 컴파일러를 opt-in 모드로 활용하는 방법이었습니다. 필요할 때만 선택적으로 메모이제이션을 켜서 성능과 관리의 균형을 잘 맞춰보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>참고로, React에서는 "use no memo"라는 지시어도 사용할 수 있는데요, 이건 반대로 컴포넌트나 훅을 메모이제이션에서 제외하고 싶을 때 쓰는 방법이에요. 즉, 특정 컴포넌트나 훅이 리렌더링 될 때마다 항상 새롭게 실행되도록 하고 싶다면 이 지시어를 적용할 수 있죠.</p>
<p>메모이제이션(memoization)이란, 컴포넌트가 같은 props나 상태를 가진다면 이전에 계산한 결과를 재사용해서 불필요한 렌더링을 줄이는 최적화 기법이에요. 그런데 때로는 업데이트가 항상 필요하거나 캐싱을 원하지 않는 상황도 있거든요. 그럴 때 "use no memo"를 사용하는 게 도움이 됩니다.</p>
<p>참고로 "use no memo"는 공식 React API에 포함된 기능은 아니고, 보통 개발자들이 직접 구현하거나 특정 라이브러리에서 제공하는 기능인데요. 이름만큼이나 'no memo' 효과를 내어 성능을 제어하는 데 사용됩니다. 따라서 사용 시 문서나 라이브러리 가이드를 꼭 확인하는 게 좋아요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Nextjs 15 에서 reactCompiler 사용하는 방법","description":"","date":"2025-04-22 13:18","slug":"2025-04-22-reactCompiler","content":"\n\n# reactCompiler\n\nNext.js 15에서는 React Compiler를 공식 지원하기 시작했어요. 이 컴파일러는 성능을 쑥 올려주는 마법 같은 역할을 하는데요, 컴포넌트 렌더링을 자동으로 최적화해줘서 개발자가 직접 useMemo나 useCallback 같은 API를 통해 메모이제이션을 신경 쓸 필요가 훨씬 줄어들게 되었답니다.\n\n사용 방법도 간단해요! Next.js 15 버전으로 업그레이드한 뒤, `babel-plugin-react-compiler`를 설치하면 끝!  \n설치 명령어는 다음과 같아요:\n\n```bash\nnpm install babel-plugin-react-compiler\n```\n\n\u003e 참고로, 이 컴파일러는 특히 복잡한 상태 로직을 가진 대규모 애플리케이션에서 효과가 크게 나타나요. 기존에 매번 리렌더링 때문에 고민했던 부분들이 자연스럽게 해소될 수 있으니 꼭 활용해보세요.\n\n또 한 가지, babel 플러그인을 설정하는 부분은 `babel.config.js`나 `.babelrc` 파일에 다음과 같이 추가해주시면 돼요:\n\n```js\nmodule.exports = {\n  plugins: [\"babel-plugin-react-compiler\"],\n};\n```\n\n이렇게만 해주면 Next.js 15와 함께 더욱 빠르고 깔끔한 React 앱을 만들 준비가 끝난 거예요! 앞으로는 불필요한 렌더링 걱정 없이 개발에 집중할 수 있겠네요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그럼 next.config.js 파일에 experimental.reactCompiler 옵션을 추가해볼게요:\n\n```js\nimport type { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  experimental: {\n    reactCompiler: true,\n  },\n}\n\nexport default nextConfig\n```\n\n\u003e 참고: React Compiler는 현재 Next.js에서 Babel 플러그인을 통해서만 사용할 수 있어요. 이 옵션을 켜면 Next.js 기본 Rust 기반 컴파일러를 사용하지 않게 되어서, 빌드 시간이 조금 더 길어질 수 있어요. 하지만 Next.js 팀에서 앞으로 React Compiler를 기본 컴파일러로 지원할 계획이라고 하니 기대해도 좋습니다!\n\n## 주석(Annotations)\n\n'Annotations'는 코드나 설정 등에 부가적인 설명이나 메타데이터를 달아주는 역할을 해요. 예를 들면, 함수나 컴포넌트 위에 달리는 주석들이나 TypeScript의 데코레이터(@) 같은 것도 일종의 애노테이션이죠. Next.js에서는 여러 실험적 옵션들에 대해 주석이나 문서화 작업을 통해 개발자를 돕고 있답니다.\n\n추가로, React Compiler를 통해 얻을 수 있는 장점은 다음과 같아요:\n\n- 더 빠른 렌더링 속도\n- 중간 빌드 산출물 감소\n- 향상된 개발자 경험(에러 메시지 개선 등)\n\n하지만 아직은 실험 단계라서 호환성 문제나 빌드 속도 저하가 생길 수 있으니, 프로덕션 환경에서는 신중하게 테스트해보는 걸 추천해요.\n\n필요하면 이 옵션을 켜고 끄면서 빌드 성능과 동작 안정성을 직접 체험해보는 것도 좋은 공부가 될 거예요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번에는 Next.js에서 컴파일러를 'opt-in' 모드로 설정하는 방법을 공유할게요. 이 설정을 통해 필요한 컴포넌트나 훅에만 React의 메모이제이션(캐싱)을 적용할 수 있는데요, 크게 두 단계가 있어요.\n\n### 1. Next.js 설정 변경하기\n\n먼저 `next.config.js` 혹은 `next.config.ts` 파일에서 컴파일러의 `compilationMode`를 `'annotation'`으로 설정해줘야 해요. 이렇게 하면 코드 내 특정 위치에만 메모이제이션을 활성화할 수 있게 돼요.\n\n```js\nimport type { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  experimental: {\n    reactCompiler: {\n      compilationMode: 'annotation',\n    },\n  },\n}\n\nexport default nextConfig\n```\n\n`experimental` 아래에 있는 설정이라 아직 완전히 안정화된 기능은 아닐 수 있으니, 프로젝트 상황에 맞게 테스트해보는 걸 추천합니다.\n\n### 2. 특정 컴포넌트에 메모이제이션 적용하기\n\n설정이 끝나면, 메모이제이션을 적용하고 싶은 컴포넌트나 훅에 `'use memo'`라는 디렉티브를 추가하세요. 아래처럼 컴포넌트 함수 최상단에 문자열로 선언하면 됩니다.\n\n```js\nexport default function Page() {\n  'use memo'\n  // 이 컴포넌트는 React 메모이제이션의 혜택을 받게 돼요.\n}\n```\n\n이걸 붙이는 순간, React 컴파일러가 이 컴포넌트를 최적화 대상으로 인식해 불필요한 리렌더링을 줄일 수 있어요.\n\n---\n\n### 추가 팁!\n- `compilationMode`에 `'annotation'` 외에도 `'global'` 모드가 있는데, 이건 모든 컴포넌트에 자동으로 최적화를 적용하는 방식이에요. 하지만, 상황에 따라 부작용이 있을 수 있으니 꼭 필요한 부분에만 최적화를 적용하려면 `'annotation'` 모드를 추천합니다.\n- React의 이와 같은 실험적인 최적화 기능은 프로젝트 규모가 크거나 복잡한 상태일 때 성능에 도움이 될 수 있어요. 하지만 작거나 단순한 프로젝트에서는 오히려 디버깅이 복잡해질 수 있으니 신중히 적용하세요.\n\n이상으로 Next.js에서 React 컴파일러를 opt-in 모드로 활용하는 방법이었습니다. 필요할 때만 선택적으로 메모이제이션을 켜서 성능과 관리의 균형을 잘 맞춰보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n참고로, React에서는 \"use no memo\"라는 지시어도 사용할 수 있는데요, 이건 반대로 컴포넌트나 훅을 메모이제이션에서 제외하고 싶을 때 쓰는 방법이에요. 즉, 특정 컴포넌트나 훅이 리렌더링 될 때마다 항상 새롭게 실행되도록 하고 싶다면 이 지시어를 적용할 수 있죠.\n\n메모이제이션(memoization)이란, 컴포넌트가 같은 props나 상태를 가진다면 이전에 계산한 결과를 재사용해서 불필요한 렌더링을 줄이는 최적화 기법이에요. 그런데 때로는 업데이트가 항상 필요하거나 캐싱을 원하지 않는 상황도 있거든요. 그럴 때 \"use no memo\"를 사용하는 게 도움이 됩니다.\n\n참고로 \"use no memo\"는 공식 React API에 포함된 기능은 아니고, 보통 개발자들이 직접 구현하거나 특정 라이브러리에서 제공하는 기능인데요. 이름만큼이나 'no memo' 효과를 내어 성능을 제어하는 데 사용됩니다. 따라서 사용 시 문서나 라이브러리 가이드를 꼭 확인하는 게 좋아요.","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":5},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003ereactCompiler\u003c/h1\u003e\n\u003cp\u003eNext.js 15에서는 React Compiler를 공식 지원하기 시작했어요. 이 컴파일러는 성능을 쑥 올려주는 마법 같은 역할을 하는데요, 컴포넌트 렌더링을 자동으로 최적화해줘서 개발자가 직접 useMemo나 useCallback 같은 API를 통해 메모이제이션을 신경 쓸 필요가 훨씬 줄어들게 되었답니다.\u003c/p\u003e\n\u003cp\u003e사용 방법도 간단해요! Next.js 15 버전으로 업그레이드한 뒤, \u003ccode\u003ebabel-plugin-react-compiler\u003c/code\u003e를 설치하면 끝!\u003cbr\u003e\n설치 명령어는 다음과 같아요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003enpm install babel-plugin-react-compiler\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e참고로, 이 컴파일러는 특히 복잡한 상태 로직을 가진 대규모 애플리케이션에서 효과가 크게 나타나요. 기존에 매번 리렌더링 때문에 고민했던 부분들이 자연스럽게 해소될 수 있으니 꼭 활용해보세요.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e또 한 가지, babel 플러그인을 설정하는 부분은 \u003ccode\u003ebabel.config.js\u003c/code\u003e나 \u003ccode\u003e.babelrc\u003c/code\u003e 파일에 다음과 같이 추가해주시면 돼요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eplugins\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\"babel-plugin-react-compiler\"\u003c/span\u003e],\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게만 해주면 Next.js 15와 함께 더욱 빠르고 깔끔한 React 앱을 만들 준비가 끝난 거예요! 앞으로는 불필요한 렌더링 걱정 없이 개발에 집중할 수 있겠네요 :)\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그럼 next.config.js 파일에 experimental.reactCompiler 옵션을 추가해볼게요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e type { \u003cspan class=\"hljs-title class_\"\u003eNextConfig\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003enextConfig\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eNextConfig\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eexperimental\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003ereactCompiler\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  },\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e nextConfig\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e참고: React Compiler는 현재 Next.js에서 Babel 플러그인을 통해서만 사용할 수 있어요. 이 옵션을 켜면 Next.js 기본 Rust 기반 컴파일러를 사용하지 않게 되어서, 빌드 시간이 조금 더 길어질 수 있어요. 하지만 Next.js 팀에서 앞으로 React Compiler를 기본 컴파일러로 지원할 계획이라고 하니 기대해도 좋습니다!\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e주석(Annotations)\u003c/h2\u003e\n\u003cp\u003e'Annotations'는 코드나 설정 등에 부가적인 설명이나 메타데이터를 달아주는 역할을 해요. 예를 들면, 함수나 컴포넌트 위에 달리는 주석들이나 TypeScript의 데코레이터(@) 같은 것도 일종의 애노테이션이죠. Next.js에서는 여러 실험적 옵션들에 대해 주석이나 문서화 작업을 통해 개발자를 돕고 있답니다.\u003c/p\u003e\n\u003cp\u003e추가로, React Compiler를 통해 얻을 수 있는 장점은 다음과 같아요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e더 빠른 렌더링 속도\u003c/li\u003e\n\u003cli\u003e중간 빌드 산출물 감소\u003c/li\u003e\n\u003cli\u003e향상된 개발자 경험(에러 메시지 개선 등)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e하지만 아직은 실험 단계라서 호환성 문제나 빌드 속도 저하가 생길 수 있으니, 프로덕션 환경에서는 신중하게 테스트해보는 걸 추천해요.\u003c/p\u003e\n\u003cp\u003e필요하면 이 옵션을 켜고 끄면서 빌드 성능과 동작 안정성을 직접 체험해보는 것도 좋은 공부가 될 거예요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이번에는 Next.js에서 컴파일러를 'opt-in' 모드로 설정하는 방법을 공유할게요. 이 설정을 통해 필요한 컴포넌트나 훅에만 React의 메모이제이션(캐싱)을 적용할 수 있는데요, 크게 두 단계가 있어요.\u003c/p\u003e\n\u003ch3\u003e1. Next.js 설정 변경하기\u003c/h3\u003e\n\u003cp\u003e먼저 \u003ccode\u003enext.config.js\u003c/code\u003e 혹은 \u003ccode\u003enext.config.ts\u003c/code\u003e 파일에서 컴파일러의 \u003ccode\u003ecompilationMode\u003c/code\u003e를 \u003ccode\u003e'annotation'\u003c/code\u003e으로 설정해줘야 해요. 이렇게 하면 코드 내 특정 위치에만 메모이제이션을 활성화할 수 있게 돼요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e type { \u003cspan class=\"hljs-title class_\"\u003eNextConfig\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003enextConfig\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eNextConfig\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eexperimental\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003ereactCompiler\u003c/span\u003e: {\n      \u003cspan class=\"hljs-attr\"\u003ecompilationMode\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'annotation'\u003c/span\u003e,\n    },\n  },\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e nextConfig\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eexperimental\u003c/code\u003e 아래에 있는 설정이라 아직 완전히 안정화된 기능은 아닐 수 있으니, 프로젝트 상황에 맞게 테스트해보는 걸 추천합니다.\u003c/p\u003e\n\u003ch3\u003e2. 특정 컴포넌트에 메모이제이션 적용하기\u003c/h3\u003e\n\u003cp\u003e설정이 끝나면, 메모이제이션을 적용하고 싶은 컴포넌트나 훅에 \u003ccode\u003e'use memo'\u003c/code\u003e라는 디렉티브를 추가하세요. 아래처럼 컴포넌트 함수 최상단에 문자열로 선언하면 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-string\"\u003e'use memo'\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 이 컴포넌트는 React 메모이제이션의 혜택을 받게 돼요.\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이걸 붙이는 순간, React 컴파일러가 이 컴포넌트를 최적화 대상으로 인식해 불필요한 리렌더링을 줄일 수 있어요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e추가 팁!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ecompilationMode\u003c/code\u003e에 \u003ccode\u003e'annotation'\u003c/code\u003e 외에도 \u003ccode\u003e'global'\u003c/code\u003e 모드가 있는데, 이건 모든 컴포넌트에 자동으로 최적화를 적용하는 방식이에요. 하지만, 상황에 따라 부작용이 있을 수 있으니 꼭 필요한 부분에만 최적화를 적용하려면 \u003ccode\u003e'annotation'\u003c/code\u003e 모드를 추천합니다.\u003c/li\u003e\n\u003cli\u003eReact의 이와 같은 실험적인 최적화 기능은 프로젝트 규모가 크거나 복잡한 상태일 때 성능에 도움이 될 수 있어요. 하지만 작거나 단순한 프로젝트에서는 오히려 디버깅이 복잡해질 수 있으니 신중히 적용하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이상으로 Next.js에서 React 컴파일러를 opt-in 모드로 활용하는 방법이었습니다. 필요할 때만 선택적으로 메모이제이션을 켜서 성능과 관리의 균형을 잘 맞춰보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e참고로, React에서는 \"use no memo\"라는 지시어도 사용할 수 있는데요, 이건 반대로 컴포넌트나 훅을 메모이제이션에서 제외하고 싶을 때 쓰는 방법이에요. 즉, 특정 컴포넌트나 훅이 리렌더링 될 때마다 항상 새롭게 실행되도록 하고 싶다면 이 지시어를 적용할 수 있죠.\u003c/p\u003e\n\u003cp\u003e메모이제이션(memoization)이란, 컴포넌트가 같은 props나 상태를 가진다면 이전에 계산한 결과를 재사용해서 불필요한 렌더링을 줄이는 최적화 기법이에요. 그런데 때로는 업데이트가 항상 필요하거나 캐싱을 원하지 않는 상황도 있거든요. 그럴 때 \"use no memo\"를 사용하는 게 도움이 됩니다.\u003c/p\u003e\n\u003cp\u003e참고로 \"use no memo\"는 공식 React API에 포함된 기능은 아니고, 보통 개발자들이 직접 구현하거나 특정 라이브러리에서 제공하는 기능인데요. 이름만큼이나 'no memo' 효과를 내어 성능을 제어하는 데 사용됩니다. 따라서 사용 시 문서나 라이브러리 가이드를 꼭 확인하는 게 좋아요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2025-04-22-reactCompiler"},"buildId":"KUC9M_yIlA1Ugo01xmkHL","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>