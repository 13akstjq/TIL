<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Next.js 15 unstable_cache로 캐싱 최적화하는 최신 방법 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-unstable_cache" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Next.js 15 unstable_cache로 캐싱 최적화하는 최신 방법 | TIL" data-gatsby-head="true"/><meta property="og:title" content="Next.js 15 unstable_cache로 캐싱 최적화하는 최신 방법 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-unstable_cache" data-gatsby-head="true"/><meta name="twitter:title" content="Next.js 15 unstable_cache로 캐싱 최적화하는 최신 방법 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2025-04-22 12:47" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/0eef537492fed77a.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/0eef537492fed77a.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-8ded8b979ba73586.js" defer=""></script><script src="/TIL/_next/static/M7pU9hOcx8u_ZIFMf95sd/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/M7pU9hOcx8u_ZIFMf95sd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Next.js 15 unstable_cache로 캐싱 최적화하는 최신 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Next.js 15 unstable_cache로 캐싱 최적화하는 최신 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Apr 22, 2025</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>unstable_cache 함수 소개</h1>
<blockquote>
<p>참고: 이 API는 아직 불안정 버전이며, 안정화되면 use cache라는 새로운 API로 대체될 예정이에요.</p>
</blockquote>
<p><code>unstable_cache</code>는 데이터베이스 쿼리처럼 비용이 많이 드는 작업 결과를 캐싱해서, 여러 요청 간에 그 결과를 재사용할 수 있게 도와주는 함수입니다. 덕분에 서버나 클라이언트에서 반복적인 작업을 줄여 성능을 개선할 수 있죠.</p>
<p>예를 들어, 사용자 정보를 데이터베이스에서 가져오는 작업이 있다고 할 때, <code>unstable_cache</code>로 감싸면 한 번 캐시된 결과를 재사용해서 같은 데이터를 다시 가져올 때 시간을 아낄 수 있어요.</p>
<p>아래 코드를 볼게요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { getUser } <span class="hljs-keyword">from</span> <span class="hljs-string">'./data'</span>;
<span class="hljs-keyword">import</span> { unstable_cache } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/cache'</span>;

<span class="hljs-keyword">const</span> getCachedUser = <span class="hljs-title function_">unstable_cache</span>(
  <span class="hljs-keyword">async</span> (id) => <span class="hljs-title function_">getUser</span>(id),
  [<span class="hljs-string">'my-app-user'</span>]
);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span>(<span class="hljs-params">{ userID }</span>) {
  <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getCachedUser</span>(userID);
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>위 예제에서는 <code>getUser</code>라는 비싼 연산(사용자 정보 조회 함수)을 <code>unstable_cache</code>로 감싸서 <code>getCachedUser</code>라는 캐시된 함수를 만들었어요. 그 후 <code>Component</code> 컴포넌트 내에서 <code>getCachedUser</code>를 통해 빠르게 캐시된 사용자 정보를 받아올 수 있습니다.</p>
<hr>
<h2>조금 더 알아두면 좋은 점들</h2>
<ul>
<li><code>unstable_cache</code>의 두 번째 인자인 배열(<code>['my-app-user']</code>)은 캐시 키로 사용돼요. 이 키를 통해 캐시를 그룹화하거나 특정 조건에 따라 캐시를 재사용하거나 갱신할 수 있어요.</li>
<li>이 API는 아직 실험적이므로, 향후 Next.js 업데이트 시 API가 변경될 수 있다는 점 참고하세요.</li>
<li>캐시되는 데이터가 민감하거나 동적으로 자주 바뀌는 경우, 적절한 만료 전략과 무효화 로직이 꼭 필요해요.</li>
<li>React 서버 컴포넌트에서 특히 유용하게 사용할 수 있는데, 서버 측에서 불필요하게 중복된 데이터 로드를 줄여 페이지 렌더링 속도를 높여줍니다.</li>
</ul>
<p>이처럼 <code>unstable_cache</code>는 데이터 요청을 줄여 성능을 개선하는 좋은 수단이에요. 다만 안정적인 API가 나올 때까지는 테스트 환경에서 사용해보면서 차차 적용해보는 걸 추천드립니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<blockquote>
<p>알아두면 좋은 점:
캐시 범위 내에서 헤더나 쿠키 같은 동적인 데이터 소스에 접근하는 것은 지원되지 않습니다. 만약 캐시된 함수 안에서 이런 데이터가 필요하다면, 캐시 함수 외부에서 헤더를 받아서 필요한 동적 데이터를 함수 인자로 전달하는 방식을 사용하세요.
이 API는 Next.js의 내장 데이터 캐시 기능을 활용하여 요청이나 배포가 바뀌어도 결과를 유지합니다.</p>
</blockquote>
<blockquote>
<p>경고: 이 API는 아직 불안정한 상태이며 앞으로 변경될 수 있습니다. API가 안정화되면 마이그레이션 문서와 코드 변환 도구(codemods)를 제공할 예정입니다.</p>
</blockquote>
<h2>파라미터 설명</h2>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> data = <span class="hljs-title function_">unstable_cache</span>(fetchData, keyParts, options)()
</code></pre>
<p>위 코드는 <code>unstable_cache</code>라는 함수를 사용해 데이터를 캐싱하는 예시인데요, 여기서 각 인자가 무엇을 의미하는지 조금 더 자세히 알려드릴게요.</p>





















<table><thead><tr><th>파라미터명</th><th>설명</th></tr></thead><tbody><tr><td><code>fetchData</code></td><td>캐시할 데이터를 가져오는 함수</td></tr><tr><td><code>keyParts</code></td><td>캐시 키를 구성하는 값 혹은 배열 (캐시 식별자 역할)</td></tr><tr><td><code>options</code></td><td>캐싱 동작을 제어하는 옵션 (예: 만료 시간 등)</td></tr></tbody></table>
<p>이 함수를 호출하면 <code>fetchData</code> 함수가 반환하는 결과를 캐시에 저장해 두고, 다음부터는 같은 키로 요청할 때 캐시된 값을 재사용합니다. 서버 사이드 렌더링이나 API 라우트에서 자주 사용하는 패턴이죠.</p>
<blockquote>
<p>팁!
동적 데이터를 다뤄야 할 때 헤더나 쿠키를 함수 외부에서 받아 인자로 넘기는 걸 꼭 기억하세요! 그래야 캐시가 잘 작동하면서도 필요한 동적 정보를 사용할 수 있습니다.</p>
</blockquote>
<p>또한, <code>unstable_cache</code>는 아직 실험적인 기능이라 버전 업데이트 시 API가 달라질 수 있으니 프로젝트 적용 시 주의하세요! 필요하면 공식 문서나 업데이트 노트를 자주 확인하는 게 좋습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>fetchData: 비동기 함수로, 캐싱하려는 데이터를 가져와야 해요. 이 함수는 반드시 Promise를 반환해야 합니다.<br>
keyParts: 캐시 식별을 좀 더 세분화하기 위한 추가 키 배열이에요. 기본적으로 unstable_cache는 함수 인자와 함수의 문자열화된 버전을 캐시 키로 사용합니다. 대부분의 경우 선택 사항이지만, 매개변수로 전달하지 않는 외부 변수를 사용할 때 꼭 필요해요. 특히 클로저로 사용하는 변수는 여기 꼭 넣어줘야 합니다.<br>
options: 캐시 동작을 제어하는 객체인데, 다음과 같은 속성을 가질 수 있어요:</p>
<ul>
<li>tags: 캐시 무효화를 제어하는 데 사용하는 태그의 배열입니다. Next.js는 이 태그를 함수의 고유 식별자로 사용하지는 않아요.</li>
<li>revalidate: 캐시를 다시 검증할 시간(초)입니다. 생략하거나 false를 전달하면 무기한 캐시하거나, revalidateTag() 또는 revalidatePath()가 호출될 때까지 캐시가 유지돼요.</li>
</ul>
<hr>
<h3>반환값</h3>
<p>unstable_cache는 호출 시 캐시된 데이터를 반환하는 함수(비동기)를 리턴합니다. 만약 캐시에 데이터가 없으면, 전달한 함수가 호출되고 결과가 캐시되어 반환됩니다.</p>
<hr>
<h2>예시</h2>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { unstable_cache } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/cache'</span>;

<span class="hljs-keyword">const</span> fetchUsers = <span class="hljs-title function_">unstable_cache</span>(<span class="hljs-keyword">async</span> (page) => {
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/users?page=<span class="hljs-subst">${page}</span>`</span>);
  <span class="hljs-keyword">if</span> (!res.<span class="hljs-property">ok</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Failed to fetch users'</span>);
  <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">json</span>();
}, {
  <span class="hljs-attr">revalidate</span>: <span class="hljs-number">60</span>,  <span class="hljs-comment">// 60초마다 캐시 재검증</span>
  <span class="hljs-attr">tags</span>: [<span class="hljs-string">'users'</span>],
});

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getData</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> users = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchUsers</span>(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">return</span> users;
}
</code></pre>
<hr>
<h3>추가 팁!</h3>
<ul>
<li><code>keyParts</code>는 캐시 키 생성 시 핵심적인 역할을 하는데, 예를 들어 전역 상태나 설정 값을 참조할 때 꼭 넣어주면 캐시가 꼬이는 걸 방지할 수 있어요.</li>
<li><code>revalidate</code>를 너무 짧게 설정하면 캐시 효율이 떨어지고, 너무 길게 하면 오래된 데이터를 쓰게 되니 상황에 맞게 적절히 조절해주시는 게 좋아요!</li>
<li><code>tags</code>는 나중에 특정 태그에 해당하는 캐시를 한 번에 무효화할 때 유용합니다. 예를 들어 사용자 관련 데이터가 변했을 때 'users' 태그를 가진 모든 캐시를 리셋할 수 있죠.</li>
</ul>
<p>캐시를 잘 활용하면 서버 부담도 줄이고, 사용자 경험도 훨씬 좋아질 테니 꼭 한번 시도해보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>자, 오늘은 Next.js에서 <code>unstable_cache</code>라는 캐싱 함수가 어떻게 쓰이는지 간단하게 살펴볼게요. 코드 예제를 보면서 함께 이해해봐요!</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { unstable_cache } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/cache'</span>
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params">{
  params,
}: {
  params: <span class="hljs-built_in">Promise</span>&#x3C;{ userId: string }>
}</span>) {
  <span class="hljs-keyword">const</span> { userId } = <span class="hljs-keyword">await</span> params
  <span class="hljs-keyword">const</span> getCachedUser = <span class="hljs-title function_">unstable_cache</span>(
    <span class="hljs-keyword">async</span> () => {
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">id</span>: userId }
    },
    [userId], <span class="hljs-comment">// userId를 캐시 키에 포함해서 특정 사용자 데이터를 캐싱</span>
    {
      <span class="hljs-attr">tags</span>: [<span class="hljs-string">'users'</span>], <span class="hljs-comment">// 태그로 캐시 그룹 지정, 나중에 태그 기반으로 재검증 가능</span>
      <span class="hljs-attr">revalidate</span>: <span class="hljs-number">60</span>,  <span class="hljs-comment">// 60초 후 캐시 자동 무효화(재요청 시 다시 호출)</span>
    }
  )

  <span class="hljs-comment">//...</span>
}
</code></pre>
<h3>이 코드가 하는 일은?</h3>
<ul>
<li><code>unstable_cache</code> 함수는 Next.js에서 제공하는 비공식(unstable) 캐시 함수예요.</li>
<li>첫 번째 인자는 실제 실행할 비동기 함수 (이 경우 <code>userId</code>를 받아 간단한 객체를 반환).</li>
<li>두 번째 인자는 캐시 키를 결정하는 배열로, <code>userId</code>가 바뀌면 캐시도 새로 생성됩니다.</li>
<li>세 번째 옵션 객체에는 <code>tags</code>와 <code>revalidate</code> 같은 설정들이 있어요.
<ul>
<li><code>tags</code>는 특정 그룹으로 묶어, 같은 태그를 가진 캐시들을 한 번에 무효화 할 때 사용 가능.</li>
<li><code>revalidate</code>는 위 캐시가 자동으로 재갱신되는 시간(초) 설정입니다.</li>
</ul>
</li>
</ul>
<h3>제가 더 알려드리고 싶은 점!</h3>
<ul>
<li><code>unstable_cache</code>가 "unstable"인 이유는 아직 공식 API가 완전히 안정화된 게 아니기 때문이에요. 그러니 프로덕션용으로 쓸 때는 주의가 필요하겠죠.</li>
<li>하지만 Next.js 14부터 도입된 이 기능은 서버 컴포넌트나 API 라우트에서 데이터 중복 호출을 줄이고, 성능 최적화에 꽤 도움을 줄 수 있어요.</li>
<li>또, 태그 기반 캐싱 덕분에 관련된 여러 데이터들을 한 번에 무효화하는 전략을 쉽게 구현할 수 있답니다.</li>
<li>캐싱 정책을 잘 설계하면 페이지 렌더링 속도가 확실히 빨라지니, 꼭 자기 프로젝트에 맞춰 실험해 보세요!</li>
</ul>
<hr>
<h2>버전 히스토리</h2>













<table><thead><tr><th>Version</th><th>Changes</th></tr></thead><tbody><tr><td>v14.0.0</td><td><code>unstable_cache</code> 도입</td></tr></tbody></table>
<p>Next.js의 최신 기능들을 잘 활용해서 여러분 프로젝트도 한층 더 빠르고 똑똑하게 만들 수 있길 바랄게요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Next.js 15 unstable_cache로 캐싱 최적화하는 최신 방법","description":"","date":"2025-04-22 12:47","slug":"2025-04-22-unstable_cache","content":"\n\n# unstable_cache 함수 소개\n\n\u003e 참고: 이 API는 아직 불안정 버전이며, 안정화되면 use cache라는 새로운 API로 대체될 예정이에요.\n\n`unstable_cache`는 데이터베이스 쿼리처럼 비용이 많이 드는 작업 결과를 캐싱해서, 여러 요청 간에 그 결과를 재사용할 수 있게 도와주는 함수입니다. 덕분에 서버나 클라이언트에서 반복적인 작업을 줄여 성능을 개선할 수 있죠.\n\n예를 들어, 사용자 정보를 데이터베이스에서 가져오는 작업이 있다고 할 때, `unstable_cache`로 감싸면 한 번 캐시된 결과를 재사용해서 같은 데이터를 다시 가져올 때 시간을 아낄 수 있어요.\n\n아래 코드를 볼게요.\n\n```js\nimport { getUser } from './data';\nimport { unstable_cache } from 'next/cache';\n\nconst getCachedUser = unstable_cache(\n  async (id) =\u003e getUser(id),\n  ['my-app-user']\n);\n\nexport default async function Component({ userID }) {\n  const user = await getCachedUser(userID);\n  // ...\n}\n```\n\n위 예제에서는 `getUser`라는 비싼 연산(사용자 정보 조회 함수)을 `unstable_cache`로 감싸서 `getCachedUser`라는 캐시된 함수를 만들었어요. 그 후 `Component` 컴포넌트 내에서 `getCachedUser`를 통해 빠르게 캐시된 사용자 정보를 받아올 수 있습니다.\n\n---\n\n## 조금 더 알아두면 좋은 점들\n\n- `unstable_cache`의 두 번째 인자인 배열(`['my-app-user']`)은 캐시 키로 사용돼요. 이 키를 통해 캐시를 그룹화하거나 특정 조건에 따라 캐시를 재사용하거나 갱신할 수 있어요.\n- 이 API는 아직 실험적이므로, 향후 Next.js 업데이트 시 API가 변경될 수 있다는 점 참고하세요.\n- 캐시되는 데이터가 민감하거나 동적으로 자주 바뀌는 경우, 적절한 만료 전략과 무효화 로직이 꼭 필요해요.\n- React 서버 컴포넌트에서 특히 유용하게 사용할 수 있는데, 서버 측에서 불필요하게 중복된 데이터 로드를 줄여 페이지 렌더링 속도를 높여줍니다.\n\n이처럼 `unstable_cache`는 데이터 요청을 줄여 성능을 개선하는 좋은 수단이에요. 다만 안정적인 API가 나올 때까지는 테스트 환경에서 사용해보면서 차차 적용해보는 걸 추천드립니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003e 알아두면 좋은 점:\n캐시 범위 내에서 헤더나 쿠키 같은 동적인 데이터 소스에 접근하는 것은 지원되지 않습니다. 만약 캐시된 함수 안에서 이런 데이터가 필요하다면, 캐시 함수 외부에서 헤더를 받아서 필요한 동적 데이터를 함수 인자로 전달하는 방식을 사용하세요.\n이 API는 Next.js의 내장 데이터 캐시 기능을 활용하여 요청이나 배포가 바뀌어도 결과를 유지합니다.\n\n\u003e 경고: 이 API는 아직 불안정한 상태이며 앞으로 변경될 수 있습니다. API가 안정화되면 마이그레이션 문서와 코드 변환 도구(codemods)를 제공할 예정입니다.\n\n## 파라미터 설명\n\n```js\nconst data = unstable_cache(fetchData, keyParts, options)()\n```\n\n위 코드는 `unstable_cache`라는 함수를 사용해 데이터를 캐싱하는 예시인데요, 여기서 각 인자가 무엇을 의미하는지 조금 더 자세히 알려드릴게요.\n\n| 파라미터명  | 설명                                   |\n|-------------|--------------------------------------|\n| `fetchData` | 캐시할 데이터를 가져오는 함수          |\n| `keyParts`  | 캐시 키를 구성하는 값 혹은 배열 (캐시 식별자 역할) |\n| `options`   | 캐싱 동작을 제어하는 옵션 (예: 만료 시간 등)      |\n\n이 함수를 호출하면 `fetchData` 함수가 반환하는 결과를 캐시에 저장해 두고, 다음부터는 같은 키로 요청할 때 캐시된 값을 재사용합니다. 서버 사이드 렌더링이나 API 라우트에서 자주 사용하는 패턴이죠.\n\n\u003e 팁!\n동적 데이터를 다뤄야 할 때 헤더나 쿠키를 함수 외부에서 받아 인자로 넘기는 걸 꼭 기억하세요! 그래야 캐시가 잘 작동하면서도 필요한 동적 정보를 사용할 수 있습니다.\n\n또한, `unstable_cache`는 아직 실험적인 기능이라 버전 업데이트 시 API가 달라질 수 있으니 프로젝트 적용 시 주의하세요! 필요하면 공식 문서나 업데이트 노트를 자주 확인하는 게 좋습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nfetchData: 비동기 함수로, 캐싱하려는 데이터를 가져와야 해요. 이 함수는 반드시 Promise를 반환해야 합니다.  \nkeyParts: 캐시 식별을 좀 더 세분화하기 위한 추가 키 배열이에요. 기본적으로 unstable_cache는 함수 인자와 함수의 문자열화된 버전을 캐시 키로 사용합니다. 대부분의 경우 선택 사항이지만, 매개변수로 전달하지 않는 외부 변수를 사용할 때 꼭 필요해요. 특히 클로저로 사용하는 변수는 여기 꼭 넣어줘야 합니다.  \noptions: 캐시 동작을 제어하는 객체인데, 다음과 같은 속성을 가질 수 있어요:\n- tags: 캐시 무효화를 제어하는 데 사용하는 태그의 배열입니다. Next.js는 이 태그를 함수의 고유 식별자로 사용하지는 않아요.\n- revalidate: 캐시를 다시 검증할 시간(초)입니다. 생략하거나 false를 전달하면 무기한 캐시하거나, revalidateTag() 또는 revalidatePath()가 호출될 때까지 캐시가 유지돼요.\n\n---\n\n### 반환값\n\nunstable_cache는 호출 시 캐시된 데이터를 반환하는 함수(비동기)를 리턴합니다. 만약 캐시에 데이터가 없으면, 전달한 함수가 호출되고 결과가 캐시되어 반환됩니다.\n\n---\n\n## 예시\n\n```javascript\nimport { unstable_cache } from 'next/cache';\n\nconst fetchUsers = unstable_cache(async (page) =\u003e {\n  const res = await fetch(`/api/users?page=${page}`);\n  if (!res.ok) throw new Error('Failed to fetch users');\n  return res.json();\n}, {\n  revalidate: 60,  // 60초마다 캐시 재검증\n  tags: ['users'],\n});\n\nexport async function getData() {\n  const users = await fetchUsers(1);\n  return users;\n}\n```\n\n---\n\n### 추가 팁!  \n- `keyParts`는 캐시 키 생성 시 핵심적인 역할을 하는데, 예를 들어 전역 상태나 설정 값을 참조할 때 꼭 넣어주면 캐시가 꼬이는 걸 방지할 수 있어요.  \n- `revalidate`를 너무 짧게 설정하면 캐시 효율이 떨어지고, 너무 길게 하면 오래된 데이터를 쓰게 되니 상황에 맞게 적절히 조절해주시는 게 좋아요!  \n- `tags`는 나중에 특정 태그에 해당하는 캐시를 한 번에 무효화할 때 유용합니다. 예를 들어 사용자 관련 데이터가 변했을 때 'users' 태그를 가진 모든 캐시를 리셋할 수 있죠.  \n\n캐시를 잘 활용하면 서버 부담도 줄이고, 사용자 경험도 훨씬 좋아질 테니 꼭 한번 시도해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자, 오늘은 Next.js에서 `unstable_cache`라는 캐싱 함수가 어떻게 쓰이는지 간단하게 살펴볼게요. 코드 예제를 보면서 함께 이해해봐요!\n\n```js\nimport { unstable_cache } from 'next/cache'\n \nexport default async function Page({\n  params,\n}: {\n  params: Promise\u003c{ userId: string }\u003e\n}) {\n  const { userId } = await params\n  const getCachedUser = unstable_cache(\n    async () =\u003e {\n      return { id: userId }\n    },\n    [userId], // userId를 캐시 키에 포함해서 특정 사용자 데이터를 캐싱\n    {\n      tags: ['users'], // 태그로 캐시 그룹 지정, 나중에 태그 기반으로 재검증 가능\n      revalidate: 60,  // 60초 후 캐시 자동 무효화(재요청 시 다시 호출)\n    }\n  )\n\n  //...\n}\n```\n\n### 이 코드가 하는 일은?\n\n- `unstable_cache` 함수는 Next.js에서 제공하는 비공식(unstable) 캐시 함수예요.\n- 첫 번째 인자는 실제 실행할 비동기 함수 (이 경우 `userId`를 받아 간단한 객체를 반환).\n- 두 번째 인자는 캐시 키를 결정하는 배열로, `userId`가 바뀌면 캐시도 새로 생성됩니다.\n- 세 번째 옵션 객체에는 `tags`와 `revalidate` 같은 설정들이 있어요.\n  - `tags`는 특정 그룹으로 묶어, 같은 태그를 가진 캐시들을 한 번에 무효화 할 때 사용 가능.\n  - `revalidate`는 위 캐시가 자동으로 재갱신되는 시간(초) 설정입니다.\n\n### 제가 더 알려드리고 싶은 점!\n\n- `unstable_cache`가 \"unstable\"인 이유는 아직 공식 API가 완전히 안정화된 게 아니기 때문이에요. 그러니 프로덕션용으로 쓸 때는 주의가 필요하겠죠.\n- 하지만 Next.js 14부터 도입된 이 기능은 서버 컴포넌트나 API 라우트에서 데이터 중복 호출을 줄이고, 성능 최적화에 꽤 도움을 줄 수 있어요.\n- 또, 태그 기반 캐싱 덕분에 관련된 여러 데이터들을 한 번에 무효화하는 전략을 쉽게 구현할 수 있답니다.\n- 캐싱 정책을 잘 설계하면 페이지 렌더링 속도가 확실히 빨라지니, 꼭 자기 프로젝트에 맞춰 실험해 보세요!\n\n---\n\n## 버전 히스토리\n\n| Version   | Changes                  |\n|-----------|--------------------------|\n| v14.0.0   | `unstable_cache` 도입   |\n\nNext.js의 최신 기능들을 잘 활용해서 여러분 프로젝트도 한층 더 빠르고 똑똑하게 만들 수 있길 바랄게요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003eunstable_cache 함수 소개\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e참고: 이 API는 아직 불안정 버전이며, 안정화되면 use cache라는 새로운 API로 대체될 예정이에요.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003ccode\u003eunstable_cache\u003c/code\u003e는 데이터베이스 쿼리처럼 비용이 많이 드는 작업 결과를 캐싱해서, 여러 요청 간에 그 결과를 재사용할 수 있게 도와주는 함수입니다. 덕분에 서버나 클라이언트에서 반복적인 작업을 줄여 성능을 개선할 수 있죠.\u003c/p\u003e\n\u003cp\u003e예를 들어, 사용자 정보를 데이터베이스에서 가져오는 작업이 있다고 할 때, \u003ccode\u003eunstable_cache\u003c/code\u003e로 감싸면 한 번 캐시된 결과를 재사용해서 같은 데이터를 다시 가져올 때 시간을 아낄 수 있어요.\u003c/p\u003e\n\u003cp\u003e아래 코드를 볼게요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { getUser } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./data'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { unstable_cache } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/cache'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e getCachedUser = \u003cspan class=\"hljs-title function_\"\u003eunstable_cache\u003c/span\u003e(\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (id) =\u003e \u003cspan class=\"hljs-title function_\"\u003egetUser\u003c/span\u003e(id),\n  [\u003cspan class=\"hljs-string\"\u003e'my-app-user'\u003c/span\u003e]\n);\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eComponent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ userID }\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e user = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetCachedUser\u003c/span\u003e(userID);\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 예제에서는 \u003ccode\u003egetUser\u003c/code\u003e라는 비싼 연산(사용자 정보 조회 함수)을 \u003ccode\u003eunstable_cache\u003c/code\u003e로 감싸서 \u003ccode\u003egetCachedUser\u003c/code\u003e라는 캐시된 함수를 만들었어요. 그 후 \u003ccode\u003eComponent\u003c/code\u003e 컴포넌트 내에서 \u003ccode\u003egetCachedUser\u003c/code\u003e를 통해 빠르게 캐시된 사용자 정보를 받아올 수 있습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e조금 더 알아두면 좋은 점들\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eunstable_cache\u003c/code\u003e의 두 번째 인자인 배열(\u003ccode\u003e['my-app-user']\u003c/code\u003e)은 캐시 키로 사용돼요. 이 키를 통해 캐시를 그룹화하거나 특정 조건에 따라 캐시를 재사용하거나 갱신할 수 있어요.\u003c/li\u003e\n\u003cli\u003e이 API는 아직 실험적이므로, 향후 Next.js 업데이트 시 API가 변경될 수 있다는 점 참고하세요.\u003c/li\u003e\n\u003cli\u003e캐시되는 데이터가 민감하거나 동적으로 자주 바뀌는 경우, 적절한 만료 전략과 무효화 로직이 꼭 필요해요.\u003c/li\u003e\n\u003cli\u003eReact 서버 컴포넌트에서 특히 유용하게 사용할 수 있는데, 서버 측에서 불필요하게 중복된 데이터 로드를 줄여 페이지 렌더링 속도를 높여줍니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이처럼 \u003ccode\u003eunstable_cache\u003c/code\u003e는 데이터 요청을 줄여 성능을 개선하는 좋은 수단이에요. 다만 안정적인 API가 나올 때까지는 테스트 환경에서 사용해보면서 차차 적용해보는 걸 추천드립니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cblockquote\u003e\n\u003cp\u003e알아두면 좋은 점:\n캐시 범위 내에서 헤더나 쿠키 같은 동적인 데이터 소스에 접근하는 것은 지원되지 않습니다. 만약 캐시된 함수 안에서 이런 데이터가 필요하다면, 캐시 함수 외부에서 헤더를 받아서 필요한 동적 데이터를 함수 인자로 전달하는 방식을 사용하세요.\n이 API는 Next.js의 내장 데이터 캐시 기능을 활용하여 요청이나 배포가 바뀌어도 결과를 유지합니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e경고: 이 API는 아직 불안정한 상태이며 앞으로 변경될 수 있습니다. API가 안정화되면 마이그레이션 문서와 코드 변환 도구(codemods)를 제공할 예정입니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e파라미터 설명\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e data = \u003cspan class=\"hljs-title function_\"\u003eunstable_cache\u003c/span\u003e(fetchData, keyParts, options)()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드는 \u003ccode\u003eunstable_cache\u003c/code\u003e라는 함수를 사용해 데이터를 캐싱하는 예시인데요, 여기서 각 인자가 무엇을 의미하는지 조금 더 자세히 알려드릴게요.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e파라미터명\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003efetchData\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e캐시할 데이터를 가져오는 함수\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ekeyParts\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e캐시 키를 구성하는 값 혹은 배열 (캐시 식별자 역할)\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eoptions\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e캐싱 동작을 제어하는 옵션 (예: 만료 시간 등)\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e이 함수를 호출하면 \u003ccode\u003efetchData\u003c/code\u003e 함수가 반환하는 결과를 캐시에 저장해 두고, 다음부터는 같은 키로 요청할 때 캐시된 값을 재사용합니다. 서버 사이드 렌더링이나 API 라우트에서 자주 사용하는 패턴이죠.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e팁!\n동적 데이터를 다뤄야 할 때 헤더나 쿠키를 함수 외부에서 받아 인자로 넘기는 걸 꼭 기억하세요! 그래야 캐시가 잘 작동하면서도 필요한 동적 정보를 사용할 수 있습니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e또한, \u003ccode\u003eunstable_cache\u003c/code\u003e는 아직 실험적인 기능이라 버전 업데이트 시 API가 달라질 수 있으니 프로젝트 적용 시 주의하세요! 필요하면 공식 문서나 업데이트 노트를 자주 확인하는 게 좋습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003efetchData: 비동기 함수로, 캐싱하려는 데이터를 가져와야 해요. 이 함수는 반드시 Promise를 반환해야 합니다.\u003cbr\u003e\nkeyParts: 캐시 식별을 좀 더 세분화하기 위한 추가 키 배열이에요. 기본적으로 unstable_cache는 함수 인자와 함수의 문자열화된 버전을 캐시 키로 사용합니다. 대부분의 경우 선택 사항이지만, 매개변수로 전달하지 않는 외부 변수를 사용할 때 꼭 필요해요. 특히 클로저로 사용하는 변수는 여기 꼭 넣어줘야 합니다.\u003cbr\u003e\noptions: 캐시 동작을 제어하는 객체인데, 다음과 같은 속성을 가질 수 있어요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003etags: 캐시 무효화를 제어하는 데 사용하는 태그의 배열입니다. Next.js는 이 태그를 함수의 고유 식별자로 사용하지는 않아요.\u003c/li\u003e\n\u003cli\u003erevalidate: 캐시를 다시 검증할 시간(초)입니다. 생략하거나 false를 전달하면 무기한 캐시하거나, revalidateTag() 또는 revalidatePath()가 호출될 때까지 캐시가 유지돼요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003e반환값\u003c/h3\u003e\n\u003cp\u003eunstable_cache는 호출 시 캐시된 데이터를 반환하는 함수(비동기)를 리턴합니다. 만약 캐시에 데이터가 없으면, 전달한 함수가 호출되고 결과가 캐시되어 반환됩니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e예시\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { unstable_cache } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/cache'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fetchUsers = \u003cspan class=\"hljs-title function_\"\u003eunstable_cache\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (page) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e res = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`/api/users?page=\u003cspan class=\"hljs-subst\"\u003e${page}\u003c/span\u003e`\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!res.\u003cspan class=\"hljs-property\"\u003eok\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Failed to fetch users'\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e res.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e();\n}, {\n  \u003cspan class=\"hljs-attr\"\u003erevalidate\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e,  \u003cspan class=\"hljs-comment\"\u003e// 60초마다 캐시 재검증\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003etags\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e'users'\u003c/span\u003e],\n});\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetData\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e users = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetchUsers\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e users;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003e추가 팁!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ekeyParts\u003c/code\u003e는 캐시 키 생성 시 핵심적인 역할을 하는데, 예를 들어 전역 상태나 설정 값을 참조할 때 꼭 넣어주면 캐시가 꼬이는 걸 방지할 수 있어요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erevalidate\u003c/code\u003e를 너무 짧게 설정하면 캐시 효율이 떨어지고, 너무 길게 하면 오래된 데이터를 쓰게 되니 상황에 맞게 적절히 조절해주시는 게 좋아요!\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etags\u003c/code\u003e는 나중에 특정 태그에 해당하는 캐시를 한 번에 무효화할 때 유용합니다. 예를 들어 사용자 관련 데이터가 변했을 때 'users' 태그를 가진 모든 캐시를 리셋할 수 있죠.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e캐시를 잘 활용하면 서버 부담도 줄이고, 사용자 경험도 훨씬 좋아질 테니 꼭 한번 시도해보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e자, 오늘은 Next.js에서 \u003ccode\u003eunstable_cache\u003c/code\u003e라는 캐싱 함수가 어떻게 쓰이는지 간단하게 살펴볼게요. 코드 예제를 보면서 함께 이해해봐요!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { unstable_cache } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/cache'\u003c/span\u003e\n \n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{\n  params,\n}: {\n  params: \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e\u0026#x3C;{ userId: string }\u003e\n}\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { userId } = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e params\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e getCachedUser = \u003cspan class=\"hljs-title function_\"\u003eunstable_cache\u003c/span\u003e(\n    \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e () =\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e { \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: userId }\n    },\n    [userId], \u003cspan class=\"hljs-comment\"\u003e// userId를 캐시 키에 포함해서 특정 사용자 데이터를 캐싱\u003c/span\u003e\n    {\n      \u003cspan class=\"hljs-attr\"\u003etags\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e'users'\u003c/span\u003e], \u003cspan class=\"hljs-comment\"\u003e// 태그로 캐시 그룹 지정, 나중에 태그 기반으로 재검증 가능\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003erevalidate\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e,  \u003cspan class=\"hljs-comment\"\u003e// 60초 후 캐시 자동 무효화(재요청 시 다시 호출)\u003c/span\u003e\n    }\n  )\n\n  \u003cspan class=\"hljs-comment\"\u003e//...\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e이 코드가 하는 일은?\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eunstable_cache\u003c/code\u003e 함수는 Next.js에서 제공하는 비공식(unstable) 캐시 함수예요.\u003c/li\u003e\n\u003cli\u003e첫 번째 인자는 실제 실행할 비동기 함수 (이 경우 \u003ccode\u003euserId\u003c/code\u003e를 받아 간단한 객체를 반환).\u003c/li\u003e\n\u003cli\u003e두 번째 인자는 캐시 키를 결정하는 배열로, \u003ccode\u003euserId\u003c/code\u003e가 바뀌면 캐시도 새로 생성됩니다.\u003c/li\u003e\n\u003cli\u003e세 번째 옵션 객체에는 \u003ccode\u003etags\u003c/code\u003e와 \u003ccode\u003erevalidate\u003c/code\u003e 같은 설정들이 있어요.\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003etags\u003c/code\u003e는 특정 그룹으로 묶어, 같은 태그를 가진 캐시들을 한 번에 무효화 할 때 사용 가능.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erevalidate\u003c/code\u003e는 위 캐시가 자동으로 재갱신되는 시간(초) 설정입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e제가 더 알려드리고 싶은 점!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eunstable_cache\u003c/code\u003e가 \"unstable\"인 이유는 아직 공식 API가 완전히 안정화된 게 아니기 때문이에요. 그러니 프로덕션용으로 쓸 때는 주의가 필요하겠죠.\u003c/li\u003e\n\u003cli\u003e하지만 Next.js 14부터 도입된 이 기능은 서버 컴포넌트나 API 라우트에서 데이터 중복 호출을 줄이고, 성능 최적화에 꽤 도움을 줄 수 있어요.\u003c/li\u003e\n\u003cli\u003e또, 태그 기반 캐싱 덕분에 관련된 여러 데이터들을 한 번에 무효화하는 전략을 쉽게 구현할 수 있답니다.\u003c/li\u003e\n\u003cli\u003e캐싱 정책을 잘 설계하면 페이지 렌더링 속도가 확실히 빨라지니, 꼭 자기 프로젝트에 맞춰 실험해 보세요!\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003e버전 히스토리\u003c/h2\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eVersion\u003c/th\u003e\u003cth\u003eChanges\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003ev14.0.0\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eunstable_cache\u003c/code\u003e 도입\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003eNext.js의 최신 기능들을 잘 활용해서 여러분 프로젝트도 한층 더 빠르고 똑똑하게 만들 수 있길 바랄게요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2025-04-22-unstable_cache"},"buildId":"M7pU9hOcx8u_ZIFMf95sd","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>