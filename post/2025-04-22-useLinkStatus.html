<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ReactJS에서 useLinkStatus로 현재 링크 상태 쉽게 확인하는 방법 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-useLinkStatus" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ReactJS에서 useLinkStatus로 현재 링크 상태 쉽게 확인하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:title" content="ReactJS에서 useLinkStatus로 현재 링크 상태 쉽게 확인하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-useLinkStatus" data-gatsby-head="true"/><meta name="twitter:title" content="ReactJS에서 useLinkStatus로 현재 링크 상태 쉽게 확인하는 방법 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2025-04-22 12:49" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-8ded8b979ba73586.js" defer=""></script><script src="/TIL/_next/static/X4OrKfmLtU3-3BijwfHe6/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/X4OrKfmLtU3-3BijwfHe6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">ReactJS에서 useLinkStatus로 현재 링크 상태 쉽게 확인하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="ReactJS에서 useLinkStatus로 현재 링크 상태 쉽게 확인하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Apr 22, 2025</span><span class="posts_reading_time__f7YPP">9<!-- --> min read</span></span></div></div></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>useLinkStatus</h1>
<p><code>useLinkStatus</code> 훅은 <code>Link</code> 컴포넌트의 pending 상태(즉, 네비게이션이 진행 중인 상태)를 추적할 수 있게 해줍니다. 이걸 활용하면 페이지 이동이 완료될 때까지 스피너나 텍스트 깜빡임 같은 인라인 시각적 피드백을 사용자에게 보여줄 수 있어요.</p>
<h3>언제 쓸까?</h3>

















<table><thead><tr><th>상황</th><th>설명</th></tr></thead><tbody><tr><td>Prefetching이 꺼져 있거나</td><td>Prefetch가 비활성화되어 있거나 진행 중이면 네비게이션이 잠시 막힙니다.</td></tr><tr><td>동적 라우트인데 <code>loading.js</code>가 없는 경우</td><td>목적지 라우트가 동적이고, 즉각적인 네비게이션을 도와줄 <code>loading.js</code> 파일이 없을 때</td></tr></tbody></table>
<p>이렇게 네비가 바로 이루어지지 않을 때, <code>useLinkStatus</code>를 사용하면 유저 경험을 좀 더 부드럽게 만들어 줄 수 있답니다.</p>
<h3>덧붙이는 팁!</h3>
<ul>
<li>동적 라우트에서 로딩 컴포넌트를 별도로 관리하는게 귀찮다면, <code>useLinkStatus</code>로 간단하게 네비바에 로딩 표시만이라도 넣어주는 게 꽤 효과적이에요.</li>
<li>네비게이션 동안 UI가 멈춘 것처럼 보이는 건 사용자 경험에서 큰 마이너스 포인트니까, 이런 작은 피드백도 신경 쓰는 게 중요합니다.</li>
</ul>
<p>필요하다면 다음 글에서 실제 사용 예제도 가져와서 보여드릴게요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이번에 소개할 내용은 Next.js에서 링크가 눌렸을 때 로딩 상태를 쉽게 감지할 수 있는 <code>useLinkStatus</code> 훅에 대해 얘기해볼게요. 실제로 프로젝트에 적용하면 사용자 경험을 좀 더 부드럽게 만들어줄 수 있답니다.</p>
<h3>코드 예제</h3>
<p>먼저, 로딩 인디케이터를 보여주는 컴포넌트가 있어요. 링크가 클릭되고 나서 페이지가 로드 중일 때 동그란 스피너가 나타나도록 하는 간단한 코드입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-string">'use client'</span>

<span class="hljs-keyword">import</span> { useLinkStatus } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/link'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">LoadingIndicator</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> { pending } = <span class="hljs-title function_">useLinkStatus</span>()
  <span class="hljs-keyword">return</span> pending ? (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">role</span>=<span class="hljs-string">"status"</span> <span class="hljs-attr">aria-label</span>=<span class="hljs-string">"Loading"</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"spinner"</span> /></span></span>
  ) : <span class="hljs-literal">null</span>
}
</code></pre>
<p>다음은 이 <code>LoadingIndicator</code> 컴포넌트를 활용해서 헤더 안에 링크와 함께 로딩 상태를 보여주는 예시입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Link</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'next/link'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">LoadingIndicator</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./loading-indicator'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Header</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">header</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/dashboard"</span> <span class="hljs-attr">prefetch</span>=<span class="hljs-string">{false}</span>></span>
        Dashboard <span class="hljs-tag">&#x3C;<span class="hljs-name">LoadingIndicator</span> /></span>
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">Link</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">header</span>></span></span>
  )
}
</code></pre>
<h3>알아두면 좋은 팁</h3>





























<table><thead><tr><th>내용</th><th>설명</th></tr></thead><tbody><tr><td><code>useLinkStatus</code>는 <code>Link</code> 컴포넌트 하위에 위치해야 사용 가능하다</td><td>훅이 제대로 상태 변화를 감지하려면 링크 컨텍스트 내부여야 해요</td></tr><tr><td><code>prefetch='false'</code>일 때 특히 유용</td><td>미리 페이지를 불러오면 로딩 상태가 안 보이기 때문에, 미리 불러오기 해제시 효과적이죠</td></tr><tr><td>이미 프리패치된 라우트라면 pending 상태가 건너뛰어진다</td><td>즉, 빠르게 로딩되는 경우엔 스피너가 안 띄워질 수 있어요</td></tr><tr><td>연속해서 여러 링크를 클릭하면 가장 마지막 클릭한 링크만 로딩 상태가 반영된다</td><td>사용자 입장에서 자연스럽고 깔끔하게 처리해주는 부분이죠</td></tr><tr><td>이 훅은 Pages Router에서는 지원하지 않는다</td><td>앱 라우터(app router) 전용 기능이라는 점 기억하세요</td></tr></tbody></table>
<h3>참고할 점</h3>
<ul>
<li><code>useLinkStatus</code> 훅은 사용자 클릭 후 네비게이션 상태를 실시간으로 감지할 수 있어서, ‘이 페이지 가려고 클릭했는데 지금 loading 중’이라는 걸 UI에서 바로 반영하기 좋아요.</li>
<li>동시에 여러 링크를 클릭하면서도 혼란 없이 마지막 링크의 로딩 상태만 보여주기 때문에, 사용자 경험이 매끄럽죠.</li>
<li>만약 Next.js 앱 라우터를 사용하는 중이고, 로딩 표시가 필요하다면 이 훅을 적극 활용해보세요.</li>
<li>반대로 기존의 Pages Router에서는 지원하지 않으니, 다른 방법을 찾아야 함을 잊지 마시고요!</li>
</ul>
<p>사용할 때 간단히 <code>prefetch={false}</code> 옵션을 넣으면 그 링크가 클릭될 때만 실제 라우트를 불러와서 로딩 상태를 감지할 수 있어요. 미리 페이지를 불러오는 게 싫거나, 로딩 스피너를 정확히 보여주고 싶을 때 딱 좋답니다!</p>
<p>필요하다면 직접 CSS로 <code>spinner</code> 클래스를 만들어 돌리는 모양새를 구현해보는 것도 추천해요. 사용자에게 좋은 피드백을 주는 거니까요!</p>
<p>다른 궁금한 내용 있으면 언제든 질문 주세요~ 😊</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> { pending } = <span class="hljs-title function_">useLinkStatus</span>()
</code></pre>
<p><code>useLinkStatus</code>는 파라미터를 받지 않는 훅입니다.</p>
<h2>반환값</h2>
<p><code>useLinkStatus</code>는 하나의 프로퍼티를 가진 객체를 반환하는데요, 그 프로퍼티는 다음과 같습니다:</p>













<table><thead><tr><th>프로퍼티명</th><th>설명</th></tr></thead><tbody><tr><td>pending</td><td>현재 링크 상태가 "대기 중"인지 여부를 나타내는 불리언 값</td></tr></tbody></table>
<p>이 <code>pending</code> 값이 <code>true</code>면, 링크가 아직 처리 중이라는 뜻이고, <code>false</code>면 처리가 완료됐다는 의미입니다.</p>
<hr>
<p>사실, 이런 상태 값은 UI에서 로딩 인디케이터를 표시하거나, 사용자 입력을 잠시 막아야 할 때 굉장히 유용하답니다.<br>
예를 들어, 버튼 클릭 후 페이지 전환이 완료될 때까지 로딩 스피너를 보여주고 싶을 때 쓰면 좋아요!<br>
작게라도 이런 사용자 경험(UX) 개선이 앱을 더 프로답게 만들어줍니다 :)</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>아래는 <code>pending</code> 프로퍼티에 관한 내용을 좀 더 쉽게 설명한 내용입니다.</p>















<table><thead><tr><th>Property</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>pending</td><td>boolean</td><td>히스토리 업데이트 전에는 <code>true</code>, 업데이트 후에는 <code>false</code></td></tr></tbody></table>
<p><code>pending</code>은 주로 네비게이션이 아직 진행 중일 때 <code>true</code>가 되었다가, 네비게이션이 완료되면 <code>false</code>로 바뀌는 불리언 값이에요. 이걸 활용하면 사용자가 링크를 클릭했을 때, 네비게이션이 아직 끝나지 않았다는 시각적 피드백을 줄 수 있죠.</p>
<hr>
<h2>예제</h2>
<h3>인라인 로딩 인디케이터(loading indicator)</h3>
<p>사용자가 어떤 링크를 클릭했을 때, 백그라운드에서 페이지가 로드되거나 데이터가 로딩되는 동안 아무런 표시가 없으면 좀 답답하잖아요? 그래서 <code>pending</code> 값을 확인해서 로딩 중임을 보여주는 인디케이터를 추가하는 게 UX 측면에서 좋아요.</p>
<p>예를 들어, React에서 <code>pending</code> 상태를 체크해서 텍스트 옆에 작은 로딩 스피너를 띄우는 식으로 활용할 수 있죠. 이렇게 하면 사용자는 클릭한 순간부터 변화가 느껴져서 기다림이 덜 지루해집니다.</p>
<hr>
<p>실제로 이런 상태 관리와 사용자 피드백은 요즘 웹 개발에서 굉장히 중요한 부분이라서, 네비게이션 라이브러리나 데이터 페칭 라이브러리들에 <code>pending</code>, <code>loading</code> 같은 프로퍼티가 자주 등장해요. 여러분도 프로젝트에 적용할 때 꼭 고려해보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이번에 소개할 내용은 Next.js에서 링크를 클릭했을 때 로딩 인디케이터를 자연스럽게 보여주는 방법이에요. 보통 페이지 이동이 느릴 때 로딩 스피너를 보여주면 좋은데, 너무 빨리 넘어가면 깜빡임처럼 느껴져서 오히려 UX가 떨어질 수 있거든요.</p>
<p>아래 코드를 보면, <code>useLinkStatus</code> 훅을 사용해서 현재 링크가 이동 중인지 (<code>pending</code>)를 체크해요. 링크가 이동 중일 때만 <code>&#x3C;div role="status" aria-label="Loading" className="spinner" /></code>가 렌더링 돼서 로딩 인디케이터를 보여주죠.</p>
<pre><code class="hljs language-jsx"><span class="hljs-string">'use client'</span>
 
<span class="hljs-keyword">import</span> { useLinkStatus } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/link'</span>
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">LoadingIndicator</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> { pending } = <span class="hljs-title function_">useLinkStatus</span>()
  <span class="hljs-keyword">return</span> pending ? (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">role</span>=<span class="hljs-string">"status"</span> <span class="hljs-attr">aria-label</span>=<span class="hljs-string">"Loading"</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"spinner"</span> /></span></span>
  ) : <span class="hljs-literal">null</span>
}
</code></pre>
<p>그리고 메뉴바 컴포넌트에서는 각 링크 옆에 <code>LoadingIndicator</code>를 붙여서, 사용자가 클릭하면 이동 상태에 따라 스피너가 나타나요.</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Link</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'next/link'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">LoadingIndicator</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./components/loading-indicator'</span>
 
<span class="hljs-keyword">const</span> links = [
  { <span class="hljs-attr">href</span>: <span class="hljs-string">'/shop/electronics'</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">'Electronics'</span> },
  { <span class="hljs-attr">href</span>: <span class="hljs-string">'/shop/clothing'</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">'Clothing'</span> },
  { <span class="hljs-attr">href</span>: <span class="hljs-string">'/shop/books'</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">'Books'</span> },
]
 
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Menubar</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      {links.map((link) => (
        <span class="hljs-tag">&#x3C;<span class="hljs-name">Link</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{link.label}</span> <span class="hljs-attr">href</span>=<span class="hljs-string">{link.href}</span>></span>
          {link.label} <span class="hljs-tag">&#x3C;<span class="hljs-name">LoadingIndicator</span> /></span>
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">Link</span>></span>
      ))}
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  )
}
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Layout</span>(<span class="hljs-params">{ children }: { children: React.ReactNode }</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">Menubar</span> /></span>
      {children}
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  )
}
</code></pre>
<p>여기서 한 가지 팁! 페이지가 아주 빠르게 로딩되면 로딩 인디케이터가 잠깐 깜빡이는 것처럼 보여서 사용자가 거슬릴 수 있어요. 이런 문제를 해결하는 방법은 로딩 인디케이터에 '딜레이'를 주는 겁니다. 예를 들어 100ms 정도 딜레이를 주고, 처음에는 투명도 opacity를 0으로 시작해 서서히 보이도록 하면 훨씬 자연스러워져요.</p>
<p>간단한 예시 CSS를 보여드리면:</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.spinner</span> {
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">transition</span>: opacity <span class="hljs-number">0.3s</span> ease;
  <span class="hljs-attribute">animation-delay</span>: <span class="hljs-number">100ms</span>; <span class="hljs-comment">/* 딜레이 설정 */</span>
  <span class="hljs-attribute">animation-fill-mode</span>: forwards;
  <span class="hljs-comment">/* spinner 스타일 추가 */</span>
}
<span class="hljs-selector-class">.spinner</span><span class="hljs-selector-class">.visible</span> {
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;
}
</code></pre>
<p>그리고 로딩 상태가 시작되고 딜레이가 지난 후에 <code>visible</code> 클래스를 붙여서 보이도록 조절하면 됩니다.</p>
<hr>
<h3>요약</h3>













<table><thead><tr><th>문제점</th><th>해결법</th></tr></thead><tbody><tr><td>로딩 인디케이터가 너무 빨리 깜빡임</td><td>처음 보여주기 전에 100ms 정도 딜레이를 주고 opacity 0에서 시작하여 자연스럽게 나타나도록 함</td></tr></tbody></table>
<p>사실 이런 작은 UX 개선이 사용자 경험에 큰 차이를 만든답니다. 여러분도 Next.js 앱에서 로딩 인디케이터를 쓸 땐 이런 딜레이 기법을 한 번 적용해보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 CSS 코드는 간단한 로딩 스피너 애니메이션을 만드는 예제예요.</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.spinner</span> {
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">animation</span>:
    fadeIn <span class="hljs-number">500ms</span> <span class="hljs-number">100ms</span> forwards,
    rotate <span class="hljs-number">1s</span> linear infinite;
}
 
<span class="hljs-keyword">@keyframes</span> fadeIn {
  <span class="hljs-selector-tag">from</span> {
    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;
  }
  <span class="hljs-selector-tag">to</span> {
    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;
  }
}
 
<span class="hljs-keyword">@keyframes</span> rotate {
  <span class="hljs-selector-tag">to</span> {
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">360deg</span>);
  }
}
</code></pre>
<ul>
<li><code>.spinner</code> 클래스는 처음에 투명도(opacity)가 0으로 설정되어 있어요.</li>
<li><code>fadeIn</code> 애니메이션은 500ms 동안 100ms 딜레이 후에 투명도가 0에서 1로 변하며 나타나게 해주고요.</li>
<li><code>rotate</code> 애니메이션은 1초 동안 회전을 계속 반복하도록 설정되어 있어, 스피너가 빙글빙글 도는 것처럼 보이게 합니다.</li>
</ul>
<p>여기서 중요한 점은 두 애니메이션을 동시에 적용했기 때문에, 페이드인하고 나서 스피너가 계속 회전하는 동작이 자연스럽게 연결된다는 거예요.</p>
<hr>
<p>간단하게 이 애니메이션을 HTML에 적용하는 법도 알려드릴게요.</p>
<pre><code class="hljs language-html"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"spinner"</span>></span>
  <span class="hljs-comment">&#x3C;!-- 여기에 스피너 아이콘이나 SVG, 이미지 등을 넣을 수 있어요 --></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
</code></pre>
<p>그리고 스피너의 크기나 모양을 CSS로 더 커스터마이징하는 것도 가능하니, 필요에 따라 조절해 보세요.</p>
<hr>
<p>또한 최신 브라우저들은 애니메이션 성능을 최적화해주지만, 너무 많은 애니메이션을 한꺼번에 적용하면 CPU 사용량이 늘 수 있으니 주의하세요!</p>
<hr>
<p>이제 표 정보도 Markdown 형식으로 바꿔서 보여드릴게요:</p>













<table><thead><tr><th>Version</th><th>Changes</th></tr></thead><tbody><tr><td>v15.3.0</td><td><code>useLinkStatus</code> introduced.</td></tr></tbody></table>
<p><code>useLinkStatus</code>가 뭔지 궁금하다면, 다음에 자세히 다뤄볼게요! 지금은 CSS 애니메이션과 함께 잠깐 살펴봤어요. 도움이 되셨길 바랍니다!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"ReactJS에서 useLinkStatus로 현재 링크 상태 쉽게 확인하는 방법","description":"","date":"2025-04-22 12:49","slug":"2025-04-22-useLinkStatus","content":"\n\n# useLinkStatus\n\n`useLinkStatus` 훅은 `Link` 컴포넌트의 pending 상태(즉, 네비게이션이 진행 중인 상태)를 추적할 수 있게 해줍니다. 이걸 활용하면 페이지 이동이 완료될 때까지 스피너나 텍스트 깜빡임 같은 인라인 시각적 피드백을 사용자에게 보여줄 수 있어요.\n\n### 언제 쓸까?\n\n| 상황                     | 설명                                                          |\n|-------------------------|-------------------------------------------------------------|\n| Prefetching이 꺼져 있거나  | Prefetch가 비활성화되어 있거나 진행 중이면 네비게이션이 잠시 막힙니다.   |\n| 동적 라우트인데 `loading.js`가 없는 경우 | 목적지 라우트가 동적이고, 즉각적인 네비게이션을 도와줄 `loading.js` 파일이 없을 때 |\n\n이렇게 네비가 바로 이루어지지 않을 때, `useLinkStatus`를 사용하면 유저 경험을 좀 더 부드럽게 만들어 줄 수 있답니다.\n\n### 덧붙이는 팁!\n\n- 동적 라우트에서 로딩 컴포넌트를 별도로 관리하는게 귀찮다면, `useLinkStatus`로 간단하게 네비바에 로딩 표시만이라도 넣어주는 게 꽤 효과적이에요.\n- 네비게이션 동안 UI가 멈춘 것처럼 보이는 건 사용자 경험에서 큰 마이너스 포인트니까, 이런 작은 피드백도 신경 쓰는 게 중요합니다.\n\n필요하다면 다음 글에서 실제 사용 예제도 가져와서 보여드릴게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번에 소개할 내용은 Next.js에서 링크가 눌렸을 때 로딩 상태를 쉽게 감지할 수 있는 `useLinkStatus` 훅에 대해 얘기해볼게요. 실제로 프로젝트에 적용하면 사용자 경험을 좀 더 부드럽게 만들어줄 수 있답니다.\n\n### 코드 예제\n\n먼저, 로딩 인디케이터를 보여주는 컴포넌트가 있어요. 링크가 클릭되고 나서 페이지가 로드 중일 때 동그란 스피너가 나타나도록 하는 간단한 코드입니다.\n\n```js\n'use client'\n\nimport { useLinkStatus } from 'next/link'\n\nexport default function LoadingIndicator() {\n  const { pending } = useLinkStatus()\n  return pending ? (\n    \u003cdiv role=\"status\" aria-label=\"Loading\" className=\"spinner\" /\u003e\n  ) : null\n}\n```\n\n다음은 이 `LoadingIndicator` 컴포넌트를 활용해서 헤더 안에 링크와 함께 로딩 상태를 보여주는 예시입니다.\n\n```js\nimport Link from 'next/link'\nimport LoadingIndicator from './loading-indicator'\n\nexport default function Header() {\n  return (\n    \u003cheader\u003e\n      \u003cLink href=\"/dashboard\" prefetch={false}\u003e\n        Dashboard \u003cLoadingIndicator /\u003e\n      \u003c/Link\u003e\n    \u003c/header\u003e\n  )\n}\n```\n\n### 알아두면 좋은 팁\n\n| 내용 | 설명 |\n|-------|-------|\n| `useLinkStatus`는 `Link` 컴포넌트 하위에 위치해야 사용 가능하다 | 훅이 제대로 상태 변화를 감지하려면 링크 컨텍스트 내부여야 해요 |\n| `prefetch='false'`일 때 특히 유용 | 미리 페이지를 불러오면 로딩 상태가 안 보이기 때문에, 미리 불러오기 해제시 효과적이죠 |\n| 이미 프리패치된 라우트라면 pending 상태가 건너뛰어진다 | 즉, 빠르게 로딩되는 경우엔 스피너가 안 띄워질 수 있어요 |\n| 연속해서 여러 링크를 클릭하면 가장 마지막 클릭한 링크만 로딩 상태가 반영된다 | 사용자 입장에서 자연스럽고 깔끔하게 처리해주는 부분이죠 |\n| 이 훅은 Pages Router에서는 지원하지 않는다 | 앱 라우터(app router) 전용 기능이라는 점 기억하세요 |\n\n### 참고할 점\n\n- `useLinkStatus` 훅은 사용자 클릭 후 네비게이션 상태를 실시간으로 감지할 수 있어서, ‘이 페이지 가려고 클릭했는데 지금 loading 중’이라는 걸 UI에서 바로 반영하기 좋아요.\n- 동시에 여러 링크를 클릭하면서도 혼란 없이 마지막 링크의 로딩 상태만 보여주기 때문에, 사용자 경험이 매끄럽죠.\n- 만약 Next.js 앱 라우터를 사용하는 중이고, 로딩 표시가 필요하다면 이 훅을 적극 활용해보세요.\n- 반대로 기존의 Pages Router에서는 지원하지 않으니, 다른 방법을 찾아야 함을 잊지 마시고요!\n\n사용할 때 간단히 `prefetch={false}` 옵션을 넣으면 그 링크가 클릭될 때만 실제 라우트를 불러와서 로딩 상태를 감지할 수 있어요. 미리 페이지를 불러오는 게 싫거나, 로딩 스피너를 정확히 보여주고 싶을 때 딱 좋답니다!\n\n필요하다면 직접 CSS로 `spinner` 클래스를 만들어 돌리는 모양새를 구현해보는 것도 추천해요. 사용자에게 좋은 피드백을 주는 거니까요!\n\n다른 궁금한 내용 있으면 언제든 질문 주세요~ 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n```js\nconst { pending } = useLinkStatus()\n```\n\n`useLinkStatus`는 파라미터를 받지 않는 훅입니다.\n\n## 반환값\n\n`useLinkStatus`는 하나의 프로퍼티를 가진 객체를 반환하는데요, 그 프로퍼티는 다음과 같습니다:\n\n| 프로퍼티명 | 설명                         |\n|------------|------------------------------|\n| pending    | 현재 링크 상태가 \"대기 중\"인지 여부를 나타내는 불리언 값 |\n\n이 `pending` 값이 `true`면, 링크가 아직 처리 중이라는 뜻이고, `false`면 처리가 완료됐다는 의미입니다.\n\n---\n\n사실, 이런 상태 값은 UI에서 로딩 인디케이터를 표시하거나, 사용자 입력을 잠시 막아야 할 때 굉장히 유용하답니다.  \n예를 들어, 버튼 클릭 후 페이지 전환이 완료될 때까지 로딩 스피너를 보여주고 싶을 때 쓰면 좋아요!  \n작게라도 이런 사용자 경험(UX) 개선이 앱을 더 프로답게 만들어줍니다 :)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 `pending` 프로퍼티에 관한 내용을 좀 더 쉽게 설명한 내용입니다.\n\n| Property | Type    | Description                         |\n| -------- | ------- | --------------------------------- |\n| pending  | boolean | 히스토리 업데이트 전에는 `true`, 업데이트 후에는 `false` |\n\n`pending`은 주로 네비게이션이 아직 진행 중일 때 `true`가 되었다가, 네비게이션이 완료되면 `false`로 바뀌는 불리언 값이에요. 이걸 활용하면 사용자가 링크를 클릭했을 때, 네비게이션이 아직 끝나지 않았다는 시각적 피드백을 줄 수 있죠.\n\n---\n\n## 예제\n\n### 인라인 로딩 인디케이터(loading indicator)\n\n사용자가 어떤 링크를 클릭했을 때, 백그라운드에서 페이지가 로드되거나 데이터가 로딩되는 동안 아무런 표시가 없으면 좀 답답하잖아요? 그래서 `pending` 값을 확인해서 로딩 중임을 보여주는 인디케이터를 추가하는 게 UX 측면에서 좋아요.\n\n예를 들어, React에서 `pending` 상태를 체크해서 텍스트 옆에 작은 로딩 스피너를 띄우는 식으로 활용할 수 있죠. 이렇게 하면 사용자는 클릭한 순간부터 변화가 느껴져서 기다림이 덜 지루해집니다.\n\n---\n\n실제로 이런 상태 관리와 사용자 피드백은 요즘 웹 개발에서 굉장히 중요한 부분이라서, 네비게이션 라이브러리나 데이터 페칭 라이브러리들에 `pending`, `loading` 같은 프로퍼티가 자주 등장해요. 여러분도 프로젝트에 적용할 때 꼭 고려해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번에 소개할 내용은 Next.js에서 링크를 클릭했을 때 로딩 인디케이터를 자연스럽게 보여주는 방법이에요. 보통 페이지 이동이 느릴 때 로딩 스피너를 보여주면 좋은데, 너무 빨리 넘어가면 깜빡임처럼 느껴져서 오히려 UX가 떨어질 수 있거든요.\n\n아래 코드를 보면, `useLinkStatus` 훅을 사용해서 현재 링크가 이동 중인지 (`pending`)를 체크해요. 링크가 이동 중일 때만 `\u003cdiv role=\"status\" aria-label=\"Loading\" className=\"spinner\" /\u003e`가 렌더링 돼서 로딩 인디케이터를 보여주죠.\n\n```jsx\n'use client'\n \nimport { useLinkStatus } from 'next/link'\n \nexport default function LoadingIndicator() {\n  const { pending } = useLinkStatus()\n  return pending ? (\n    \u003cdiv role=\"status\" aria-label=\"Loading\" className=\"spinner\" /\u003e\n  ) : null\n}\n```\n\n그리고 메뉴바 컴포넌트에서는 각 링크 옆에 `LoadingIndicator`를 붙여서, 사용자가 클릭하면 이동 상태에 따라 스피너가 나타나요.\n\n```jsx\nimport Link from 'next/link'\nimport LoadingIndicator from './components/loading-indicator'\n \nconst links = [\n  { href: '/shop/electronics', label: 'Electronics' },\n  { href: '/shop/clothing', label: 'Clothing' },\n  { href: '/shop/books', label: 'Books' },\n]\n \nfunction Menubar() {\n  return (\n    \u003cdiv\u003e\n      {links.map((link) =\u003e (\n        \u003cLink key={link.label} href={link.href}\u003e\n          {link.label} \u003cLoadingIndicator /\u003e\n        \u003c/Link\u003e\n      ))}\n    \u003c/div\u003e\n  )\n}\n \nexport default function Layout({ children }: { children: React.ReactNode }) {\n  return (\n    \u003cdiv\u003e\n      \u003cMenubar /\u003e\n      {children}\n    \u003c/div\u003e\n  )\n}\n```\n\n여기서 한 가지 팁! 페이지가 아주 빠르게 로딩되면 로딩 인디케이터가 잠깐 깜빡이는 것처럼 보여서 사용자가 거슬릴 수 있어요. 이런 문제를 해결하는 방법은 로딩 인디케이터에 '딜레이'를 주는 겁니다. 예를 들어 100ms 정도 딜레이를 주고, 처음에는 투명도 opacity를 0으로 시작해 서서히 보이도록 하면 훨씬 자연스러워져요.\n\n간단한 예시 CSS를 보여드리면:\n\n```css\n.spinner {\n  opacity: 0;\n  transition: opacity 0.3s ease;\n  animation-delay: 100ms; /* 딜레이 설정 */\n  animation-fill-mode: forwards;\n  /* spinner 스타일 추가 */\n}\n.spinner.visible {\n  opacity: 1;\n}\n```\n\n그리고 로딩 상태가 시작되고 딜레이가 지난 후에 `visible` 클래스를 붙여서 보이도록 조절하면 됩니다.\n\n---\n\n### 요약\n\n| 문제점                   | 해결법                                                  |\n|-----------------------|-----------------------------------------------------|\n| 로딩 인디케이터가 너무 빨리 깜빡임 | 처음 보여주기 전에 100ms 정도 딜레이를 주고 opacity 0에서 시작하여 자연스럽게 나타나도록 함 |\n\n사실 이런 작은 UX 개선이 사용자 경험에 큰 차이를 만든답니다. 여러분도 Next.js 앱에서 로딩 인디케이터를 쓸 땐 이런 딜레이 기법을 한 번 적용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 CSS 코드는 간단한 로딩 스피너 애니메이션을 만드는 예제예요. \n\n```css\n.spinner {\n  opacity: 0;\n  animation:\n    fadeIn 500ms 100ms forwards,\n    rotate 1s linear infinite;\n}\n \n@keyframes fadeIn {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n \n@keyframes rotate {\n  to {\n    transform: rotate(360deg);\n  }\n}\n```\n\n- `.spinner` 클래스는 처음에 투명도(opacity)가 0으로 설정되어 있어요.\n- `fadeIn` 애니메이션은 500ms 동안 100ms 딜레이 후에 투명도가 0에서 1로 변하며 나타나게 해주고요.\n- `rotate` 애니메이션은 1초 동안 회전을 계속 반복하도록 설정되어 있어, 스피너가 빙글빙글 도는 것처럼 보이게 합니다.\n\n여기서 중요한 점은 두 애니메이션을 동시에 적용했기 때문에, 페이드인하고 나서 스피너가 계속 회전하는 동작이 자연스럽게 연결된다는 거예요.\n\n---\n\n간단하게 이 애니메이션을 HTML에 적용하는 법도 알려드릴게요.\n\n```html\n\u003cdiv class=\"spinner\"\u003e\n  \u003c!-- 여기에 스피너 아이콘이나 SVG, 이미지 등을 넣을 수 있어요 --\u003e\n\u003c/div\u003e\n```\n\n그리고 스피너의 크기나 모양을 CSS로 더 커스터마이징하는 것도 가능하니, 필요에 따라 조절해 보세요.\n\n---\n\n또한 최신 브라우저들은 애니메이션 성능을 최적화해주지만, 너무 많은 애니메이션을 한꺼번에 적용하면 CPU 사용량이 늘 수 있으니 주의하세요!\n\n---\n\n이제 표 정보도 Markdown 형식으로 바꿔서 보여드릴게요:\n\n| Version  | Changes                  |\n|----------|--------------------------|\n| v15.3.0  | `useLinkStatus` introduced. |\n\n`useLinkStatus`가 뭔지 궁금하다면, 다음에 자세히 다뤄볼게요! 지금은 CSS 애니메이션과 함께 잠깐 살펴봤어요. 도움이 되셨길 바랍니다!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":9},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003euseLinkStatus\u003c/h1\u003e\n\u003cp\u003e\u003ccode\u003euseLinkStatus\u003c/code\u003e 훅은 \u003ccode\u003eLink\u003c/code\u003e 컴포넌트의 pending 상태(즉, 네비게이션이 진행 중인 상태)를 추적할 수 있게 해줍니다. 이걸 활용하면 페이지 이동이 완료될 때까지 스피너나 텍스트 깜빡임 같은 인라인 시각적 피드백을 사용자에게 보여줄 수 있어요.\u003c/p\u003e\n\u003ch3\u003e언제 쓸까?\u003c/h3\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e상황\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003ePrefetching이 꺼져 있거나\u003c/td\u003e\u003ctd\u003ePrefetch가 비활성화되어 있거나 진행 중이면 네비게이션이 잠시 막힙니다.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e동적 라우트인데 \u003ccode\u003eloading.js\u003c/code\u003e가 없는 경우\u003c/td\u003e\u003ctd\u003e목적지 라우트가 동적이고, 즉각적인 네비게이션을 도와줄 \u003ccode\u003eloading.js\u003c/code\u003e 파일이 없을 때\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e이렇게 네비가 바로 이루어지지 않을 때, \u003ccode\u003euseLinkStatus\u003c/code\u003e를 사용하면 유저 경험을 좀 더 부드럽게 만들어 줄 수 있답니다.\u003c/p\u003e\n\u003ch3\u003e덧붙이는 팁!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e동적 라우트에서 로딩 컴포넌트를 별도로 관리하는게 귀찮다면, \u003ccode\u003euseLinkStatus\u003c/code\u003e로 간단하게 네비바에 로딩 표시만이라도 넣어주는 게 꽤 효과적이에요.\u003c/li\u003e\n\u003cli\u003e네비게이션 동안 UI가 멈춘 것처럼 보이는 건 사용자 경험에서 큰 마이너스 포인트니까, 이런 작은 피드백도 신경 쓰는 게 중요합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e필요하다면 다음 글에서 실제 사용 예제도 가져와서 보여드릴게요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이번에 소개할 내용은 Next.js에서 링크가 눌렸을 때 로딩 상태를 쉽게 감지할 수 있는 \u003ccode\u003euseLinkStatus\u003c/code\u003e 훅에 대해 얘기해볼게요. 실제로 프로젝트에 적용하면 사용자 경험을 좀 더 부드럽게 만들어줄 수 있답니다.\u003c/p\u003e\n\u003ch3\u003e코드 예제\u003c/h3\u003e\n\u003cp\u003e먼저, 로딩 인디케이터를 보여주는 컴포넌트가 있어요. 링크가 클릭되고 나서 페이지가 로드 중일 때 동그란 스피너가 나타나도록 하는 간단한 코드입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e'use client'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useLinkStatus } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/link'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eLoadingIndicator\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { pending } = \u003cspan class=\"hljs-title function_\"\u003euseLinkStatus\u003c/span\u003e()\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e pending ? (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003erole\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"status\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003earia-label\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"Loading\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"spinner\"\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e\n  ) : \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음은 이 \u003ccode\u003eLoadingIndicator\u003c/code\u003e 컴포넌트를 활용해서 헤더 안에 링크와 함께 로딩 상태를 보여주는 예시입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLink\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/link'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLoadingIndicator\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./loading-indicator'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eHeader\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eheader\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eLink\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehref\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"/dashboard\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eprefetch\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{false}\u003c/span\u003e\u003e\u003c/span\u003e\n        Dashboard \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eLoadingIndicator\u003c/span\u003e /\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eLink\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eheader\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e알아두면 좋은 팁\u003c/h3\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e내용\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003euseLinkStatus\u003c/code\u003e는 \u003ccode\u003eLink\u003c/code\u003e 컴포넌트 하위에 위치해야 사용 가능하다\u003c/td\u003e\u003ctd\u003e훅이 제대로 상태 변화를 감지하려면 링크 컨텍스트 내부여야 해요\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eprefetch='false'\u003c/code\u003e일 때 특히 유용\u003c/td\u003e\u003ctd\u003e미리 페이지를 불러오면 로딩 상태가 안 보이기 때문에, 미리 불러오기 해제시 효과적이죠\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e이미 프리패치된 라우트라면 pending 상태가 건너뛰어진다\u003c/td\u003e\u003ctd\u003e즉, 빠르게 로딩되는 경우엔 스피너가 안 띄워질 수 있어요\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e연속해서 여러 링크를 클릭하면 가장 마지막 클릭한 링크만 로딩 상태가 반영된다\u003c/td\u003e\u003ctd\u003e사용자 입장에서 자연스럽고 깔끔하게 처리해주는 부분이죠\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e이 훅은 Pages Router에서는 지원하지 않는다\u003c/td\u003e\u003ctd\u003e앱 라우터(app router) 전용 기능이라는 점 기억하세요\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e참고할 점\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003euseLinkStatus\u003c/code\u003e 훅은 사용자 클릭 후 네비게이션 상태를 실시간으로 감지할 수 있어서, ‘이 페이지 가려고 클릭했는데 지금 loading 중’이라는 걸 UI에서 바로 반영하기 좋아요.\u003c/li\u003e\n\u003cli\u003e동시에 여러 링크를 클릭하면서도 혼란 없이 마지막 링크의 로딩 상태만 보여주기 때문에, 사용자 경험이 매끄럽죠.\u003c/li\u003e\n\u003cli\u003e만약 Next.js 앱 라우터를 사용하는 중이고, 로딩 표시가 필요하다면 이 훅을 적극 활용해보세요.\u003c/li\u003e\n\u003cli\u003e반대로 기존의 Pages Router에서는 지원하지 않으니, 다른 방법을 찾아야 함을 잊지 마시고요!\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e사용할 때 간단히 \u003ccode\u003eprefetch={false}\u003c/code\u003e 옵션을 넣으면 그 링크가 클릭될 때만 실제 라우트를 불러와서 로딩 상태를 감지할 수 있어요. 미리 페이지를 불러오는 게 싫거나, 로딩 스피너를 정확히 보여주고 싶을 때 딱 좋답니다!\u003c/p\u003e\n\u003cp\u003e필요하다면 직접 CSS로 \u003ccode\u003espinner\u003c/code\u003e 클래스를 만들어 돌리는 모양새를 구현해보는 것도 추천해요. 사용자에게 좋은 피드백을 주는 거니까요!\u003c/p\u003e\n\u003cp\u003e다른 궁금한 내용 있으면 언제든 질문 주세요~ 😊\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { pending } = \u003cspan class=\"hljs-title function_\"\u003euseLinkStatus\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003euseLinkStatus\u003c/code\u003e는 파라미터를 받지 않는 훅입니다.\u003c/p\u003e\n\u003ch2\u003e반환값\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003euseLinkStatus\u003c/code\u003e는 하나의 프로퍼티를 가진 객체를 반환하는데요, 그 프로퍼티는 다음과 같습니다:\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e프로퍼티명\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003epending\u003c/td\u003e\u003ctd\u003e현재 링크 상태가 \"대기 중\"인지 여부를 나타내는 불리언 값\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e이 \u003ccode\u003epending\u003c/code\u003e 값이 \u003ccode\u003etrue\u003c/code\u003e면, 링크가 아직 처리 중이라는 뜻이고, \u003ccode\u003efalse\u003c/code\u003e면 처리가 완료됐다는 의미입니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e사실, 이런 상태 값은 UI에서 로딩 인디케이터를 표시하거나, 사용자 입력을 잠시 막아야 할 때 굉장히 유용하답니다.\u003cbr\u003e\n예를 들어, 버튼 클릭 후 페이지 전환이 완료될 때까지 로딩 스피너를 보여주고 싶을 때 쓰면 좋아요!\u003cbr\u003e\n작게라도 이런 사용자 경험(UX) 개선이 앱을 더 프로답게 만들어줍니다 :)\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e아래는 \u003ccode\u003epending\u003c/code\u003e 프로퍼티에 관한 내용을 좀 더 쉽게 설명한 내용입니다.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eProperty\u003c/th\u003e\u003cth\u003eType\u003c/th\u003e\u003cth\u003eDescription\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003epending\u003c/td\u003e\u003ctd\u003eboolean\u003c/td\u003e\u003ctd\u003e히스토리 업데이트 전에는 \u003ccode\u003etrue\u003c/code\u003e, 업데이트 후에는 \u003ccode\u003efalse\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003ccode\u003epending\u003c/code\u003e은 주로 네비게이션이 아직 진행 중일 때 \u003ccode\u003etrue\u003c/code\u003e가 되었다가, 네비게이션이 완료되면 \u003ccode\u003efalse\u003c/code\u003e로 바뀌는 불리언 값이에요. 이걸 활용하면 사용자가 링크를 클릭했을 때, 네비게이션이 아직 끝나지 않았다는 시각적 피드백을 줄 수 있죠.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e예제\u003c/h2\u003e\n\u003ch3\u003e인라인 로딩 인디케이터(loading indicator)\u003c/h3\u003e\n\u003cp\u003e사용자가 어떤 링크를 클릭했을 때, 백그라운드에서 페이지가 로드되거나 데이터가 로딩되는 동안 아무런 표시가 없으면 좀 답답하잖아요? 그래서 \u003ccode\u003epending\u003c/code\u003e 값을 확인해서 로딩 중임을 보여주는 인디케이터를 추가하는 게 UX 측면에서 좋아요.\u003c/p\u003e\n\u003cp\u003e예를 들어, React에서 \u003ccode\u003epending\u003c/code\u003e 상태를 체크해서 텍스트 옆에 작은 로딩 스피너를 띄우는 식으로 활용할 수 있죠. 이렇게 하면 사용자는 클릭한 순간부터 변화가 느껴져서 기다림이 덜 지루해집니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e실제로 이런 상태 관리와 사용자 피드백은 요즘 웹 개발에서 굉장히 중요한 부분이라서, 네비게이션 라이브러리나 데이터 페칭 라이브러리들에 \u003ccode\u003epending\u003c/code\u003e, \u003ccode\u003eloading\u003c/code\u003e 같은 프로퍼티가 자주 등장해요. 여러분도 프로젝트에 적용할 때 꼭 고려해보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이번에 소개할 내용은 Next.js에서 링크를 클릭했을 때 로딩 인디케이터를 자연스럽게 보여주는 방법이에요. 보통 페이지 이동이 느릴 때 로딩 스피너를 보여주면 좋은데, 너무 빨리 넘어가면 깜빡임처럼 느껴져서 오히려 UX가 떨어질 수 있거든요.\u003c/p\u003e\n\u003cp\u003e아래 코드를 보면, \u003ccode\u003euseLinkStatus\u003c/code\u003e 훅을 사용해서 현재 링크가 이동 중인지 (\u003ccode\u003epending\u003c/code\u003e)를 체크해요. 링크가 이동 중일 때만 \u003ccode\u003e\u0026#x3C;div role=\"status\" aria-label=\"Loading\" className=\"spinner\" /\u003e\u003c/code\u003e가 렌더링 돼서 로딩 인디케이터를 보여주죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-string\"\u003e'use client'\u003c/span\u003e\n \n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useLinkStatus } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/link'\u003c/span\u003e\n \n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eLoadingIndicator\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { pending } = \u003cspan class=\"hljs-title function_\"\u003euseLinkStatus\u003c/span\u003e()\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e pending ? (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003erole\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"status\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003earia-label\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"Loading\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"spinner\"\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e\n  ) : \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 메뉴바 컴포넌트에서는 각 링크 옆에 \u003ccode\u003eLoadingIndicator\u003c/code\u003e를 붙여서, 사용자가 클릭하면 이동 상태에 따라 스피너가 나타나요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLink\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/link'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLoadingIndicator\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./components/loading-indicator'\u003c/span\u003e\n \n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e links = [\n  { \u003cspan class=\"hljs-attr\"\u003ehref\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/shop/electronics'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003elabel\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Electronics'\u003c/span\u003e },\n  { \u003cspan class=\"hljs-attr\"\u003ehref\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/shop/clothing'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003elabel\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Clothing'\u003c/span\u003e },\n  { \u003cspan class=\"hljs-attr\"\u003ehref\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/shop/books'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003elabel\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Books'\u003c/span\u003e },\n]\n \n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eMenubar\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      {links.map((link) =\u003e (\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eLink\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{link.label}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehref\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{link.href}\u003c/span\u003e\u003e\u003c/span\u003e\n          {link.label} \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eLoadingIndicator\u003c/span\u003e /\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eLink\u003c/span\u003e\u003e\u003c/span\u003e\n      ))}\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n \n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eLayout\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ children }: { children: React.ReactNode }\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eMenubar\u003c/span\u003e /\u003e\u003c/span\u003e\n      {children}\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 한 가지 팁! 페이지가 아주 빠르게 로딩되면 로딩 인디케이터가 잠깐 깜빡이는 것처럼 보여서 사용자가 거슬릴 수 있어요. 이런 문제를 해결하는 방법은 로딩 인디케이터에 '딜레이'를 주는 겁니다. 예를 들어 100ms 정도 딜레이를 주고, 처음에는 투명도 opacity를 0으로 시작해 서서히 보이도록 하면 훨씬 자연스러워져요.\u003c/p\u003e\n\u003cp\u003e간단한 예시 CSS를 보여드리면:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-css\"\u003e\u003cspan class=\"hljs-selector-class\"\u003e.spinner\u003c/span\u003e {\n  \u003cspan class=\"hljs-attribute\"\u003eopacity\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  \u003cspan class=\"hljs-attribute\"\u003etransition\u003c/span\u003e: opacity \u003cspan class=\"hljs-number\"\u003e0.3s\u003c/span\u003e ease;\n  \u003cspan class=\"hljs-attribute\"\u003eanimation-delay\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e100ms\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e/* 딜레이 설정 */\u003c/span\u003e\n  \u003cspan class=\"hljs-attribute\"\u003eanimation-fill-mode\u003c/span\u003e: forwards;\n  \u003cspan class=\"hljs-comment\"\u003e/* spinner 스타일 추가 */\u003c/span\u003e\n}\n\u003cspan class=\"hljs-selector-class\"\u003e.spinner\u003c/span\u003e\u003cspan class=\"hljs-selector-class\"\u003e.visible\u003c/span\u003e {\n  \u003cspan class=\"hljs-attribute\"\u003eopacity\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 로딩 상태가 시작되고 딜레이가 지난 후에 \u003ccode\u003evisible\u003c/code\u003e 클래스를 붙여서 보이도록 조절하면 됩니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e요약\u003c/h3\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e문제점\u003c/th\u003e\u003cth\u003e해결법\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e로딩 인디케이터가 너무 빨리 깜빡임\u003c/td\u003e\u003ctd\u003e처음 보여주기 전에 100ms 정도 딜레이를 주고 opacity 0에서 시작하여 자연스럽게 나타나도록 함\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e사실 이런 작은 UX 개선이 사용자 경험에 큰 차이를 만든답니다. 여러분도 Next.js 앱에서 로딩 인디케이터를 쓸 땐 이런 딜레이 기법을 한 번 적용해보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 CSS 코드는 간단한 로딩 스피너 애니메이션을 만드는 예제예요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-css\"\u003e\u003cspan class=\"hljs-selector-class\"\u003e.spinner\u003c/span\u003e {\n  \u003cspan class=\"hljs-attribute\"\u003eopacity\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  \u003cspan class=\"hljs-attribute\"\u003eanimation\u003c/span\u003e:\n    fadeIn \u003cspan class=\"hljs-number\"\u003e500ms\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e100ms\u003c/span\u003e forwards,\n    rotate \u003cspan class=\"hljs-number\"\u003e1s\u003c/span\u003e linear infinite;\n}\n \n\u003cspan class=\"hljs-keyword\"\u003e@keyframes\u003c/span\u003e fadeIn {\n  \u003cspan class=\"hljs-selector-tag\"\u003efrom\u003c/span\u003e {\n    \u003cspan class=\"hljs-attribute\"\u003eopacity\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-selector-tag\"\u003eto\u003c/span\u003e {\n    \u003cspan class=\"hljs-attribute\"\u003eopacity\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n  }\n}\n \n\u003cspan class=\"hljs-keyword\"\u003e@keyframes\u003c/span\u003e rotate {\n  \u003cspan class=\"hljs-selector-tag\"\u003eto\u003c/span\u003e {\n    \u003cspan class=\"hljs-attribute\"\u003etransform\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003erotate\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e360deg\u003c/span\u003e);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e.spinner\u003c/code\u003e 클래스는 처음에 투명도(opacity)가 0으로 설정되어 있어요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efadeIn\u003c/code\u003e 애니메이션은 500ms 동안 100ms 딜레이 후에 투명도가 0에서 1로 변하며 나타나게 해주고요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erotate\u003c/code\u003e 애니메이션은 1초 동안 회전을 계속 반복하도록 설정되어 있어, 스피너가 빙글빙글 도는 것처럼 보이게 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e여기서 중요한 점은 두 애니메이션을 동시에 적용했기 때문에, 페이드인하고 나서 스피너가 계속 회전하는 동작이 자연스럽게 연결된다는 거예요.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e간단하게 이 애니메이션을 HTML에 적용하는 법도 알려드릴게요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-html\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"spinner\"\u003c/span\u003e\u003e\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e\u0026#x3C;!-- 여기에 스피너 아이콘이나 SVG, 이미지 등을 넣을 수 있어요 --\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 스피너의 크기나 모양을 CSS로 더 커스터마이징하는 것도 가능하니, 필요에 따라 조절해 보세요.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e또한 최신 브라우저들은 애니메이션 성능을 최적화해주지만, 너무 많은 애니메이션을 한꺼번에 적용하면 CPU 사용량이 늘 수 있으니 주의하세요!\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e이제 표 정보도 Markdown 형식으로 바꿔서 보여드릴게요:\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eVersion\u003c/th\u003e\u003cth\u003eChanges\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003ev15.3.0\u003c/td\u003e\u003ctd\u003e\u003ccode\u003euseLinkStatus\u003c/code\u003e introduced.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003ccode\u003euseLinkStatus\u003c/code\u003e가 뭔지 궁금하다면, 다음에 자세히 다뤄볼게요! 지금은 CSS 애니메이션과 함께 잠깐 살펴봤어요. 도움이 되셨길 바랍니다!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2025-04-22-useLinkStatus"},"buildId":"X4OrKfmLtU3-3BijwfHe6","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>