<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Next.js 15 서버 사이드 렌더링 사용법(use server) | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-useserver" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Next.js 15 서버 사이드 렌더링 사용법(use server) | TIL" data-gatsby-head="true"/><meta property="og:title" content="Next.js 15 서버 사이드 렌더링 사용법(use server) | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-useserver" data-gatsby-head="true"/><meta name="twitter:title" content="Next.js 15 서버 사이드 렌더링 사용법(use server) | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2025-04-22 02:14" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/0eef537492fed77a.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/0eef537492fed77a.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-8ded8b979ba73586.js" defer=""></script><script src="/TIL/_next/static/M7pU9hOcx8u_ZIFMf95sd/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/M7pU9hOcx8u_ZIFMf95sd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Next.js 15 서버 사이드 렌더링 사용법(use server)</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Next.js 15 서버 사이드 렌더링 사용법(use server)" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Apr 22, 2025</span><span class="posts_reading_time__f7YPP">11<!-- --> min read</span></span></div></div></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>use server</h1>
<p>'use server' 지시어는 특정 함수나 파일이 서버 측에서 실행되어야 함을 명시하는 역할을 해요. 파일 맨 위에 쓰면 그 파일 안의 모든 함수가 서버에서 실행된다는 뜻이고, 함수 바로 위에 inline으로 쓰면 그 함수만 서버 함수(Server Function)로 지정할 수 있답니다. 이건 React에서 제공하는 기능이에요.</p>
<h2>파일 맨 위에 use server 쓰기</h2>
<p>아래 예시는 파일 최상단에 <code>use server</code> 지시어를 넣은 경우에요. 이렇게 하면 그 안에 있는 모든 함수는 서버에서 실행됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-string">'use server'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getServerData</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 서버에서만 실행되는 로직</span>
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://api.example.com/data'</span>);
  <span class="hljs-keyword">return</span> data.<span class="hljs-title function_">json</span>();
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">helperFunction</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 이 함수도 서버에서 실행돼요</span>
}
</code></pre>
<h3>추가 설명!</h3>
<ul>
<li><code>use server</code>를 쓰는 이유는 클라이언트에서 실행하면 안 되는 무거운 연산, 비밀 정보 처리, 데이터베이스 쿼리 등을 서버 쪽으로 감추기 위함이에요.</li>
<li>React 컴포넌트 내에서 서버 함수 호출 시 클라이언트 코드와 서버 코드를 깔끔하게 분리할 수 있어서 보안과 성능 면에서 유리합니다.</li>
<li>만약 한 파일에 서버 함수와 클라이언트 함수가 혼재되어 있으면, 필요한 함수에만 inline으로 <code>use server</code>를 붙여서 관리하는 걸 추천해요.</li>
</ul>
<p>서버 함수 잘 활용하면 앱 구조를 더 명확하게 하고, 유지보수도 쉬워지니 꼭 익혀두시면 좋아요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-comment">// actions.ts</span>
<span class="hljs-string">"use server"</span>

<span class="hljs-keyword">import</span> { db } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/lib/db'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchUsers</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> users = <span class="hljs-keyword">await</span> db.<span class="hljs-property">user</span>.<span class="hljs-title function_">findMany</span>()
  <span class="hljs-keyword">return</span> users
}
</code></pre>
<p>이렇게 Server Functions는 <code>"use server"</code> 지시어를 파일 상단에 작성해줘야 해요. 그리고 만들고 나면 클라이언트 컴포넌트나 서버 컴포넌트 어디에서든 가져다 쓸 수 있게 됩니다.</p>
<p>예를 들어 클라이언트 컴포넌트에서 fetchUsers 함수를 사용하고 싶으면 이렇게 하면 돼요:</p>
<pre><code class="hljs language-tsx"><span class="hljs-string">"use client"</span>

<span class="hljs-keyword">import</span> { fetchUsers } <span class="hljs-keyword">from</span> <span class="hljs-string">'./actions'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">UserList</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">loadUsers</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> users = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchUsers</span>()
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(users)
  }

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =></span> loadUsers()}>Load Users<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span></span>
}
</code></pre>
<p>여기서 포인트는 바로 클라이언트 컴포넌트에선 서버 함수가 비동기(Async) 함수라는 점이에요. 이걸 직접 호출하려면 이렇게 버튼 클릭 같은 이벤트 핸들러 안에서 호출하고 결과를 받아서 화면에 보여 주거나 로그를 찍는 식으로 사용합니다.</p>
<hr>
<h3>Server Functions와 Database 연동 정리</h3>

























<table><thead><tr><th>설명</th><th>내용</th></tr></thead><tbody><tr><td>Server Function 생성법</td><td><code>use server</code> 지시어를 파일 상단에 넣고 비동기 함수 작성</td></tr><tr><td>Server 함수 위치</td><td>별도 파일(actions.ts 등)에 작성해 여러 컴포넌트에서 import 가능</td></tr><tr><td>Client 컴포넌트에서 사용법</td><td>async 함수 안에서 호출, 이벤트 핸들러에서 호출하는 식으로 비동기 처리</td></tr><tr><td>데이터베이스 연동</td><td>서버 함수 내에서 직접 <code>db</code> 클라이언트를 사용해 데이터 조회/수정 가능</td></tr></tbody></table>
<hr>
<h3>참고 사항</h3>
<ul>
<li>아직 Next.js나 React에서 완전히 SSR과 Client 컴포넌트 경계가 명확하여 이 방식을 적용할 때 내가 직접 어떤 작업이 서버에서 일어나고 있는지 분명히 이해하고 사용해야 해요.</li>
<li>클라이언트에서 서버 함수를 호출할 때는 내부적으로 서버로 요청이 나가게 된다 생각하면 편해요. 그래서 고통 없는 데이터를 직접 다루는 것보다 네트워크 요청 비용이 있으니 꼭 필요한 경우에만 사용하세요.</li>
<li>또, 인증 처리 같은 민감한 로직은 항상 서버 함수에서 관리하는 게 안전합니다.</li>
</ul>
<p>이 정도 핵심만 잘 이해해 두면 Server Functions를 효과적으로 쓸 수 있어요! 도움이 되었길 바랄게요 :)</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이번 시간에는 Next.js의 Server Functions를 사용해서 데이터베이스에서 유저 데이터를 가져오는 예제를 살펴볼게요. 그리고 Fetch Users 함수를 클라이언트 컴포넌트에서 어떻게 호출할 수 있는지도 함께 알아봅니다.</p>
<hr>
<h3>1. Server Function 작성하기</h3>
<p>아래 코드는 <code>fetchUsers</code>라는 Server Function입니다. 데이터베이스에서 모든 유저를 가져와서 반환해주죠.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { db } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/lib/db'</span> <span class="hljs-comment">// 데이터베이스 클라이언트 임포트</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchUsers</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> users = <span class="hljs-keyword">await</span> db.<span class="hljs-property">user</span>.<span class="hljs-title function_">findMany</span>()
  <span class="hljs-keyword">return</span> users
}
</code></pre>
<p>여기서 <code>db.user.findMany()</code>는 Prisma 같은 ORM을 사용한다고 가정하고, 유저들을 모두 조회하는 코드입니다.</p>
<hr>
<h3>2. 클라이언트 컴포넌트에서 Server Function 호출하기</h3>
<p>이제 위에서 만든 <code>fetchUsers</code> 함수를 클라이언트 컴포넌트에서 호출해 보겠습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">MyButton</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =></span> fetchUsers()}>Fetch Users<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span></span>
}
</code></pre>
<p>버튼 클릭 시 <code>fetchUsers</code>가 실행됩니다.</p>
<hr>
<h3>참고</h3>
<ul>
<li>일반적으로 Server Function은 서버에서 실행하기 때문에, 클라이언트에서 직접 호출하려면 Next.js가 지원하는 방식으로 호출해야 합니다.</li>
<li>만약 바로 클라이언트에서 <code>fetchUsers</code>를 호출하면, 서버 측 환경 변수가 없거나 보안 이슈가 생길 수 있으니 주의하세요.</li>
<li>Next.js 13 최신 기능 중 하나인 <strong>Inline use server</strong> 문법을 활용하면, 클라이언트 컴포넌트 안에서 서버 함수를 좀 더 쉽게 호출할 수 있습니다.</li>
</ul>
<hr>
<h2>Using <code>use server</code> inline</h2>
<p><code>use server</code>는 Server Action 혹은 Server Function을 클라이언트 컴포넌트 내에서 바로 선언하고 사용할 수 있는 문법입니다. 예를 들어,</p>
<pre><code class="hljs language-js"><span class="hljs-string">'use client'</span>

<span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">MyButton</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchUsers</span>(<span class="hljs-params"></span>) {
    <span class="hljs-string">'use server'</span>  <span class="hljs-comment">// 여기서 서버 함수 선언</span>
    <span class="hljs-keyword">const</span> users = <span class="hljs-keyword">await</span> db.<span class="hljs-property">user</span>.<span class="hljs-title function_">findMany</span>()
    <span class="hljs-keyword">return</span> users
  }

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =></span> fetchUsers()}>Fetch Users<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span></span>
}
</code></pre>
<p>이런 식으로 하면, <code>fetchUsers</code> 함수가 서버에서 실행되고 클라이언트에서 호출할 수 있습니다.</p>
<hr>
<h2>정리</h2>





















<table><thead><tr><th>개념</th><th>설명</th></tr></thead><tbody><tr><td>Server Function</td><td>서버에서만 실행되는 함수. 서버 자원에 직접 접근 가능</td></tr><tr><td>클라이언트에서 호출</td><td>클라이언트에서 호출 시 서버와 통신하거나, Next.js 방식 활용 필요</td></tr><tr><td><code>use server</code> inline</td><td>클라이언트 컴포넌트 내에서 서버 함수를 선언하고 실행 가능</td></tr></tbody></table>
<hr>
<p>이제 여러분도 Next.js에서 Server Functions를 어떻게 만들고 클라이언트에서 호출하는지 감이 좀 오시죠? 요즘 프레임워크가 점점 더 편리해지고 있어서, 서버와 클라이언트 코드 구분이 한결 수월해지고 있어요. 필요할 때 서버 함수를 잘 활용하면 더 깔끔하고 안전한 앱을 만들 수 있답니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>서버 함수(Server Function)를 표시할 때 <code>use server</code>를 함수 맨 위에 인라인으로 작성하는 방법에 대해 이야기해볼게요. 아래 예제를 보면, 데이터베이스에서 사용자 목록을 가져오는 함수가 있어요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { db } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/lib/db'</span> <span class="hljs-comment">// 데이터베이스 클라이언트 불러오기</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">UserList</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchUsers</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> users = <span class="hljs-keyword">await</span> db.<span class="hljs-property">user</span>.<span class="hljs-title function_">findMany</span>()
    <span class="hljs-keyword">return</span> users
  }

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =></span> fetchUsers()}>Fetch Users<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span></span>
}
</code></pre>
<p>이 예제에서는 <code>fetchUsers</code> 함수가 서버에서 실행되어야 하는데, 실제로 현재 함수 위에 <code>use server</code> 지시어가 빠져 있어요. 이걸 명시하면 Next.js 같은 프레임워크가 이 함수가 서버 전용임을 확실히 알 수 있답니다.</p>
<h3>서버 함수에 <code>use server</code>를 추가할 때는 이렇게!</h3>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { db } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/lib/db'</span> <span class="hljs-comment">// 데이터베이스 클라이언트 불러오기</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">UserList</span>(<span class="hljs-params"></span>) {
  <span class="hljs-string">"use server"</span>
  
  <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchUsers</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> users = <span class="hljs-keyword">await</span> db.<span class="hljs-property">user</span>.<span class="hljs-title function_">findMany</span>()
    <span class="hljs-keyword">return</span> users
  }

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =></span> fetchUsers()}>Fetch Users<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span></span>
}
</code></pre>
<p>혹은 함수 바로 앞에 붙이는 경우도 있어요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { db } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/lib/db'</span> <span class="hljs-comment">// 데이터베이스 클라이언트 불러오기</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">UserList</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchUsers</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) => {
    <span class="hljs-string">"use server"</span>
    <span class="hljs-keyword">const</span> users = <span class="hljs-keyword">await</span> db.<span class="hljs-property">user</span>.<span class="hljs-title function_">findMany</span>()
    <span class="hljs-keyword">return</span> users
  }

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =></span> fetchUsers()}>Fetch Users<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span></span>
}
</code></pre>
<p>서버 함수는 클라이언트에 번들되지 않고, 서버에서만 실행되도록 보장해줘서 보안 측면에서 매우 중요해요.</p>
<hr>
<h2>보안 고려사항 (Security considerations)</h2>
<p><code>use server</code> 지시어를 사용해 서버 함수를 작성할 때는 보안을 꼭 염두에 두어야 해요. 서버에서 실행되는 만큼, 다음 사항들을 기억하세요:</p>

























<table><thead><tr><th>체크포인트</th><th>설명</th></tr></thead><tbody><tr><td>민감한 데이터 보호하기</td><td>데이터베이스 연결 정보, API 키, 사용자 비밀정보 등은 절대 클라이언트에 노출되면 안 됩니다. 서버 함수 내부에서만 접근하도록 하세요.</td></tr><tr><td>데이터 검증 및 인가 처리</td><td>클라이언트 요청 시 입력값을 반드시 검증하고, 인증과 권한 체크를 통해 불법 접근을 막으세요.</td></tr><tr><td>에러 처리 및 로그 관리</td><td>서버 함수에서 발생하는 예외 처리를 신경쓰고, 보안 관련 로그는 적절히 기록해 두세요.</td></tr><tr><td>XSS 및 Injection 공격 방지</td><td>쿼리를 생성할 때 SQL 주입 또는 스크립트 주입 공격을 방지하도록 준비된 쿼리 사용과 데이터 정제 수행.</td></tr></tbody></table>
<p>서버 함수는 서버 전용 코드임을 명확하게 표시하고, 클라이언트에서는 최소한의 정보만 주고받도록 하는 게 핵심입니다. 이런 방법들을 지키면 더욱 안전한 웹 애플리케이션 개발에 한 걸음 더 다가갈 수 있어요.</p>
<hr>
<p>더 자세한 내용이 궁금하면, 사용하는 프레임워크 문서에서 <code>Server Functions</code> 또는 <code>Server Components</code> 부분을 참고해 보세요. <code>use server</code> 지시어를 어떻게 활용하는지, 그리고 클라이언트와 서버 간 데이터 흐름을 어떻게 구성하는지 실무에 큰 도움이 될 거예요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>인증(Authentication)과 인가(Authorization)</h3>
<p>서버 쪽에서 중요한 작업을 수행할 때는 항상 사용자가 누구인지 인증(Authentication)하고, 그 작업을 할 권한이 있는지를 확인하는 인가(Authorization)를 먼저 하셔야 해요.</p>
<p>아래 예제 코드를 살짝 바꿔가며 설명해볼게요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { db } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/lib/db'</span> <span class="hljs-comment">// 데이터베이스 클라이언트</span>
<span class="hljs-keyword">import</span> { authenticate } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/lib/auth'</span> <span class="hljs-comment">// 인증 라이브러리</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createUser</span>(<span class="hljs-params">data, request</span>) {
  <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-title function_">authenticate</span>(request) <span class="hljs-comment">// 요청에서 사용자 인증</span>
  
  <span class="hljs-keyword">if</span> (!user) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Unauthorized'</span>) <span class="hljs-comment">// 인증 실패 시 에러 처리</span>
  }
  
  <span class="hljs-comment">// 인증된 사용자만 새 사용자 생성 가능</span>
  <span class="hljs-keyword">const</span> newUser = <span class="hljs-keyword">await</span> db.<span class="hljs-property">user</span>.<span class="hljs-title function_">create</span>({ data })
  <span class="hljs-keyword">return</span> newUser
}
</code></pre>
<p>위 코드에서 중요한 포인트는 <code>authenticate</code> 함수를 통해 사용자의 신원을 확인하는 과정을 거친다는 점이에요. 인증이 안 된 상태로 <code>createUser</code> 같은 주요 작업을 진행한다면 보안 이슈가 생길 수 있으니 꼭 확인해야 합니다.</p>
<h3>인증과 인가, 이 둘의 차이</h3>
<ul>
<li><strong>인증(Authentication)</strong>: "너 누구야?" 라며 사용자 신원을 확인하는 과정</li>
<li><strong>인가(Authorization)</strong>: "너 이 작업 해도 돼?" 라며 권한을 확인하는 과정</li>
</ul>
<p>예를 들어, 로그인된 사용자가 있더라도 그 사람이 게시글 삭제 권한이 없다면 삭제할 수 없게 막는 게 바로 인가 절차가 됩니다.</p>
<h3>덧붙여서</h3>
<p>API 설계 시 보통 토큰(JWT 등)을 활용한 인증 방식을 많이 사용해요. 그리고 권한 관리는 역할(Role) 기반으로 하거나 특정 권한을 부여하는 식으로 구현하는 게 실무에서 흔하죠.</p>
<p>또한, 프론트엔드에서도 인증 상태를 관리하고, 서버에는 절대 신뢰할 수 없는 상태로 요청하지 않는 게 중요합니다! 서버가 항상 “내가 진짜 인증한 사용자와 이야기 중인지”를 검증해야 한다는 점, 꼭 기억하세요.</p>
<hr>
<h2>참고 문서</h2>
<ul>
<li><a href="https://oauth.net/2/" rel="nofollow" target="_blank">OAuth 2.0 공식 문서</a></li>
<li><a href="https://jwt.io/introduction" rel="nofollow" target="_blank">JWT 소개와 활용법</a></li>
<li><a href="https://blog.nodejs.org/2021/10/05/node-js-authentication-best-practices/" rel="nofollow" target="_blank">Node.js Authentication Best Practices</a></li>
</ul>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>React 공식 문서에서 'use server'에 대한 자세한 내용을 확인할 수 있어요.</p>
<p>'Use server'는 React 18부터 도입된 기능 중 하나로, 서버 컴포넌트를 사용할 때 주로 활용됩니다. 서버 컴포넌트를 통해 렌더링이 서버에서 이루어지기 때문에 클라이언트 사이드보다 초기 로딩 속도가 빠르고, SEO에도 좋다는 장점이 있어요.</p>
<p>React 공식 문서에서는 'use server'가 어떻게 동작하는지, 그리고 서버 컴포넌트를 어떻게 잘 활용할 수 있는지 구체적으로 설명하고 있으니 직접 확인해보시면 많은 도움이 될 거예요.</p>
<p>또한, 서버 컴포넌트는 데이터 요청(fetch) 같은 작업을 서버에서 직접 처리할 수 있어서 클라이언트의 부담을 줄여주는데, React의 'use server' 기능과 잘 결합하면 더욱 효과적이죠.</p>
<p>궁금하다면 아래 React 공식 문서 링크에서 자세한 내용 읽어보세요!<br>
<a href="https://reactjs.org/docs/getting-started.html" rel="nofollow" target="_blank">https://reactjs.org/docs/getting-started.html</a> (React 공식 문서 메인 페이지입니다. 'Server Components'나 'use server'를 검색해보시면 도움됩니다.)</p>
<p>필요하다면 관련 예제나 사용법도 같이 소개해드릴게요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Next.js 15 서버 사이드 렌더링 사용법(use server)","description":"","date":"2025-04-22 02:14","slug":"2025-04-22-useserver","content":"\n\n# use server\n\n'use server' 지시어는 특정 함수나 파일이 서버 측에서 실행되어야 함을 명시하는 역할을 해요. 파일 맨 위에 쓰면 그 파일 안의 모든 함수가 서버에서 실행된다는 뜻이고, 함수 바로 위에 inline으로 쓰면 그 함수만 서버 함수(Server Function)로 지정할 수 있답니다. 이건 React에서 제공하는 기능이에요.\n\n## 파일 맨 위에 use server 쓰기\n\n아래 예시는 파일 최상단에 `use server` 지시어를 넣은 경우에요. 이렇게 하면 그 안에 있는 모든 함수는 서버에서 실행됩니다.\n\n```js\n'use server';\n\nexport async function getServerData() {\n  // 서버에서만 실행되는 로직\n  const data = await fetch('https://api.example.com/data');\n  return data.json();\n}\n\nexport function helperFunction() {\n  // 이 함수도 서버에서 실행돼요\n}\n```\n\n### 추가 설명!\n\n- `use server`를 쓰는 이유는 클라이언트에서 실행하면 안 되는 무거운 연산, 비밀 정보 처리, 데이터베이스 쿼리 등을 서버 쪽으로 감추기 위함이에요.\n- React 컴포넌트 내에서 서버 함수 호출 시 클라이언트 코드와 서버 코드를 깔끔하게 분리할 수 있어서 보안과 성능 면에서 유리합니다.\n- 만약 한 파일에 서버 함수와 클라이언트 함수가 혼재되어 있으면, 필요한 함수에만 inline으로 `use server`를 붙여서 관리하는 걸 추천해요.\n\n서버 함수 잘 활용하면 앱 구조를 더 명확하게 하고, 유지보수도 쉬워지니 꼭 익혀두시면 좋아요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n// actions.ts\n\"use server\"\n\nimport { db } from '@/lib/db'\n\nexport async function fetchUsers() {\n  const users = await db.user.findMany()\n  return users\n}\n```\n\n이렇게 Server Functions는 `\"use server\"` 지시어를 파일 상단에 작성해줘야 해요. 그리고 만들고 나면 클라이언트 컴포넌트나 서버 컴포넌트 어디에서든 가져다 쓸 수 있게 됩니다.\n\n예를 들어 클라이언트 컴포넌트에서 fetchUsers 함수를 사용하고 싶으면 이렇게 하면 돼요:\n\n```tsx\n\"use client\"\n\nimport { fetchUsers } from './actions'\n\nexport default function UserList() {\n  async function loadUsers() {\n    const users = await fetchUsers()\n    console.log(users)\n  }\n\n  return \u003cbutton onClick={() =\u003e loadUsers()}\u003eLoad Users\u003c/button\u003e\n}\n```\n\n여기서 포인트는 바로 클라이언트 컴포넌트에선 서버 함수가 비동기(Async) 함수라는 점이에요. 이걸 직접 호출하려면 이렇게 버튼 클릭 같은 이벤트 핸들러 안에서 호출하고 결과를 받아서 화면에 보여 주거나 로그를 찍는 식으로 사용합니다.\n\n---\n\n### Server Functions와 Database 연동 정리\n\n| 설명              | 내용                                                         |\n|-----------------|------------------------------------------------------------|\n| Server Function 생성법    | `use server` 지시어를 파일 상단에 넣고 비동기 함수 작성                |\n| Server 함수 위치          | 별도 파일(actions.ts 등)에 작성해 여러 컴포넌트에서 import 가능          |\n| Client 컴포넌트에서 사용법 | async 함수 안에서 호출, 이벤트 핸들러에서 호출하는 식으로 비동기 처리        |\n| 데이터베이스 연동          | 서버 함수 내에서 직접 `db` 클라이언트를 사용해 데이터 조회/수정 가능         |\n\n---\n\n### 참고 사항\n- 아직 Next.js나 React에서 완전히 SSR과 Client 컴포넌트 경계가 명확하여 이 방식을 적용할 때 내가 직접 어떤 작업이 서버에서 일어나고 있는지 분명히 이해하고 사용해야 해요.\n- 클라이언트에서 서버 함수를 호출할 때는 내부적으로 서버로 요청이 나가게 된다 생각하면 편해요. 그래서 고통 없는 데이터를 직접 다루는 것보다 네트워크 요청 비용이 있으니 꼭 필요한 경우에만 사용하세요.\n- 또, 인증 처리 같은 민감한 로직은 항상 서버 함수에서 관리하는 게 안전합니다.\n\n이 정도 핵심만 잘 이해해 두면 Server Functions를 효과적으로 쓸 수 있어요! 도움이 되었길 바랄게요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번 시간에는 Next.js의 Server Functions를 사용해서 데이터베이스에서 유저 데이터를 가져오는 예제를 살펴볼게요. 그리고 Fetch Users 함수를 클라이언트 컴포넌트에서 어떻게 호출할 수 있는지도 함께 알아봅니다.\n\n---\n\n### 1. Server Function 작성하기\n\n아래 코드는 `fetchUsers`라는 Server Function입니다. 데이터베이스에서 모든 유저를 가져와서 반환해주죠.\n\n```js\nimport { db } from '@/lib/db' // 데이터베이스 클라이언트 임포트\n\nexport async function fetchUsers() {\n  const users = await db.user.findMany()\n  return users\n}\n```\n\n여기서 `db.user.findMany()`는 Prisma 같은 ORM을 사용한다고 가정하고, 유저들을 모두 조회하는 코드입니다.\n\n---\n\n### 2. 클라이언트 컴포넌트에서 Server Function 호출하기\n\n이제 위에서 만든 `fetchUsers` 함수를 클라이언트 컴포넌트에서 호출해 보겠습니다.\n\n```js\nexport default function MyButton() {\n  return \u003cbutton onClick={() =\u003e fetchUsers()}\u003eFetch Users\u003c/button\u003e\n}\n```\n\n버튼 클릭 시 `fetchUsers`가 실행됩니다.\n\n---\n\n### 참고\n\n- 일반적으로 Server Function은 서버에서 실행하기 때문에, 클라이언트에서 직접 호출하려면 Next.js가 지원하는 방식으로 호출해야 합니다.\n- 만약 바로 클라이언트에서 `fetchUsers`를 호출하면, 서버 측 환경 변수가 없거나 보안 이슈가 생길 수 있으니 주의하세요.\n- Next.js 13 최신 기능 중 하나인 **Inline use server** 문법을 활용하면, 클라이언트 컴포넌트 안에서 서버 함수를 좀 더 쉽게 호출할 수 있습니다.\n\n---\n\n## Using `use server` inline\n\n`use server`는 Server Action 혹은 Server Function을 클라이언트 컴포넌트 내에서 바로 선언하고 사용할 수 있는 문법입니다. 예를 들어,\n\n```js\n'use client'\n\nimport { useState } from 'react'\n\nexport default function MyButton() {\n  async function fetchUsers() {\n    'use server'  // 여기서 서버 함수 선언\n    const users = await db.user.findMany()\n    return users\n  }\n\n  return \u003cbutton onClick={() =\u003e fetchUsers()}\u003eFetch Users\u003c/button\u003e\n}\n```\n\n이런 식으로 하면, `fetchUsers` 함수가 서버에서 실행되고 클라이언트에서 호출할 수 있습니다.\n\n---\n\n## 정리\n\n| 개념                | 설명                                                         |\n|---------------------|--------------------------------------------------------------|\n| Server Function     | 서버에서만 실행되는 함수. 서버 자원에 직접 접근 가능          |\n| 클라이언트에서 호출 | 클라이언트에서 호출 시 서버와 통신하거나, Next.js 방식 활용 필요 |\n| `use server` inline | 클라이언트 컴포넌트 내에서 서버 함수를 선언하고 실행 가능     |\n\n---\n\n이제 여러분도 Next.js에서 Server Functions를 어떻게 만들고 클라이언트에서 호출하는지 감이 좀 오시죠? 요즘 프레임워크가 점점 더 편리해지고 있어서, 서버와 클라이언트 코드 구분이 한결 수월해지고 있어요. 필요할 때 서버 함수를 잘 활용하면 더 깔끔하고 안전한 앱을 만들 수 있답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n서버 함수(Server Function)를 표시할 때 `use server`를 함수 맨 위에 인라인으로 작성하는 방법에 대해 이야기해볼게요. 아래 예제를 보면, 데이터베이스에서 사용자 목록을 가져오는 함수가 있어요.\n\n```js\nimport { db } from '@/lib/db' // 데이터베이스 클라이언트 불러오기\n\nexport default function UserList() {\n  async function fetchUsers() {\n    const users = await db.user.findMany()\n    return users\n  }\n\n  return \u003cbutton onClick={() =\u003e fetchUsers()}\u003eFetch Users\u003c/button\u003e\n}\n```\n\n이 예제에서는 `fetchUsers` 함수가 서버에서 실행되어야 하는데, 실제로 현재 함수 위에 `use server` 지시어가 빠져 있어요. 이걸 명시하면 Next.js 같은 프레임워크가 이 함수가 서버 전용임을 확실히 알 수 있답니다.\n\n### 서버 함수에 `use server`를 추가할 때는 이렇게!\n\n```js\nimport { db } from '@/lib/db' // 데이터베이스 클라이언트 불러오기\n\nexport default function UserList() {\n  \"use server\"\n  \n  async function fetchUsers() {\n    const users = await db.user.findMany()\n    return users\n  }\n\n  return \u003cbutton onClick={() =\u003e fetchUsers()}\u003eFetch Users\u003c/button\u003e\n}\n```\n\n혹은 함수 바로 앞에 붙이는 경우도 있어요.\n\n```js\nimport { db } from '@/lib/db' // 데이터베이스 클라이언트 불러오기\n\nexport default function UserList() {\n  const fetchUsers = async () =\u003e {\n    \"use server\"\n    const users = await db.user.findMany()\n    return users\n  }\n\n  return \u003cbutton onClick={() =\u003e fetchUsers()}\u003eFetch Users\u003c/button\u003e\n}\n```\n\n서버 함수는 클라이언트에 번들되지 않고, 서버에서만 실행되도록 보장해줘서 보안 측면에서 매우 중요해요.\n\n---\n\n## 보안 고려사항 (Security considerations)\n\n`use server` 지시어를 사용해 서버 함수를 작성할 때는 보안을 꼭 염두에 두어야 해요. 서버에서 실행되는 만큼, 다음 사항들을 기억하세요:\n\n| 체크포인트                    | 설명                                                                    |\n|-----------------------------|------------------------------------------------------------------------|\n| 민감한 데이터 보호하기          | 데이터베이스 연결 정보, API 키, 사용자 비밀정보 등은 절대 클라이언트에 노출되면 안 됩니다. 서버 함수 내부에서만 접근하도록 하세요. |\n| 데이터 검증 및 인가 처리       | 클라이언트 요청 시 입력값을 반드시 검증하고, 인증과 권한 체크를 통해 불법 접근을 막으세요.          |\n| 에러 처리 및 로그 관리          | 서버 함수에서 발생하는 예외 처리를 신경쓰고, 보안 관련 로그는 적절히 기록해 두세요.            |\n| XSS 및 Injection 공격 방지    | 쿼리를 생성할 때 SQL 주입 또는 스크립트 주입 공격을 방지하도록 준비된 쿼리 사용과 데이터 정제 수행. |\n\n서버 함수는 서버 전용 코드임을 명확하게 표시하고, 클라이언트에서는 최소한의 정보만 주고받도록 하는 게 핵심입니다. 이런 방법들을 지키면 더욱 안전한 웹 애플리케이션 개발에 한 걸음 더 다가갈 수 있어요.\n\n---\n\n더 자세한 내용이 궁금하면, 사용하는 프레임워크 문서에서 `Server Functions` 또는 `Server Components` 부분을 참고해 보세요. `use server` 지시어를 어떻게 활용하는지, 그리고 클라이언트와 서버 간 데이터 흐름을 어떻게 구성하는지 실무에 큰 도움이 될 거예요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 인증(Authentication)과 인가(Authorization)\n\n서버 쪽에서 중요한 작업을 수행할 때는 항상 사용자가 누구인지 인증(Authentication)하고, 그 작업을 할 권한이 있는지를 확인하는 인가(Authorization)를 먼저 하셔야 해요.\n\n아래 예제 코드를 살짝 바꿔가며 설명해볼게요.\n\n```js\nimport { db } from '@/lib/db' // 데이터베이스 클라이언트\nimport { authenticate } from '@/lib/auth' // 인증 라이브러리\n\nexport async function createUser(data, request) {\n  const user = await authenticate(request) // 요청에서 사용자 인증\n  \n  if (!user) {\n    throw new Error('Unauthorized') // 인증 실패 시 에러 처리\n  }\n  \n  // 인증된 사용자만 새 사용자 생성 가능\n  const newUser = await db.user.create({ data })\n  return newUser\n}\n```\n\n위 코드에서 중요한 포인트는 `authenticate` 함수를 통해 사용자의 신원을 확인하는 과정을 거친다는 점이에요. 인증이 안 된 상태로 `createUser` 같은 주요 작업을 진행한다면 보안 이슈가 생길 수 있으니 꼭 확인해야 합니다.\n\n### 인증과 인가, 이 둘의 차이\n\n- **인증(Authentication)**: \"너 누구야?\" 라며 사용자 신원을 확인하는 과정  \n- **인가(Authorization)**: \"너 이 작업 해도 돼?\" 라며 권한을 확인하는 과정\n\n예를 들어, 로그인된 사용자가 있더라도 그 사람이 게시글 삭제 권한이 없다면 삭제할 수 없게 막는 게 바로 인가 절차가 됩니다.\n\n### 덧붙여서\n\nAPI 설계 시 보통 토큰(JWT 등)을 활용한 인증 방식을 많이 사용해요. 그리고 권한 관리는 역할(Role) 기반으로 하거나 특정 권한을 부여하는 식으로 구현하는 게 실무에서 흔하죠.\n\n또한, 프론트엔드에서도 인증 상태를 관리하고, 서버에는 절대 신뢰할 수 없는 상태로 요청하지 않는 게 중요합니다! 서버가 항상 “내가 진짜 인증한 사용자와 이야기 중인지”를 검증해야 한다는 점, 꼭 기억하세요.\n\n---\n\n## 참고 문서\n\n- [OAuth 2.0 공식 문서](https://oauth.net/2/)\n- [JWT 소개와 활용법](https://jwt.io/introduction)\n- [Node.js Authentication Best Practices](https://blog.nodejs.org/2021/10/05/node-js-authentication-best-practices/)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nReact 공식 문서에서 'use server'에 대한 자세한 내용을 확인할 수 있어요.  \n\n'Use server'는 React 18부터 도입된 기능 중 하나로, 서버 컴포넌트를 사용할 때 주로 활용됩니다. 서버 컴포넌트를 통해 렌더링이 서버에서 이루어지기 때문에 클라이언트 사이드보다 초기 로딩 속도가 빠르고, SEO에도 좋다는 장점이 있어요.  \n\nReact 공식 문서에서는 'use server'가 어떻게 동작하는지, 그리고 서버 컴포넌트를 어떻게 잘 활용할 수 있는지 구체적으로 설명하고 있으니 직접 확인해보시면 많은 도움이 될 거예요.  \n\n또한, 서버 컴포넌트는 데이터 요청(fetch) 같은 작업을 서버에서 직접 처리할 수 있어서 클라이언트의 부담을 줄여주는데, React의 'use server' 기능과 잘 결합하면 더욱 효과적이죠.  \n\n궁금하다면 아래 React 공식 문서 링크에서 자세한 내용 읽어보세요!  \nhttps://reactjs.org/docs/getting-started.html (React 공식 문서 메인 페이지입니다. 'Server Components'나 'use server'를 검색해보시면 도움됩니다.)  \n\n필요하다면 관련 예제나 사용법도 같이 소개해드릴게요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":11},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003euse server\u003c/h1\u003e\n\u003cp\u003e'use server' 지시어는 특정 함수나 파일이 서버 측에서 실행되어야 함을 명시하는 역할을 해요. 파일 맨 위에 쓰면 그 파일 안의 모든 함수가 서버에서 실행된다는 뜻이고, 함수 바로 위에 inline으로 쓰면 그 함수만 서버 함수(Server Function)로 지정할 수 있답니다. 이건 React에서 제공하는 기능이에요.\u003c/p\u003e\n\u003ch2\u003e파일 맨 위에 use server 쓰기\u003c/h2\u003e\n\u003cp\u003e아래 예시는 파일 최상단에 \u003ccode\u003euse server\u003c/code\u003e 지시어를 넣은 경우에요. 이렇게 하면 그 안에 있는 모든 함수는 서버에서 실행됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e'use server'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetServerData\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 서버에서만 실행되는 로직\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e data = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'https://api.example.com/data'\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e data.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e();\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehelperFunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 이 함수도 서버에서 실행돼요\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e추가 설명!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003euse server\u003c/code\u003e를 쓰는 이유는 클라이언트에서 실행하면 안 되는 무거운 연산, 비밀 정보 처리, 데이터베이스 쿼리 등을 서버 쪽으로 감추기 위함이에요.\u003c/li\u003e\n\u003cli\u003eReact 컴포넌트 내에서 서버 함수 호출 시 클라이언트 코드와 서버 코드를 깔끔하게 분리할 수 있어서 보안과 성능 면에서 유리합니다.\u003c/li\u003e\n\u003cli\u003e만약 한 파일에 서버 함수와 클라이언트 함수가 혼재되어 있으면, 필요한 함수에만 inline으로 \u003ccode\u003euse server\u003c/code\u003e를 붙여서 관리하는 걸 추천해요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e서버 함수 잘 활용하면 앱 구조를 더 명확하게 하고, 유지보수도 쉬워지니 꼭 익혀두시면 좋아요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// actions.ts\u003c/span\u003e\n\u003cspan class=\"hljs-string\"\u003e\"use server\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { db } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@/lib/db'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetchUsers\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e users = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e db.\u003cspan class=\"hljs-property\"\u003euser\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efindMany\u003c/span\u003e()\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e users\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 Server Functions는 \u003ccode\u003e\"use server\"\u003c/code\u003e 지시어를 파일 상단에 작성해줘야 해요. 그리고 만들고 나면 클라이언트 컴포넌트나 서버 컴포넌트 어디에서든 가져다 쓸 수 있게 됩니다.\u003c/p\u003e\n\u003cp\u003e예를 들어 클라이언트 컴포넌트에서 fetchUsers 함수를 사용하고 싶으면 이렇게 하면 돼요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-tsx\"\u003e\u003cspan class=\"hljs-string\"\u003e\"use client\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { fetchUsers } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./actions'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eUserList\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eloadUsers\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e users = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetchUsers\u003c/span\u003e()\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(users)\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{()\u003c/span\u003e =\u003e\u003c/span\u003e loadUsers()}\u003eLoad Users\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 포인트는 바로 클라이언트 컴포넌트에선 서버 함수가 비동기(Async) 함수라는 점이에요. 이걸 직접 호출하려면 이렇게 버튼 클릭 같은 이벤트 핸들러 안에서 호출하고 결과를 받아서 화면에 보여 주거나 로그를 찍는 식으로 사용합니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003eServer Functions와 Database 연동 정리\u003c/h3\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e설명\u003c/th\u003e\u003cth\u003e내용\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eServer Function 생성법\u003c/td\u003e\u003ctd\u003e\u003ccode\u003euse server\u003c/code\u003e 지시어를 파일 상단에 넣고 비동기 함수 작성\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eServer 함수 위치\u003c/td\u003e\u003ctd\u003e별도 파일(actions.ts 등)에 작성해 여러 컴포넌트에서 import 가능\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eClient 컴포넌트에서 사용법\u003c/td\u003e\u003ctd\u003easync 함수 안에서 호출, 이벤트 핸들러에서 호출하는 식으로 비동기 처리\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e데이터베이스 연동\u003c/td\u003e\u003ctd\u003e서버 함수 내에서 직접 \u003ccode\u003edb\u003c/code\u003e 클라이언트를 사용해 데이터 조회/수정 가능\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003ch3\u003e참고 사항\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e아직 Next.js나 React에서 완전히 SSR과 Client 컴포넌트 경계가 명확하여 이 방식을 적용할 때 내가 직접 어떤 작업이 서버에서 일어나고 있는지 분명히 이해하고 사용해야 해요.\u003c/li\u003e\n\u003cli\u003e클라이언트에서 서버 함수를 호출할 때는 내부적으로 서버로 요청이 나가게 된다 생각하면 편해요. 그래서 고통 없는 데이터를 직접 다루는 것보다 네트워크 요청 비용이 있으니 꼭 필요한 경우에만 사용하세요.\u003c/li\u003e\n\u003cli\u003e또, 인증 처리 같은 민감한 로직은 항상 서버 함수에서 관리하는 게 안전합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 정도 핵심만 잘 이해해 두면 Server Functions를 효과적으로 쓸 수 있어요! 도움이 되었길 바랄게요 :)\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이번 시간에는 Next.js의 Server Functions를 사용해서 데이터베이스에서 유저 데이터를 가져오는 예제를 살펴볼게요. 그리고 Fetch Users 함수를 클라이언트 컴포넌트에서 어떻게 호출할 수 있는지도 함께 알아봅니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e1. Server Function 작성하기\u003c/h3\u003e\n\u003cp\u003e아래 코드는 \u003ccode\u003efetchUsers\u003c/code\u003e라는 Server Function입니다. 데이터베이스에서 모든 유저를 가져와서 반환해주죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { db } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@/lib/db'\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// 데이터베이스 클라이언트 임포트\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetchUsers\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e users = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e db.\u003cspan class=\"hljs-property\"\u003euser\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efindMany\u003c/span\u003e()\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e users\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 \u003ccode\u003edb.user.findMany()\u003c/code\u003e는 Prisma 같은 ORM을 사용한다고 가정하고, 유저들을 모두 조회하는 코드입니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e2. 클라이언트 컴포넌트에서 Server Function 호출하기\u003c/h3\u003e\n\u003cp\u003e이제 위에서 만든 \u003ccode\u003efetchUsers\u003c/code\u003e 함수를 클라이언트 컴포넌트에서 호출해 보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eMyButton\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{()\u003c/span\u003e =\u003e\u003c/span\u003e fetchUsers()}\u003eFetch Users\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e버튼 클릭 시 \u003ccode\u003efetchUsers\u003c/code\u003e가 실행됩니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e참고\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e일반적으로 Server Function은 서버에서 실행하기 때문에, 클라이언트에서 직접 호출하려면 Next.js가 지원하는 방식으로 호출해야 합니다.\u003c/li\u003e\n\u003cli\u003e만약 바로 클라이언트에서 \u003ccode\u003efetchUsers\u003c/code\u003e를 호출하면, 서버 측 환경 변수가 없거나 보안 이슈가 생길 수 있으니 주의하세요.\u003c/li\u003e\n\u003cli\u003eNext.js 13 최신 기능 중 하나인 \u003cstrong\u003eInline use server\u003c/strong\u003e 문법을 활용하면, 클라이언트 컴포넌트 안에서 서버 함수를 좀 더 쉽게 호출할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003eUsing \u003ccode\u003euse server\u003c/code\u003e inline\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003euse server\u003c/code\u003e는 Server Action 혹은 Server Function을 클라이언트 컴포넌트 내에서 바로 선언하고 사용할 수 있는 문법입니다. 예를 들어,\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e'use client'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useState } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eMyButton\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetchUsers\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-string\"\u003e'use server'\u003c/span\u003e  \u003cspan class=\"hljs-comment\"\u003e// 여기서 서버 함수 선언\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e users = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e db.\u003cspan class=\"hljs-property\"\u003euser\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efindMany\u003c/span\u003e()\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e users\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{()\u003c/span\u003e =\u003e\u003c/span\u003e fetchUsers()}\u003eFetch Users\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이런 식으로 하면, \u003ccode\u003efetchUsers\u003c/code\u003e 함수가 서버에서 실행되고 클라이언트에서 호출할 수 있습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e정리\u003c/h2\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e개념\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eServer Function\u003c/td\u003e\u003ctd\u003e서버에서만 실행되는 함수. 서버 자원에 직접 접근 가능\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e클라이언트에서 호출\u003c/td\u003e\u003ctd\u003e클라이언트에서 호출 시 서버와 통신하거나, Next.js 방식 활용 필요\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003euse server\u003c/code\u003e inline\u003c/td\u003e\u003ctd\u003e클라이언트 컴포넌트 내에서 서버 함수를 선언하고 실행 가능\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003cp\u003e이제 여러분도 Next.js에서 Server Functions를 어떻게 만들고 클라이언트에서 호출하는지 감이 좀 오시죠? 요즘 프레임워크가 점점 더 편리해지고 있어서, 서버와 클라이언트 코드 구분이 한결 수월해지고 있어요. 필요할 때 서버 함수를 잘 활용하면 더 깔끔하고 안전한 앱을 만들 수 있답니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e서버 함수(Server Function)를 표시할 때 \u003ccode\u003euse server\u003c/code\u003e를 함수 맨 위에 인라인으로 작성하는 방법에 대해 이야기해볼게요. 아래 예제를 보면, 데이터베이스에서 사용자 목록을 가져오는 함수가 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { db } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@/lib/db'\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// 데이터베이스 클라이언트 불러오기\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eUserList\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetchUsers\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e users = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e db.\u003cspan class=\"hljs-property\"\u003euser\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efindMany\u003c/span\u003e()\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e users\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{()\u003c/span\u003e =\u003e\u003c/span\u003e fetchUsers()}\u003eFetch Users\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예제에서는 \u003ccode\u003efetchUsers\u003c/code\u003e 함수가 서버에서 실행되어야 하는데, 실제로 현재 함수 위에 \u003ccode\u003euse server\u003c/code\u003e 지시어가 빠져 있어요. 이걸 명시하면 Next.js 같은 프레임워크가 이 함수가 서버 전용임을 확실히 알 수 있답니다.\u003c/p\u003e\n\u003ch3\u003e서버 함수에 \u003ccode\u003euse server\u003c/code\u003e를 추가할 때는 이렇게!\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { db } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@/lib/db'\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// 데이터베이스 클라이언트 불러오기\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eUserList\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-string\"\u003e\"use server\"\u003c/span\u003e\n  \n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetchUsers\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e users = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e db.\u003cspan class=\"hljs-property\"\u003euser\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efindMany\u003c/span\u003e()\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e users\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{()\u003c/span\u003e =\u003e\u003c/span\u003e fetchUsers()}\u003eFetch Users\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e혹은 함수 바로 앞에 붙이는 경우도 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { db } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@/lib/db'\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// 데이터베이스 클라이언트 불러오기\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eUserList\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetchUsers\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-string\"\u003e\"use server\"\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e users = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e db.\u003cspan class=\"hljs-property\"\u003euser\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efindMany\u003c/span\u003e()\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e users\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{()\u003c/span\u003e =\u003e\u003c/span\u003e fetchUsers()}\u003eFetch Users\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e서버 함수는 클라이언트에 번들되지 않고, 서버에서만 실행되도록 보장해줘서 보안 측면에서 매우 중요해요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e보안 고려사항 (Security considerations)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003euse server\u003c/code\u003e 지시어를 사용해 서버 함수를 작성할 때는 보안을 꼭 염두에 두어야 해요. 서버에서 실행되는 만큼, 다음 사항들을 기억하세요:\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e체크포인트\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e민감한 데이터 보호하기\u003c/td\u003e\u003ctd\u003e데이터베이스 연결 정보, API 키, 사용자 비밀정보 등은 절대 클라이언트에 노출되면 안 됩니다. 서버 함수 내부에서만 접근하도록 하세요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e데이터 검증 및 인가 처리\u003c/td\u003e\u003ctd\u003e클라이언트 요청 시 입력값을 반드시 검증하고, 인증과 권한 체크를 통해 불법 접근을 막으세요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e에러 처리 및 로그 관리\u003c/td\u003e\u003ctd\u003e서버 함수에서 발생하는 예외 처리를 신경쓰고, 보안 관련 로그는 적절히 기록해 두세요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eXSS 및 Injection 공격 방지\u003c/td\u003e\u003ctd\u003e쿼리를 생성할 때 SQL 주입 또는 스크립트 주입 공격을 방지하도록 준비된 쿼리 사용과 데이터 정제 수행.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e서버 함수는 서버 전용 코드임을 명확하게 표시하고, 클라이언트에서는 최소한의 정보만 주고받도록 하는 게 핵심입니다. 이런 방법들을 지키면 더욱 안전한 웹 애플리케이션 개발에 한 걸음 더 다가갈 수 있어요.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e더 자세한 내용이 궁금하면, 사용하는 프레임워크 문서에서 \u003ccode\u003eServer Functions\u003c/code\u003e 또는 \u003ccode\u003eServer Components\u003c/code\u003e 부분을 참고해 보세요. \u003ccode\u003euse server\u003c/code\u003e 지시어를 어떻게 활용하는지, 그리고 클라이언트와 서버 간 데이터 흐름을 어떻게 구성하는지 실무에 큰 도움이 될 거예요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003e인증(Authentication)과 인가(Authorization)\u003c/h3\u003e\n\u003cp\u003e서버 쪽에서 중요한 작업을 수행할 때는 항상 사용자가 누구인지 인증(Authentication)하고, 그 작업을 할 권한이 있는지를 확인하는 인가(Authorization)를 먼저 하셔야 해요.\u003c/p\u003e\n\u003cp\u003e아래 예제 코드를 살짝 바꿔가며 설명해볼게요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { db } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@/lib/db'\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// 데이터베이스 클라이언트\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { authenticate } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@/lib/auth'\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// 인증 라이브러리\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreateUser\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edata, request\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e user = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eauthenticate\u003c/span\u003e(request) \u003cspan class=\"hljs-comment\"\u003e// 요청에서 사용자 인증\u003c/span\u003e\n  \n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!user) {\n    \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Unauthorized'\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e// 인증 실패 시 에러 처리\u003c/span\u003e\n  }\n  \n  \u003cspan class=\"hljs-comment\"\u003e// 인증된 사용자만 새 사용자 생성 가능\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newUser = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e db.\u003cspan class=\"hljs-property\"\u003euser\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e({ data })\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e newUser\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드에서 중요한 포인트는 \u003ccode\u003eauthenticate\u003c/code\u003e 함수를 통해 사용자의 신원을 확인하는 과정을 거친다는 점이에요. 인증이 안 된 상태로 \u003ccode\u003ecreateUser\u003c/code\u003e 같은 주요 작업을 진행한다면 보안 이슈가 생길 수 있으니 꼭 확인해야 합니다.\u003c/p\u003e\n\u003ch3\u003e인증과 인가, 이 둘의 차이\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e인증(Authentication)\u003c/strong\u003e: \"너 누구야?\" 라며 사용자 신원을 확인하는 과정\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e인가(Authorization)\u003c/strong\u003e: \"너 이 작업 해도 돼?\" 라며 권한을 확인하는 과정\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예를 들어, 로그인된 사용자가 있더라도 그 사람이 게시글 삭제 권한이 없다면 삭제할 수 없게 막는 게 바로 인가 절차가 됩니다.\u003c/p\u003e\n\u003ch3\u003e덧붙여서\u003c/h3\u003e\n\u003cp\u003eAPI 설계 시 보통 토큰(JWT 등)을 활용한 인증 방식을 많이 사용해요. 그리고 권한 관리는 역할(Role) 기반으로 하거나 특정 권한을 부여하는 식으로 구현하는 게 실무에서 흔하죠.\u003c/p\u003e\n\u003cp\u003e또한, 프론트엔드에서도 인증 상태를 관리하고, 서버에는 절대 신뢰할 수 없는 상태로 요청하지 않는 게 중요합니다! 서버가 항상 “내가 진짜 인증한 사용자와 이야기 중인지”를 검증해야 한다는 점, 꼭 기억하세요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e참고 문서\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://oauth.net/2/\" rel=\"nofollow\" target=\"_blank\"\u003eOAuth 2.0 공식 문서\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://jwt.io/introduction\" rel=\"nofollow\" target=\"_blank\"\u003eJWT 소개와 활용법\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://blog.nodejs.org/2021/10/05/node-js-authentication-best-practices/\" rel=\"nofollow\" target=\"_blank\"\u003eNode.js Authentication Best Practices\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eReact 공식 문서에서 'use server'에 대한 자세한 내용을 확인할 수 있어요.\u003c/p\u003e\n\u003cp\u003e'Use server'는 React 18부터 도입된 기능 중 하나로, 서버 컴포넌트를 사용할 때 주로 활용됩니다. 서버 컴포넌트를 통해 렌더링이 서버에서 이루어지기 때문에 클라이언트 사이드보다 초기 로딩 속도가 빠르고, SEO에도 좋다는 장점이 있어요.\u003c/p\u003e\n\u003cp\u003eReact 공식 문서에서는 'use server'가 어떻게 동작하는지, 그리고 서버 컴포넌트를 어떻게 잘 활용할 수 있는지 구체적으로 설명하고 있으니 직접 확인해보시면 많은 도움이 될 거예요.\u003c/p\u003e\n\u003cp\u003e또한, 서버 컴포넌트는 데이터 요청(fetch) 같은 작업을 서버에서 직접 처리할 수 있어서 클라이언트의 부담을 줄여주는데, React의 'use server' 기능과 잘 결합하면 더욱 효과적이죠.\u003c/p\u003e\n\u003cp\u003e궁금하다면 아래 React 공식 문서 링크에서 자세한 내용 읽어보세요!\u003cbr\u003e\n\u003ca href=\"https://reactjs.org/docs/getting-started.html\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://reactjs.org/docs/getting-started.html\u003c/a\u003e (React 공식 문서 메인 페이지입니다. 'Server Components'나 'use server'를 검색해보시면 도움됩니다.)\u003c/p\u003e\n\u003cp\u003e필요하다면 관련 예제나 사용법도 같이 소개해드릴게요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2025-04-22-useserver"},"buildId":"M7pU9hOcx8u_ZIFMf95sd","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>