<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Next.js 15 라우트 세그먼트 설정 방법과 활용팁 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-RouteSegmentConfig" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Next.js 15 라우트 세그먼트 설정 방법과 활용팁 | TIL" data-gatsby-head="true"/><meta property="og:title" content="Next.js 15 라우트 세그먼트 설정 방법과 활용팁 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-RouteSegmentConfig" data-gatsby-head="true"/><meta name="twitter:title" content="Next.js 15 라우트 세그먼트 설정 방법과 활용팁 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2025-04-22 02:45" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/0eef537492fed77a.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/0eef537492fed77a.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-8ded8b979ba73586.js" defer=""></script><script src="/TIL/_next/static/KUC9M_yIlA1Ugo01xmkHL/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/KUC9M_yIlA1Ugo01xmkHL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Next.js 15 라우트 세그먼트 설정 방법과 활용팁</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Next.js 15 라우트 세그먼트 설정 방법과 활용팁" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Apr 22, 2025</span><span class="posts_reading_time__f7YPP">18<!-- --> min read</span></span></div></div></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>Route Segment Config</h1>
<blockquote>
<p>이 페이지에 소개된 옵션들은 <code>dynamicIO</code> 플래그가 켜져 있으면 비활성화되고, 앞으로는 없어질 예정이에요.</p>
</blockquote>
<p>Route Segment 옵션은 Page, Layout, 또는 Route Handler의 동작 방식을 직접 제어하고 싶을 때 유용해요. 이 옵션들은 아래 변수들을 export 해서 설정할 수 있습니다.</p>


















































<table><thead><tr><th>옵션</th><th>타입</th><th>기본값</th></tr></thead><tbody><tr><td><a href="#experimental_ppr">experimental_ppr</a></td><td><code>boolean</code></td><td></td></tr><tr><td><a href="#dynamic">dynamic</a></td><td><code>'auto'</code> | <code>'force-dynamic'</code> | <code>'error'</code> | <code>'force-static'</code></td><td><code>'auto'</code></td></tr><tr><td><a href="#dynamicparams">dynamicParams</a></td><td><code>boolean</code></td><td><code>true</code></td></tr><tr><td><a href="#revalidate">revalidate</a></td><td><code>false</code> | <code>0</code> | <code>number</code></td><td><code>false</code></td></tr><tr><td><a href="#fetchcache">fetchCache</a></td><td><code>'auto'</code> | <code>'default-cache'</code> | <code>'only-cache'</code> | <code>'force-cache'</code> | <code>'force-no-store'</code> | <code>'default-no-store'</code> | <code>'only-no-store'</code></td><td><code>'auto'</code></td></tr><tr><td><a href="#runtime">runtime</a></td><td><code>'nodejs'</code> | <code>'edge'</code></td><td><code>'nodejs'</code></td></tr><tr><td><a href="#preferredregion">preferredRegion</a></td><td><code>'auto'</code> | <code>'global'</code> | <code>'home'</code> | <code>string</code> | <code>string[]</code></td><td><code>'auto'</code></td></tr><tr><td><a href="#maxduration">maxDuration</a></td><td><code>number</code></td><td>배포 플랫폼에 따라 설정</td></tr></tbody></table>
<hr>
<h3>한눈에 보기</h3>
<ul>
<li><strong>experimental_ppr</strong>: 실험적인 부분들에 대한 설정인데, 자세한 내용은 공식 문서를 참고해야 해요.</li>
<li><strong>dynamic</strong>: 페이지를 동적으로 처리할지, 정적으로 처리할지 결정할 수 있어요. 기본값은 <code>'auto'</code>라 알아서 최적의 방식을 선택합니다.</li>
<li><strong>dynamicParams</strong>: 동적 경로 파라미터 사용 여부를 설정해요. 기본적으로 <code>true</code>라 동적 파라미터를 허용합니다.</li>
<li><strong>revalidate</strong>: ISR(Incremental Static Regeneration)을 사용할 때 재빌드 주기를 설정합니다. <code>false</code>는 재빌드를 하지 않는다는 의미고, 숫자를 지정하면 해당 초마다 재빌드 돼요.</li>
<li><strong>fetchCache</strong>: 서버 측 데이터 fetching 시 어떤 캐싱 전략을 사용할지 정하는 옵션입니다.</li>
<li><strong>runtime</strong>: <code>nodejs</code> 또는 <code>edge</code> 중 실행 환경을 선택할 수 있어요. 기본은 <code>nodejs</code>.</li>
<li><strong>preferredRegion</strong>: 배포 리전을 지정할 수 있는 옵션입니다. 글로벌 서비스를 위한 <code>'global'</code>이나 특정 리전 이름, 혹은 배열로 여러 리전을 설정할 수 있죠.</li>
<li><strong>maxDuration</strong>: 함수 실행 최장 시간을 의미하는데, 보통 배포 환경에 따라 제한됩니다.</li>
</ul>
<hr>
<h3>그리고 살짝 덧붙이자면...</h3>
<p>이런 Route Segment 설정을 통해서 Next.js 같은 프레임워크에서 페이지나 API 경로의 동작 방식을 세밀하게 조정할 수 있어요. 예를 들어, <code>dynamic: 'force-dynamic'</code>으로 지정하면 요청마다 항상 새롭게 렌더링해서 가장 최신 데이터를 보여주고, <code>revalidate</code> 시간을 설정해두면 효율적인 캐싱을 하면서도 일정 주기로 콘텐츠가 갱신되게 할 수 있죠.</p>
<p>또한, <code>runtime</code>을 <code>edge</code>로 설정하면 전 세계 엣지 서버에서 빠르게 처리가 가능해서 속도 향상과 지연 감소에 도움 될 수 있습니다. 다만 엣지 런타임 환경 제약 조건이 있으니, 사용 시 주의하세요.</p>
<p>이렇게 구성해두면 사용자 경험을 더 좋게 만들어주고, 서버 리소스를 효과적으로 사용할 수 있다는 장점이 있습니다. 다음에는 각 옵션별 좀 더 구체적인 활용법도 소개해볼게요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>옵션</h2>
<h3>experimental_ppr</h3>
<p>Partial Prerendering, 줄여서 PPR을 레이아웃이나 페이지에 적용할 수 있는 옵션이에요. 이걸 활성화하면 페이지나 특정 레이아웃이 부분적으로 미리 렌더링 되어서, 사용자가 페이지를 더 빨리 볼 수 있도록 도와줘요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> experimental_ppr = <span class="hljs-literal">true</span>
<span class="hljs-comment">// true | false</span>
</code></pre>
<p>참고로, 이 옵션은 아직 실험적인 기능이라 가끔 예상치 못한 동작이 있을 수도 있어요. 그래서 프로젝트에 바로 적용하기보다는 테스트 환경에서 먼저 써보고, 잘 맞는지 확인하는 걸 추천드려요!</p>
<p>추가로 Partial Prerendering은 페이지의 일부만 미리 만들어두고 나머지는 필요할 때 로드하는 방식이기 때문에, 데이터가 자주 변하는 부분이나 사용자 맞춤형 콘텐츠에서 유용할 수 있어요. 만약에 페이지가 크고 렌더링 시간이 길다면, PPR을 활용해서 초기 로딩 속도를 확실히 개선할 수 있답니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>dynamic</h3>
<p>레이아웃이나 페이지의 동작 방식을 완전 정적(static) 또는 완전 동적(dynamic)으로 바꿀 수 있는 옵션이에요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> dynamic = <span class="hljs-string">'auto'</span>
<span class="hljs-comment">// 사용할 수 있는 값: 'auto' | 'force-dynamic' | 'error' | 'force-static'</span>
</code></pre>
<p>여기서 각 값의 의미는 다음과 같아요:</p>
<ul>
<li><code>'auto'</code>: 기본값이에요. 상황에 따라 동적 또는 정적으로 처리해요.</li>
<li><code>'force-dynamic'</code>: 무조건 동적으로 렌더링해요.</li>
<li><code>'force-static'</code>: 무조건 정적으로 렌더링해요.</li>
<li><code>'error'</code>: 동적 동작이 필요할 때 에러를 발생시켜요.</li>
</ul>
<blockquote>
<p>참고로 알면 좋은 점: Next.js의 최신 app 디렉토리 구조에서는 페이지 단위에서 모두 다 동적이거나 모두 다 정적인 getServerSideProps, getStaticProps 대신, fetch 요청 단위에서 좀 더 세밀하게 캐싱을 조절하는 방식을 선호해요. 즉, 이전의 방식보다 더 유연해졌죠. 그런데 기존의 페이지 단위 동작 모델로 쉽게 돌아가고 싶은 경우, 이 <code>dynamic</code> 옵션을 활용하면 간편하게 이전 모델을 유지할 수 있어서 마이그레이션할 때도 편리해요.</p>
</blockquote>
<hr>
<p>추가로 덧붙이자면, 실제로는 fetch 함수에서 <code>cache</code> 옵션을 주는 쪽이 더 권장됩니다. 예를 들어:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'/api/data'</span>, { <span class="hljs-attr">cache</span>: <span class="hljs-string">'no-store'</span> }) <span class="hljs-comment">// 항상 최신 데이터를 받아오도록 강제</span>
</code></pre>
<p>이런 식으로 개별 fetch 요청마다 캐싱 동작을 세부 조절할 수 있어요. <code>dynamic</code> 옵션은 주로 전체 페이지 단위의 기본 동작을 결정할 때 사용한다고 생각하면 됩니다.</p>
<p>즉, Next.js의 최신 앱 구조는 “모든 것을 다 세부적으로 제어하는 시대”라고 이해하면 좋겠네요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><code>dynamic</code> 옵션에는 총 네 가지가 있어요. 각 옵션이 어떤 차이를 만드는지 쉽게 정리해볼게요!</p>






























<table><thead><tr><th>옵션</th><th>설명</th><th>추가 팁</th></tr></thead><tbody><tr><td><code>auto</code> (기본값)</td><td>가능한 한 많이 캐시하지만, 동적으로 동작하고 싶은 컴포넌트는 이를 선택할 수 있도록 허용합니다.</td><td>기본값 그대로 쓰면 딱히 설정하지 않아도 자동으로 적절히 작동해요.</td></tr><tr><td><code>force-dynamic</code></td><td>무조건 동적 렌더링을 합니다. 즉, 각 요청마다 매번 페이지가 새로 렌더링됨.</td><td>내부적으로 모든 fetch() 요청은 <code>'cache: no-store', next: { revalidate: 0 }</code> 설정이 되고, <code>fetchCache = force-no-store</code> 로 강제되죠.</td></tr><tr><td><code>error</code></td><td>정적 렌더링만 강제하고, 만약 Dynamic API나 캐시되지 않는 데이터를 쓰면 에러 발생!</td><td>pages 디렉토리의 <code>getStaticProps()</code>와 비슷해요. fetch()는 <code>'cache: force-cache'</code>를 사용하고, <code>fetchCache = only-cache</code>, <code>dynamicParams = false</code>로 설정됩니다. 동적 파라미터가 필요하면 수동으로 <code>dynamicParams = true</code>로 바꿔야 해요.</td></tr><tr><td><code>force-static</code></td><td>정적 렌더링 강제 + cookies, headers(), useSearchParams() 호출 시 빈값만 반환하게 만듭니다.</td><td>정말 정적으로만 작동해야 하는 상황에 쓸 수 있어요.</td></tr></tbody></table>
<hr>
<h3>참고!</h3>
<p><code>getServerSideProps</code>, <code>getStaticProps</code>에서 <code>dynamic: 'force-dynamic'</code>이나 <code>dynamic: 'error'</code>로 마이그레이션하는 방법은 <a href="https://nextjs.org/docs/pages/building-your-application/data-fetching/upgrading" rel="nofollow" target="_blank">업그레이드 가이드</a>에서 자세히 설명하고 있으니 참고하세요.</p>
<hr>
<h3>dynamicParams란?</h3>
<p>이건 <code>generateStaticParams</code>로 미리 생성하지 않은 동적 경로(<code>/posts/[id]</code> 같은)가 방문됐을 때 어떻게 처리할지 결정할 수 있는 옵션이에요. 예를 들면 동적 경로가 너무 많을 때 미리 다 생성할 수 없으니, 방문 시점에 동적으로 처리할지, 아니면 에러를 표시할지 선택할 수 있습니다.</p>
<hr>
<p>이렇게 보면 <code>dynamic</code> 옵션을 상황과 필요에 맞게 조절하는 게 핵심이라는 걸 알 수 있죠. 예를 들어, 자주 바뀌는 데이터를 보여주는 페이지라면 <code>force-dynamic</code>이 유리하고, 가능하면 빌드 타임에 다 끝내고 싶으면 <code>error</code> 혹은 <code>force-static</code>을 쓰는 식이에요.</p>
<p>실제로 프로젝트에 적용할 때는 데이터 특성과 사용자 경험을 잘 고려해서 가장 적합한 설정을 찾아 보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> dynamicParams = <span class="hljs-literal">true</span> <span class="hljs-comment">// true | false,</span>
</code></pre>
<ul>
<li>true (기본값): <code>generateStaticParams</code>에 포함되지 않은 동적 세그먼트는 요청 시점에 생성돼요.</li>
<li>false: <code>generateStaticParams</code>에 없는 동적 세그먼트에 접근하면 404 페이지가 반환됩니다.</li>
</ul>
<blockquote>
<p>알아두면 좋은 점:<br>
이 옵션은 pages 디렉터리에서 사용하던 <code>getStaticPaths</code>의 <code>fallback: true | false | blocking</code> 옵션을 대체해요.<br>
만약 모든 경로를 처음부터 정적으로 렌더링하고 싶다면, <code>generateStaticParams</code>에서 빈 배열을 반환하거나 <code>export const dynamic = 'force-static'</code>을 사용해야 합니다.<br>
<code>dynamicParams = true</code>인 경우, 해당 세그먼트는 스트리밍 서버 렌더링(Streaming Server Rendering)을 사용해요.<br>
그리고 <code>dynamic = 'error'</code>나 <code>dynamic = 'force-static'</code>을 쓰면 <code>dynamicParams</code>의 기본값이 false로 바뀝니다.</p>
</blockquote>
<hr>
<h3>revalidate</h3>
<p><em>여기서 부터는 <code>revalidate</code> 옵션에 대해 살펴볼게요.</em></p>
<p>Next.js의 <code>revalidate</code> 옵션은 ISR(Incremental Static Regeneration) 기능을 제어하는 데 사용돼요.<br>
간단히 말해서, 특정 페이지를 정적으로 렌더링한 뒤, 일정 시간이 지나면 백그라운드에서 다시 빌드해서 최신 데이터를 반영할 수 있게 해줍니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> revalidate = <span class="hljs-number">10</span>; <span class="hljs-comment">// 10초마다 페이지 재생성</span>
</code></pre>
<ul>
<li>숫자 (초 단위): 페이지가 이 값만큼의 시간이 지나면 재생성됩니다.</li>
<li><code>false</code> 또는 <code>0</code>: ISR 비활성화, 빌드 시 한 번만 생성됨.</li>
</ul>
<p>재생성 시점에 방문한 사용자는 기존 페이지를 보고, 백그라운드에서 새 페이지가 만들어지니까 사용자 경험에 끊김이 적어요.</p>
<hr>
<h3>간단 요약</h3>

















<table><thead><tr><th>옵션</th><th>설명</th></tr></thead><tbody><tr><td><code>dynamicParams</code></td><td>동적 세그먼트가 동적으로 생성되는지 여부 설정</td></tr><tr><td><code>revalidate</code></td><td>ISR 주기 설정, 몇 초마다 페이지를 다시 생성할지 결정</td></tr></tbody></table>
<hr>
<h3>추가 팁!</h3>
<ul>
<li>
<p><strong><code>dynamicParams = true</code>와 ISR 함께 쓰기</strong><br>
동적 경로가 많거나 데이터가 자주 바뀌는 경우에 유용해요. 첫 요청 때만 페이지를 생성하고, 나중에 ISR로 업데이트할 수 있거든요.</p>
</li>
<li>
<p><strong>빈 배열 반환시 모든 경로 미리 생성</strong><br>
미리 생성할 경로를 다 알 수 있으면 <code>generateStaticParams</code>에서 배열을 반환해 정적으로 빠른 페이지를 만들 수 있어요.</p>
</li>
<li>
<p><strong><code>dynamic = 'force-static'</code> 사용</strong><br>
앱 전체를 정적으로 만들고 싶을 땐 이 값을 써서 SSR이나 동적 params 없이 순수 정적 빌드만 하게 설정해보세요.</p>
</li>
</ul>
<p>여러분 프로젝트에 맞게 이런 설정들을 적절히 활용하면, 효율적인 빌드와 빠른 퍼포먼스를 동시에 잡을 수 있답니다!<br>
추가로 Next.js 공식 문서도 자주 확인하면서 최신 기능을 놓치지 않는 게 중요해요~</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>레이아웃이나 페이지에 기본 revalidation(재검증) 시간을 설정할 수 있어요. 여기서 중요한 점은 이 설정이 개별 fetch 요청에서 설정한 revalidate 값을 덮어쓰지 않는다는 거예요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> revalidate = <span class="hljs-literal">false</span>
<span class="hljs-comment">// false | 0 | number</span>
</code></pre>





















<table><thead><tr><th>값</th><th>의미</th></tr></thead><tbody><tr><td>false (기본값)</td><td>기본적으로 <code>force-cache</code> 옵션이 붙은 fetch 요청이나 Dynamic API 사용 이전에 발견된 요청들은 캐싱합니다. 사실상 재검증 기간이 무한대(<code>revalidate: Infinity</code>)인 것과 같아서, 리소스를 무한정 캐시하겠다는 의미예요. 그래도 개별 fetch 요청에서 <code>cache: no-store</code> 나 <code>revalidate: 0</code>을 써서 캐시를 회피하거나, 경로의 기본값보다 짧은 재검증 시간을 가진 양수로 설정해 재검증 빈도를 높이는 건 가능합니다.</td></tr><tr><td>0</td><td>이 옵션을 설정하면 Dynamic API를 사용하지 않더라도 레이아웃이나 페이지가 항상 동적으로 렌더링됩니다. 이 경우 캐시 옵션을 명시하지 않은 fetch 요청은 기본적으로 <code>no-store</code>로 동작하지만, <code>force-cache</code> 옵션을 준 요청이나 양의 재검증 시간을 가진 요청은 그대로 유지됩니다.</td></tr><tr><td>number (초 단위)</td><td>레이아웃이나 페이지의 기본 재검증 주기를 초 단위 숫자로 설정합니다. 예를 들어 <code>revalidate = 600</code>이면 10분마다 재검증합니다.</td></tr></tbody></table>
<hr>
<h3>참고할 점</h3>
<ul>
<li><code>revalidate</code> 값은 정적으로 분석 가능해야 해요. 예를 들어 <code>revalidate = 600</code>은 유효하지만, <code>revalidate = 60 * 10</code> 같이 계산식은 안 됩니다. 즉, 값을 변수나 계산식이 아닌 숫자 리터럴로 직접 입력해야 하는 점을 기억하세요.</li>
<li><code>runtime = 'edge'</code>를 사용할 때는 <code>revalidate</code> 값이 적용되지 않습니다.</li>
<li>개발 모드(Development)에서는 모든 페이지가 항상 on-demand로 렌더링되며 캐싱되지 않아요. 덕분에 코드를 바로바로 수정 확인할 수 있고, 재검증 시간을 기다릴 필요가 없답니다.</li>
</ul>
<hr>
<h3>추가로 알아두면 좋은 팁!</h3>
<p><code>revalidate</code>를 적절히 사용하면 페이지의 최신성을 유지하면서도 캐싱을 통해 빠른 응답 속도를 얻을 수 있어요. 예를 들어 자주 변경되지 않는 블로그 글 같은 경우에는 긴 재검증 시간(<code>false</code> 또는 큰 숫자)을 줘서 트래픽 부담을 줄이고, 자주 갱신이 필요한 데이터엔 짧은 재검증 시간을 설정하는 식이죠.</p>
<p>기본 설정을 잘 활용하면 서버 부하를 줄이면서 사용자에게 더 빠른 웹 경험을 제공할 수 있으니, 상황에 맞는 값을 고민해보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h4>재검증 주기 (Revalidation Frequency)</h4>
<ul>
<li>하나의 경로(route)에 속한 레이아웃(layout)과 페이지(page)들 각각이 재검증(revalidate) 시간을 갖는데, 이 중 가장 짧은 재검증 주기가 그 경로 전체의 재검증 주기가 됩니다. 즉, 자식 페이지들도 부모 레이아웃만큼 자주 재검증되도록 보장하는 거죠.</li>
<li>개별 fetch 요청(fetch requests)에서는 경로의 기본 재검증 주기보다 더 짧은 재검증 주기를 설정할 수 있어요. 이를 통해 특정 경로나 상황에 맞게 동적으로 재검증 빈도를 높일 수 있습니다.</li>
</ul>
<p>예를 들어, 뉴스 기사 페이지는 자주 업데이트돼야 할 수도 있으니까 이 경우엔 재검증 주기를 더 짧게 설정할 수 있겠죠.</p>
<hr>
<h3>fetchCache</h3>
<p><code>fetchCache</code>는 클라이언트에서 데이터를 호출할 때 결과를 캐시하는 방식을 다루는 설정이에요. 원격 API를 호출할 때마다 서버에 부담주지 않으면서도, 최신 데이터를 적절히 유지하기 위한 중요한 포인트랍니다. cache-control 헤더 같이 HTTP 표준 캐싱 정책과도 연동되니까, 이 부분을 적절히 활용하면 효율적인 데이터 요청과 성능 향상에 큰 도움이 됩니다.</p>
<hr>
<h3>runtime</h3>
<p><code>runtime</code>은 코드를 실행하는 환경을 의미해요. Next.js 같은 프레임워크에서 <code>runtime</code>은 서버 사이드에서 동작하는지, 클라이언트 사이드에서 동작하는지에 따라 달라집니다. 서버에선 Node.js 환경에서 구동되고, 클라이언트에선 브라우저 환경이죠.</p>
<p>실제로 <code>runtime</code>이 중요해지는 이유는, 일부 기능들은 서버에서만, 또는 클라이언트에서만 동작해야 하기 때문입니다. 예를 들어, 민감한 API 키로 데이터를 불러오는 작업은 서버에서만 실행하도록 하고, 사용자 상호작용에 따른 UI 업데이트는 클라이언트에서 처리하는 식이죠.</p>
<hr>
<p>이렇게 <code>revalidation frequency</code>부터 <code>fetchCache</code>, <code>runtime</code>까지 조합해서 쓰면, 데이터 신선도 유지와 성능 최적화를 모두 잡을 수 있어요. Next.js 같은 최신 프레임워크를 사용할 때 이 부분들을 잘 이해하고 활용하는 게 개발 생산성 향상에 큰 도움이 되니 참고하시길 바랍니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>애플리케이션 렌더링에는 Node.js 런타임을 사용하는 걸 추천드리고, 미들웨어(Middleware)에는 Edge 런타임만 지원되니 이 점 참고해 주세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> runtime = <span class="hljs-string">'nodejs'</span>
<span class="hljs-comment">// 'nodejs' | 'edge'</span>
</code></pre>

















<table><thead><tr><th>런타임 종류</th><th>설명</th></tr></thead><tbody><tr><td>nodejs</td><td>기본값, 앱 렌더링용</td></tr><tr><td>edge</td><td>미들웨어 전용, 빠른 응답에 적합</td></tr></tbody></table>
<p>Node.js 런타임은 널리 사용되는 서버 환경으로, 풍부한 라이브러리와 안정성 덕분에 앱 렌더링에 최적입니다. 반면, Edge 런타임은 전세계적으로 분산된 서버에서 실행돼 지연시간을 최소화하기 때문에 미들웨어 같은 경량 작업에 딱이죠.</p>
<p>더 자세한 런타임 차이점과 사용법은 공식 문서를 참고하시면 도움이 될 거예요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>preferredRegion</h3>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> preferredRegion = <span class="hljs-string">'auto'</span>
<span class="hljs-comment">// 'auto' | 'global' | 'home' | ['iad1', 'sfo1']</span>
</code></pre>
<p><code>preferredRegion</code> 옵션은 배포하는 플랫폼에 따라 지원 여부와 사용 가능한 지역이 달라진다는 점, 꼭 기억하세요!</p>
<blockquote>
<p>참고할 점<br>
만약 <code>preferredRegion</code>을 따로 지정하지 않으면, 가장 가까운 상위 레이아웃(parent layout)의 설정을 상속받습니다.<br>
그리고 최상위 레이아웃(root layout)은 기본값으로 모든 지역(all regions)을 대상으로 합니다.</p>
</blockquote>
<hr>
<p>이 기능은 여러 서버 지역(Region) 중 어디서 코드를 실행할지 선택할 때 아주 유용해요. 예를 들어, 사용자가 미국 동부에 많다면 'iad1' 같은 특정 리전을 지정해 그쪽에서 서비스하도록 설정할 수 있죠. 'auto'로 설정하면 Next.js가 가장 적합한 지역을 자동으로 선택해주니 편리합니다.</p>
<p>여기서 'global'은 전 세계 여러 지역에 걸쳐 배포하는 경우이고, 'home'은 특정 홈 지역을 지칭할 때 사용됩니다. 또한 배열 형태로 여러 리전을 직접 지정해 여러 곳에서 동시에 실행되도록 할 수도 있답니다.</p>
<p>이처럼 <code>preferredRegion</code>을 잘 활용하면 사용자 경험을 크게 향상시킬 수 있으니, 필요에 맞게 설정하는 걸 추천드립니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>maxDuration</h3>
<p>Next.js에서는 기본적으로 서버 사이드 로직(페이지 렌더링이나 API 처리 등)의 실행 시간을 제한하지 않아요. 그런데 배포 플랫폼에서 Next.js 빌드 결과에 포함된 <code>maxDuration</code> 값을 활용해 실행 시간 제한을 걸 수 있답니다. 예를 들어, Vercel 같은 곳에서는 이 값을 참고해서 서버 로직이 너무 오래 걸리지 않도록 관리할 수 있죠.</p>
<blockquote>
<p><strong>참고</strong>: <code>maxDuration</code> 설정은 Next.js 13.4.10 이상 버전에서만 사용할 수 있어요.</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> maxDuration = <span class="hljs-number">5</span>
</code></pre>
<p>위처럼 <code>maxDuration</code>을 5로 설정하면, 해당 서버 로직이 5초 이상 실행되지 않도록 제한할 것을 제안하게 되는 거예요.</p>
<hr>
<h3>보너스 팁!</h3>
<ul>
<li>
<p><strong>왜 실행 시간 제한이 중요할까?</strong><br>
서버 쪽 로직이 무한루프에 빠지거나 너무 오래 걸리면, 서버 자원을 낭비하고 사용자 경험도 악화돼요. 특히 서버리스 환경에서는 실행 시간이 길어질수록 비용이 더 발생할 수 있어서, 이런 제한을 두는 게 효율적이랍니다.</p>
</li>
<li>
<p><strong><code>maxDuration</code>은 어디에 적용될까?</strong><br>
서버 컴포넌트의 렌더링 로직이나 API Route 핸들러 등, 서버에서 실행되는 모든 로직에 적용할 수 있어요.</p>
</li>
<li>
<p><strong>Next.js 버전 확인법</strong><br>
프로젝트에서 현재 사용하는 Next.js 버전을 확인하려면 <code>package.json</code> 파일에서 <code>next</code> 항목을 보면 되니 참고하세요!</p>
</li>
</ul>
<hr>
<p>혹시 여러분의 프로젝트에서 실행 시간이 너무 긴 서버 코드를 발견했다면, <code>maxDuration</code> 설정과 함께 코드를 최적화하는 걸 추천드려요. 작은 설정과 최적화가 서버 환경 전반의 효율성을 크게 올려준답니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<blockquote>
<p>알아두면 좋은 점:<br>
만약 Server Actions를 사용할 경우, 페이지 단위에서 maxDuration을 설정해서 해당 페이지 내 모든 Server Actions의 기본 타임아웃 시간을 변경할 수 있어요.</p>
</blockquote>
<h3>generateStaticParams</h3>
<p>generateStaticParams 함수는 동적 라우트 세그먼트와 함께 사용할 수 있는데요, 이 함수를 이용하면 빌드 시점에 정적으로 생성할 라우트 세그먼트 파라미터 리스트를 정의할 수 있어요.<br>
즉, 요청할 때마다(dynamic하게) 생성하는 것이 아니라, 미리(static하게) 만들어 두는 거죠.</p>
<p>이렇게 하면 빌드 시 미리 생성된 페이지 덕분에 사용자 경험이 더 빨라지고 서버 부하도 줄일 수 있어요.</p>
<p>조금 더 자세한 내용은 공식 API 문서를 참고해보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>버전 히스토리</h2>













<table><thead><tr><th>Version</th><th>설명</th></tr></thead><tbody><tr><td><code>v15.0.0-RC</code></td><td><code>export const runtime = "experimental-edge"</code>가 deprecated 되었습니다. 이에 따른 코드 변경을 쉽게 해주는 <a href="https://nextjs.org/docs/app/guides/upgrading/codemods#transform-app-router-route-segment-config-runtime-value-from-experimental-edge-to-edge" rel="nofollow" target="_blank">codemod</a>가 제공됩니다.</td></tr></tbody></table>
<p>여기서 codemod란, 코드 변환을 자동으로 해주는 도구를 의미해요. 기존에 <code>experimental-edge</code>로 설정해둔 부분을 새로운 방식인 <code>edge</code>로 한 번에 바꿔주니까, 직접 손으로 일일이 수정할 필요가 없어서 편하답니다. 혹시 Next.js로 프로젝트를 진행 중이라면 이 부분 꼭 참고하세요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Next.js 15 라우트 세그먼트 설정 방법과 활용팁","description":"","date":"2025-04-22 02:45","slug":"2025-04-22-RouteSegmentConfig","content":"\n\n# Route Segment Config\n\n\u003e 이 페이지에 소개된 옵션들은 `dynamicIO` 플래그가 켜져 있으면 비활성화되고, 앞으로는 없어질 예정이에요.\n\nRoute Segment 옵션은 Page, Layout, 또는 Route Handler의 동작 방식을 직접 제어하고 싶을 때 유용해요. 이 옵션들은 아래 변수들을 export 해서 설정할 수 있습니다.\n\n| 옵션             | 타입                                                                                  | 기본값           |\n|-----------------|-------------------------------------------------------------------------------------|-----------------|\n| [experimental_ppr](#experimental_ppr) | `boolean`                                                                             |                 |\n| [dynamic](#dynamic)                   | `'auto'` \\| `'force-dynamic'` \\| `'error'` \\| `'force-static'`                        | `'auto'`        |\n| [dynamicParams](#dynamicparams)      | `boolean`                                                                             | `true`          |\n| [revalidate](#revalidate)             | `false` \\| `0` \\| `number`                                                            | `false`         |\n| [fetchCache](#fetchcache)             | `'auto'` \\| `'default-cache'` \\| `'only-cache'` \\| `'force-cache'` \\| `'force-no-store'` \\| `'default-no-store'` \\| `'only-no-store'` | `'auto'`        |\n| [runtime](#runtime)                   | `'nodejs'` \\| `'edge'`                                                                | `'nodejs'`      |\n| [preferredRegion](#preferredregion)  | `'auto'` \\| `'global'` \\| `'home'` \\| `string` \\| `string[]`                          | `'auto'`        |\n| [maxDuration](#maxduration)           | `number`                                                                             | 배포 플랫폼에 따라 설정 |\n\n---\n\n### 한눈에 보기\n\n- **experimental_ppr**: 실험적인 부분들에 대한 설정인데, 자세한 내용은 공식 문서를 참고해야 해요.\n- **dynamic**: 페이지를 동적으로 처리할지, 정적으로 처리할지 결정할 수 있어요. 기본값은 `'auto'`라 알아서 최적의 방식을 선택합니다.\n- **dynamicParams**: 동적 경로 파라미터 사용 여부를 설정해요. 기본적으로 `true`라 동적 파라미터를 허용합니다.\n- **revalidate**: ISR(Incremental Static Regeneration)을 사용할 때 재빌드 주기를 설정합니다. `false`는 재빌드를 하지 않는다는 의미고, 숫자를 지정하면 해당 초마다 재빌드 돼요.\n- **fetchCache**: 서버 측 데이터 fetching 시 어떤 캐싱 전략을 사용할지 정하는 옵션입니다.\n- **runtime**: `nodejs` 또는 `edge` 중 실행 환경을 선택할 수 있어요. 기본은 `nodejs`.\n- **preferredRegion**: 배포 리전을 지정할 수 있는 옵션입니다. 글로벌 서비스를 위한 `'global'`이나 특정 리전 이름, 혹은 배열로 여러 리전을 설정할 수 있죠.\n- **maxDuration**: 함수 실행 최장 시간을 의미하는데, 보통 배포 환경에 따라 제한됩니다.\n\n---\n\n### 그리고 살짝 덧붙이자면...\n\n이런 Route Segment 설정을 통해서 Next.js 같은 프레임워크에서 페이지나 API 경로의 동작 방식을 세밀하게 조정할 수 있어요. 예를 들어, `dynamic: 'force-dynamic'`으로 지정하면 요청마다 항상 새롭게 렌더링해서 가장 최신 데이터를 보여주고, `revalidate` 시간을 설정해두면 효율적인 캐싱을 하면서도 일정 주기로 콘텐츠가 갱신되게 할 수 있죠.\n\n또한, `runtime`을 `edge`로 설정하면 전 세계 엣지 서버에서 빠르게 처리가 가능해서 속도 향상과 지연 감소에 도움 될 수 있습니다. 다만 엣지 런타임 환경 제약 조건이 있으니, 사용 시 주의하세요.\n\n이렇게 구성해두면 사용자 경험을 더 좋게 만들어주고, 서버 리소스를 효과적으로 사용할 수 있다는 장점이 있습니다. 다음에는 각 옵션별 좀 더 구체적인 활용법도 소개해볼게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 옵션\n\n### experimental_ppr\n\nPartial Prerendering, 줄여서 PPR을 레이아웃이나 페이지에 적용할 수 있는 옵션이에요. 이걸 활성화하면 페이지나 특정 레이아웃이 부분적으로 미리 렌더링 되어서, 사용자가 페이지를 더 빨리 볼 수 있도록 도와줘요.\n\n```js\nexport const experimental_ppr = true\n// true | false\n```\n\n참고로, 이 옵션은 아직 실험적인 기능이라 가끔 예상치 못한 동작이 있을 수도 있어요. 그래서 프로젝트에 바로 적용하기보다는 테스트 환경에서 먼저 써보고, 잘 맞는지 확인하는 걸 추천드려요!\n\n추가로 Partial Prerendering은 페이지의 일부만 미리 만들어두고 나머지는 필요할 때 로드하는 방식이기 때문에, 데이터가 자주 변하는 부분이나 사용자 맞춤형 콘텐츠에서 유용할 수 있어요. 만약에 페이지가 크고 렌더링 시간이 길다면, PPR을 활용해서 초기 로딩 속도를 확실히 개선할 수 있답니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### dynamic\n\n레이아웃이나 페이지의 동작 방식을 완전 정적(static) 또는 완전 동적(dynamic)으로 바꿀 수 있는 옵션이에요.\n\n```js\nexport const dynamic = 'auto'\n// 사용할 수 있는 값: 'auto' | 'force-dynamic' | 'error' | 'force-static'\n```\n\n여기서 각 값의 의미는 다음과 같아요:\n\n- `'auto'`: 기본값이에요. 상황에 따라 동적 또는 정적으로 처리해요.\n- `'force-dynamic'`: 무조건 동적으로 렌더링해요.\n- `'force-static'`: 무조건 정적으로 렌더링해요.\n- `'error'`: 동적 동작이 필요할 때 에러를 발생시켜요.\n\n\u003e 참고로 알면 좋은 점: Next.js의 최신 app 디렉토리 구조에서는 페이지 단위에서 모두 다 동적이거나 모두 다 정적인 getServerSideProps, getStaticProps 대신, fetch 요청 단위에서 좀 더 세밀하게 캐싱을 조절하는 방식을 선호해요. 즉, 이전의 방식보다 더 유연해졌죠. 그런데 기존의 페이지 단위 동작 모델로 쉽게 돌아가고 싶은 경우, 이 `dynamic` 옵션을 활용하면 간편하게 이전 모델을 유지할 수 있어서 마이그레이션할 때도 편리해요.\n\n---\n\n추가로 덧붙이자면, 실제로는 fetch 함수에서 `cache` 옵션을 주는 쪽이 더 권장됩니다. 예를 들어:\n\n```js\nconst res = await fetch('/api/data', { cache: 'no-store' }) // 항상 최신 데이터를 받아오도록 강제\n```\n\n이런 식으로 개별 fetch 요청마다 캐싱 동작을 세부 조절할 수 있어요. `dynamic` 옵션은 주로 전체 페이지 단위의 기본 동작을 결정할 때 사용한다고 생각하면 됩니다. \n\n즉, Next.js의 최신 앱 구조는 “모든 것을 다 세부적으로 제어하는 시대”라고 이해하면 좋겠네요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n`dynamic` 옵션에는 총 네 가지가 있어요. 각 옵션이 어떤 차이를 만드는지 쉽게 정리해볼게요!\n\n| 옵션           | 설명                                                                                                  | 추가 팁                                                                                          |\n|---------------|-----------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------|\n| `auto` (기본값) | 가능한 한 많이 캐시하지만, 동적으로 동작하고 싶은 컴포넌트는 이를 선택할 수 있도록 허용합니다.                                    | 기본값 그대로 쓰면 딱히 설정하지 않아도 자동으로 적절히 작동해요.                                      |\n| `force-dynamic` | 무조건 동적 렌더링을 합니다. 즉, 각 요청마다 매번 페이지가 새로 렌더링됨.                                       | 내부적으로 모든 fetch() 요청은 `'cache: no-store', next: { revalidate: 0 }` 설정이 되고, `fetchCache = force-no-store` 로 강제되죠. |\n| `error`        | 정적 렌더링만 강제하고, 만약 Dynamic API나 캐시되지 않는 데이터를 쓰면 에러 발생!                                    | pages 디렉토리의 `getStaticProps()`와 비슷해요. fetch()는 `'cache: force-cache'`를 사용하고, `fetchCache = only-cache`, `dynamicParams = false`로 설정됩니다. 동적 파라미터가 필요하면 수동으로 `dynamicParams = true`로 바꿔야 해요.        |\n| `force-static` | 정적 렌더링 강제 + cookies, headers(), useSearchParams() 호출 시 빈값만 반환하게 만듭니다.                          | 정말 정적으로만 작동해야 하는 상황에 쓸 수 있어요.                                                    |\n\n---\n\n### 참고! \n`getServerSideProps`, `getStaticProps`에서 `dynamic: 'force-dynamic'`이나 `dynamic: 'error'`로 마이그레이션하는 방법은 [업그레이드 가이드](https://nextjs.org/docs/pages/building-your-application/data-fetching/upgrading)에서 자세히 설명하고 있으니 참고하세요.\n\n---\n\n### dynamicParams란?\n이건 `generateStaticParams`로 미리 생성하지 않은 동적 경로(`/posts/[id]` 같은)가 방문됐을 때 어떻게 처리할지 결정할 수 있는 옵션이에요. 예를 들면 동적 경로가 너무 많을 때 미리 다 생성할 수 없으니, 방문 시점에 동적으로 처리할지, 아니면 에러를 표시할지 선택할 수 있습니다.\n\n---\n\n이렇게 보면 `dynamic` 옵션을 상황과 필요에 맞게 조절하는 게 핵심이라는 걸 알 수 있죠. 예를 들어, 자주 바뀌는 데이터를 보여주는 페이지라면 `force-dynamic`이 유리하고, 가능하면 빌드 타임에 다 끝내고 싶으면 `error` 혹은 `force-static`을 쓰는 식이에요.\n\n실제로 프로젝트에 적용할 때는 데이터 특성과 사용자 경험을 잘 고려해서 가장 적합한 설정을 찾아 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nexport const dynamicParams = true // true | false,\n```\n\n- true (기본값): `generateStaticParams`에 포함되지 않은 동적 세그먼트는 요청 시점에 생성돼요.\n- false: `generateStaticParams`에 없는 동적 세그먼트에 접근하면 404 페이지가 반환됩니다.\n\n\u003e 알아두면 좋은 점:  \n이 옵션은 pages 디렉터리에서 사용하던 `getStaticPaths`의 `fallback: true | false | blocking` 옵션을 대체해요.  \n만약 모든 경로를 처음부터 정적으로 렌더링하고 싶다면, `generateStaticParams`에서 빈 배열을 반환하거나 `export const dynamic = 'force-static'`을 사용해야 합니다.  \n`dynamicParams = true`인 경우, 해당 세그먼트는 스트리밍 서버 렌더링(Streaming Server Rendering)을 사용해요.  \n그리고 `dynamic = 'error'`나 `dynamic = 'force-static'`을 쓰면 `dynamicParams`의 기본값이 false로 바뀝니다.\n\n---\n\n### revalidate  \n\n*여기서 부터는 `revalidate` 옵션에 대해 살펴볼게요.*  \n\nNext.js의 `revalidate` 옵션은 ISR(Incremental Static Regeneration) 기능을 제어하는 데 사용돼요.  \n간단히 말해서, 특정 페이지를 정적으로 렌더링한 뒤, 일정 시간이 지나면 백그라운드에서 다시 빌드해서 최신 데이터를 반영할 수 있게 해줍니다.\n\n```js\nexport const revalidate = 10; // 10초마다 페이지 재생성\n```\n\n- 숫자 (초 단위): 페이지가 이 값만큼의 시간이 지나면 재생성됩니다.  \n- `false` 또는 `0`: ISR 비활성화, 빌드 시 한 번만 생성됨.\n\n재생성 시점에 방문한 사용자는 기존 페이지를 보고, 백그라운드에서 새 페이지가 만들어지니까 사용자 경험에 끊김이 적어요.\n\n---\n\n### 간단 요약\n\n| 옵션               | 설명                                                |\n|--------------------|---------------------------------------------------|\n| `dynamicParams`     | 동적 세그먼트가 동적으로 생성되는지 여부 설정          |\n| `revalidate`        | ISR 주기 설정, 몇 초마다 페이지를 다시 생성할지 결정     |\n\n---\n\n### 추가 팁!\n\n- **`dynamicParams = true`와 ISR 함께 쓰기**  \n   동적 경로가 많거나 데이터가 자주 바뀌는 경우에 유용해요. 첫 요청 때만 페이지를 생성하고, 나중에 ISR로 업데이트할 수 있거든요.\n\n- **빈 배열 반환시 모든 경로 미리 생성**  \n   미리 생성할 경로를 다 알 수 있으면 `generateStaticParams`에서 배열을 반환해 정적으로 빠른 페이지를 만들 수 있어요.  \n\n- **`dynamic = 'force-static'` 사용**  \n   앱 전체를 정적으로 만들고 싶을 땐 이 값을 써서 SSR이나 동적 params 없이 순수 정적 빌드만 하게 설정해보세요.\n\n여러분 프로젝트에 맞게 이런 설정들을 적절히 활용하면, 효율적인 빌드와 빠른 퍼포먼스를 동시에 잡을 수 있답니다!  \n추가로 Next.js 공식 문서도 자주 확인하면서 최신 기능을 놓치지 않는 게 중요해요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n레이아웃이나 페이지에 기본 revalidation(재검증) 시간을 설정할 수 있어요. 여기서 중요한 점은 이 설정이 개별 fetch 요청에서 설정한 revalidate 값을 덮어쓰지 않는다는 거예요.\n\n```js\nexport const revalidate = false\n// false | 0 | number\n```\n\n| 값 | 의미 |\n|---|---|\n| false (기본값) | 기본적으로 `force-cache` 옵션이 붙은 fetch 요청이나 Dynamic API 사용 이전에 발견된 요청들은 캐싱합니다. 사실상 재검증 기간이 무한대(`revalidate: Infinity`)인 것과 같아서, 리소스를 무한정 캐시하겠다는 의미예요. 그래도 개별 fetch 요청에서 `cache: no-store` 나 `revalidate: 0`을 써서 캐시를 회피하거나, 경로의 기본값보다 짧은 재검증 시간을 가진 양수로 설정해 재검증 빈도를 높이는 건 가능합니다. |\n| 0 | 이 옵션을 설정하면 Dynamic API를 사용하지 않더라도 레이아웃이나 페이지가 항상 동적으로 렌더링됩니다. 이 경우 캐시 옵션을 명시하지 않은 fetch 요청은 기본적으로 `no-store`로 동작하지만, `force-cache` 옵션을 준 요청이나 양의 재검증 시간을 가진 요청은 그대로 유지됩니다. |\n| number (초 단위) | 레이아웃이나 페이지의 기본 재검증 주기를 초 단위 숫자로 설정합니다. 예를 들어 `revalidate = 600`이면 10분마다 재검증합니다. |\n\n---\n\n### 참고할 점\n- `revalidate` 값은 정적으로 분석 가능해야 해요. 예를 들어 `revalidate = 600`은 유효하지만, `revalidate = 60 * 10` 같이 계산식은 안 됩니다. 즉, 값을 변수나 계산식이 아닌 숫자 리터럴로 직접 입력해야 하는 점을 기억하세요.\n- `runtime = 'edge'`를 사용할 때는 `revalidate` 값이 적용되지 않습니다.\n- 개발 모드(Development)에서는 모든 페이지가 항상 on-demand로 렌더링되며 캐싱되지 않아요. 덕분에 코드를 바로바로 수정 확인할 수 있고, 재검증 시간을 기다릴 필요가 없답니다.\n\n---\n\n### 추가로 알아두면 좋은 팁!\n`revalidate`를 적절히 사용하면 페이지의 최신성을 유지하면서도 캐싱을 통해 빠른 응답 속도를 얻을 수 있어요. 예를 들어 자주 변경되지 않는 블로그 글 같은 경우에는 긴 재검증 시간(`false` 또는 큰 숫자)을 줘서 트래픽 부담을 줄이고, 자주 갱신이 필요한 데이터엔 짧은 재검증 시간을 설정하는 식이죠.\n\n기본 설정을 잘 활용하면 서버 부하를 줄이면서 사용자에게 더 빠른 웹 경험을 제공할 수 있으니, 상황에 맞는 값을 고민해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n#### 재검증 주기 (Revalidation Frequency)\n\n- 하나의 경로(route)에 속한 레이아웃(layout)과 페이지(page)들 각각이 재검증(revalidate) 시간을 갖는데, 이 중 가장 짧은 재검증 주기가 그 경로 전체의 재검증 주기가 됩니다. 즉, 자식 페이지들도 부모 레이아웃만큼 자주 재검증되도록 보장하는 거죠.\n- 개별 fetch 요청(fetch requests)에서는 경로의 기본 재검증 주기보다 더 짧은 재검증 주기를 설정할 수 있어요. 이를 통해 특정 경로나 상황에 맞게 동적으로 재검증 빈도를 높일 수 있습니다.\n\n예를 들어, 뉴스 기사 페이지는 자주 업데이트돼야 할 수도 있으니까 이 경우엔 재검증 주기를 더 짧게 설정할 수 있겠죠.\n\n---\n\n### fetchCache\n\n`fetchCache`는 클라이언트에서 데이터를 호출할 때 결과를 캐시하는 방식을 다루는 설정이에요. 원격 API를 호출할 때마다 서버에 부담주지 않으면서도, 최신 데이터를 적절히 유지하기 위한 중요한 포인트랍니다. cache-control 헤더 같이 HTTP 표준 캐싱 정책과도 연동되니까, 이 부분을 적절히 활용하면 효율적인 데이터 요청과 성능 향상에 큰 도움이 됩니다.\n\n---\n\n### runtime\n\n`runtime`은 코드를 실행하는 환경을 의미해요. Next.js 같은 프레임워크에서 `runtime`은 서버 사이드에서 동작하는지, 클라이언트 사이드에서 동작하는지에 따라 달라집니다. 서버에선 Node.js 환경에서 구동되고, 클라이언트에선 브라우저 환경이죠.\n\n실제로 `runtime`이 중요해지는 이유는, 일부 기능들은 서버에서만, 또는 클라이언트에서만 동작해야 하기 때문입니다. 예를 들어, 민감한 API 키로 데이터를 불러오는 작업은 서버에서만 실행하도록 하고, 사용자 상호작용에 따른 UI 업데이트는 클라이언트에서 처리하는 식이죠.\n\n---\n\n이렇게 `revalidation frequency`부터 `fetchCache`, `runtime`까지 조합해서 쓰면, 데이터 신선도 유지와 성능 최적화를 모두 잡을 수 있어요. Next.js 같은 최신 프레임워크를 사용할 때 이 부분들을 잘 이해하고 활용하는 게 개발 생산성 향상에 큰 도움이 되니 참고하시길 바랍니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n애플리케이션 렌더링에는 Node.js 런타임을 사용하는 걸 추천드리고, 미들웨어(Middleware)에는 Edge 런타임만 지원되니 이 점 참고해 주세요.\n\n```js\nexport const runtime = 'nodejs'\n// 'nodejs' | 'edge'\n```\n\n| 런타임 종류 | 설명                   |\n| --------- | -------------------- |\n| nodejs    | 기본값, 앱 렌더링용        |\n| edge      | 미들웨어 전용, 빠른 응답에 적합 |\n\nNode.js 런타임은 널리 사용되는 서버 환경으로, 풍부한 라이브러리와 안정성 덕분에 앱 렌더링에 최적입니다. 반면, Edge 런타임은 전세계적으로 분산된 서버에서 실행돼 지연시간을 최소화하기 때문에 미들웨어 같은 경량 작업에 딱이죠.\n\n더 자세한 런타임 차이점과 사용법은 공식 문서를 참고하시면 도움이 될 거예요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### preferredRegion\n\n```js\nexport const preferredRegion = 'auto'\n// 'auto' | 'global' | 'home' | ['iad1', 'sfo1']\n```\n\n`preferredRegion` 옵션은 배포하는 플랫폼에 따라 지원 여부와 사용 가능한 지역이 달라진다는 점, 꼭 기억하세요!\n\n\u003e 참고할 점  \n만약 `preferredRegion`을 따로 지정하지 않으면, 가장 가까운 상위 레이아웃(parent layout)의 설정을 상속받습니다.  \n그리고 최상위 레이아웃(root layout)은 기본값으로 모든 지역(all regions)을 대상으로 합니다.\n\n---\n\n이 기능은 여러 서버 지역(Region) 중 어디서 코드를 실행할지 선택할 때 아주 유용해요. 예를 들어, 사용자가 미국 동부에 많다면 'iad1' 같은 특정 리전을 지정해 그쪽에서 서비스하도록 설정할 수 있죠. 'auto'로 설정하면 Next.js가 가장 적합한 지역을 자동으로 선택해주니 편리합니다.\n\n여기서 'global'은 전 세계 여러 지역에 걸쳐 배포하는 경우이고, 'home'은 특정 홈 지역을 지칭할 때 사용됩니다. 또한 배열 형태로 여러 리전을 직접 지정해 여러 곳에서 동시에 실행되도록 할 수도 있답니다.\n\n이처럼 `preferredRegion`을 잘 활용하면 사용자 경험을 크게 향상시킬 수 있으니, 필요에 맞게 설정하는 걸 추천드립니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### maxDuration\n\nNext.js에서는 기본적으로 서버 사이드 로직(페이지 렌더링이나 API 처리 등)의 실행 시간을 제한하지 않아요. 그런데 배포 플랫폼에서 Next.js 빌드 결과에 포함된 `maxDuration` 값을 활용해 실행 시간 제한을 걸 수 있답니다. 예를 들어, Vercel 같은 곳에서는 이 값을 참고해서 서버 로직이 너무 오래 걸리지 않도록 관리할 수 있죠.\n\n\u003e **참고**: `maxDuration` 설정은 Next.js 13.4.10 이상 버전에서만 사용할 수 있어요.\n\n```js\nexport const maxDuration = 5\n```\n\n위처럼 `maxDuration`을 5로 설정하면, 해당 서버 로직이 5초 이상 실행되지 않도록 제한할 것을 제안하게 되는 거예요.\n\n---\n\n### 보너스 팁!\n\n- **왜 실행 시간 제한이 중요할까?**  \n  서버 쪽 로직이 무한루프에 빠지거나 너무 오래 걸리면, 서버 자원을 낭비하고 사용자 경험도 악화돼요. 특히 서버리스 환경에서는 실행 시간이 길어질수록 비용이 더 발생할 수 있어서, 이런 제한을 두는 게 효율적이랍니다.\n\n- **`maxDuration`은 어디에 적용될까?**  \n  서버 컴포넌트의 렌더링 로직이나 API Route 핸들러 등, 서버에서 실행되는 모든 로직에 적용할 수 있어요.\n\n- **Next.js 버전 확인법**  \n  프로젝트에서 현재 사용하는 Next.js 버전을 확인하려면 `package.json` 파일에서 `next` 항목을 보면 되니 참고하세요!\n\n---\n\n혹시 여러분의 프로젝트에서 실행 시간이 너무 긴 서버 코드를 발견했다면, `maxDuration` 설정과 함께 코드를 최적화하는 걸 추천드려요. 작은 설정과 최적화가 서버 환경 전반의 효율성을 크게 올려준답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003e 알아두면 좋은 점:  \n만약 Server Actions를 사용할 경우, 페이지 단위에서 maxDuration을 설정해서 해당 페이지 내 모든 Server Actions의 기본 타임아웃 시간을 변경할 수 있어요.\n\n### generateStaticParams\n\ngenerateStaticParams 함수는 동적 라우트 세그먼트와 함께 사용할 수 있는데요, 이 함수를 이용하면 빌드 시점에 정적으로 생성할 라우트 세그먼트 파라미터 리스트를 정의할 수 있어요.  \n즉, 요청할 때마다(dynamic하게) 생성하는 것이 아니라, 미리(static하게) 만들어 두는 거죠.\n\n이렇게 하면 빌드 시 미리 생성된 페이지 덕분에 사용자 경험이 더 빨라지고 서버 부하도 줄일 수 있어요.\n\n조금 더 자세한 내용은 공식 API 문서를 참고해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 버전 히스토리\n\n| Version         | 설명                                                                                                         |\n|-----------------|------------------------------------------------------------------------------------------------------------|\n| `v15.0.0-RC`    | `export const runtime = \"experimental-edge\"`가 deprecated 되었습니다. 이에 따른 코드 변경을 쉽게 해주는 [codemod](https://nextjs.org/docs/app/guides/upgrading/codemods#transform-app-router-route-segment-config-runtime-value-from-experimental-edge-to-edge)가 제공됩니다. |\n\n여기서 codemod란, 코드 변환을 자동으로 해주는 도구를 의미해요. 기존에 `experimental-edge`로 설정해둔 부분을 새로운 방식인 `edge`로 한 번에 바꿔주니까, 직접 손으로 일일이 수정할 필요가 없어서 편하답니다. 혹시 Next.js로 프로젝트를 진행 중이라면 이 부분 꼭 참고하세요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":18},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003eRoute Segment Config\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e이 페이지에 소개된 옵션들은 \u003ccode\u003edynamicIO\u003c/code\u003e 플래그가 켜져 있으면 비활성화되고, 앞으로는 없어질 예정이에요.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eRoute Segment 옵션은 Page, Layout, 또는 Route Handler의 동작 방식을 직접 제어하고 싶을 때 유용해요. 이 옵션들은 아래 변수들을 export 해서 설정할 수 있습니다.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e옵션\u003c/th\u003e\u003cth\u003e타입\u003c/th\u003e\u003cth\u003e기본값\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ca href=\"#experimental_ppr\"\u003eexperimental_ppr\u003c/a\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eboolean\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ca href=\"#dynamic\"\u003edynamic\u003c/a\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e'auto'\u003c/code\u003e | \u003ccode\u003e'force-dynamic'\u003c/code\u003e | \u003ccode\u003e'error'\u003c/code\u003e | \u003ccode\u003e'force-static'\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e'auto'\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ca href=\"#dynamicparams\"\u003edynamicParams\u003c/a\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eboolean\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003etrue\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ca href=\"#revalidate\"\u003erevalidate\u003c/a\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003efalse\u003c/code\u003e | \u003ccode\u003e0\u003c/code\u003e | \u003ccode\u003enumber\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003efalse\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ca href=\"#fetchcache\"\u003efetchCache\u003c/a\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e'auto'\u003c/code\u003e | \u003ccode\u003e'default-cache'\u003c/code\u003e | \u003ccode\u003e'only-cache'\u003c/code\u003e | \u003ccode\u003e'force-cache'\u003c/code\u003e | \u003ccode\u003e'force-no-store'\u003c/code\u003e | \u003ccode\u003e'default-no-store'\u003c/code\u003e | \u003ccode\u003e'only-no-store'\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e'auto'\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ca href=\"#runtime\"\u003eruntime\u003c/a\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e'nodejs'\u003c/code\u003e | \u003ccode\u003e'edge'\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e'nodejs'\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ca href=\"#preferredregion\"\u003epreferredRegion\u003c/a\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e'auto'\u003c/code\u003e | \u003ccode\u003e'global'\u003c/code\u003e | \u003ccode\u003e'home'\u003c/code\u003e | \u003ccode\u003estring\u003c/code\u003e | \u003ccode\u003estring[]\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e'auto'\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ca href=\"#maxduration\"\u003emaxDuration\u003c/a\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003enumber\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e배포 플랫폼에 따라 설정\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003ch3\u003e한눈에 보기\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eexperimental_ppr\u003c/strong\u003e: 실험적인 부분들에 대한 설정인데, 자세한 내용은 공식 문서를 참고해야 해요.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003edynamic\u003c/strong\u003e: 페이지를 동적으로 처리할지, 정적으로 처리할지 결정할 수 있어요. 기본값은 \u003ccode\u003e'auto'\u003c/code\u003e라 알아서 최적의 방식을 선택합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003edynamicParams\u003c/strong\u003e: 동적 경로 파라미터 사용 여부를 설정해요. 기본적으로 \u003ccode\u003etrue\u003c/code\u003e라 동적 파라미터를 허용합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003erevalidate\u003c/strong\u003e: ISR(Incremental Static Regeneration)을 사용할 때 재빌드 주기를 설정합니다. \u003ccode\u003efalse\u003c/code\u003e는 재빌드를 하지 않는다는 의미고, 숫자를 지정하면 해당 초마다 재빌드 돼요.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003efetchCache\u003c/strong\u003e: 서버 측 데이터 fetching 시 어떤 캐싱 전략을 사용할지 정하는 옵션입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eruntime\u003c/strong\u003e: \u003ccode\u003enodejs\u003c/code\u003e 또는 \u003ccode\u003eedge\u003c/code\u003e 중 실행 환경을 선택할 수 있어요. 기본은 \u003ccode\u003enodejs\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003epreferredRegion\u003c/strong\u003e: 배포 리전을 지정할 수 있는 옵션입니다. 글로벌 서비스를 위한 \u003ccode\u003e'global'\u003c/code\u003e이나 특정 리전 이름, 혹은 배열로 여러 리전을 설정할 수 있죠.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003emaxDuration\u003c/strong\u003e: 함수 실행 최장 시간을 의미하는데, 보통 배포 환경에 따라 제한됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003e그리고 살짝 덧붙이자면...\u003c/h3\u003e\n\u003cp\u003e이런 Route Segment 설정을 통해서 Next.js 같은 프레임워크에서 페이지나 API 경로의 동작 방식을 세밀하게 조정할 수 있어요. 예를 들어, \u003ccode\u003edynamic: 'force-dynamic'\u003c/code\u003e으로 지정하면 요청마다 항상 새롭게 렌더링해서 가장 최신 데이터를 보여주고, \u003ccode\u003erevalidate\u003c/code\u003e 시간을 설정해두면 효율적인 캐싱을 하면서도 일정 주기로 콘텐츠가 갱신되게 할 수 있죠.\u003c/p\u003e\n\u003cp\u003e또한, \u003ccode\u003eruntime\u003c/code\u003e을 \u003ccode\u003eedge\u003c/code\u003e로 설정하면 전 세계 엣지 서버에서 빠르게 처리가 가능해서 속도 향상과 지연 감소에 도움 될 수 있습니다. 다만 엣지 런타임 환경 제약 조건이 있으니, 사용 시 주의하세요.\u003c/p\u003e\n\u003cp\u003e이렇게 구성해두면 사용자 경험을 더 좋게 만들어주고, 서버 리소스를 효과적으로 사용할 수 있다는 장점이 있습니다. 다음에는 각 옵션별 좀 더 구체적인 활용법도 소개해볼게요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e옵션\u003c/h2\u003e\n\u003ch3\u003eexperimental_ppr\u003c/h3\u003e\n\u003cp\u003ePartial Prerendering, 줄여서 PPR을 레이아웃이나 페이지에 적용할 수 있는 옵션이에요. 이걸 활성화하면 페이지나 특정 레이아웃이 부분적으로 미리 렌더링 되어서, 사용자가 페이지를 더 빨리 볼 수 있도록 도와줘요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e experimental_ppr = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// true | false\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e참고로, 이 옵션은 아직 실험적인 기능이라 가끔 예상치 못한 동작이 있을 수도 있어요. 그래서 프로젝트에 바로 적용하기보다는 테스트 환경에서 먼저 써보고, 잘 맞는지 확인하는 걸 추천드려요!\u003c/p\u003e\n\u003cp\u003e추가로 Partial Prerendering은 페이지의 일부만 미리 만들어두고 나머지는 필요할 때 로드하는 방식이기 때문에, 데이터가 자주 변하는 부분이나 사용자 맞춤형 콘텐츠에서 유용할 수 있어요. 만약에 페이지가 크고 렌더링 시간이 길다면, PPR을 활용해서 초기 로딩 속도를 확실히 개선할 수 있답니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003edynamic\u003c/h3\u003e\n\u003cp\u003e레이아웃이나 페이지의 동작 방식을 완전 정적(static) 또는 완전 동적(dynamic)으로 바꿀 수 있는 옵션이에요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e dynamic = \u003cspan class=\"hljs-string\"\u003e'auto'\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 사용할 수 있는 값: 'auto' | 'force-dynamic' | 'error' | 'force-static'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 각 값의 의미는 다음과 같아요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e'auto'\u003c/code\u003e: 기본값이에요. 상황에 따라 동적 또는 정적으로 처리해요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e'force-dynamic'\u003c/code\u003e: 무조건 동적으로 렌더링해요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e'force-static'\u003c/code\u003e: 무조건 정적으로 렌더링해요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e'error'\u003c/code\u003e: 동적 동작이 필요할 때 에러를 발생시켜요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e참고로 알면 좋은 점: Next.js의 최신 app 디렉토리 구조에서는 페이지 단위에서 모두 다 동적이거나 모두 다 정적인 getServerSideProps, getStaticProps 대신, fetch 요청 단위에서 좀 더 세밀하게 캐싱을 조절하는 방식을 선호해요. 즉, 이전의 방식보다 더 유연해졌죠. 그런데 기존의 페이지 단위 동작 모델로 쉽게 돌아가고 싶은 경우, 이 \u003ccode\u003edynamic\u003c/code\u003e 옵션을 활용하면 간편하게 이전 모델을 유지할 수 있어서 마이그레이션할 때도 편리해요.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003cp\u003e추가로 덧붙이자면, 실제로는 fetch 함수에서 \u003ccode\u003ecache\u003c/code\u003e 옵션을 주는 쪽이 더 권장됩니다. 예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e res = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/api/data'\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003ecache\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'no-store'\u003c/span\u003e }) \u003cspan class=\"hljs-comment\"\u003e// 항상 최신 데이터를 받아오도록 강제\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이런 식으로 개별 fetch 요청마다 캐싱 동작을 세부 조절할 수 있어요. \u003ccode\u003edynamic\u003c/code\u003e 옵션은 주로 전체 페이지 단위의 기본 동작을 결정할 때 사용한다고 생각하면 됩니다.\u003c/p\u003e\n\u003cp\u003e즉, Next.js의 최신 앱 구조는 “모든 것을 다 세부적으로 제어하는 시대”라고 이해하면 좋겠네요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003ccode\u003edynamic\u003c/code\u003e 옵션에는 총 네 가지가 있어요. 각 옵션이 어떤 차이를 만드는지 쉽게 정리해볼게요!\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e옵션\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003cth\u003e추가 팁\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eauto\u003c/code\u003e (기본값)\u003c/td\u003e\u003ctd\u003e가능한 한 많이 캐시하지만, 동적으로 동작하고 싶은 컴포넌트는 이를 선택할 수 있도록 허용합니다.\u003c/td\u003e\u003ctd\u003e기본값 그대로 쓰면 딱히 설정하지 않아도 자동으로 적절히 작동해요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eforce-dynamic\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e무조건 동적 렌더링을 합니다. 즉, 각 요청마다 매번 페이지가 새로 렌더링됨.\u003c/td\u003e\u003ctd\u003e내부적으로 모든 fetch() 요청은 \u003ccode\u003e'cache: no-store', next: { revalidate: 0 }\u003c/code\u003e 설정이 되고, \u003ccode\u003efetchCache = force-no-store\u003c/code\u003e 로 강제되죠.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eerror\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e정적 렌더링만 강제하고, 만약 Dynamic API나 캐시되지 않는 데이터를 쓰면 에러 발생!\u003c/td\u003e\u003ctd\u003epages 디렉토리의 \u003ccode\u003egetStaticProps()\u003c/code\u003e와 비슷해요. fetch()는 \u003ccode\u003e'cache: force-cache'\u003c/code\u003e를 사용하고, \u003ccode\u003efetchCache = only-cache\u003c/code\u003e, \u003ccode\u003edynamicParams = false\u003c/code\u003e로 설정됩니다. 동적 파라미터가 필요하면 수동으로 \u003ccode\u003edynamicParams = true\u003c/code\u003e로 바꿔야 해요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eforce-static\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e정적 렌더링 강제 + cookies, headers(), useSearchParams() 호출 시 빈값만 반환하게 만듭니다.\u003c/td\u003e\u003ctd\u003e정말 정적으로만 작동해야 하는 상황에 쓸 수 있어요.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003ch3\u003e참고!\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003egetServerSideProps\u003c/code\u003e, \u003ccode\u003egetStaticProps\u003c/code\u003e에서 \u003ccode\u003edynamic: 'force-dynamic'\u003c/code\u003e이나 \u003ccode\u003edynamic: 'error'\u003c/code\u003e로 마이그레이션하는 방법은 \u003ca href=\"https://nextjs.org/docs/pages/building-your-application/data-fetching/upgrading\" rel=\"nofollow\" target=\"_blank\"\u003e업그레이드 가이드\u003c/a\u003e에서 자세히 설명하고 있으니 참고하세요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003edynamicParams란?\u003c/h3\u003e\n\u003cp\u003e이건 \u003ccode\u003egenerateStaticParams\u003c/code\u003e로 미리 생성하지 않은 동적 경로(\u003ccode\u003e/posts/[id]\u003c/code\u003e 같은)가 방문됐을 때 어떻게 처리할지 결정할 수 있는 옵션이에요. 예를 들면 동적 경로가 너무 많을 때 미리 다 생성할 수 없으니, 방문 시점에 동적으로 처리할지, 아니면 에러를 표시할지 선택할 수 있습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e이렇게 보면 \u003ccode\u003edynamic\u003c/code\u003e 옵션을 상황과 필요에 맞게 조절하는 게 핵심이라는 걸 알 수 있죠. 예를 들어, 자주 바뀌는 데이터를 보여주는 페이지라면 \u003ccode\u003eforce-dynamic\u003c/code\u003e이 유리하고, 가능하면 빌드 타임에 다 끝내고 싶으면 \u003ccode\u003eerror\u003c/code\u003e 혹은 \u003ccode\u003eforce-static\u003c/code\u003e을 쓰는 식이에요.\u003c/p\u003e\n\u003cp\u003e실제로 프로젝트에 적용할 때는 데이터 특성과 사용자 경험을 잘 고려해서 가장 적합한 설정을 찾아 보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e dynamicParams = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// true | false,\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003etrue (기본값): \u003ccode\u003egenerateStaticParams\u003c/code\u003e에 포함되지 않은 동적 세그먼트는 요청 시점에 생성돼요.\u003c/li\u003e\n\u003cli\u003efalse: \u003ccode\u003egenerateStaticParams\u003c/code\u003e에 없는 동적 세그먼트에 접근하면 404 페이지가 반환됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e알아두면 좋은 점:\u003cbr\u003e\n이 옵션은 pages 디렉터리에서 사용하던 \u003ccode\u003egetStaticPaths\u003c/code\u003e의 \u003ccode\u003efallback: true | false | blocking\u003c/code\u003e 옵션을 대체해요.\u003cbr\u003e\n만약 모든 경로를 처음부터 정적으로 렌더링하고 싶다면, \u003ccode\u003egenerateStaticParams\u003c/code\u003e에서 빈 배열을 반환하거나 \u003ccode\u003eexport const dynamic = 'force-static'\u003c/code\u003e을 사용해야 합니다.\u003cbr\u003e\n\u003ccode\u003edynamicParams = true\u003c/code\u003e인 경우, 해당 세그먼트는 스트리밍 서버 렌더링(Streaming Server Rendering)을 사용해요.\u003cbr\u003e\n그리고 \u003ccode\u003edynamic = 'error'\u003c/code\u003e나 \u003ccode\u003edynamic = 'force-static'\u003c/code\u003e을 쓰면 \u003ccode\u003edynamicParams\u003c/code\u003e의 기본값이 false로 바뀝니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch3\u003erevalidate\u003c/h3\u003e\n\u003cp\u003e\u003cem\u003e여기서 부터는 \u003ccode\u003erevalidate\u003c/code\u003e 옵션에 대해 살펴볼게요.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eNext.js의 \u003ccode\u003erevalidate\u003c/code\u003e 옵션은 ISR(Incremental Static Regeneration) 기능을 제어하는 데 사용돼요.\u003cbr\u003e\n간단히 말해서, 특정 페이지를 정적으로 렌더링한 뒤, 일정 시간이 지나면 백그라운드에서 다시 빌드해서 최신 데이터를 반영할 수 있게 해줍니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e revalidate = \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 10초마다 페이지 재생성\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e숫자 (초 단위): 페이지가 이 값만큼의 시간이 지나면 재생성됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efalse\u003c/code\u003e 또는 \u003ccode\u003e0\u003c/code\u003e: ISR 비활성화, 빌드 시 한 번만 생성됨.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e재생성 시점에 방문한 사용자는 기존 페이지를 보고, 백그라운드에서 새 페이지가 만들어지니까 사용자 경험에 끊김이 적어요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e간단 요약\u003c/h3\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e옵션\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003edynamicParams\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e동적 세그먼트가 동적으로 생성되는지 여부 설정\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003erevalidate\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eISR 주기 설정, 몇 초마다 페이지를 다시 생성할지 결정\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003ch3\u003e추가 팁!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003edynamicParams = true\u003c/code\u003e와 ISR 함께 쓰기\u003c/strong\u003e\u003cbr\u003e\n동적 경로가 많거나 데이터가 자주 바뀌는 경우에 유용해요. 첫 요청 때만 페이지를 생성하고, 나중에 ISR로 업데이트할 수 있거든요.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e빈 배열 반환시 모든 경로 미리 생성\u003c/strong\u003e\u003cbr\u003e\n미리 생성할 경로를 다 알 수 있으면 \u003ccode\u003egenerateStaticParams\u003c/code\u003e에서 배열을 반환해 정적으로 빠른 페이지를 만들 수 있어요.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003edynamic = 'force-static'\u003c/code\u003e 사용\u003c/strong\u003e\u003cbr\u003e\n앱 전체를 정적으로 만들고 싶을 땐 이 값을 써서 SSR이나 동적 params 없이 순수 정적 빌드만 하게 설정해보세요.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e여러분 프로젝트에 맞게 이런 설정들을 적절히 활용하면, 효율적인 빌드와 빠른 퍼포먼스를 동시에 잡을 수 있답니다!\u003cbr\u003e\n추가로 Next.js 공식 문서도 자주 확인하면서 최신 기능을 놓치지 않는 게 중요해요~\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e레이아웃이나 페이지에 기본 revalidation(재검증) 시간을 설정할 수 있어요. 여기서 중요한 점은 이 설정이 개별 fetch 요청에서 설정한 revalidate 값을 덮어쓰지 않는다는 거예요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e revalidate = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// false | 0 | number\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e값\u003c/th\u003e\u003cth\u003e의미\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003efalse (기본값)\u003c/td\u003e\u003ctd\u003e기본적으로 \u003ccode\u003eforce-cache\u003c/code\u003e 옵션이 붙은 fetch 요청이나 Dynamic API 사용 이전에 발견된 요청들은 캐싱합니다. 사실상 재검증 기간이 무한대(\u003ccode\u003erevalidate: Infinity\u003c/code\u003e)인 것과 같아서, 리소스를 무한정 캐시하겠다는 의미예요. 그래도 개별 fetch 요청에서 \u003ccode\u003ecache: no-store\u003c/code\u003e 나 \u003ccode\u003erevalidate: 0\u003c/code\u003e을 써서 캐시를 회피하거나, 경로의 기본값보다 짧은 재검증 시간을 가진 양수로 설정해 재검증 빈도를 높이는 건 가능합니다.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e0\u003c/td\u003e\u003ctd\u003e이 옵션을 설정하면 Dynamic API를 사용하지 않더라도 레이아웃이나 페이지가 항상 동적으로 렌더링됩니다. 이 경우 캐시 옵션을 명시하지 않은 fetch 요청은 기본적으로 \u003ccode\u003eno-store\u003c/code\u003e로 동작하지만, \u003ccode\u003eforce-cache\u003c/code\u003e 옵션을 준 요청이나 양의 재검증 시간을 가진 요청은 그대로 유지됩니다.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003enumber (초 단위)\u003c/td\u003e\u003ctd\u003e레이아웃이나 페이지의 기본 재검증 주기를 초 단위 숫자로 설정합니다. 예를 들어 \u003ccode\u003erevalidate = 600\u003c/code\u003e이면 10분마다 재검증합니다.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003ch3\u003e참고할 점\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003erevalidate\u003c/code\u003e 값은 정적으로 분석 가능해야 해요. 예를 들어 \u003ccode\u003erevalidate = 600\u003c/code\u003e은 유효하지만, \u003ccode\u003erevalidate = 60 * 10\u003c/code\u003e 같이 계산식은 안 됩니다. 즉, 값을 변수나 계산식이 아닌 숫자 리터럴로 직접 입력해야 하는 점을 기억하세요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eruntime = 'edge'\u003c/code\u003e를 사용할 때는 \u003ccode\u003erevalidate\u003c/code\u003e 값이 적용되지 않습니다.\u003c/li\u003e\n\u003cli\u003e개발 모드(Development)에서는 모든 페이지가 항상 on-demand로 렌더링되며 캐싱되지 않아요. 덕분에 코드를 바로바로 수정 확인할 수 있고, 재검증 시간을 기다릴 필요가 없답니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003e추가로 알아두면 좋은 팁!\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003erevalidate\u003c/code\u003e를 적절히 사용하면 페이지의 최신성을 유지하면서도 캐싱을 통해 빠른 응답 속도를 얻을 수 있어요. 예를 들어 자주 변경되지 않는 블로그 글 같은 경우에는 긴 재검증 시간(\u003ccode\u003efalse\u003c/code\u003e 또는 큰 숫자)을 줘서 트래픽 부담을 줄이고, 자주 갱신이 필요한 데이터엔 짧은 재검증 시간을 설정하는 식이죠.\u003c/p\u003e\n\u003cp\u003e기본 설정을 잘 활용하면 서버 부하를 줄이면서 사용자에게 더 빠른 웹 경험을 제공할 수 있으니, 상황에 맞는 값을 고민해보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch4\u003e재검증 주기 (Revalidation Frequency)\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e하나의 경로(route)에 속한 레이아웃(layout)과 페이지(page)들 각각이 재검증(revalidate) 시간을 갖는데, 이 중 가장 짧은 재검증 주기가 그 경로 전체의 재검증 주기가 됩니다. 즉, 자식 페이지들도 부모 레이아웃만큼 자주 재검증되도록 보장하는 거죠.\u003c/li\u003e\n\u003cli\u003e개별 fetch 요청(fetch requests)에서는 경로의 기본 재검증 주기보다 더 짧은 재검증 주기를 설정할 수 있어요. 이를 통해 특정 경로나 상황에 맞게 동적으로 재검증 빈도를 높일 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예를 들어, 뉴스 기사 페이지는 자주 업데이트돼야 할 수도 있으니까 이 경우엔 재검증 주기를 더 짧게 설정할 수 있겠죠.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003efetchCache\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003efetchCache\u003c/code\u003e는 클라이언트에서 데이터를 호출할 때 결과를 캐시하는 방식을 다루는 설정이에요. 원격 API를 호출할 때마다 서버에 부담주지 않으면서도, 최신 데이터를 적절히 유지하기 위한 중요한 포인트랍니다. cache-control 헤더 같이 HTTP 표준 캐싱 정책과도 연동되니까, 이 부분을 적절히 활용하면 효율적인 데이터 요청과 성능 향상에 큰 도움이 됩니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003eruntime\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eruntime\u003c/code\u003e은 코드를 실행하는 환경을 의미해요. Next.js 같은 프레임워크에서 \u003ccode\u003eruntime\u003c/code\u003e은 서버 사이드에서 동작하는지, 클라이언트 사이드에서 동작하는지에 따라 달라집니다. 서버에선 Node.js 환경에서 구동되고, 클라이언트에선 브라우저 환경이죠.\u003c/p\u003e\n\u003cp\u003e실제로 \u003ccode\u003eruntime\u003c/code\u003e이 중요해지는 이유는, 일부 기능들은 서버에서만, 또는 클라이언트에서만 동작해야 하기 때문입니다. 예를 들어, 민감한 API 키로 데이터를 불러오는 작업은 서버에서만 실행하도록 하고, 사용자 상호작용에 따른 UI 업데이트는 클라이언트에서 처리하는 식이죠.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e이렇게 \u003ccode\u003erevalidation frequency\u003c/code\u003e부터 \u003ccode\u003efetchCache\u003c/code\u003e, \u003ccode\u003eruntime\u003c/code\u003e까지 조합해서 쓰면, 데이터 신선도 유지와 성능 최적화를 모두 잡을 수 있어요. Next.js 같은 최신 프레임워크를 사용할 때 이 부분들을 잘 이해하고 활용하는 게 개발 생산성 향상에 큰 도움이 되니 참고하시길 바랍니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e애플리케이션 렌더링에는 Node.js 런타임을 사용하는 걸 추천드리고, 미들웨어(Middleware)에는 Edge 런타임만 지원되니 이 점 참고해 주세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e runtime = \u003cspan class=\"hljs-string\"\u003e'nodejs'\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 'nodejs' | 'edge'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e런타임 종류\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003enodejs\u003c/td\u003e\u003ctd\u003e기본값, 앱 렌더링용\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eedge\u003c/td\u003e\u003ctd\u003e미들웨어 전용, 빠른 응답에 적합\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003eNode.js 런타임은 널리 사용되는 서버 환경으로, 풍부한 라이브러리와 안정성 덕분에 앱 렌더링에 최적입니다. 반면, Edge 런타임은 전세계적으로 분산된 서버에서 실행돼 지연시간을 최소화하기 때문에 미들웨어 같은 경량 작업에 딱이죠.\u003c/p\u003e\n\u003cp\u003e더 자세한 런타임 차이점과 사용법은 공식 문서를 참고하시면 도움이 될 거예요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003epreferredRegion\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e preferredRegion = \u003cspan class=\"hljs-string\"\u003e'auto'\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 'auto' | 'global' | 'home' | ['iad1', 'sfo1']\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003epreferredRegion\u003c/code\u003e 옵션은 배포하는 플랫폼에 따라 지원 여부와 사용 가능한 지역이 달라진다는 점, 꼭 기억하세요!\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e참고할 점\u003cbr\u003e\n만약 \u003ccode\u003epreferredRegion\u003c/code\u003e을 따로 지정하지 않으면, 가장 가까운 상위 레이아웃(parent layout)의 설정을 상속받습니다.\u003cbr\u003e\n그리고 최상위 레이아웃(root layout)은 기본값으로 모든 지역(all regions)을 대상으로 합니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003cp\u003e이 기능은 여러 서버 지역(Region) 중 어디서 코드를 실행할지 선택할 때 아주 유용해요. 예를 들어, 사용자가 미국 동부에 많다면 'iad1' 같은 특정 리전을 지정해 그쪽에서 서비스하도록 설정할 수 있죠. 'auto'로 설정하면 Next.js가 가장 적합한 지역을 자동으로 선택해주니 편리합니다.\u003c/p\u003e\n\u003cp\u003e여기서 'global'은 전 세계 여러 지역에 걸쳐 배포하는 경우이고, 'home'은 특정 홈 지역을 지칭할 때 사용됩니다. 또한 배열 형태로 여러 리전을 직접 지정해 여러 곳에서 동시에 실행되도록 할 수도 있답니다.\u003c/p\u003e\n\u003cp\u003e이처럼 \u003ccode\u003epreferredRegion\u003c/code\u003e을 잘 활용하면 사용자 경험을 크게 향상시킬 수 있으니, 필요에 맞게 설정하는 걸 추천드립니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003emaxDuration\u003c/h3\u003e\n\u003cp\u003eNext.js에서는 기본적으로 서버 사이드 로직(페이지 렌더링이나 API 처리 등)의 실행 시간을 제한하지 않아요. 그런데 배포 플랫폼에서 Next.js 빌드 결과에 포함된 \u003ccode\u003emaxDuration\u003c/code\u003e 값을 활용해 실행 시간 제한을 걸 수 있답니다. 예를 들어, Vercel 같은 곳에서는 이 값을 참고해서 서버 로직이 너무 오래 걸리지 않도록 관리할 수 있죠.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e참고\u003c/strong\u003e: \u003ccode\u003emaxDuration\u003c/code\u003e 설정은 Next.js 13.4.10 이상 버전에서만 사용할 수 있어요.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e maxDuration = \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위처럼 \u003ccode\u003emaxDuration\u003c/code\u003e을 5로 설정하면, 해당 서버 로직이 5초 이상 실행되지 않도록 제한할 것을 제안하게 되는 거예요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e보너스 팁!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e왜 실행 시간 제한이 중요할까?\u003c/strong\u003e\u003cbr\u003e\n서버 쪽 로직이 무한루프에 빠지거나 너무 오래 걸리면, 서버 자원을 낭비하고 사용자 경험도 악화돼요. 특히 서버리스 환경에서는 실행 시간이 길어질수록 비용이 더 발생할 수 있어서, 이런 제한을 두는 게 효율적이랍니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003emaxDuration\u003c/code\u003e은 어디에 적용될까?\u003c/strong\u003e\u003cbr\u003e\n서버 컴포넌트의 렌더링 로직이나 API Route 핸들러 등, 서버에서 실행되는 모든 로직에 적용할 수 있어요.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eNext.js 버전 확인법\u003c/strong\u003e\u003cbr\u003e\n프로젝트에서 현재 사용하는 Next.js 버전을 확인하려면 \u003ccode\u003epackage.json\u003c/code\u003e 파일에서 \u003ccode\u003enext\u003c/code\u003e 항목을 보면 되니 참고하세요!\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e혹시 여러분의 프로젝트에서 실행 시간이 너무 긴 서버 코드를 발견했다면, \u003ccode\u003emaxDuration\u003c/code\u003e 설정과 함께 코드를 최적화하는 걸 추천드려요. 작은 설정과 최적화가 서버 환경 전반의 효율성을 크게 올려준답니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cblockquote\u003e\n\u003cp\u003e알아두면 좋은 점:\u003cbr\u003e\n만약 Server Actions를 사용할 경우, 페이지 단위에서 maxDuration을 설정해서 해당 페이지 내 모든 Server Actions의 기본 타임아웃 시간을 변경할 수 있어요.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3\u003egenerateStaticParams\u003c/h3\u003e\n\u003cp\u003egenerateStaticParams 함수는 동적 라우트 세그먼트와 함께 사용할 수 있는데요, 이 함수를 이용하면 빌드 시점에 정적으로 생성할 라우트 세그먼트 파라미터 리스트를 정의할 수 있어요.\u003cbr\u003e\n즉, 요청할 때마다(dynamic하게) 생성하는 것이 아니라, 미리(static하게) 만들어 두는 거죠.\u003c/p\u003e\n\u003cp\u003e이렇게 하면 빌드 시 미리 생성된 페이지 덕분에 사용자 경험이 더 빨라지고 서버 부하도 줄일 수 있어요.\u003c/p\u003e\n\u003cp\u003e조금 더 자세한 내용은 공식 API 문서를 참고해보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e버전 히스토리\u003c/h2\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eVersion\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev15.0.0-RC\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eexport const runtime = \"experimental-edge\"\u003c/code\u003e가 deprecated 되었습니다. 이에 따른 코드 변경을 쉽게 해주는 \u003ca href=\"https://nextjs.org/docs/app/guides/upgrading/codemods#transform-app-router-route-segment-config-runtime-value-from-experimental-edge-to-edge\" rel=\"nofollow\" target=\"_blank\"\u003ecodemod\u003c/a\u003e가 제공됩니다.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e여기서 codemod란, 코드 변환을 자동으로 해주는 도구를 의미해요. 기존에 \u003ccode\u003eexperimental-edge\u003c/code\u003e로 설정해둔 부분을 새로운 방식인 \u003ccode\u003eedge\u003c/code\u003e로 한 번에 바꿔주니까, 직접 손으로 일일이 수정할 필요가 없어서 편하답니다. 혹시 Next.js로 프로젝트를 진행 중이라면 이 부분 꼭 참고하세요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2025-04-22-RouteSegmentConfig"},"buildId":"KUC9M_yIlA1Ugo01xmkHL","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>