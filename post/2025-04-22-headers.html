<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Next.js 15에서 HTTP 요청 헤더 쉽게 작성하기 (headers)  | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-headers" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Next.js 15에서 HTTP 요청 헤더 쉽게 작성하기 (headers)  | TIL" data-gatsby-head="true"/><meta property="og:title" content="Next.js 15에서 HTTP 요청 헤더 쉽게 작성하기 (headers)  | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-headers" data-gatsby-head="true"/><meta name="twitter:title" content="Next.js 15에서 HTTP 요청 헤더 쉽게 작성하기 (headers)  | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2025-04-22 12:41" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/0eef537492fed77a.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/0eef537492fed77a.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-8ded8b979ba73586.js" defer=""></script><script src="/TIL/_next/static/KUC9M_yIlA1Ugo01xmkHL/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/KUC9M_yIlA1Ugo01xmkHL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Next.js 15에서 HTTP 요청 헤더 쉽게 작성하기 (headers) </h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Next.js 15에서 HTTP 요청 헤더 쉽게 작성하기 (headers) " loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Apr 22, 2025</span><span class="posts_reading_time__f7YPP">6<!-- --> min read</span></span></div></div></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>headers 함수 알아보기</h1>
<p><code>headers</code> 함수는 Server Component 내에서 HTTP 요청 헤더를 비동기로 읽을 수 있게 도와주는 유틸리티입니다. 간단히 말해, 클라이언트가 서버에 보낸 요청의 헤더 정보를 서버 컴포넌트 안에서 쉽게 확인할 수 있다는 거죠.</p>
<p>아래 예제를 보고 한번 살펴볼게요!</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { headers } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/headers'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> headersList = <span class="hljs-keyword">await</span> <span class="hljs-title function_">headers</span>()
  <span class="hljs-keyword">const</span> userAgent = headersList.<span class="hljs-title function_">get</span>(<span class="hljs-string">'user-agent'</span>)

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>당신의 User-Agent: {userAgent}<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  )
}
</code></pre>
<ul>
<li>여기서 <code>headers()</code>를 호출하면 요청에 포함된 모든 헤더 정보를 담은 객체를 비동기로 가져옵니다.</li>
<li><code>headersList.get('user-agent')</code>로 특정 헤더(<code>user-agent</code>) 값을 얻을 수 있어요.</li>
<li>이렇게 얻은 헤더 정보로 클라이언트 환경에 따라 다른 내용을 렌더링하거나, API 요청 시 헤더를 조작할 수도 있습니다.</li>
</ul>
<blockquote>
<p>참고로, <code>headers()</code> 함수는 Server Component에서만 사용 가능하기 때문에 클라이언트 컴포넌트에서는 사용할 수 없다는 점 기억하세요!</p>
</blockquote>
<hr>
<h3>헤더 정보 활용 팁</h3>
<ul>
<li><strong>사용자 환경 감지:</strong> User-Agent 헤더를 통해 브라우저 종류나 버전을 확인할 수 있어, 맞춤형 UI를 제공할 때 유용해요.</li>
<li><strong>보안 검사:</strong> 특정 헤더 값을 검사해서 요청이 정상적인지 체크할 수도 있고, 토큰이나 인증 정보를 확인하는 데도 쓰입니다.</li>
<li><strong>로깅 및 분석:</strong> 클라이언트 IP, 언어 설정, 쿠키 등 다양한 헤더 정보를 기록해서 서비스 개선에 활용하세요.</li>
</ul>
<hr>
<p>필요할 때마다 <code>headers</code>를 활용하면 서버 사이드에서 더 스마트하게 사용자 요청을 다룰 수 있으니 꼭 기억해두세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>파라미터</h3>
<p>headers는 별도의 파라미터를 받지 않습니다.</p>
<h3>반환값</h3>
<p>headers는 읽기 전용(Web Headers) 객체를 반환합니다.</p>
<hr>
<p>여기서 Web Headers 객체란, 웹 요청과 응답에 포함되는 헤더 정보를 나타내는 객체예요. 쉽게 말해서, 서버나 클라이언트가 주고받는 부가 정보를 가지고 있는 거죠. 주로 콘텐츠 타입(Content-Type), 인증 정보(Authorization), 캐시 제어(Cache-Control) 등 다양한 정보를 담고 있답니다.</p>
<p>이 객체가 읽기 전용이라서, 값들을 마음대로 바꾸지는 못하지만, 필요한 경우 새로운 헤더를 만들어서 요청에 추가할 수 있어요. 혹시 헤더를 조작하거나 확인하는 작업이 필요하다면, 이 점 참고하면 좋을 것 같아요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Headers 객체 메서드 정리해봤어요! 웹 개발할 때 Headers 다룰 일 많으니 참고해 보세요.</p>

































<table><thead><tr><th>메서드</th><th>설명</th></tr></thead><tbody><tr><td>Headers.entries()</td><td>Headers 객체에 들어있는 모든 키/값 쌍을 돌면서 이터레이터(iterator)를 반환해요.</td></tr><tr><td>Headers.forEach()</td><td>Headers 내 각 키/값 쌍에 대해 한 번씩 제공한 함수를 실행해요.</td></tr><tr><td>Headers.get()</td><td>특정 이름을 가진 헤더의 모든 값을 문자열(String)로 반환해요.</td></tr><tr><td>Headers.has()</td><td>해당 헤더가 존재하는지 여부를 boolean으로 알려줘요.</td></tr><tr><td>Headers.keys()</td><td>모든 키를 순회할 수 있는 이터레이터를 반환해요.</td></tr><tr><td>Headers.values()</td><td>모든 값을 순회할 수 있는 이터레이터를 반환해요.</td></tr></tbody></table>
<hr>
<h2>알아두면 좋은 점</h2>
<ul>
<li>
<p><code>headers</code> 함수는 비동기(async) 함수라 Promise를 반환해요. 그래서 <code>async/await</code> 문법이나 React에서 제공하는 hook들을 사용해야 합니다.</p>
</li>
<li>
<p>Next.js 14버전 이전까진 <code>headers</code>가 동기 함수였는데, Next.js 15버전에서도 아직 동기 방식으로 접근은 가능하지만 점점 사라질 예정이에요. 호환성 때문에 아직 남겨두고 있긴 합니다.</p>
</li>
<li>
<p><code>headers</code>는 읽기 전용(Read-only)입니다. 그래서 요청 헤더를 새로 설정하거나 삭제하는 건 불가능해요.</p>
</li>
<li>
<p><code>headers</code>가 동적으로 API 값을 반환하기 때문에, 해당 라우트(페이지)는 자동으로 ‘동적 렌더링’ 모드로 들어갑니다. 정적 생성(Static Generation)이 필요한 상황에서는 주의하세요.</p>
</li>
</ul>
<hr>
<p>혹시 <code>Headers</code> 객체를 사용할 때 어떻게 데이터를 순회하는지 궁금하다면, 다음처럼 간단한 예제도 있어요!</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> headers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Headers</span>();
headers.<span class="hljs-title function_">append</span>(<span class="hljs-string">'Content-Type'</span>, <span class="hljs-string">'application/json'</span>);
headers.<span class="hljs-title function_">append</span>(<span class="hljs-string">'X-Custom-Header'</span>, <span class="hljs-string">'Value123'</span>);

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> headers.<span class="hljs-title function_">entries</span>()) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${key}</span>: <span class="hljs-subst">${value}</span>`</span>);
}

headers.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${key}</span> = <span class="hljs-subst">${value}</span>`</span>);
});
</code></pre>
<p>이런 식으로 <code>entries()</code>로 반복문 사용하거나 <code>forEach</code>를 바로 쓸 수 있어요.</p>
<p>개발하시면서 Headers 객체를 다룰 일이 많다면, 이런 기본 메서드들을 익혀두면 훨씬 편리합니다. 꼭 기억해두세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>Authorization 헤더 사용하기</h3>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { headers } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/headers'</span>
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> authorization = (<span class="hljs-keyword">await</span> <span class="hljs-title function_">headers</span>()).<span class="hljs-title function_">get</span>(<span class="hljs-string">'authorization'</span>)
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'...'</span>, {
    <span class="hljs-attr">headers</span>: { authorization }, <span class="hljs-comment">// Authorization 헤더 전달하기</span>
  })
  <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>()
 
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>{user.name}<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span></span>
}
</code></pre>
<p>여기서 중요한 점은, Next.js 13부터 <code>headers()</code> 함수가 비동기 함수가 되었다는 거예요. 그래서 <code>await headers()</code>로 호출해야 하고, 그 결과에서 <code>authorization</code> 헤더 값을 가져올 수 있습니다. 그리고 이 값을 fetch 요청의 헤더로 그대로 넘겨줘서, 서버 간 인증 정보를 전달할 수 있죠.</p>
<p>이 방법은 특히 API 라우트나 서버 컴포넌트에서 클라이언트가 보낸 헤더를 그대로 백엔드 API에 넘길 때 유용해요. 예를 들어, JWT 토큰을 포함한 Authorization 헤더를 안전하게 전달할 수 있다는 뜻이죠.</p>
<p>다만, Authorization 헤더에는 민감한 정보가 많이 담기므로, 꼭 신뢰할 수 있는 환경에서만 이렇게 포워딩하고, 노출되지 않도록 주의해야 합니다.</p>
<hr>
<h2>버전 히스토리</h2>

















<table><thead><tr><th>Version</th><th>Changes</th></tr></thead><tbody><tr><td><code>v15.0.0-RC</code></td><td><code>headers</code>가 이제 비동기 함수가 되었습니다. 관련 코드 변경을 도와주는 <a href="/docs/app/guides/upgrading/codemods#150">codemod</a>가 제공됩니다.</td></tr><tr><td><code>v13.0.0</code></td><td><code>headers</code> 함수가 도입되었습니다.</td></tr></tbody></table>
<hr>
<p>참고로, 예전 Next.js 버전에서는 <code>headers</code>가 동기 함수였는데, 비동기 함수로 변경되면서 더 유연한 비동기 작업이 가능해졌어요. 업그레이드할 때는 이 점 꼭 체크하세요! 그리고 <code>authorization</code> 외에도 필요한 다른 헤더들도 동일한 방식으로 가져와서 활용할 수 있답니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Next.js 15에서 HTTP 요청 헤더 쉽게 작성하기 (headers) ","description":"","date":"2025-04-22 12:41","slug":"2025-04-22-headers","content":"\n\n# headers 함수 알아보기\n\n`headers` 함수는 Server Component 내에서 HTTP 요청 헤더를 비동기로 읽을 수 있게 도와주는 유틸리티입니다. 간단히 말해, 클라이언트가 서버에 보낸 요청의 헤더 정보를 서버 컴포넌트 안에서 쉽게 확인할 수 있다는 거죠.\n\n아래 예제를 보고 한번 살펴볼게요!\n\n```js\nimport { headers } from 'next/headers'\n\nexport default async function Page() {\n  const headersList = await headers()\n  const userAgent = headersList.get('user-agent')\n\n  return (\n    \u003cdiv\u003e\n      \u003cp\u003e당신의 User-Agent: {userAgent}\u003c/p\u003e\n    \u003c/div\u003e\n  )\n}\n```\n\n- 여기서 `headers()`를 호출하면 요청에 포함된 모든 헤더 정보를 담은 객체를 비동기로 가져옵니다.\n- `headersList.get('user-agent')`로 특정 헤더(`user-agent`) 값을 얻을 수 있어요.\n- 이렇게 얻은 헤더 정보로 클라이언트 환경에 따라 다른 내용을 렌더링하거나, API 요청 시 헤더를 조작할 수도 있습니다.\n\n\u003e 참고로, `headers()` 함수는 Server Component에서만 사용 가능하기 때문에 클라이언트 컴포넌트에서는 사용할 수 없다는 점 기억하세요!\n\n---\n\n### 헤더 정보 활용 팁\n\n- **사용자 환경 감지:** User-Agent 헤더를 통해 브라우저 종류나 버전을 확인할 수 있어, 맞춤형 UI를 제공할 때 유용해요.\n- **보안 검사:** 특정 헤더 값을 검사해서 요청이 정상적인지 체크할 수도 있고, 토큰이나 인증 정보를 확인하는 데도 쓰입니다.\n- **로깅 및 분석:** 클라이언트 IP, 언어 설정, 쿠키 등 다양한 헤더 정보를 기록해서 서비스 개선에 활용하세요.\n\n---\n\n필요할 때마다 `headers`를 활용하면 서버 사이드에서 더 스마트하게 사용자 요청을 다룰 수 있으니 꼭 기억해두세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 파라미터\n\nheaders는 별도의 파라미터를 받지 않습니다.\n\n### 반환값\n\nheaders는 읽기 전용(Web Headers) 객체를 반환합니다.\n\n---\n\n여기서 Web Headers 객체란, 웹 요청과 응답에 포함되는 헤더 정보를 나타내는 객체예요. 쉽게 말해서, 서버나 클라이언트가 주고받는 부가 정보를 가지고 있는 거죠. 주로 콘텐츠 타입(Content-Type), 인증 정보(Authorization), 캐시 제어(Cache-Control) 등 다양한 정보를 담고 있답니다.\n\n이 객체가 읽기 전용이라서, 값들을 마음대로 바꾸지는 못하지만, 필요한 경우 새로운 헤더를 만들어서 요청에 추가할 수 있어요. 혹시 헤더를 조작하거나 확인하는 작업이 필요하다면, 이 점 참고하면 좋을 것 같아요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nHeaders 객체 메서드 정리해봤어요! 웹 개발할 때 Headers 다룰 일 많으니 참고해 보세요.\n\n| 메서드              | 설명                                                                                           |\n|---------------------|------------------------------------------------------------------------------------------------|\n| Headers.entries()   | Headers 객체에 들어있는 모든 키/값 쌍을 돌면서 이터레이터(iterator)를 반환해요.                      |\n| Headers.forEach()   | Headers 내 각 키/값 쌍에 대해 한 번씩 제공한 함수를 실행해요.                                    |\n| Headers.get()       | 특정 이름을 가진 헤더의 모든 값을 문자열(String)로 반환해요.                                    |\n| Headers.has()       | 해당 헤더가 존재하는지 여부를 boolean으로 알려줘요.                                              |\n| Headers.keys()      | 모든 키를 순회할 수 있는 이터레이터를 반환해요.                                                 |\n| Headers.values()    | 모든 값을 순회할 수 있는 이터레이터를 반환해요.                                                 |\n\n---\n\n## 알아두면 좋은 점\n\n- `headers` 함수는 비동기(async) 함수라 Promise를 반환해요. 그래서 `async/await` 문법이나 React에서 제공하는 hook들을 사용해야 합니다.\n\n- Next.js 14버전 이전까진 `headers`가 동기 함수였는데, Next.js 15버전에서도 아직 동기 방식으로 접근은 가능하지만 점점 사라질 예정이에요. 호환성 때문에 아직 남겨두고 있긴 합니다.\n\n- `headers`는 읽기 전용(Read-only)입니다. 그래서 요청 헤더를 새로 설정하거나 삭제하는 건 불가능해요.\n\n- `headers`가 동적으로 API 값을 반환하기 때문에, 해당 라우트(페이지)는 자동으로 ‘동적 렌더링’ 모드로 들어갑니다. 정적 생성(Static Generation)이 필요한 상황에서는 주의하세요.\n\n---\n\n혹시 `Headers` 객체를 사용할 때 어떻게 데이터를 순회하는지 궁금하다면, 다음처럼 간단한 예제도 있어요!\n\n```js\nconst headers = new Headers();\nheaders.append('Content-Type', 'application/json');\nheaders.append('X-Custom-Header', 'Value123');\n\nfor (const [key, value] of headers.entries()) {\n  console.log(`${key}: ${value}`);\n}\n\nheaders.forEach((value, key) =\u003e {\n  console.log(`${key} = ${value}`);\n});\n```\n\n이런 식으로 `entries()`로 반복문 사용하거나 `forEach`를 바로 쓸 수 있어요.\n\n개발하시면서 Headers 객체를 다룰 일이 많다면, 이런 기본 메서드들을 익혀두면 훨씬 편리합니다. 꼭 기억해두세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Authorization 헤더 사용하기\n\n```js\nimport { headers } from 'next/headers'\n \nexport default async function Page() {\n  const authorization = (await headers()).get('authorization')\n  const res = await fetch('...', {\n    headers: { authorization }, // Authorization 헤더 전달하기\n  })\n  const user = await res.json()\n \n  return \u003ch1\u003e{user.name}\u003c/h1\u003e\n}\n```\n\n여기서 중요한 점은, Next.js 13부터 `headers()` 함수가 비동기 함수가 되었다는 거예요. 그래서 `await headers()`로 호출해야 하고, 그 결과에서 `authorization` 헤더 값을 가져올 수 있습니다. 그리고 이 값을 fetch 요청의 헤더로 그대로 넘겨줘서, 서버 간 인증 정보를 전달할 수 있죠.\n\n이 방법은 특히 API 라우트나 서버 컴포넌트에서 클라이언트가 보낸 헤더를 그대로 백엔드 API에 넘길 때 유용해요. 예를 들어, JWT 토큰을 포함한 Authorization 헤더를 안전하게 전달할 수 있다는 뜻이죠.\n\n다만, Authorization 헤더에는 민감한 정보가 많이 담기므로, 꼭 신뢰할 수 있는 환경에서만 이렇게 포워딩하고, 노출되지 않도록 주의해야 합니다.\n\n---\n\n## 버전 히스토리\n\n| Version         | Changes                                                                                      |\n|-----------------|----------------------------------------------------------------------------------------------|\n| `v15.0.0-RC`    | `headers`가 이제 비동기 함수가 되었습니다. 관련 코드 변경을 도와주는 \u003ca href=\"/docs/app/guides/upgrading/codemods#150\"\u003ecodemod\u003c/a\u003e가 제공됩니다. |\n| `v13.0.0`       | `headers` 함수가 도입되었습니다.                                                              |\n\n---\n\n참고로, 예전 Next.js 버전에서는 `headers`가 동기 함수였는데, 비동기 함수로 변경되면서 더 유연한 비동기 작업이 가능해졌어요. 업그레이드할 때는 이 점 꼭 체크하세요! 그리고 `authorization` 외에도 필요한 다른 헤더들도 동일한 방식으로 가져와서 활용할 수 있답니다.","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":6},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003eheaders 함수 알아보기\u003c/h1\u003e\n\u003cp\u003e\u003ccode\u003eheaders\u003c/code\u003e 함수는 Server Component 내에서 HTTP 요청 헤더를 비동기로 읽을 수 있게 도와주는 유틸리티입니다. 간단히 말해, 클라이언트가 서버에 보낸 요청의 헤더 정보를 서버 컴포넌트 안에서 쉽게 확인할 수 있다는 거죠.\u003c/p\u003e\n\u003cp\u003e아래 예제를 보고 한번 살펴볼게요!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { headers } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/headers'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e headersList = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eheaders\u003c/span\u003e()\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e userAgent = headersList.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'user-agent'\u003c/span\u003e)\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e당신의 User-Agent: {userAgent}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e여기서 \u003ccode\u003eheaders()\u003c/code\u003e를 호출하면 요청에 포함된 모든 헤더 정보를 담은 객체를 비동기로 가져옵니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eheadersList.get('user-agent')\u003c/code\u003e로 특정 헤더(\u003ccode\u003euser-agent\u003c/code\u003e) 값을 얻을 수 있어요.\u003c/li\u003e\n\u003cli\u003e이렇게 얻은 헤더 정보로 클라이언트 환경에 따라 다른 내용을 렌더링하거나, API 요청 시 헤더를 조작할 수도 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e참고로, \u003ccode\u003eheaders()\u003c/code\u003e 함수는 Server Component에서만 사용 가능하기 때문에 클라이언트 컴포넌트에서는 사용할 수 없다는 점 기억하세요!\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch3\u003e헤더 정보 활용 팁\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e사용자 환경 감지:\u003c/strong\u003e User-Agent 헤더를 통해 브라우저 종류나 버전을 확인할 수 있어, 맞춤형 UI를 제공할 때 유용해요.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e보안 검사:\u003c/strong\u003e 특정 헤더 값을 검사해서 요청이 정상적인지 체크할 수도 있고, 토큰이나 인증 정보를 확인하는 데도 쓰입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e로깅 및 분석:\u003c/strong\u003e 클라이언트 IP, 언어 설정, 쿠키 등 다양한 헤더 정보를 기록해서 서비스 개선에 활용하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e필요할 때마다 \u003ccode\u003eheaders\u003c/code\u003e를 활용하면 서버 사이드에서 더 스마트하게 사용자 요청을 다룰 수 있으니 꼭 기억해두세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003e파라미터\u003c/h3\u003e\n\u003cp\u003eheaders는 별도의 파라미터를 받지 않습니다.\u003c/p\u003e\n\u003ch3\u003e반환값\u003c/h3\u003e\n\u003cp\u003eheaders는 읽기 전용(Web Headers) 객체를 반환합니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e여기서 Web Headers 객체란, 웹 요청과 응답에 포함되는 헤더 정보를 나타내는 객체예요. 쉽게 말해서, 서버나 클라이언트가 주고받는 부가 정보를 가지고 있는 거죠. 주로 콘텐츠 타입(Content-Type), 인증 정보(Authorization), 캐시 제어(Cache-Control) 등 다양한 정보를 담고 있답니다.\u003c/p\u003e\n\u003cp\u003e이 객체가 읽기 전용이라서, 값들을 마음대로 바꾸지는 못하지만, 필요한 경우 새로운 헤더를 만들어서 요청에 추가할 수 있어요. 혹시 헤더를 조작하거나 확인하는 작업이 필요하다면, 이 점 참고하면 좋을 것 같아요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eHeaders 객체 메서드 정리해봤어요! 웹 개발할 때 Headers 다룰 일 많으니 참고해 보세요.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e메서드\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eHeaders.entries()\u003c/td\u003e\u003ctd\u003eHeaders 객체에 들어있는 모든 키/값 쌍을 돌면서 이터레이터(iterator)를 반환해요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eHeaders.forEach()\u003c/td\u003e\u003ctd\u003eHeaders 내 각 키/값 쌍에 대해 한 번씩 제공한 함수를 실행해요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eHeaders.get()\u003c/td\u003e\u003ctd\u003e특정 이름을 가진 헤더의 모든 값을 문자열(String)로 반환해요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eHeaders.has()\u003c/td\u003e\u003ctd\u003e해당 헤더가 존재하는지 여부를 boolean으로 알려줘요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eHeaders.keys()\u003c/td\u003e\u003ctd\u003e모든 키를 순회할 수 있는 이터레이터를 반환해요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eHeaders.values()\u003c/td\u003e\u003ctd\u003e모든 값을 순회할 수 있는 이터레이터를 반환해요.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003ch2\u003e알아두면 좋은 점\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eheaders\u003c/code\u003e 함수는 비동기(async) 함수라 Promise를 반환해요. 그래서 \u003ccode\u003easync/await\u003c/code\u003e 문법이나 React에서 제공하는 hook들을 사용해야 합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eNext.js 14버전 이전까진 \u003ccode\u003eheaders\u003c/code\u003e가 동기 함수였는데, Next.js 15버전에서도 아직 동기 방식으로 접근은 가능하지만 점점 사라질 예정이에요. 호환성 때문에 아직 남겨두고 있긴 합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eheaders\u003c/code\u003e는 읽기 전용(Read-only)입니다. 그래서 요청 헤더를 새로 설정하거나 삭제하는 건 불가능해요.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eheaders\u003c/code\u003e가 동적으로 API 값을 반환하기 때문에, 해당 라우트(페이지)는 자동으로 ‘동적 렌더링’ 모드로 들어갑니다. 정적 생성(Static Generation)이 필요한 상황에서는 주의하세요.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e혹시 \u003ccode\u003eHeaders\u003c/code\u003e 객체를 사용할 때 어떻게 데이터를 순회하는지 궁금하다면, 다음처럼 간단한 예제도 있어요!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e headers = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHeaders\u003c/span\u003e();\nheaders.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Content-Type'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'application/json'\u003c/span\u003e);\nheaders.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'X-Custom-Header'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'Value123'\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [key, value] \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e headers.\u003cspan class=\"hljs-title function_\"\u003eentries\u003c/span\u003e()) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${key}\u003c/span\u003e: \u003cspan class=\"hljs-subst\"\u003e${value}\u003c/span\u003e`\u003c/span\u003e);\n}\n\nheaders.\u003cspan class=\"hljs-title function_\"\u003eforEach\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003evalue, key\u003c/span\u003e) =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${key}\u003c/span\u003e = \u003cspan class=\"hljs-subst\"\u003e${value}\u003c/span\u003e`\u003c/span\u003e);\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이런 식으로 \u003ccode\u003eentries()\u003c/code\u003e로 반복문 사용하거나 \u003ccode\u003eforEach\u003c/code\u003e를 바로 쓸 수 있어요.\u003c/p\u003e\n\u003cp\u003e개발하시면서 Headers 객체를 다룰 일이 많다면, 이런 기본 메서드들을 익혀두면 훨씬 편리합니다. 꼭 기억해두세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003eAuthorization 헤더 사용하기\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { headers } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/headers'\u003c/span\u003e\n \n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e authorization = (\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eheaders\u003c/span\u003e()).\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'authorization'\u003c/span\u003e)\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e res = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'...'\u003c/span\u003e, {\n    \u003cspan class=\"hljs-attr\"\u003eheaders\u003c/span\u003e: { authorization }, \u003cspan class=\"hljs-comment\"\u003e// Authorization 헤더 전달하기\u003c/span\u003e\n  })\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e user = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e res.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e()\n \n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e{user.name}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 중요한 점은, Next.js 13부터 \u003ccode\u003eheaders()\u003c/code\u003e 함수가 비동기 함수가 되었다는 거예요. 그래서 \u003ccode\u003eawait headers()\u003c/code\u003e로 호출해야 하고, 그 결과에서 \u003ccode\u003eauthorization\u003c/code\u003e 헤더 값을 가져올 수 있습니다. 그리고 이 값을 fetch 요청의 헤더로 그대로 넘겨줘서, 서버 간 인증 정보를 전달할 수 있죠.\u003c/p\u003e\n\u003cp\u003e이 방법은 특히 API 라우트나 서버 컴포넌트에서 클라이언트가 보낸 헤더를 그대로 백엔드 API에 넘길 때 유용해요. 예를 들어, JWT 토큰을 포함한 Authorization 헤더를 안전하게 전달할 수 있다는 뜻이죠.\u003c/p\u003e\n\u003cp\u003e다만, Authorization 헤더에는 민감한 정보가 많이 담기므로, 꼭 신뢰할 수 있는 환경에서만 이렇게 포워딩하고, 노출되지 않도록 주의해야 합니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e버전 히스토리\u003c/h2\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eVersion\u003c/th\u003e\u003cth\u003eChanges\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev15.0.0-RC\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eheaders\u003c/code\u003e가 이제 비동기 함수가 되었습니다. 관련 코드 변경을 도와주는 \u003ca href=\"/docs/app/guides/upgrading/codemods#150\"\u003ecodemod\u003c/a\u003e가 제공됩니다.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev13.0.0\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eheaders\u003c/code\u003e 함수가 도입되었습니다.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003cp\u003e참고로, 예전 Next.js 버전에서는 \u003ccode\u003eheaders\u003c/code\u003e가 동기 함수였는데, 비동기 함수로 변경되면서 더 유연한 비동기 작업이 가능해졌어요. 업그레이드할 때는 이 점 꼭 체크하세요! 그리고 \u003ccode\u003eauthorization\u003c/code\u003e 외에도 필요한 다른 헤더들도 동일한 방식으로 가져와서 활용할 수 있답니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2025-04-22-headers"},"buildId":"KUC9M_yIlA1Ugo01xmkHL","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>