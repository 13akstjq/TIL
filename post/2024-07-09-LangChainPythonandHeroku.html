<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>2024년 최신 LangChain, Python, Heroku 사용 방법 실제 사용 사례와 팁 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2024-07-09-LangChainPythonandHeroku" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="2024년 최신 LangChain, Python, Heroku 사용 방법 실제 사용 사례와 팁 | TIL" data-gatsby-head="true"/><meta property="og:title" content="2024년 최신 LangChain, Python, Heroku 사용 방법 실제 사용 사례와 팁 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-07-09-LangChainPythonandHeroku_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2024-07-09-LangChainPythonandHeroku" data-gatsby-head="true"/><meta name="twitter:title" content="2024년 최신 LangChain, Python, Heroku 사용 방법 실제 사용 사례와 팁 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-07-09-LangChainPythonandHeroku_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-09 20:59" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/TIL/_next/static/chunks/463-925361deb4cec4b1.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-9d7ebbd29b9e08ce.js" defer=""></script><script src="/TIL/_next/static/71zJMhK9mFbQV7s02rMGq/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/71zJMhK9mFbQV7s02rMGq/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">2024년 최신 LangChain, Python, Heroku 사용 방법 실제 사용 사례와 팁</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="2024년 최신 LangChain, Python, Heroku 사용 방법 실제 사용 사례와 팁" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 9, 2024</span><span class="posts_reading_time__f7YPP">20<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-07-09-LangChainPythonandHeroku&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/TIL/assets/img/2024-07-09-LangChainPythonandHeroku_0.png">
<h2>커피숍에서 코딩하기</h2>
<p>2022년 말 이후 ChatGPT의 출시 및 널리 사용되면서 대형 언어 모델(LLM) 및 생성적 AI(GenAI)에서 비롯된 도구, 제품 및 혁신에 대한 뉴스 폭풍이 몰려왔습니다. 많은 기술 유행이 몇 년 내에 사라지는 반면, LLM 및 GenAI가 여기에 남아있음이 분명합니다.</p>
<p>이러한 새로운 도구와 제품의 배경에 이어지는 다양한 도구들과 제품들에 대해 궁금한 적이 있나요? 또한 개발자와 최종 사용자 모두가 활용하는 이러한 도구들이 어떻게 운영되는지 궁금해할 수도 있습니다. 이러한 도구와 응용 프로그램 중 많은 경우, LangChain, Python 및 Heroku를 알 수 있습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 문서에서는 다룰 조각들입니다. 인공 지능/기계 학습 개발자들이 이들을 사용하여 복잡한 LLM 파이프라인 구성 요소를 구축하고 쉽게 배포하는 실제 예시를 살펴보겠습니다.</p>
<h1>LLM 워크플로우와 파이프라인 해독하기</h1>
<p>기계 학습 파이프라인과 워크플로우는 AI 세계에 입문한 이들에게는 불투명해 보일 수 있습니다. 특히 LLM과 그와 관련된 도구에서는 더 그렇습니다. 왜냐하면 이들은 (비교적으로) 새로운 기술들이기 때문입니다. LLM을 처리하는 것은 도전적일 수 있습니다. 특히 엔지니어링이 강화되고 제품용으로 준비된 파이프라인, 워크플로 및 배포를 만들려고 할 때입니다. 새로운 도구들, 빠르게 변화하는 문서 및 제한된 지침들로 인해 어디서부터 시작하거나 무엇을 사용해야 할지를 알기 어려울 수 있습니다. 그래서 LangChain과 Heroku의 기본부터 시작해 봅시다.</p>
<p>LangChain의 문서에는 다음과 같이 나와 있습니다: "LangChain은 언어 모델을 기반으로 한 애플리케이션을 개발할 수 있는 프레임워크입니다."</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>한편, Heroku는 다음과 같이 자신을 설명합니다: "Heroku는 회사가 앱을 구축, 전달, 모니터링 및 확장할 수 있는 클라우드 플랫폼입니다. 아이디어에서 URL로 이동하는 가장 빠른 방법입니다. 모든 인프라 문제를 우회합니다."</p>
<p>이를 LLM 애플리케이션 구축의 맥락으로 놓으면, LangChain과 Heroku는 최고의 조합입니다. 우리는 LLM 애플리케이션을 구축하기 위해 테스트된 쉬운 프레임워크(LangChain)가 필요하고, 그 애플리케이션을 배포하고 호스팅할 방법(Heroku)이 필요합니다.</p>
<p>이제 각 기술에 대해 자세히 살펴보겠습니다.</p>
<h2>LangChain 탐구하기</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>LangChain을 사용하는 방법에 대해 간단히 이야기해 봅시다. LangChain은 LLM 모델과 사용 사례를 기반으로 한 애플리케이션을 개발하는 개발자들을 지원하는 프레임워크입니다. Python, JavaScript, TypeScript를 지원합니다. 예를 들어, 사용자 입력에 기반을 둔 보고서를 생성하거나 고객 지원 응답을 자동화하는 도구를 개발 중이라고 가정해 봅시다. LangChain은 프로젝트의 골조로 작용하여 언어 모델을 효율적으로 솔루션에 통합할 수 있는 도구와 구조를 제공합니다.</p>
<p>LangChain 내에는 몇 가지 주요 구성 요소가 있습니다:</p>
<ul>
<li>에이전트: 에이전트는 우리의 요구 사항에 따라 작업을 수행하기 위해 언어 모델과 상호 작용하는 구성 요소입니다. 이것은 우리 애플리케이션의 두뇌로, 언어 모델의 기능을 활용하여 텍스트를 이해하고 생성합니다.</li>
<li>체인: 에이전트가 작업을 수행하는 데 따르는 동작이나 프로세스의 시퀀스입니다. 예를 들어, 고객 지원을 자동화한다면 체인은 고객 질문 수락, 관련 정보 찾기, 그리고 응답 작성 등의 단계를 포함할 수 있습니다.</li>
<li>템플릿: 템플릿은 언어 모델의 출력을 구조화하는 방법을 제공합니다. 예를 들어, 애플리케이션이 보고서를 생성하는 경우, 모델의 출력을 기반으로 이러한 보고서를 일관되게 포맷하는 데 도움이 되는 템플릿을 활용할 것입니다.</li>
<li>LangServe: 개발자가 LangChain 애플리케이션을 REST API로 배포하고 제공할 수 있도록 합니다.</li>
<li>LangSmith: 이 도구는 언어 모델 애플리케이션의 상호 작용을 평가, 테스트 및 정제하여 제품을 상용화할 준비를 얻도록 도와줍니다.</li>
</ul>
<p>LangChain은 인기 있는 AI 및 LLM 애플리케이션을 구축하기 위한 프레임워크이며, 그 이유를 쉽게 이해할 수 있습니다. LangChain은 제품을 끝까지 구축하고 배포하는 데 필요한 기능을 제공합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>Heroku를 탐험해보세요</h2>
<p>Heroku는 클라우드 플랫폼 서비스(PaaS)로서 애플리케이션을 클라우드에 간단하게 배포할 수 있게 해주어 가장 잘 알려져 있습니다. 개발자들은 주로 코드와 구현에만 집중하고 싶어합니다. 이미 복잡한 데이터 파이프라인과 LLM 기반 애플리케이션을 다루고 있을 때는 서버, 네트워크, 지속적인 저장소와 같은 인프라 문제를 다루는데 필요한 자원이나 전문지식이 부족할 수 있습니다.</p>
<p>Heroku를 통해 애플리케이션을 쉽게 배포할 수 있기 때문에 프로젝트를 제품화하는 주요 장벽이 손쉽게 처리됩니다.</p>
<h1>LangChain으로 빌드하기</h1>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>LangChain이 LLM 애플리케이션에서 어떻게 사용되는지 더 잘 이해하기 위해 몇 가지 예제 문제를 통해 과정을 명확하게 알아보겠습니다. 일반적으로, LLM 체인을 구성하기 위해 다음 항목을 연결하여 단일 워크플로우를 형성합니다:</p>
<ul>
<li>사용자의 매개 변수를 기반으로 프롬프트를 생성하는 프롬프트 템플릿으로 시작합니다.</li>
<li>언어 모델이 원래 훈련되지 않은 데이터를 검색하는 리트리버를 체인에 추가합니다(예: 문서 데이터베이스에서).</li>
<li>더 나은 응답을 형성하기 위해 언어 모델에 맥락을 제공하기 위해 채팅 기록을 포함하는 회화 검색 체이닝을 추가합니다.</li>
<li>실제 LLM과 상호 작용하는 에이전트를 추가합니다.</li>
</ul>
<p>LangChain을 사용하면 LLM 애플리케이션의 기본을 형성하는 프로세스를 연결할 수 있습니다. 이는 우리의 구현을 쉽고 친근하게 만듭니다. 간단한 예제를 통해 함께 살펴보겠습니다.</p>
<p>이 예시에서는 OpenAI와 함께 작업하겠습니다. 프롬프트를 이렇게 작성해 보겠습니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>안녕하세요! LangChain을 사용하고 계시다니 멋지네요! 여기 저희 훌륭한 가상 트레이너, OpenAI에게 문의하시면 됩니다. 사용자의 질문을 입력해 주세요. 요청하신 내용에 따라 OpenAI가 도움을 들어드리겠습니다. 함께 성공적인 코딩 여정을 시작해봐요!</p>
<p>Markdown 형식을 사용해 표를 만들어보세요:</p>













<table><thead><tr><th>컬럼1</th><th>컬럼2</th></tr></thead><tbody><tr><td>데이터1</td><td>데이터2</td></tr></tbody></table>
<p>그럼 좋은 하루 보내세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>main.py라는 새 파일을 만들겠습니다. 우리의 기본 Python 코드는 다음과 같습니다:</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> os
<span class="hljs-keyword">from</span> langchain_core.prompts <span class="hljs-keyword">import</span> ChatPromptTemplate
<span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> ChatOpenAI

my_prompt = ChatPromptTemplate.from_messages([
    (<span class="hljs-string">"system"</span>, <span class="hljs-string">"You are a friendly and encouraging fitness trainer."</span>),
    (<span class="hljs-string">"user"</span>, <span class="hljs-string">"{input}"</span>)
])

llm = ChatOpenAI(openai_api_key=os.getenv(<span class="hljs-string">"OPENAI_API_KEY"</span>])

chain = my_prompt | llm
</code></pre>
<p>여기서 그만입니다! 이 기본 예제에서는 LangChain을 사용하여 프롬프트 템플릿과 OpenAI 에이전트를 연결했습니다.</p>
<p>이를 명령줄에서 사용하려면 다음 코드를 추가해야합니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">user_input = <span class="hljs-title function_">input</span>(<span class="hljs-string">"피트니스 목표와 관련된 질문을 하세요.\n"</span>);
response = chain.<span class="hljs-title function_">invoke</span>({
  <span class="hljs-attr">input</span>: user_input,
});

<span class="hljs-title function_">print</span>(response);
</code></pre>
<p>위에서 코드블록을 보면 우리 애플리케이션을 명령줄에서 테스트할 수 있습니다.</p>
<pre><code class="hljs language-js">(venv) $ <span class="hljs-variable constant_">OPENAI_API_KEY</span>=insert-key-here python3 main.<span class="hljs-property">py</span>
피트니스 목표와 관련된 질문을 하세요.
<span class="hljs-number">60</span>초 동안 플랭크를 유지하는 방법은 무엇인가요?
content=<span class="hljs-string">"60초 동안 플랭크를 유지하는 것은 좋은 목표입니다! 60초 동안 플랭크를 유지하기 위해선 올바른 자세로 시작하고 천천히 플랭크를 유지하는 시간을 늘려나가는 것이 중요합니다. 진행하는 데 도움이 될 몇 가지 팁을 드리겠습니다:\n\n1. 짧은 시간으로 시작하기: 자세를 잘 유지한 채로 플랭크를 유지할 수 있는 시간부터 시작해보세요. 몇 초만이라도 괜찮으니 강해지면서 시간을 늘려가세요.\n\n2. 올바른 자세에 집중하기: 머리부터 발끝까지 직선으로 몸을 유지하고 복부 근육을 사용하며 어깨를 팔꿈치 바로 위에 유지하세요.\n\n3. 꾸준히 연습하기: 매주 몇 번씩 플랭크를 운동 루틴에 포함시키도록 노력해보세요. 꾸준함이 힘과 인내를 키우는 데 중요합니다.\n\n4. 다양한 플랭크 도전하기: 사이드 플랭크나 다리를 들거나하는 등 다양한 플랭크 변형을 시도하여 다른 근육 꾸러미에 작용하고 운동을 도전스럽게 유지하세요.\n\n5. 몸의 신호를 듣기: 자신을 밀어내는 것도 중요하지만 자신의 한계를 알아야 합니다. 통증이나 불편함을 느낀다면 멈추고 휴식을 취하세요.\n\n기억하세요, 발전에는 시간과 인내가 필요합니다. 새로운 플랭크 기법을 마스터하거나 몇 초 더 플랭크를 유지한다든지하는 모든 단계를 축하하세요. 당신은 할 수 있어요!"</span>
</code></pre>
<p>(가독성을 위해 위에서 줄 바꿈을 추가했습니다.)</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그것은 훌륭한 시작이에요. 하지만 출력물을 조금 더 사람이 읽기 쉬운 형식으로 포맷팅하는 것이 좋겣죠. 이를 위해 단순히 체인에 출력 파서를 추가하면 됩니다. StrOutputParser를 사용할 거에요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> os
<span class="hljs-keyword">from</span> langchain_core.<span class="hljs-property">prompts</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">ChatPromptTemplate</span>
<span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> <span class="hljs-title class_">ChatOpenAI</span>
<span class="hljs-keyword">from</span> langchain_core.<span class="hljs-property">output_parsers</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">StrOutputParser</span>

my_prompt = <span class="hljs-title class_">ChatPromptTemplate</span>.<span class="hljs-title function_">from_messages</span>([
    (<span class="hljs-string">"system"</span>, <span class="hljs-string">"당신은 친절하고 격려하는 피트니스 트레이너입니다."</span>),
    (<span class="hljs-string">"user"</span>, <span class="hljs-string">"{input}"</span>)
])

llm = <span class="hljs-title class_">ChatOpenAI</span>(openai_api_key=os.<span class="hljs-title function_">getenv</span>(<span class="hljs-string">"OPENAI_API_KEY"</span>))
output_parser = <span class="hljs-title class_">StrOutputParser</span>()

chain = my_prompt | llm | output_parser

user_input = <span class="hljs-title function_">input</span>(<span class="hljs-string">"당신의 피트니스 목표에 관한 질문을 해주세요.\n"</span>)
response = chain.<span class="hljs-title function_">invoke</span>({
  <span class="hljs-string">"input"</span>: user_input
})

<span class="hljs-title function_">print</span>(response)
</code></pre>
<p>이제 명령행에서 우리의 애플리케이션이 이렇게 보일 거에요:</p>
<pre><code class="hljs language-js">(venv) $ <span class="hljs-variable constant_">OPENAI_API_KEY</span>=insert-key-here python3 main.<span class="hljs-property">py</span>
당신의 피트니스 목표에 관한 질문을 해주세요.
피스톨 스쿼트를 어떻게 배우나요?
그것은 훌륭한 목표에요! 피스톨 스쿼트는 도전적일 수 있지만, 연습과 인내로 꼭 배울 수 있어요.

피스톨 스쿼트를 연습하기 위해 다음 단계를 따라가보세요:

<span class="hljs-number">1.</span> 스쿼트, 런지, 스텝업과 같은 운동으로 하체 근력을 키워보세요.
<span class="hljs-number">2.</span> 단일다리 균형 운동을 통해 균형과 안정성을 향상시켜보세요.
<span class="hljs-number">3.</span> 벤치나 의자 위로 몸을 내려친다는 부분적인 피스톨 스쿼트를 연습한 후 점차 전체적인 피스톨 스쿼트를 수행할 수 있게 되세요.
<span class="hljs-number">4.</span> <span class="hljs-variable constant_">TRX</span> 밴드나 막대기와 같은 지원 도구를 사용하여 균형 유지와 몸을 내려치는 데 도움을 받아, 충분한 근력을 쌓아 무도도 수행할 수 있도록 하세요.

피스톨 스쿼트를 시도하기 전에 반드시 웜업을 실시하고 부상을 피하기 위해 몸의 신호를 들어주는 것을 잊지 마세요. 그리고 가장 중요한 것은, 이 도전적인 운동을 마스터하는 데 노력하는 동안 긍정적이고 인내심을 가지세요. 당신은 할 수 있어요!
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>LLM 응담은 가독성을 향상시키기 위해 형식화되었습니다.</p>
<p>강력한 LLM 애플리케이션을 구축하기 위해, 우리의 체인은 이보다 훨씬 더 복잡할 것입니다. 그렇지만 그것이 LangChain의 강점이자 간결함입니다. 프레임워크는 당신의 필요에 맞는 로직을 모듈화할 수 있도록 해줘서 복잡한 워크플로우를 쉽게 연결할 수 있습니다.</p>
<p>간단한 LLM 애플리케이션을 만들었으니, 여전히 우리 애플리케이션을 배포하고 호스팅하며 서비스하기 위한 능력이 필요합니다. 인프라보다 앱 빌드에 초점을 맞춘 개발자로써, LangServe와 Heroku에 의존합니다.</p>
<h1>LangServe로 서비스 하기</h1>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>LangServe는 LangChain 체인과 상호 작용할 수 있도록 REST API를 통해 도와줍니다. LangChain LLM 애플리케이션의 서빙 부분을 작성하기 위해 세 가지 주요 구성 요소가 필요합니다:</p>
<ul>
<li>유효한 체인 (우리가 위에서 구축한 것과 같이)</li>
<li>API 애플리케이션 프레임워크 (예: FastAPI)</li>
<li>라우트 정의 (REST API를 구축할 때와 같이)</li>
</ul>
<p>LangServe 문서에는 시작하는 방법에 대한 유용한 예제가 제공됩니다. 우리 예제에서는 FastAPI를 사용하여 API 서버를 시작하고 LangServe의 add_routes()를 호출하여 체인을 API 엔드포인트를 통해 접근 가능하게 만들면 됩니다.</p>
<p>이와 함께 기존 코드를 약간 수정해야합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>우리는 StrOutputParser의 사용을 제거할 것입니다. 이렇게 하면 API를 호출하는 사용자들이 출력을 어떻게 형식화하고 사용할지에 대해 유연성을 가질 수 있습니다.</li>
<li>명령 줄에서 사용자 입력을 요청하지 않을 것입니다. API 호출 요청이 사용자의 입력을 제공할 것입니다.</li>
<li>chain.invoke()를 호출하지 않을 것입니다. LangServe가 API 요청 처리의 일부로 이를 처리할 것입니다.</li>
</ul>
<p>우리는 프로젝트에 FastAPI와 LangServe 패키지를 추가했음을 확인합니다:</p>
<pre><code class="hljs language-js">(venv) $ pip install langserve fastapi
</code></pre>
<p>우리의 최종 main.py 파일은 다음과 같습니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> os
<span class="hljs-keyword">from</span> langchain_core.prompts <span class="hljs-keyword">import</span> ChatPromptTemplate
<span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> ChatOpenAI
<span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI
<span class="hljs-keyword">from</span> langserve <span class="hljs-keyword">import</span> add_routes

my_prompt = ChatPromptTemplate.from_messages([
    (<span class="hljs-string">"system"</span>, <span class="hljs-string">"You are a friendly and encouraging fitness trainer."</span>),
    (<span class="hljs-string">"user"</span>, <span class="hljs-string">"{input}"</span>)
])

llm = ChatOpenAI(openai_api_key=os.getenv(<span class="hljs-string">"OPENAI_API_KEY"</span>))

chain = my_prompt | llm

app = FastAPI(title=<span class="hljs-string">"Fitness Trainer"</span>)

add_routes(app, chain)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    <span class="hljs-keyword">import</span> uvicorn

    uvicorn.run(app, host=<span class="hljs-string">"localhost"</span>, port=<span class="hljs-number">8000</span>)
</code></pre>
<p>내 로컬 머신인 우분투 20.04.6 LTS에서는 Python 3.8.10을 실행 중이었는데, 몇 가지 경고 메시지를 제거하기 위해 추가 패키지를 설치해야 했습니다. 당신의 머신에서는 이 작업이 필요하지 않을 수도 있어요.</p>
<pre><code class="hljs language-shell">(venv) $ pip install sse_starlette pydantic==1.10.13
</code></pre>
<p>이제 서버를 시작해 볼까요?</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>(venv) $ OPENAI_API_KEY=insert-key-here python3 main.py</p>
<p>INFO: 서버 프로세스 시작 [629848]
INFO: 애플리케이션 시작을 기다리는 중.</p>
<p>LANGSERVE: "/" 경로의 Playground이 활성화되었습니다:
LANGSERVE: │
LANGSERVE: └──> /playground/
LANGSERVE:
LANGSERVE: 사용 가능한 모든 경로는 /docs/에서 확인할 수 있습니다.</p>
<p>INFO: 애플리케이션 시작 완료.
INFO: Uvicorn이 <a href="http://localhost:8000%EC%97%90%EC%84%9C" rel="nofollow" target="_blank">http://localhost:8000에서</a> 실행 중 (종료하려면 CTRL+C를 누르세요)</p>
<p>와아... 멋져요!</p>
<p>브라우저에서 <a href="http://localhost:8000/docs" rel="nofollow" target="_blank">http://localhost:8000/docs</a> 로 이동할 수 있어요. 여기에서 확인할 수 있는 내용은:</p>
<img src="/TIL/assets/img/2024-07-09-LangChainPythonandHeroku_1.png">
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>LangServe는 Swagger UI를 사용하는 API 문서 페이지를 제공합니다! 이제 LangServe를 통해 사용 가능한 엔드포인트들이 있습니다. 우리는 invoke/ 엔드포인트로 POST 요청을 보낼 수 있습니다. 하지만 LangServe는 우리에게 chain을 직접 다룰 수 있는 웹 인터페이스가 있는 playground/ 엔드포인트도 제공합니다.</p>
<p><img src="/TIL/assets/img/2024-07-09-LangChainPythonandHeroku_2.png" alt="이미지"></p>
<p>우리는 입력을 제공하고 시작을 클릭합니다. 결과는 다음과 같습니다:</p>
<p><img src="/TIL/assets/img/2024-07-09-LangChainPythonandHeroku_3.png" alt="이미지"></p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>LLM 애플리케이션 워크플로의 맥락에서 API의 중요성을 강조하는 것이 중요합니다. LLM 및 해당 애플리케이션의 대부분 사용 사례를 생각해보면, 로컬 모델 및 자원에 의존할 수 없습니다. 이것은 합리적이지 않고 확장성이 떨어집니다.</p>
<p>LLM 애플리케이션의 실제 파워는 이전까지 설명한 복잡한 워크플로를 추상화하는 능력에 있습니다. 우리는 수행한 모든 것을 API 뒤에 숨겨 사용 사례가 확장되고 다른 사람들이 통합할 수 있도록 하려고 합니다. 이는 API를 호스팅하고 제공할 수 있는 쉬운 옵션이 있다면에만 가능합니다. 그리고 바로 그것이 Heroku에서 할 수 있습니다.</p>
<h1>Heroku에 배포</h1>
<p>Heroku는 LLM 애플리케이션 구현의 중요한 마지막 부분입니다. 우리는 LangChain을 사용하여 워크플로를 조합하고 LangServe를 사용하여 유용한 REST API로 제공합니다. 이제 복잡한 자원을 수동으로 설정하여 트래픽을 호스팅하고 제공하는 대신, Heroku를 사용하여 애플리케이션을 간단히 배포할 수 있습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>헤로쿠 계정을 설정한 후에, 이제 거의 배포할 준비가 끝났어요. 함께 순서대로 진행해볼게요.</p>
<h2>새로운 헤로쿠 앱 생성하기</h2>
<p>헤로쿠 CLI를 사용해서 로그인하고 새로운 앱을 생성해요.</p>
<pre><code class="hljs language-js">$ heroku login
$ heroku create my-langchain-app
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>설정 변수 설정하기</h2>
<p>이제 Heroku 앱 환경에서 OPENAI_API_KEY 환경 변수를 설정해야 합니다.</p>
<pre><code class="hljs language-js">$ heroku <span class="hljs-attr">config</span>:set <span class="hljs-variable constant_">OPENAI_API_KEY</span>=여러분의-openai-api-key로-대체하세요
</code></pre>
<h2>Python 애플리케이션 배포를 위한 설정 파일 만들기</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>헤로쿠가 우리의 파이썬 애플리케이션을 실행하기 위해 필요한 것을 알 수 있도록 하려면 세 가지 간단한 파일을 만들어야 합니다:</p>
<ul>
<li>Procfile: 헤로쿠가 앱을 시작하는 데 사용해야 하는 명령을 선언합니다.</li>
<li>requirements.txt: 헤로쿠가 설치해야 하는 Python 패키지 종속성을 지정합니다.</li>
<li>runtime.txt: 앱에 사용하려는 정확한 Python 런타임 버전을 지정합니다.</li>
</ul>
<p>이 파일들은 빠르고 쉽게 만들 수 있습니다. 각각은 프로젝트의 루트 폴더에 들어갑니다. Procfile을 만들려면 다음 명령을 실행하면 됩니다:</p>
<pre><code class="hljs language-bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">'web: uvicorn main:app --host=0.0.0.0 --port=${PORT}'</span> > Procfile
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이것은 Heroku에게 Python에서 웹 서버 구현인 uvicorn을 실행하도록 지시합니다.</p>
<p>requirements.txt에 대해, pip freeze 명령을 사용하여 설치된 패키지 목록을 출력할 수 있습니다.</p>
<pre><code class="hljs language-js">$ pip freeze > requirements.<span class="hljs-property">txt</span>
</code></pre>
<p>마지막으로, runtime.txt에는 Python 3.11.8을 사용할 것입니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">$ echo <span class="hljs-string">'python-3.11.8'</span> > runtime.<span class="hljs-property">txt</span>
</code></pre>
<p>이 파일들이 준비된 상태에서 프로젝트 루트 폴더는 다음과 같이 보일 것입니다:</p>
<pre><code class="hljs language-js">$ tree
.
├── main.<span class="hljs-property">py</span>
├── <span class="hljs-title class_">Procfile</span>
├── requirements.<span class="hljs-property">txt</span>
└── runtime.<span class="hljs-property">txt</span>

<span class="hljs-number">0</span> directories, <span class="hljs-number">4</span> files
</code></pre>
<p>이 파일들을 모두 GitHub 저장소에 커밋합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>Heroku와 GitHub 저장소 연결하기</h2>
<p>마지막으로 할 일은 GitHub 저장소에 대한 Heroku 원격을 생성한 다음 코드를 해당 원격으로 푸시하는 것입니다. Heroku는 새 코드를 푸시하면 해당 코드를 응용 프로그램에 배포합니다.</p>
<pre><code class="hljs language-js">$ heroku <span class="hljs-attr">git</span>:remote -a my-langchain-app
$ git push heroku main
</code></pre>
<p>우리의 코드가 Heroku 원격으로 푸시되면, Heroku는 애플리케이션을 빌드하고 종속성을 설치한 다음 Procfile에서 지정된 명령을 실행합니다. git push 명령어의 최종 결과는 다음과 같습니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">…

<span class="hljs-attr">remote</span>: -----> 프로세스 유형 검색 중
<span class="hljs-attr">remote</span>:        <span class="hljs-title class_">Procfile</span>이 다음 유형을 선언함 -> web
<span class="hljs-attr">remote</span>:
<span class="hljs-attr">remote</span>: -----> 압축 중...
<span class="hljs-attr">remote</span>:        완료: <span class="hljs-number">71.</span>8M
<span class="hljs-attr">remote</span>: -----> 배포 중...
<span class="hljs-attr">remote</span>:        v4 버전이 릴리스됨
<span class="hljs-attr">remote</span>:        <span class="hljs-attr">https</span>:<span class="hljs-comment">//my-langchain-app-ea95419b2750.herokuapp.com/ 에 배포됨</span>
<span class="hljs-attr">remote</span>:
<span class="hljs-attr">remote</span>: 배포 확인... 완료.
</code></pre>
<p>우리의 Heroku 앱 URL이 표시됩니다. 브라우저에서 <a href="https://my-langchain-app-ea95419b2750.herokuapp.com/playground%EC%9D%84" rel="nofollow" target="_blank">https://my-langchain-app-ea95419b2750.herokuapp.com/playground을</a> 방문해주세요.</p>
<p><img src="/TIL/assets/img/2024-07-09-LangChainPythonandHeroku_4.png" alt="이미지"></p>
<p>또한 Swagger UI 문서 페이지를 확인하려면 <a href="https://my-langchain-app-ea95419b2750.herokuapp.com/docs%EB%A5%BC" rel="nofollow" target="_blank">https://my-langchain-app-ea95419b2750.herokuapp.com/docs를</a> 방문해주세요.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/TIL/assets/img/2024-07-09-LangChainPythonandHeroku_5.png" alt="이미지"></p>
<p>그리고 그렇게해서 우리는 시작했어요!</p>
<p>이 프로세스는 LangChain과 함께 작업할 때 개발 시간과 오버헤드를 줄이는 최상의 방법입니다. LangChain으로 작성된 API를 쉽게 몇 가지 간단한 명령어로 Heroku에 배포할 수 있는 기능은 LangChain과 Heroku를 결합하는 것을 당연하게 만듭니다.</p>
<h1>결론</h1>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>오늘의 기업과 개발자들은 AI와 LLM(언어 모델)의 파도를 타기에 올바른 선택을 했습니다. 이들 영역에서 혁신과 새로운 개발 가능성이 많습니다. 그러나 성공과 실패의 차이는 그들이 애플리케이션을 구축하고 배포하는 데 사용하는 도구 체인에 많이 달렸습니다.</p>
<p>LangChain 프레임워크를 사용하면 LLM 기반 애플리케이션을 만드는 프로세스가 접근 가능하고 반복 가능해집니다. 그러나 구현은 전투의 반이에 불과합니다. 애플리케이션이 만들어지면, 이러한 애플리케이션 API를 클라우드에 쉽고 빠르게 배포할 수 있는 능력이 필요합니다. 그 곳에서 더 빠른 반복과 개발의 장점을 가질 수 있고, Heroku를 통해 그 길에 도달할 수 있습니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"2024년 최신 LangChain, Python, Heroku 사용 방법 실제 사용 사례와 팁","description":"","date":"2024-07-09 20:59","slug":"2024-07-09-LangChainPythonandHeroku","content":"\n\u003cimg src=\"/TIL/assets/img/2024-07-09-LangChainPythonandHeroku_0.png\" /\u003e\n\n## 커피숍에서 코딩하기\n\n2022년 말 이후 ChatGPT의 출시 및 널리 사용되면서 대형 언어 모델(LLM) 및 생성적 AI(GenAI)에서 비롯된 도구, 제품 및 혁신에 대한 뉴스 폭풍이 몰려왔습니다. 많은 기술 유행이 몇 년 내에 사라지는 반면, LLM 및 GenAI가 여기에 남아있음이 분명합니다.\n\n이러한 새로운 도구와 제품의 배경에 이어지는 다양한 도구들과 제품들에 대해 궁금한 적이 있나요? 또한 개발자와 최종 사용자 모두가 활용하는 이러한 도구들이 어떻게 운영되는지 궁금해할 수도 있습니다. 이러한 도구와 응용 프로그램 중 많은 경우, LangChain, Python 및 Heroku를 알 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 문서에서는 다룰 조각들입니다. 인공 지능/기계 학습 개발자들이 이들을 사용하여 복잡한 LLM 파이프라인 구성 요소를 구축하고 쉽게 배포하는 실제 예시를 살펴보겠습니다.\n\n# LLM 워크플로우와 파이프라인 해독하기\n\n기계 학습 파이프라인과 워크플로우는 AI 세계에 입문한 이들에게는 불투명해 보일 수 있습니다. 특히 LLM과 그와 관련된 도구에서는 더 그렇습니다. 왜냐하면 이들은 (비교적으로) 새로운 기술들이기 때문입니다. LLM을 처리하는 것은 도전적일 수 있습니다. 특히 엔지니어링이 강화되고 제품용으로 준비된 파이프라인, 워크플로 및 배포를 만들려고 할 때입니다. 새로운 도구들, 빠르게 변화하는 문서 및 제한된 지침들로 인해 어디서부터 시작하거나 무엇을 사용해야 할지를 알기 어려울 수 있습니다. 그래서 LangChain과 Heroku의 기본부터 시작해 봅시다.\n\nLangChain의 문서에는 다음과 같이 나와 있습니다: \"LangChain은 언어 모델을 기반으로 한 애플리케이션을 개발할 수 있는 프레임워크입니다.\"\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한편, Heroku는 다음과 같이 자신을 설명합니다: \"Heroku는 회사가 앱을 구축, 전달, 모니터링 및 확장할 수 있는 클라우드 플랫폼입니다. 아이디어에서 URL로 이동하는 가장 빠른 방법입니다. 모든 인프라 문제를 우회합니다.\"\n\n이를 LLM 애플리케이션 구축의 맥락으로 놓으면, LangChain과 Heroku는 최고의 조합입니다. 우리는 LLM 애플리케이션을 구축하기 위해 테스트된 쉬운 프레임워크(LangChain)가 필요하고, 그 애플리케이션을 배포하고 호스팅할 방법(Heroku)이 필요합니다.\n\n이제 각 기술에 대해 자세히 살펴보겠습니다.\n\n## LangChain 탐구하기\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLangChain을 사용하는 방법에 대해 간단히 이야기해 봅시다. LangChain은 LLM 모델과 사용 사례를 기반으로 한 애플리케이션을 개발하는 개발자들을 지원하는 프레임워크입니다. Python, JavaScript, TypeScript를 지원합니다. 예를 들어, 사용자 입력에 기반을 둔 보고서를 생성하거나 고객 지원 응답을 자동화하는 도구를 개발 중이라고 가정해 봅시다. LangChain은 프로젝트의 골조로 작용하여 언어 모델을 효율적으로 솔루션에 통합할 수 있는 도구와 구조를 제공합니다.\n\nLangChain 내에는 몇 가지 주요 구성 요소가 있습니다:\n\n- 에이전트: 에이전트는 우리의 요구 사항에 따라 작업을 수행하기 위해 언어 모델과 상호 작용하는 구성 요소입니다. 이것은 우리 애플리케이션의 두뇌로, 언어 모델의 기능을 활용하여 텍스트를 이해하고 생성합니다.\n- 체인: 에이전트가 작업을 수행하는 데 따르는 동작이나 프로세스의 시퀀스입니다. 예를 들어, 고객 지원을 자동화한다면 체인은 고객 질문 수락, 관련 정보 찾기, 그리고 응답 작성 등의 단계를 포함할 수 있습니다.\n- 템플릿: 템플릿은 언어 모델의 출력을 구조화하는 방법을 제공합니다. 예를 들어, 애플리케이션이 보고서를 생성하는 경우, 모델의 출력을 기반으로 이러한 보고서를 일관되게 포맷하는 데 도움이 되는 템플릿을 활용할 것입니다.\n- LangServe: 개발자가 LangChain 애플리케이션을 REST API로 배포하고 제공할 수 있도록 합니다.\n- LangSmith: 이 도구는 언어 모델 애플리케이션의 상호 작용을 평가, 테스트 및 정제하여 제품을 상용화할 준비를 얻도록 도와줍니다.\n\nLangChain은 인기 있는 AI 및 LLM 애플리케이션을 구축하기 위한 프레임워크이며, 그 이유를 쉽게 이해할 수 있습니다. LangChain은 제품을 끝까지 구축하고 배포하는 데 필요한 기능을 제공합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Heroku를 탐험해보세요\n\nHeroku는 클라우드 플랫폼 서비스(PaaS)로서 애플리케이션을 클라우드에 간단하게 배포할 수 있게 해주어 가장 잘 알려져 있습니다. 개발자들은 주로 코드와 구현에만 집중하고 싶어합니다. 이미 복잡한 데이터 파이프라인과 LLM 기반 애플리케이션을 다루고 있을 때는 서버, 네트워크, 지속적인 저장소와 같은 인프라 문제를 다루는데 필요한 자원이나 전문지식이 부족할 수 있습니다.\n\nHeroku를 통해 애플리케이션을 쉽게 배포할 수 있기 때문에 프로젝트를 제품화하는 주요 장벽이 손쉽게 처리됩니다.\n\n# LangChain으로 빌드하기\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLangChain이 LLM 애플리케이션에서 어떻게 사용되는지 더 잘 이해하기 위해 몇 가지 예제 문제를 통해 과정을 명확하게 알아보겠습니다. 일반적으로, LLM 체인을 구성하기 위해 다음 항목을 연결하여 단일 워크플로우를 형성합니다:\n\n- 사용자의 매개 변수를 기반으로 프롬프트를 생성하는 프롬프트 템플릿으로 시작합니다.\n- 언어 모델이 원래 훈련되지 않은 데이터를 검색하는 리트리버를 체인에 추가합니다(예: 문서 데이터베이스에서).\n- 더 나은 응답을 형성하기 위해 언어 모델에 맥락을 제공하기 위해 채팅 기록을 포함하는 회화 검색 체이닝을 추가합니다.\n- 실제 LLM과 상호 작용하는 에이전트를 추가합니다.\n\nLangChain을 사용하면 LLM 애플리케이션의 기본을 형성하는 프로세스를 연결할 수 있습니다. 이는 우리의 구현을 쉽고 친근하게 만듭니다. 간단한 예제를 통해 함께 살펴보겠습니다.\n\n이 예시에서는 OpenAI와 함께 작업하겠습니다. 프롬프트를 이렇게 작성해 보겠습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! LangChain을 사용하고 계시다니 멋지네요! 여기 저희 훌륭한 가상 트레이너, OpenAI에게 문의하시면 됩니다. 사용자의 질문을 입력해 주세요. 요청하신 내용에 따라 OpenAI가 도움을 들어드리겠습니다. 함께 성공적인 코딩 여정을 시작해봐요!\n\nMarkdown 형식을 사용해 표를 만들어보세요:\n\n| 컬럼1   | 컬럼2   |\n| ------- | ------- |\n| 데이터1 | 데이터2 |\n\n그럼 좋은 하루 보내세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nmain.py라는 새 파일을 만들겠습니다. 우리의 기본 Python 코드는 다음과 같습니다:\n\n```python\nimport os\nfrom langchain_core.prompts import ChatPromptTemplate\nfrom langchain_openai import ChatOpenAI\n\nmy_prompt = ChatPromptTemplate.from_messages([\n    (\"system\", \"You are a friendly and encouraging fitness trainer.\"),\n    (\"user\", \"{input}\")\n])\n\nllm = ChatOpenAI(openai_api_key=os.getenv(\"OPENAI_API_KEY\"])\n\nchain = my_prompt | llm\n```\n\n여기서 그만입니다! 이 기본 예제에서는 LangChain을 사용하여 프롬프트 템플릿과 OpenAI 에이전트를 연결했습니다.\n\n이를 명령줄에서 사용하려면 다음 코드를 추가해야합니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nuser_input = input(\"피트니스 목표와 관련된 질문을 하세요.\\n\");\nresponse = chain.invoke({\n  input: user_input,\n});\n\nprint(response);\n```\n\n위에서 코드블록을 보면 우리 애플리케이션을 명령줄에서 테스트할 수 있습니다.\n\n```js\n(venv) $ OPENAI_API_KEY=insert-key-here python3 main.py\n피트니스 목표와 관련된 질문을 하세요.\n60초 동안 플랭크를 유지하는 방법은 무엇인가요?\ncontent=\"60초 동안 플랭크를 유지하는 것은 좋은 목표입니다! 60초 동안 플랭크를 유지하기 위해선 올바른 자세로 시작하고 천천히 플랭크를 유지하는 시간을 늘려나가는 것이 중요합니다. 진행하는 데 도움이 될 몇 가지 팁을 드리겠습니다:\\n\\n1. 짧은 시간으로 시작하기: 자세를 잘 유지한 채로 플랭크를 유지할 수 있는 시간부터 시작해보세요. 몇 초만이라도 괜찮으니 강해지면서 시간을 늘려가세요.\\n\\n2. 올바른 자세에 집중하기: 머리부터 발끝까지 직선으로 몸을 유지하고 복부 근육을 사용하며 어깨를 팔꿈치 바로 위에 유지하세요.\\n\\n3. 꾸준히 연습하기: 매주 몇 번씩 플랭크를 운동 루틴에 포함시키도록 노력해보세요. 꾸준함이 힘과 인내를 키우는 데 중요합니다.\\n\\n4. 다양한 플랭크 도전하기: 사이드 플랭크나 다리를 들거나하는 등 다양한 플랭크 변형을 시도하여 다른 근육 꾸러미에 작용하고 운동을 도전스럽게 유지하세요.\\n\\n5. 몸의 신호를 듣기: 자신을 밀어내는 것도 중요하지만 자신의 한계를 알아야 합니다. 통증이나 불편함을 느낀다면 멈추고 휴식을 취하세요.\\n\\n기억하세요, 발전에는 시간과 인내가 필요합니다. 새로운 플랭크 기법을 마스터하거나 몇 초 더 플랭크를 유지한다든지하는 모든 단계를 축하하세요. 당신은 할 수 있어요!\"\n```\n\n(가독성을 위해 위에서 줄 바꿈을 추가했습니다.)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그것은 훌륭한 시작이에요. 하지만 출력물을 조금 더 사람이 읽기 쉬운 형식으로 포맷팅하는 것이 좋겣죠. 이를 위해 단순히 체인에 출력 파서를 추가하면 됩니다. StrOutputParser를 사용할 거에요.\n\n```js\nimport os\nfrom langchain_core.prompts import ChatPromptTemplate\nfrom langchain_openai import ChatOpenAI\nfrom langchain_core.output_parsers import StrOutputParser\n\nmy_prompt = ChatPromptTemplate.from_messages([\n    (\"system\", \"당신은 친절하고 격려하는 피트니스 트레이너입니다.\"),\n    (\"user\", \"{input}\")\n])\n\nllm = ChatOpenAI(openai_api_key=os.getenv(\"OPENAI_API_KEY\"))\noutput_parser = StrOutputParser()\n\nchain = my_prompt | llm | output_parser\n\nuser_input = input(\"당신의 피트니스 목표에 관한 질문을 해주세요.\\n\")\nresponse = chain.invoke({\n  \"input\": user_input\n})\n\nprint(response)\n```\n\n이제 명령행에서 우리의 애플리케이션이 이렇게 보일 거에요:\n\n```js\n(venv) $ OPENAI_API_KEY=insert-key-here python3 main.py\n당신의 피트니스 목표에 관한 질문을 해주세요.\n피스톨 스쿼트를 어떻게 배우나요?\n그것은 훌륭한 목표에요! 피스톨 스쿼트는 도전적일 수 있지만, 연습과 인내로 꼭 배울 수 있어요.\n\n피스톨 스쿼트를 연습하기 위해 다음 단계를 따라가보세요:\n\n1. 스쿼트, 런지, 스텝업과 같은 운동으로 하체 근력을 키워보세요.\n2. 단일다리 균형 운동을 통해 균형과 안정성을 향상시켜보세요.\n3. 벤치나 의자 위로 몸을 내려친다는 부분적인 피스톨 스쿼트를 연습한 후 점차 전체적인 피스톨 스쿼트를 수행할 수 있게 되세요.\n4. TRX 밴드나 막대기와 같은 지원 도구를 사용하여 균형 유지와 몸을 내려치는 데 도움을 받아, 충분한 근력을 쌓아 무도도 수행할 수 있도록 하세요.\n\n피스톨 스쿼트를 시도하기 전에 반드시 웜업을 실시하고 부상을 피하기 위해 몸의 신호를 들어주는 것을 잊지 마세요. 그리고 가장 중요한 것은, 이 도전적인 운동을 마스터하는 데 노력하는 동안 긍정적이고 인내심을 가지세요. 당신은 할 수 있어요!\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLLM 응담은 가독성을 향상시키기 위해 형식화되었습니다.\n\n강력한 LLM 애플리케이션을 구축하기 위해, 우리의 체인은 이보다 훨씬 더 복잡할 것입니다. 그렇지만 그것이 LangChain의 강점이자 간결함입니다. 프레임워크는 당신의 필요에 맞는 로직을 모듈화할 수 있도록 해줘서 복잡한 워크플로우를 쉽게 연결할 수 있습니다.\n\n간단한 LLM 애플리케이션을 만들었으니, 여전히 우리 애플리케이션을 배포하고 호스팅하며 서비스하기 위한 능력이 필요합니다. 인프라보다 앱 빌드에 초점을 맞춘 개발자로써, LangServe와 Heroku에 의존합니다.\n\n# LangServe로 서비스 하기\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLangServe는 LangChain 체인과 상호 작용할 수 있도록 REST API를 통해 도와줍니다. LangChain LLM 애플리케이션의 서빙 부분을 작성하기 위해 세 가지 주요 구성 요소가 필요합니다:\n\n- 유효한 체인 (우리가 위에서 구축한 것과 같이)\n- API 애플리케이션 프레임워크 (예: FastAPI)\n- 라우트 정의 (REST API를 구축할 때와 같이)\n\nLangServe 문서에는 시작하는 방법에 대한 유용한 예제가 제공됩니다. 우리 예제에서는 FastAPI를 사용하여 API 서버를 시작하고 LangServe의 add_routes()를 호출하여 체인을 API 엔드포인트를 통해 접근 가능하게 만들면 됩니다.\n\n이와 함께 기존 코드를 약간 수정해야합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 우리는 StrOutputParser의 사용을 제거할 것입니다. 이렇게 하면 API를 호출하는 사용자들이 출력을 어떻게 형식화하고 사용할지에 대해 유연성을 가질 수 있습니다.\n- 명령 줄에서 사용자 입력을 요청하지 않을 것입니다. API 호출 요청이 사용자의 입력을 제공할 것입니다.\n- chain.invoke()를 호출하지 않을 것입니다. LangServe가 API 요청 처리의 일부로 이를 처리할 것입니다.\n\n우리는 프로젝트에 FastAPI와 LangServe 패키지를 추가했음을 확인합니다:\n\n```js\n(venv) $ pip install langserve fastapi\n```\n\n우리의 최종 main.py 파일은 다음과 같습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nimport os\nfrom langchain_core.prompts import ChatPromptTemplate\nfrom langchain_openai import ChatOpenAI\nfrom fastapi import FastAPI\nfrom langserve import add_routes\n\nmy_prompt = ChatPromptTemplate.from_messages([\n    (\"system\", \"You are a friendly and encouraging fitness trainer.\"),\n    (\"user\", \"{input}\")\n])\n\nllm = ChatOpenAI(openai_api_key=os.getenv(\"OPENAI_API_KEY\"))\n\nchain = my_prompt | llm\n\napp = FastAPI(title=\"Fitness Trainer\")\n\nadd_routes(app, chain)\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app, host=\"localhost\", port=8000)\n```\n\n내 로컬 머신인 우분투 20.04.6 LTS에서는 Python 3.8.10을 실행 중이었는데, 몇 가지 경고 메시지를 제거하기 위해 추가 패키지를 설치해야 했습니다. 당신의 머신에서는 이 작업이 필요하지 않을 수도 있어요.\n\n```shell\n(venv) $ pip install sse_starlette pydantic==1.10.13\n```\n\n이제 서버를 시작해 볼까요?\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n(venv) $ OPENAI_API_KEY=insert-key-here python3 main.py\n\nINFO: 서버 프로세스 시작 [629848]\nINFO: 애플리케이션 시작을 기다리는 중.\n\nLANGSERVE: \"/\" 경로의 Playground이 활성화되었습니다:\nLANGSERVE: │\nLANGSERVE: └──\u003e /playground/\nLANGSERVE:\nLANGSERVE: 사용 가능한 모든 경로는 /docs/에서 확인할 수 있습니다.\n\nINFO: 애플리케이션 시작 완료.\nINFO: Uvicorn이 http://localhost:8000에서 실행 중 (종료하려면 CTRL+C를 누르세요)\n\n와아... 멋져요!\n\n브라우저에서 http://localhost:8000/docs 로 이동할 수 있어요. 여기에서 확인할 수 있는 내용은:\n\n\u003cimg src=\"/TIL/assets/img/2024-07-09-LangChainPythonandHeroku_1.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLangServe는 Swagger UI를 사용하는 API 문서 페이지를 제공합니다! 이제 LangServe를 통해 사용 가능한 엔드포인트들이 있습니다. 우리는 invoke/ 엔드포인트로 POST 요청을 보낼 수 있습니다. 하지만 LangServe는 우리에게 chain을 직접 다룰 수 있는 웹 인터페이스가 있는 playground/ 엔드포인트도 제공합니다.\n\n![이미지](/TIL/assets/img/2024-07-09-LangChainPythonandHeroku_2.png)\n\n우리는 입력을 제공하고 시작을 클릭합니다. 결과는 다음과 같습니다:\n\n![이미지](/TIL/assets/img/2024-07-09-LangChainPythonandHeroku_3.png)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLLM 애플리케이션 워크플로의 맥락에서 API의 중요성을 강조하는 것이 중요합니다. LLM 및 해당 애플리케이션의 대부분 사용 사례를 생각해보면, 로컬 모델 및 자원에 의존할 수 없습니다. 이것은 합리적이지 않고 확장성이 떨어집니다.\n\nLLM 애플리케이션의 실제 파워는 이전까지 설명한 복잡한 워크플로를 추상화하는 능력에 있습니다. 우리는 수행한 모든 것을 API 뒤에 숨겨 사용 사례가 확장되고 다른 사람들이 통합할 수 있도록 하려고 합니다. 이는 API를 호스팅하고 제공할 수 있는 쉬운 옵션이 있다면에만 가능합니다. 그리고 바로 그것이 Heroku에서 할 수 있습니다.\n\n# Heroku에 배포\n\nHeroku는 LLM 애플리케이션 구현의 중요한 마지막 부분입니다. 우리는 LangChain을 사용하여 워크플로를 조합하고 LangServe를 사용하여 유용한 REST API로 제공합니다. 이제 복잡한 자원을 수동으로 설정하여 트래픽을 호스팅하고 제공하는 대신, Heroku를 사용하여 애플리케이션을 간단히 배포할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n헤로쿠 계정을 설정한 후에, 이제 거의 배포할 준비가 끝났어요. 함께 순서대로 진행해볼게요.\n\n## 새로운 헤로쿠 앱 생성하기\n\n헤로쿠 CLI를 사용해서 로그인하고 새로운 앱을 생성해요.\n\n```js\n$ heroku login\n$ heroku create my-langchain-app\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 설정 변수 설정하기\n\n이제 Heroku 앱 환경에서 OPENAI_API_KEY 환경 변수를 설정해야 합니다.\n\n```js\n$ heroku config:set OPENAI_API_KEY=여러분의-openai-api-key로-대체하세요\n```\n\n## Python 애플리케이션 배포를 위한 설정 파일 만들기\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n헤로쿠가 우리의 파이썬 애플리케이션을 실행하기 위해 필요한 것을 알 수 있도록 하려면 세 가지 간단한 파일을 만들어야 합니다:\n\n- Procfile: 헤로쿠가 앱을 시작하는 데 사용해야 하는 명령을 선언합니다.\n- requirements.txt: 헤로쿠가 설치해야 하는 Python 패키지 종속성을 지정합니다.\n- runtime.txt: 앱에 사용하려는 정확한 Python 런타임 버전을 지정합니다.\n\n이 파일들은 빠르고 쉽게 만들 수 있습니다. 각각은 프로젝트의 루트 폴더에 들어갑니다. Procfile을 만들려면 다음 명령을 실행하면 됩니다:\n\n```bash\n$ echo 'web: uvicorn main:app --host=0.0.0.0 --port=${PORT}' \u003e Procfile\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것은 Heroku에게 Python에서 웹 서버 구현인 uvicorn을 실행하도록 지시합니다.\n\nrequirements.txt에 대해, pip freeze 명령을 사용하여 설치된 패키지 목록을 출력할 수 있습니다.\n\n```js\n$ pip freeze \u003e requirements.txt\n```\n\n마지막으로, runtime.txt에는 Python 3.11.8을 사용할 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n$ echo 'python-3.11.8' \u003e runtime.txt\n```\n\n이 파일들이 준비된 상태에서 프로젝트 루트 폴더는 다음과 같이 보일 것입니다:\n\n```js\n$ tree\n.\n├── main.py\n├── Procfile\n├── requirements.txt\n└── runtime.txt\n\n0 directories, 4 files\n```\n\n이 파일들을 모두 GitHub 저장소에 커밋합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Heroku와 GitHub 저장소 연결하기\n\n마지막으로 할 일은 GitHub 저장소에 대한 Heroku 원격을 생성한 다음 코드를 해당 원격으로 푸시하는 것입니다. Heroku는 새 코드를 푸시하면 해당 코드를 응용 프로그램에 배포합니다.\n\n```js\n$ heroku git:remote -a my-langchain-app\n$ git push heroku main\n```\n\n우리의 코드가 Heroku 원격으로 푸시되면, Heroku는 애플리케이션을 빌드하고 종속성을 설치한 다음 Procfile에서 지정된 명령을 실행합니다. git push 명령어의 최종 결과는 다음과 같습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n…\n\nremote: -----\u003e 프로세스 유형 검색 중\nremote:        Procfile이 다음 유형을 선언함 -\u003e web\nremote:\nremote: -----\u003e 압축 중...\nremote:        완료: 71.8M\nremote: -----\u003e 배포 중...\nremote:        v4 버전이 릴리스됨\nremote:        https://my-langchain-app-ea95419b2750.herokuapp.com/ 에 배포됨\nremote:\nremote: 배포 확인... 완료.\n```\n\n우리의 Heroku 앱 URL이 표시됩니다. 브라우저에서 https://my-langchain-app-ea95419b2750.herokuapp.com/playground을 방문해주세요.\n\n![이미지](/TIL/assets/img/2024-07-09-LangChainPythonandHeroku_4.png)\n\n또한 Swagger UI 문서 페이지를 확인하려면 https://my-langchain-app-ea95419b2750.herokuapp.com/docs를 방문해주세요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/TIL/assets/img/2024-07-09-LangChainPythonandHeroku_5.png)\n\n그리고 그렇게해서 우리는 시작했어요!\n\n이 프로세스는 LangChain과 함께 작업할 때 개발 시간과 오버헤드를 줄이는 최상의 방법입니다. LangChain으로 작성된 API를 쉽게 몇 가지 간단한 명령어로 Heroku에 배포할 수 있는 기능은 LangChain과 Heroku를 결합하는 것을 당연하게 만듭니다.\n\n# 결론\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n오늘의 기업과 개발자들은 AI와 LLM(언어 모델)의 파도를 타기에 올바른 선택을 했습니다. 이들 영역에서 혁신과 새로운 개발 가능성이 많습니다. 그러나 성공과 실패의 차이는 그들이 애플리케이션을 구축하고 배포하는 데 사용하는 도구 체인에 많이 달렸습니다.\n\nLangChain 프레임워크를 사용하면 LLM 기반 애플리케이션을 만드는 프로세스가 접근 가능하고 반복 가능해집니다. 그러나 구현은 전투의 반이에 불과합니다. 애플리케이션이 만들어지면, 이러한 애플리케이션 API를 클라우드에 쉽고 빠르게 배포할 수 있는 능력이 필요합니다. 그 곳에서 더 빠른 반복과 개발의 장점을 가질 수 있고, Heroku를 통해 그 길에 도달할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-07-09-LangChainPythonandHeroku_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-LangChainPythonandHeroku_0.png","tag":["Tech"],"readingTime":20},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-09-LangChainPythonandHeroku_0.png\"\u003e\n\u003ch2\u003e커피숍에서 코딩하기\u003c/h2\u003e\n\u003cp\u003e2022년 말 이후 ChatGPT의 출시 및 널리 사용되면서 대형 언어 모델(LLM) 및 생성적 AI(GenAI)에서 비롯된 도구, 제품 및 혁신에 대한 뉴스 폭풍이 몰려왔습니다. 많은 기술 유행이 몇 년 내에 사라지는 반면, LLM 및 GenAI가 여기에 남아있음이 분명합니다.\u003c/p\u003e\n\u003cp\u003e이러한 새로운 도구와 제품의 배경에 이어지는 다양한 도구들과 제품들에 대해 궁금한 적이 있나요? 또한 개발자와 최종 사용자 모두가 활용하는 이러한 도구들이 어떻게 운영되는지 궁금해할 수도 있습니다. 이러한 도구와 응용 프로그램 중 많은 경우, LangChain, Python 및 Heroku를 알 수 있습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 문서에서는 다룰 조각들입니다. 인공 지능/기계 학습 개발자들이 이들을 사용하여 복잡한 LLM 파이프라인 구성 요소를 구축하고 쉽게 배포하는 실제 예시를 살펴보겠습니다.\u003c/p\u003e\n\u003ch1\u003eLLM 워크플로우와 파이프라인 해독하기\u003c/h1\u003e\n\u003cp\u003e기계 학습 파이프라인과 워크플로우는 AI 세계에 입문한 이들에게는 불투명해 보일 수 있습니다. 특히 LLM과 그와 관련된 도구에서는 더 그렇습니다. 왜냐하면 이들은 (비교적으로) 새로운 기술들이기 때문입니다. LLM을 처리하는 것은 도전적일 수 있습니다. 특히 엔지니어링이 강화되고 제품용으로 준비된 파이프라인, 워크플로 및 배포를 만들려고 할 때입니다. 새로운 도구들, 빠르게 변화하는 문서 및 제한된 지침들로 인해 어디서부터 시작하거나 무엇을 사용해야 할지를 알기 어려울 수 있습니다. 그래서 LangChain과 Heroku의 기본부터 시작해 봅시다.\u003c/p\u003e\n\u003cp\u003eLangChain의 문서에는 다음과 같이 나와 있습니다: \"LangChain은 언어 모델을 기반으로 한 애플리케이션을 개발할 수 있는 프레임워크입니다.\"\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e한편, Heroku는 다음과 같이 자신을 설명합니다: \"Heroku는 회사가 앱을 구축, 전달, 모니터링 및 확장할 수 있는 클라우드 플랫폼입니다. 아이디어에서 URL로 이동하는 가장 빠른 방법입니다. 모든 인프라 문제를 우회합니다.\"\u003c/p\u003e\n\u003cp\u003e이를 LLM 애플리케이션 구축의 맥락으로 놓으면, LangChain과 Heroku는 최고의 조합입니다. 우리는 LLM 애플리케이션을 구축하기 위해 테스트된 쉬운 프레임워크(LangChain)가 필요하고, 그 애플리케이션을 배포하고 호스팅할 방법(Heroku)이 필요합니다.\u003c/p\u003e\n\u003cp\u003e이제 각 기술에 대해 자세히 살펴보겠습니다.\u003c/p\u003e\n\u003ch2\u003eLangChain 탐구하기\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eLangChain을 사용하는 방법에 대해 간단히 이야기해 봅시다. LangChain은 LLM 모델과 사용 사례를 기반으로 한 애플리케이션을 개발하는 개발자들을 지원하는 프레임워크입니다. Python, JavaScript, TypeScript를 지원합니다. 예를 들어, 사용자 입력에 기반을 둔 보고서를 생성하거나 고객 지원 응답을 자동화하는 도구를 개발 중이라고 가정해 봅시다. LangChain은 프로젝트의 골조로 작용하여 언어 모델을 효율적으로 솔루션에 통합할 수 있는 도구와 구조를 제공합니다.\u003c/p\u003e\n\u003cp\u003eLangChain 내에는 몇 가지 주요 구성 요소가 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e에이전트: 에이전트는 우리의 요구 사항에 따라 작업을 수행하기 위해 언어 모델과 상호 작용하는 구성 요소입니다. 이것은 우리 애플리케이션의 두뇌로, 언어 모델의 기능을 활용하여 텍스트를 이해하고 생성합니다.\u003c/li\u003e\n\u003cli\u003e체인: 에이전트가 작업을 수행하는 데 따르는 동작이나 프로세스의 시퀀스입니다. 예를 들어, 고객 지원을 자동화한다면 체인은 고객 질문 수락, 관련 정보 찾기, 그리고 응답 작성 등의 단계를 포함할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e템플릿: 템플릿은 언어 모델의 출력을 구조화하는 방법을 제공합니다. 예를 들어, 애플리케이션이 보고서를 생성하는 경우, 모델의 출력을 기반으로 이러한 보고서를 일관되게 포맷하는 데 도움이 되는 템플릿을 활용할 것입니다.\u003c/li\u003e\n\u003cli\u003eLangServe: 개발자가 LangChain 애플리케이션을 REST API로 배포하고 제공할 수 있도록 합니다.\u003c/li\u003e\n\u003cli\u003eLangSmith: 이 도구는 언어 모델 애플리케이션의 상호 작용을 평가, 테스트 및 정제하여 제품을 상용화할 준비를 얻도록 도와줍니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLangChain은 인기 있는 AI 및 LLM 애플리케이션을 구축하기 위한 프레임워크이며, 그 이유를 쉽게 이해할 수 있습니다. LangChain은 제품을 끝까지 구축하고 배포하는 데 필요한 기능을 제공합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003eHeroku를 탐험해보세요\u003c/h2\u003e\n\u003cp\u003eHeroku는 클라우드 플랫폼 서비스(PaaS)로서 애플리케이션을 클라우드에 간단하게 배포할 수 있게 해주어 가장 잘 알려져 있습니다. 개발자들은 주로 코드와 구현에만 집중하고 싶어합니다. 이미 복잡한 데이터 파이프라인과 LLM 기반 애플리케이션을 다루고 있을 때는 서버, 네트워크, 지속적인 저장소와 같은 인프라 문제를 다루는데 필요한 자원이나 전문지식이 부족할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eHeroku를 통해 애플리케이션을 쉽게 배포할 수 있기 때문에 프로젝트를 제품화하는 주요 장벽이 손쉽게 처리됩니다.\u003c/p\u003e\n\u003ch1\u003eLangChain으로 빌드하기\u003c/h1\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eLangChain이 LLM 애플리케이션에서 어떻게 사용되는지 더 잘 이해하기 위해 몇 가지 예제 문제를 통해 과정을 명확하게 알아보겠습니다. 일반적으로, LLM 체인을 구성하기 위해 다음 항목을 연결하여 단일 워크플로우를 형성합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e사용자의 매개 변수를 기반으로 프롬프트를 생성하는 프롬프트 템플릿으로 시작합니다.\u003c/li\u003e\n\u003cli\u003e언어 모델이 원래 훈련되지 않은 데이터를 검색하는 리트리버를 체인에 추가합니다(예: 문서 데이터베이스에서).\u003c/li\u003e\n\u003cli\u003e더 나은 응답을 형성하기 위해 언어 모델에 맥락을 제공하기 위해 채팅 기록을 포함하는 회화 검색 체이닝을 추가합니다.\u003c/li\u003e\n\u003cli\u003e실제 LLM과 상호 작용하는 에이전트를 추가합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLangChain을 사용하면 LLM 애플리케이션의 기본을 형성하는 프로세스를 연결할 수 있습니다. 이는 우리의 구현을 쉽고 친근하게 만듭니다. 간단한 예제를 통해 함께 살펴보겠습니다.\u003c/p\u003e\n\u003cp\u003e이 예시에서는 OpenAI와 함께 작업하겠습니다. 프롬프트를 이렇게 작성해 보겠습니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e안녕하세요! LangChain을 사용하고 계시다니 멋지네요! 여기 저희 훌륭한 가상 트레이너, OpenAI에게 문의하시면 됩니다. 사용자의 질문을 입력해 주세요. 요청하신 내용에 따라 OpenAI가 도움을 들어드리겠습니다. 함께 성공적인 코딩 여정을 시작해봐요!\u003c/p\u003e\n\u003cp\u003eMarkdown 형식을 사용해 표를 만들어보세요:\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e컬럼1\u003c/th\u003e\u003cth\u003e컬럼2\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e데이터1\u003c/td\u003e\u003ctd\u003e데이터2\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e그럼 좋은 하루 보내세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003emain.py라는 새 파일을 만들겠습니다. 우리의 기본 Python 코드는 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e os\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain_core.prompts \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e ChatPromptTemplate\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain_openai \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e ChatOpenAI\n\nmy_prompt = ChatPromptTemplate.from_messages([\n    (\u003cspan class=\"hljs-string\"\u003e\"system\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"You are a friendly and encouraging fitness trainer.\"\u003c/span\u003e),\n    (\u003cspan class=\"hljs-string\"\u003e\"user\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"{input}\"\u003c/span\u003e)\n])\n\nllm = ChatOpenAI(openai_api_key=os.getenv(\u003cspan class=\"hljs-string\"\u003e\"OPENAI_API_KEY\"\u003c/span\u003e])\n\nchain = my_prompt | llm\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 그만입니다! 이 기본 예제에서는 LangChain을 사용하여 프롬프트 템플릿과 OpenAI 에이전트를 연결했습니다.\u003c/p\u003e\n\u003cp\u003e이를 명령줄에서 사용하려면 다음 코드를 추가해야합니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003euser_input = \u003cspan class=\"hljs-title function_\"\u003einput\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"피트니스 목표와 관련된 질문을 하세요.\\n\"\u003c/span\u003e);\nresponse = chain.\u003cspan class=\"hljs-title function_\"\u003einvoke\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003einput\u003c/span\u003e: user_input,\n});\n\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(response);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위에서 코드블록을 보면 우리 애플리케이션을 명령줄에서 테스트할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e(venv) $ \u003cspan class=\"hljs-variable constant_\"\u003eOPENAI_API_KEY\u003c/span\u003e=insert-key-here python3 main.\u003cspan class=\"hljs-property\"\u003epy\u003c/span\u003e\n피트니스 목표와 관련된 질문을 하세요.\n\u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e초 동안 플랭크를 유지하는 방법은 무엇인가요?\ncontent=\u003cspan class=\"hljs-string\"\u003e\"60초 동안 플랭크를 유지하는 것은 좋은 목표입니다! 60초 동안 플랭크를 유지하기 위해선 올바른 자세로 시작하고 천천히 플랭크를 유지하는 시간을 늘려나가는 것이 중요합니다. 진행하는 데 도움이 될 몇 가지 팁을 드리겠습니다:\\n\\n1. 짧은 시간으로 시작하기: 자세를 잘 유지한 채로 플랭크를 유지할 수 있는 시간부터 시작해보세요. 몇 초만이라도 괜찮으니 강해지면서 시간을 늘려가세요.\\n\\n2. 올바른 자세에 집중하기: 머리부터 발끝까지 직선으로 몸을 유지하고 복부 근육을 사용하며 어깨를 팔꿈치 바로 위에 유지하세요.\\n\\n3. 꾸준히 연습하기: 매주 몇 번씩 플랭크를 운동 루틴에 포함시키도록 노력해보세요. 꾸준함이 힘과 인내를 키우는 데 중요합니다.\\n\\n4. 다양한 플랭크 도전하기: 사이드 플랭크나 다리를 들거나하는 등 다양한 플랭크 변형을 시도하여 다른 근육 꾸러미에 작용하고 운동을 도전스럽게 유지하세요.\\n\\n5. 몸의 신호를 듣기: 자신을 밀어내는 것도 중요하지만 자신의 한계를 알아야 합니다. 통증이나 불편함을 느낀다면 멈추고 휴식을 취하세요.\\n\\n기억하세요, 발전에는 시간과 인내가 필요합니다. 새로운 플랭크 기법을 마스터하거나 몇 초 더 플랭크를 유지한다든지하는 모든 단계를 축하하세요. 당신은 할 수 있어요!\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(가독성을 위해 위에서 줄 바꿈을 추가했습니다.)\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그것은 훌륭한 시작이에요. 하지만 출력물을 조금 더 사람이 읽기 쉬운 형식으로 포맷팅하는 것이 좋겣죠. 이를 위해 단순히 체인에 출력 파서를 추가하면 됩니다. StrOutputParser를 사용할 거에요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e os\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain_core.\u003cspan class=\"hljs-property\"\u003eprompts\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eChatPromptTemplate\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain_openai \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eChatOpenAI\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain_core.\u003cspan class=\"hljs-property\"\u003eoutput_parsers\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eStrOutputParser\u003c/span\u003e\n\nmy_prompt = \u003cspan class=\"hljs-title class_\"\u003eChatPromptTemplate\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efrom_messages\u003c/span\u003e([\n    (\u003cspan class=\"hljs-string\"\u003e\"system\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"당신은 친절하고 격려하는 피트니스 트레이너입니다.\"\u003c/span\u003e),\n    (\u003cspan class=\"hljs-string\"\u003e\"user\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"{input}\"\u003c/span\u003e)\n])\n\nllm = \u003cspan class=\"hljs-title class_\"\u003eChatOpenAI\u003c/span\u003e(openai_api_key=os.\u003cspan class=\"hljs-title function_\"\u003egetenv\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"OPENAI_API_KEY\"\u003c/span\u003e))\noutput_parser = \u003cspan class=\"hljs-title class_\"\u003eStrOutputParser\u003c/span\u003e()\n\nchain = my_prompt | llm | output_parser\n\nuser_input = \u003cspan class=\"hljs-title function_\"\u003einput\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"당신의 피트니스 목표에 관한 질문을 해주세요.\\n\"\u003c/span\u003e)\nresponse = chain.\u003cspan class=\"hljs-title function_\"\u003einvoke\u003c/span\u003e({\n  \u003cspan class=\"hljs-string\"\u003e\"input\"\u003c/span\u003e: user_input\n})\n\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(response)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 명령행에서 우리의 애플리케이션이 이렇게 보일 거에요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e(venv) $ \u003cspan class=\"hljs-variable constant_\"\u003eOPENAI_API_KEY\u003c/span\u003e=insert-key-here python3 main.\u003cspan class=\"hljs-property\"\u003epy\u003c/span\u003e\n당신의 피트니스 목표에 관한 질문을 해주세요.\n피스톨 스쿼트를 어떻게 배우나요?\n그것은 훌륭한 목표에요! 피스톨 스쿼트는 도전적일 수 있지만, 연습과 인내로 꼭 배울 수 있어요.\n\n피스톨 스쿼트를 연습하기 위해 다음 단계를 따라가보세요:\n\n\u003cspan class=\"hljs-number\"\u003e1.\u003c/span\u003e 스쿼트, 런지, 스텝업과 같은 운동으로 하체 근력을 키워보세요.\n\u003cspan class=\"hljs-number\"\u003e2.\u003c/span\u003e 단일다리 균형 운동을 통해 균형과 안정성을 향상시켜보세요.\n\u003cspan class=\"hljs-number\"\u003e3.\u003c/span\u003e 벤치나 의자 위로 몸을 내려친다는 부분적인 피스톨 스쿼트를 연습한 후 점차 전체적인 피스톨 스쿼트를 수행할 수 있게 되세요.\n\u003cspan class=\"hljs-number\"\u003e4.\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eTRX\u003c/span\u003e 밴드나 막대기와 같은 지원 도구를 사용하여 균형 유지와 몸을 내려치는 데 도움을 받아, 충분한 근력을 쌓아 무도도 수행할 수 있도록 하세요.\n\n피스톨 스쿼트를 시도하기 전에 반드시 웜업을 실시하고 부상을 피하기 위해 몸의 신호를 들어주는 것을 잊지 마세요. 그리고 가장 중요한 것은, 이 도전적인 운동을 마스터하는 데 노력하는 동안 긍정적이고 인내심을 가지세요. 당신은 할 수 있어요!\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eLLM 응담은 가독성을 향상시키기 위해 형식화되었습니다.\u003c/p\u003e\n\u003cp\u003e강력한 LLM 애플리케이션을 구축하기 위해, 우리의 체인은 이보다 훨씬 더 복잡할 것입니다. 그렇지만 그것이 LangChain의 강점이자 간결함입니다. 프레임워크는 당신의 필요에 맞는 로직을 모듈화할 수 있도록 해줘서 복잡한 워크플로우를 쉽게 연결할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e간단한 LLM 애플리케이션을 만들었으니, 여전히 우리 애플리케이션을 배포하고 호스팅하며 서비스하기 위한 능력이 필요합니다. 인프라보다 앱 빌드에 초점을 맞춘 개발자로써, LangServe와 Heroku에 의존합니다.\u003c/p\u003e\n\u003ch1\u003eLangServe로 서비스 하기\u003c/h1\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eLangServe는 LangChain 체인과 상호 작용할 수 있도록 REST API를 통해 도와줍니다. LangChain LLM 애플리케이션의 서빙 부분을 작성하기 위해 세 가지 주요 구성 요소가 필요합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e유효한 체인 (우리가 위에서 구축한 것과 같이)\u003c/li\u003e\n\u003cli\u003eAPI 애플리케이션 프레임워크 (예: FastAPI)\u003c/li\u003e\n\u003cli\u003e라우트 정의 (REST API를 구축할 때와 같이)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLangServe 문서에는 시작하는 방법에 대한 유용한 예제가 제공됩니다. 우리 예제에서는 FastAPI를 사용하여 API 서버를 시작하고 LangServe의 add_routes()를 호출하여 체인을 API 엔드포인트를 통해 접근 가능하게 만들면 됩니다.\u003c/p\u003e\n\u003cp\u003e이와 함께 기존 코드를 약간 수정해야합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e우리는 StrOutputParser의 사용을 제거할 것입니다. 이렇게 하면 API를 호출하는 사용자들이 출력을 어떻게 형식화하고 사용할지에 대해 유연성을 가질 수 있습니다.\u003c/li\u003e\n\u003cli\u003e명령 줄에서 사용자 입력을 요청하지 않을 것입니다. API 호출 요청이 사용자의 입력을 제공할 것입니다.\u003c/li\u003e\n\u003cli\u003echain.invoke()를 호출하지 않을 것입니다. LangServe가 API 요청 처리의 일부로 이를 처리할 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e우리는 프로젝트에 FastAPI와 LangServe 패키지를 추가했음을 확인합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e(venv) $ pip install langserve fastapi\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리의 최종 main.py 파일은 다음과 같습니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e os\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain_core.prompts \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e ChatPromptTemplate\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain_openai \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e ChatOpenAI\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e fastapi \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e FastAPI\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langserve \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e add_routes\n\nmy_prompt = ChatPromptTemplate.from_messages([\n    (\u003cspan class=\"hljs-string\"\u003e\"system\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"You are a friendly and encouraging fitness trainer.\"\u003c/span\u003e),\n    (\u003cspan class=\"hljs-string\"\u003e\"user\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"{input}\"\u003c/span\u003e)\n])\n\nllm = ChatOpenAI(openai_api_key=os.getenv(\u003cspan class=\"hljs-string\"\u003e\"OPENAI_API_KEY\"\u003c/span\u003e))\n\nchain = my_prompt | llm\n\napp = FastAPI(title=\u003cspan class=\"hljs-string\"\u003e\"Fitness Trainer\"\u003c/span\u003e)\n\nadd_routes(app, chain)\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e __name__ == \u003cspan class=\"hljs-string\"\u003e\"__main__\"\u003c/span\u003e:\n    \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e uvicorn\n\n    uvicorn.run(app, host=\u003cspan class=\"hljs-string\"\u003e\"localhost\"\u003c/span\u003e, port=\u003cspan class=\"hljs-number\"\u003e8000\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e내 로컬 머신인 우분투 20.04.6 LTS에서는 Python 3.8.10을 실행 중이었는데, 몇 가지 경고 메시지를 제거하기 위해 추가 패키지를 설치해야 했습니다. 당신의 머신에서는 이 작업이 필요하지 않을 수도 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-shell\"\u003e(venv) $ pip install sse_starlette pydantic==1.10.13\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 서버를 시작해 볼까요?\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e(venv) $ OPENAI_API_KEY=insert-key-here python3 main.py\u003c/p\u003e\n\u003cp\u003eINFO: 서버 프로세스 시작 [629848]\nINFO: 애플리케이션 시작을 기다리는 중.\u003c/p\u003e\n\u003cp\u003eLANGSERVE: \"/\" 경로의 Playground이 활성화되었습니다:\nLANGSERVE: │\nLANGSERVE: └──\u003e /playground/\nLANGSERVE:\nLANGSERVE: 사용 가능한 모든 경로는 /docs/에서 확인할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eINFO: 애플리케이션 시작 완료.\nINFO: Uvicorn이 \u003ca href=\"http://localhost:8000%EC%97%90%EC%84%9C\" rel=\"nofollow\" target=\"_blank\"\u003ehttp://localhost:8000에서\u003c/a\u003e 실행 중 (종료하려면 CTRL+C를 누르세요)\u003c/p\u003e\n\u003cp\u003e와아... 멋져요!\u003c/p\u003e\n\u003cp\u003e브라우저에서 \u003ca href=\"http://localhost:8000/docs\" rel=\"nofollow\" target=\"_blank\"\u003ehttp://localhost:8000/docs\u003c/a\u003e 로 이동할 수 있어요. 여기에서 확인할 수 있는 내용은:\u003c/p\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-09-LangChainPythonandHeroku_1.png\"\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eLangServe는 Swagger UI를 사용하는 API 문서 페이지를 제공합니다! 이제 LangServe를 통해 사용 가능한 엔드포인트들이 있습니다. 우리는 invoke/ 엔드포인트로 POST 요청을 보낼 수 있습니다. 하지만 LangServe는 우리에게 chain을 직접 다룰 수 있는 웹 인터페이스가 있는 playground/ 엔드포인트도 제공합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-LangChainPythonandHeroku_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e우리는 입력을 제공하고 시작을 클릭합니다. 결과는 다음과 같습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-LangChainPythonandHeroku_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eLLM 애플리케이션 워크플로의 맥락에서 API의 중요성을 강조하는 것이 중요합니다. LLM 및 해당 애플리케이션의 대부분 사용 사례를 생각해보면, 로컬 모델 및 자원에 의존할 수 없습니다. 이것은 합리적이지 않고 확장성이 떨어집니다.\u003c/p\u003e\n\u003cp\u003eLLM 애플리케이션의 실제 파워는 이전까지 설명한 복잡한 워크플로를 추상화하는 능력에 있습니다. 우리는 수행한 모든 것을 API 뒤에 숨겨 사용 사례가 확장되고 다른 사람들이 통합할 수 있도록 하려고 합니다. 이는 API를 호스팅하고 제공할 수 있는 쉬운 옵션이 있다면에만 가능합니다. 그리고 바로 그것이 Heroku에서 할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003eHeroku에 배포\u003c/h1\u003e\n\u003cp\u003eHeroku는 LLM 애플리케이션 구현의 중요한 마지막 부분입니다. 우리는 LangChain을 사용하여 워크플로를 조합하고 LangServe를 사용하여 유용한 REST API로 제공합니다. 이제 복잡한 자원을 수동으로 설정하여 트래픽을 호스팅하고 제공하는 대신, Heroku를 사용하여 애플리케이션을 간단히 배포할 수 있습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e헤로쿠 계정을 설정한 후에, 이제 거의 배포할 준비가 끝났어요. 함께 순서대로 진행해볼게요.\u003c/p\u003e\n\u003ch2\u003e새로운 헤로쿠 앱 생성하기\u003c/h2\u003e\n\u003cp\u003e헤로쿠 CLI를 사용해서 로그인하고 새로운 앱을 생성해요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$ heroku login\n$ heroku create my-langchain-app\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e설정 변수 설정하기\u003c/h2\u003e\n\u003cp\u003e이제 Heroku 앱 환경에서 OPENAI_API_KEY 환경 변수를 설정해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$ heroku \u003cspan class=\"hljs-attr\"\u003econfig\u003c/span\u003e:set \u003cspan class=\"hljs-variable constant_\"\u003eOPENAI_API_KEY\u003c/span\u003e=여러분의-openai-api-key로-대체하세요\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003ePython 애플리케이션 배포를 위한 설정 파일 만들기\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e헤로쿠가 우리의 파이썬 애플리케이션을 실행하기 위해 필요한 것을 알 수 있도록 하려면 세 가지 간단한 파일을 만들어야 합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eProcfile: 헤로쿠가 앱을 시작하는 데 사용해야 하는 명령을 선언합니다.\u003c/li\u003e\n\u003cli\u003erequirements.txt: 헤로쿠가 설치해야 하는 Python 패키지 종속성을 지정합니다.\u003c/li\u003e\n\u003cli\u003eruntime.txt: 앱에 사용하려는 정확한 Python 런타임 버전을 지정합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 파일들은 빠르고 쉽게 만들 수 있습니다. 각각은 프로젝트의 루트 폴더에 들어갑니다. Procfile을 만들려면 다음 명령을 실행하면 됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e$ \u003cspan class=\"hljs-built_in\"\u003eecho\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'web: uvicorn main:app --host=0.0.0.0 --port=${PORT}'\u003c/span\u003e \u003e Procfile\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이것은 Heroku에게 Python에서 웹 서버 구현인 uvicorn을 실행하도록 지시합니다.\u003c/p\u003e\n\u003cp\u003erequirements.txt에 대해, pip freeze 명령을 사용하여 설치된 패키지 목록을 출력할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$ pip freeze \u003e requirements.\u003cspan class=\"hljs-property\"\u003etxt\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e마지막으로, runtime.txt에는 Python 3.11.8을 사용할 것입니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$ echo \u003cspan class=\"hljs-string\"\u003e'python-3.11.8'\u003c/span\u003e \u003e runtime.\u003cspan class=\"hljs-property\"\u003etxt\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 파일들이 준비된 상태에서 프로젝트 루트 폴더는 다음과 같이 보일 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$ tree\n.\n├── main.\u003cspan class=\"hljs-property\"\u003epy\u003c/span\u003e\n├── \u003cspan class=\"hljs-title class_\"\u003eProcfile\u003c/span\u003e\n├── requirements.\u003cspan class=\"hljs-property\"\u003etxt\u003c/span\u003e\n└── runtime.\u003cspan class=\"hljs-property\"\u003etxt\u003c/span\u003e\n\n\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e directories, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e files\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 파일들을 모두 GitHub 저장소에 커밋합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003eHeroku와 GitHub 저장소 연결하기\u003c/h2\u003e\n\u003cp\u003e마지막으로 할 일은 GitHub 저장소에 대한 Heroku 원격을 생성한 다음 코드를 해당 원격으로 푸시하는 것입니다. Heroku는 새 코드를 푸시하면 해당 코드를 응용 프로그램에 배포합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$ heroku \u003cspan class=\"hljs-attr\"\u003egit\u003c/span\u003e:remote -a my-langchain-app\n$ git push heroku main\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리의 코드가 Heroku 원격으로 푸시되면, Heroku는 애플리케이션을 빌드하고 종속성을 설치한 다음 Procfile에서 지정된 명령을 실행합니다. git push 명령어의 최종 결과는 다음과 같습니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e…\n\n\u003cspan class=\"hljs-attr\"\u003eremote\u003c/span\u003e: -----\u003e 프로세스 유형 검색 중\n\u003cspan class=\"hljs-attr\"\u003eremote\u003c/span\u003e:        \u003cspan class=\"hljs-title class_\"\u003eProcfile\u003c/span\u003e이 다음 유형을 선언함 -\u003e web\n\u003cspan class=\"hljs-attr\"\u003eremote\u003c/span\u003e:\n\u003cspan class=\"hljs-attr\"\u003eremote\u003c/span\u003e: -----\u003e 압축 중...\n\u003cspan class=\"hljs-attr\"\u003eremote\u003c/span\u003e:        완료: \u003cspan class=\"hljs-number\"\u003e71.\u003c/span\u003e8M\n\u003cspan class=\"hljs-attr\"\u003eremote\u003c/span\u003e: -----\u003e 배포 중...\n\u003cspan class=\"hljs-attr\"\u003eremote\u003c/span\u003e:        v4 버전이 릴리스됨\n\u003cspan class=\"hljs-attr\"\u003eremote\u003c/span\u003e:        \u003cspan class=\"hljs-attr\"\u003ehttps\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//my-langchain-app-ea95419b2750.herokuapp.com/ 에 배포됨\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003eremote\u003c/span\u003e:\n\u003cspan class=\"hljs-attr\"\u003eremote\u003c/span\u003e: 배포 확인... 완료.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리의 Heroku 앱 URL이 표시됩니다. 브라우저에서 \u003ca href=\"https://my-langchain-app-ea95419b2750.herokuapp.com/playground%EC%9D%84\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://my-langchain-app-ea95419b2750.herokuapp.com/playground을\u003c/a\u003e 방문해주세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-LangChainPythonandHeroku_4.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e또한 Swagger UI 문서 페이지를 확인하려면 \u003ca href=\"https://my-langchain-app-ea95419b2750.herokuapp.com/docs%EB%A5%BC\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://my-langchain-app-ea95419b2750.herokuapp.com/docs를\u003c/a\u003e 방문해주세요.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-LangChainPythonandHeroku_5.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e그리고 그렇게해서 우리는 시작했어요!\u003c/p\u003e\n\u003cp\u003e이 프로세스는 LangChain과 함께 작업할 때 개발 시간과 오버헤드를 줄이는 최상의 방법입니다. LangChain으로 작성된 API를 쉽게 몇 가지 간단한 명령어로 Heroku에 배포할 수 있는 기능은 LangChain과 Heroku를 결합하는 것을 당연하게 만듭니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e오늘의 기업과 개발자들은 AI와 LLM(언어 모델)의 파도를 타기에 올바른 선택을 했습니다. 이들 영역에서 혁신과 새로운 개발 가능성이 많습니다. 그러나 성공과 실패의 차이는 그들이 애플리케이션을 구축하고 배포하는 데 사용하는 도구 체인에 많이 달렸습니다.\u003c/p\u003e\n\u003cp\u003eLangChain 프레임워크를 사용하면 LLM 기반 애플리케이션을 만드는 프로세스가 접근 가능하고 반복 가능해집니다. 그러나 구현은 전투의 반이에 불과합니다. 애플리케이션이 만들어지면, 이러한 애플리케이션 API를 클라우드에 쉽고 빠르게 배포할 수 있는 능력이 필요합니다. 그 곳에서 더 빠른 반복과 개발의 장점을 가질 수 있고, Heroku를 통해 그 길에 도달할 수 있습니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-09-LangChainPythonandHeroku"},"buildId":"71zJMhK9mFbQV7s02rMGq","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>