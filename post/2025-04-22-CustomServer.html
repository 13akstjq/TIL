<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Next.js 15 커스텀 서버 구축하는 방법 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-CustomServer" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Next.js 15 커스텀 서버 구축하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:title" content="Next.js 15 커스텀 서버 구축하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-CustomServer" data-gatsby-head="true"/><meta name="twitter:title" content="Next.js 15 커스텀 서버 구축하는 방법 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2025-04-22 02:07" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/0eef537492fed77a.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/0eef537492fed77a.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-8ded8b979ba73586.js" defer=""></script><script src="/TIL/_next/static/olPs1cVezSGTqD7OaewDI/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/olPs1cVezSGTqD7OaewDI/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Next.js 15 커스텀 서버 구축하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Next.js 15 커스텀 서버 구축하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Apr 22, 2025</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>커스텀 서버(Custom Server) 이해하기</h1>
<p>Next.js를 사용하면 기본적으로 <code>next start</code> 명령어로 내장된 서버가 바로 실행돼요. 그런데 만약 이미 백엔드 서버가 따로 있다면, 그걸 그대로 유지하면서 Next.js와 함께 사용할 수도 있답니다. 이 경우를 ‘커스텀 서버(Custom Server)’라고 부르지 않아요.</p>
<p>커스텀 Next.js 서버는 필요에 따라 내 프로그램에서 직접 서버를 띄우면서 라우팅이나 요청 처리 방식을 자유롭게 바꾸고 싶을 때 사용해요. 하지만 대부분의 경우에는 Next.js가 제공하는 기본 라우터만으로도 충분하기 때문에 굳이 커스텀 서버를 만들 필요가 없어요.</p>
<blockquote>
<p><strong>여기서 주의!</strong></p>
<ul>
<li>커스텀 서버는 Next.js의 자동 정적 최적화(Automatic Static Optimization) 같은 중요한 성능 개선 기능들을 포기하는 대가를 치러야 해요.</li>
<li>그리고 Vercel 같은 Next.js 공식 배포 플랫폼에서는 커스텀 서버를 사용할 수 없어요.</li>
<li><code>standalone</code> 출력 모드를 사용할 때는 커스텀 서버 파일을 함께 추적하지 않고, 대신 최소한의 <code>server.js</code> 파일만 따로 만들어내요. 그래서 둘을 동시에 사용할 수도 없으니 주의가 필요해요.</li>
</ul>
</blockquote>
<p>아래는 커스텀 서버의 간단한 예시를 보여드릴게요. 예전에는 Express.js 같은 외부 서버 라이브러리와 함께 Next.js를 이렇게 쓰는 경우가 많았는데, 최근 Next.js가 점점 더 자체 기능을 강화하면서 점차 필요성이 줄고 있죠.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">"express"</span>);
<span class="hljs-keyword">const</span> next = <span class="hljs-built_in">require</span>(<span class="hljs-string">"next"</span>);

<span class="hljs-keyword">const</span> port = <span class="hljs-number">3000</span>;
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">next</span>({ <span class="hljs-attr">dev</span>: <span class="hljs-literal">false</span> });
<span class="hljs-keyword">const</span> handle = app.<span class="hljs-title function_">getRequestHandler</span>();

app.<span class="hljs-title function_">prepare</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =></span> {
  <span class="hljs-keyword">const</span> server = <span class="hljs-title function_">express</span>();

  <span class="hljs-comment">// 커스텀 라우트 예시</span>
  server.<span class="hljs-title function_">get</span>(<span class="hljs-string">"/p/:id"</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =></span> {
    <span class="hljs-keyword">const</span> actualPage = <span class="hljs-string">"/post"</span>;
    <span class="hljs-keyword">const</span> queryParams = { <span class="hljs-attr">id</span>: req.<span class="hljs-property">params</span>.<span class="hljs-property">id</span> };
    app.<span class="hljs-title function_">render</span>(req, res, actualPage, queryParams);
  });

  <span class="hljs-comment">// 나머지는 Next.js 기본 처리</span>
  server.<span class="hljs-title function_">all</span>(<span class="hljs-string">"*"</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =></span> {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">handle</span>(req, res);
  });

  server.<span class="hljs-title function_">listen</span>(port, <span class="hljs-function">(<span class="hljs-params">err</span>) =></span> {
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`> Ready on http://localhost:<span class="hljs-subst">${port}</span>`</span>);
  });
});
</code></pre>
<hr>
<h3>꼭 알아두면 좋은 팁</h3>
<ul>
<li>커스텀 서버는 정말 필요할 때에만 써요! 기본 Next.js 라우팅으로 충분하면 굳이 복잡하게 서버를 직접 관리할 필요 없어요.</li>
<li>Vercel 배포에서는 사용 불가라는 점, 잊지 마세요.</li>
<li>서버 없는 환경(serverless)이나 요즘 많이 쓰는 ISR(Incremental Static Regeneration) 기능이랑도 잘 맞지 않아요.</li>
<li>많이 쓰이는 기능은 공식 Next.js 라우터 기능이나 API 라우트를 활용하는 게 더 깔끔하고 이후 유지보수도 편해요.</li>
</ul>
<p>만약 커스텀 서버와 관련해서 더 궁금한 점 있으면 언제든 질문해 주세요! 혹은 Next.js 기본 라우터들의 여러 팁도 공유해 드릴게요. 😊</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Next.js 프로젝트에서 커스텀 서버를 직접 만들고 싶을 때, 보통 <code>server.js</code> 파일을 만들어서 Node.js의 HTTP 서버를 활용하곤 해요. 오늘은 간단한 커스텀 서버 예제와, 이걸 어떻게 실행할지 package.json에 스크립트를 어떻게 추가하는지 알려드릴게요.</p>
<p>먼저, 이 코드를 보시면 서버를 직접 생성하고 Next.js 앱을 <code>next()</code> 함수로 감싼 뒤에 준비가 끝나면 HTTP 서버를 띄우는 구조예요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { createServer } <span class="hljs-keyword">from</span> <span class="hljs-string">'http'</span>
<span class="hljs-keyword">import</span> { parse } <span class="hljs-keyword">from</span> <span class="hljs-string">'url'</span>
<span class="hljs-keyword">import</span> next <span class="hljs-keyword">from</span> <span class="hljs-string">'next'</span>

<span class="hljs-keyword">const</span> port = <span class="hljs-built_in">parseInt</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">PORT</span> || <span class="hljs-string">'3000'</span>, <span class="hljs-number">10</span>)
<span class="hljs-keyword">const</span> dev = process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">'production'</span>
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">next</span>({ dev })
<span class="hljs-keyword">const</span> handle = app.<span class="hljs-title function_">getRequestHandler</span>()

app.<span class="hljs-title function_">prepare</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =></span> {
  <span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =></span> {
    <span class="hljs-keyword">const</span> parsedUrl = <span class="hljs-title function_">parse</span>(req.<span class="hljs-property">url</span>!, <span class="hljs-literal">true</span>)
    <span class="hljs-title function_">handle</span>(req, res, parsedUrl)
  }).<span class="hljs-title function_">listen</span>(port)

  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
    <span class="hljs-string">`> Server listening at http://localhost:<span class="hljs-subst">${port}</span> as <span class="hljs-subst">${
      dev ? <span class="hljs-string">'development'</span> : process.env.NODE_ENV
    }</span>`</span>
  )
})
</code></pre>
<p>이 코드에서 핵심은 <code>app.prepare()</code>가 끝나면 HTTP 서버를 열며, 들어오는 요청을 <code>handle</code> 함수로 넘겨서 Next.js가 페이지를 렌더링하도록 한다는 점이에요.</p>
<h3>그런데 여기서 중요한 점!</h3>
<p><code>server.js</code>는 Next.js 컴파일러를 거치지 않고 그냥 Node.js에서 직접 실행되기 때문에, 최신 문법(예: ES 모듈 <code>import</code> 구문)을 쓸 때 Node.js 버전과 호환되는지 반드시 확인해야 합니다. 만약 호환 안 되면 직접 <code>require()</code>로 바꾸거나, Babel 같은 트랜스파일러 사용을 고려해야 해요.</p>
<hr>
<h3>package.json에 커스텀 서버 실행 스크립트 추가하기</h3>
<p>커스텀 서버를 실행하려면 <code>package.json</code>의 <code>scripts</code>를 이렇게 바꿔줘야 해요.</p>
<pre><code class="hljs language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"scripts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"dev"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"node server.js"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"build"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"next build"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"start"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"NODE_ENV=production node server.js"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<ul>
<li><code>dev</code>: 개발 모드에서 커스텀 서버 바로 실행</li>
<li><code>build</code>: Next.js 빌드 수행</li>
<li><code>start</code>: 프로덕션 환경에서 커스텀 서버 실행</li>
</ul>
<hr>
<h3>덧붙여서…</h3>
<p>커스텀 서버를 만들면 유연하게 서버 로직 제어가 가능하지만, Next.js의 기본 서버 기능과 자동 최적화, 배포 플랫폼(예: Vercel) 지원을 덜 받게 돼요. 그러니 정말 필요한 경우가 아니라면 기본 Next.js 빌트인 서버를 쓰는 걸 권장합니다!</p>
<p>그럼, 여러분만의 커스텀 서버 만들어서 원하는 기능 자유롭게 구현해보세요! 궁금한 점 있으면 언제든 질문 남겨주세요. 😄</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>대신에 nodemon을 설정해서 사용할 수도 있어요(예시 참고). 커스텀 서버는 Next.js 애플리케이션과 연결하기 위해 아래와 같은 import 문을 사용합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> next <span class="hljs-keyword">from</span> <span class="hljs-string">"next"</span>;

<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">next</span>({});
</code></pre>
<p>여기서 next 함수는 옵션들을 담은 객체를 인자로 받는데요, 주요 옵션들은 다음과 같습니다:</p>


















































<table><thead><tr><th>옵션</th><th>타입</th><th>설명</th></tr></thead><tbody><tr><td><code>conf</code></td><td><code>Object</code></td><td><code>next.config.js</code> 에서 사용하는 설정 객체와 동일해요. 기본값은 <code>{}</code> 입니다.</td></tr><tr><td><code>dev</code></td><td><code>Boolean</code></td><td>(선택) Next.js를 개발 모드로 실행할지 여부입니다. 기본값은 <code>false</code> 입니다.</td></tr><tr><td><code>dir</code></td><td><code>String</code></td><td>(선택) Next.js 프로젝트 위치를 지정합니다. 기본값은 현재 폴더 <code>'.'</code> 입니다.</td></tr><tr><td><code>quiet</code></td><td><code>Boolean</code></td><td>(선택) 서버 정보가 포함된 에러 메시지를 숨길지 결정합니다. 기본값은 <code>false</code> 입니다.</td></tr><tr><td><code>hostname</code></td><td><code>String</code></td><td>(선택) 서버가 실행되는 호스트 이름을 지정합니다.</td></tr><tr><td><code>port</code></td><td><code>Number</code></td><td>(선택) 서버가 실행되는 포트를 지정합니다.</td></tr><tr><td><code>httpServer</code></td><td><code>node:http#Server</code></td><td>(선택) Next.js가 작동 중인 HTTP 서버 객체를 넘겨줄 수 있습니다.</td></tr><tr><td><code>turbo</code></td><td><code>Boolean</code></td><td>(선택) Turbopack을 활성화할지 여부입니다.</td></tr></tbody></table>
<hr>
<p><strong>간단 팁!</strong></p>
<ul>
<li>개발할 때 <code>dev</code> 옵션을 <code>true</code>로 주면 핫 리로딩도 잡아주고 디버깅이 편해져요.</li>
<li>프로젝트 경로가 현재 폴더가 아니라면 <code>dir</code> 옵션으로 정확히 지정해주는 게 중요합니다.</li>
<li><code>quiet</code> 옵션을 켜면 서버 에러 로그가 줄어들어 콘솔이 깔끔해져서 가끔 쓰면 좋아요.</li>
<li>그리고 마지막으로 <code>turbo</code> 옵션은 Next.js의 차세대 번들러인 Turbopack을 활성화하는건데, 아직 실험적인 기능이라 프로젝트 특성에 따라 테스트해보시는 걸 추천해요.</li>
</ul>
<p>이렇게 다양한 옵션을 활용해서 커스텀 서버 환경을 자신의 필요에 맞게 세팅해보세요! 개발할 때 내 서버 환경을 좀 더 세밀하게 컨트롤할 수 있어서 편리합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>반환된 앱은 Next.js가 요청을 필요한 대로 처리할 수 있도록 사용하는 데 활용할 수 있어요.</p>
<p>여기서 중요한 점은, Next.js가 기본적으로 서버 사이드 렌더링(SSR)과 정적 생성(SSG) 모두를 지원하기 때문에, 반환된 앱으로 다양한 요청 처리 방식을 유연하게 다룰 수 있다는 거예요.</p>
<p>예를 들어, API 라우트나 커스텀 서버를 구축할 때 조금 더 세밀한 제어가 필요하면 이렇게 반환된 앱을 통해 요청을 직접 처리할 수 있고, 그렇지 않으면 Next.js의 기본 라우팅에 맡길 수도 있죠.</p>
<p>이런 방식을 활용하면 복잡한 서버 로직을 구현할 때도 Next.js의 장점을 최대한 살리면서 개발할 수 있어요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Next.js 15 커스텀 서버 구축하는 방법","description":"","date":"2025-04-22 02:07","slug":"2025-04-22-CustomServer","content":"\n# 커스텀 서버(Custom Server) 이해하기\n\nNext.js를 사용하면 기본적으로 `next start` 명령어로 내장된 서버가 바로 실행돼요. 그런데 만약 이미 백엔드 서버가 따로 있다면, 그걸 그대로 유지하면서 Next.js와 함께 사용할 수도 있답니다. 이 경우를 ‘커스텀 서버(Custom Server)’라고 부르지 않아요.\n\n커스텀 Next.js 서버는 필요에 따라 내 프로그램에서 직접 서버를 띄우면서 라우팅이나 요청 처리 방식을 자유롭게 바꾸고 싶을 때 사용해요. 하지만 대부분의 경우에는 Next.js가 제공하는 기본 라우터만으로도 충분하기 때문에 굳이 커스텀 서버를 만들 필요가 없어요.\n\n\u003e **여기서 주의!**\n\u003e\n\u003e - 커스텀 서버는 Next.js의 자동 정적 최적화(Automatic Static Optimization) 같은 중요한 성능 개선 기능들을 포기하는 대가를 치러야 해요.\n\u003e - 그리고 Vercel 같은 Next.js 공식 배포 플랫폼에서는 커스텀 서버를 사용할 수 없어요.\n\u003e - `standalone` 출력 모드를 사용할 때는 커스텀 서버 파일을 함께 추적하지 않고, 대신 최소한의 `server.js` 파일만 따로 만들어내요. 그래서 둘을 동시에 사용할 수도 없으니 주의가 필요해요.\n\n아래는 커스텀 서버의 간단한 예시를 보여드릴게요. 예전에는 Express.js 같은 외부 서버 라이브러리와 함께 Next.js를 이렇게 쓰는 경우가 많았는데, 최근 Next.js가 점점 더 자체 기능을 강화하면서 점차 필요성이 줄고 있죠.\n\n```js\nconst express = require(\"express\");\nconst next = require(\"next\");\n\nconst port = 3000;\nconst app = next({ dev: false });\nconst handle = app.getRequestHandler();\n\napp.prepare().then(() =\u003e {\n  const server = express();\n\n  // 커스텀 라우트 예시\n  server.get(\"/p/:id\", (req, res) =\u003e {\n    const actualPage = \"/post\";\n    const queryParams = { id: req.params.id };\n    app.render(req, res, actualPage, queryParams);\n  });\n\n  // 나머지는 Next.js 기본 처리\n  server.all(\"*\", (req, res) =\u003e {\n    return handle(req, res);\n  });\n\n  server.listen(port, (err) =\u003e {\n    if (err) throw err;\n    console.log(`\u003e Ready on http://localhost:${port}`);\n  });\n});\n```\n\n---\n\n### 꼭 알아두면 좋은 팁\n\n- 커스텀 서버는 정말 필요할 때에만 써요! 기본 Next.js 라우팅으로 충분하면 굳이 복잡하게 서버를 직접 관리할 필요 없어요.\n- Vercel 배포에서는 사용 불가라는 점, 잊지 마세요.\n- 서버 없는 환경(serverless)이나 요즘 많이 쓰는 ISR(Incremental Static Regeneration) 기능이랑도 잘 맞지 않아요.\n- 많이 쓰이는 기능은 공식 Next.js 라우터 기능이나 API 라우트를 활용하는 게 더 깔끔하고 이후 유지보수도 편해요.\n\n만약 커스텀 서버와 관련해서 더 궁금한 점 있으면 언제든 질문해 주세요! 혹은 Next.js 기본 라우터들의 여러 팁도 공유해 드릴게요. 😊\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js 프로젝트에서 커스텀 서버를 직접 만들고 싶을 때, 보통 `server.js` 파일을 만들어서 Node.js의 HTTP 서버를 활용하곤 해요. 오늘은 간단한 커스텀 서버 예제와, 이걸 어떻게 실행할지 package.json에 스크립트를 어떻게 추가하는지 알려드릴게요.\n\n먼저, 이 코드를 보시면 서버를 직접 생성하고 Next.js 앱을 `next()` 함수로 감싼 뒤에 준비가 끝나면 HTTP 서버를 띄우는 구조예요.\n\n```js\nimport { createServer } from 'http'\nimport { parse } from 'url'\nimport next from 'next'\n\nconst port = parseInt(process.env.PORT || '3000', 10)\nconst dev = process.env.NODE_ENV !== 'production'\nconst app = next({ dev })\nconst handle = app.getRequestHandler()\n\napp.prepare().then(() =\u003e {\n  createServer((req, res) =\u003e {\n    const parsedUrl = parse(req.url!, true)\n    handle(req, res, parsedUrl)\n  }).listen(port)\n\n  console.log(\n    `\u003e Server listening at http://localhost:${port} as ${\n      dev ? 'development' : process.env.NODE_ENV\n    }`\n  )\n})\n```\n\n이 코드에서 핵심은 `app.prepare()`가 끝나면 HTTP 서버를 열며, 들어오는 요청을 `handle` 함수로 넘겨서 Next.js가 페이지를 렌더링하도록 한다는 점이에요.\n\n### 그런데 여기서 중요한 점!\n\n`server.js`는 Next.js 컴파일러를 거치지 않고 그냥 Node.js에서 직접 실행되기 때문에, 최신 문법(예: ES 모듈 `import` 구문)을 쓸 때 Node.js 버전과 호환되는지 반드시 확인해야 합니다. 만약 호환 안 되면 직접 `require()`로 바꾸거나, Babel 같은 트랜스파일러 사용을 고려해야 해요.\n\n---\n\n### package.json에 커스텀 서버 실행 스크립트 추가하기\n\n커스텀 서버를 실행하려면 `package.json`의 `scripts`를 이렇게 바꿔줘야 해요.\n\n```json\n{\n  \"scripts\": {\n    \"dev\": \"node server.js\",\n    \"build\": \"next build\",\n    \"start\": \"NODE_ENV=production node server.js\"\n  }\n}\n```\n\n- `dev`: 개발 모드에서 커스텀 서버 바로 실행\n- `build`: Next.js 빌드 수행\n- `start`: 프로덕션 환경에서 커스텀 서버 실행\n\n---\n\n### 덧붙여서…\n\n커스텀 서버를 만들면 유연하게 서버 로직 제어가 가능하지만, Next.js의 기본 서버 기능과 자동 최적화, 배포 플랫폼(예: Vercel) 지원을 덜 받게 돼요. 그러니 정말 필요한 경우가 아니라면 기본 Next.js 빌트인 서버를 쓰는 걸 권장합니다!\n\n그럼, 여러분만의 커스텀 서버 만들어서 원하는 기능 자유롭게 구현해보세요! 궁금한 점 있으면 언제든 질문 남겨주세요. 😄\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n대신에 nodemon을 설정해서 사용할 수도 있어요(예시 참고). 커스텀 서버는 Next.js 애플리케이션과 연결하기 위해 아래와 같은 import 문을 사용합니다:\n\n```js\nimport next from \"next\";\n\nconst app = next({});\n```\n\n여기서 next 함수는 옵션들을 담은 객체를 인자로 받는데요, 주요 옵션들은 다음과 같습니다:\n\n| 옵션         | 타입               | 설명                                                                                |\n| ------------ | ------------------ | ----------------------------------------------------------------------------------- |\n| `conf`       | `Object`           | `next.config.js` 에서 사용하는 설정 객체와 동일해요. 기본값은 `{}` 입니다.          |\n| `dev`        | `Boolean`          | (선택) Next.js를 개발 모드로 실행할지 여부입니다. 기본값은 `false` 입니다.          |\n| `dir`        | `String`           | (선택) Next.js 프로젝트 위치를 지정합니다. 기본값은 현재 폴더 `'.'` 입니다.         |\n| `quiet`      | `Boolean`          | (선택) 서버 정보가 포함된 에러 메시지를 숨길지 결정합니다. 기본값은 `false` 입니다. |\n| `hostname`   | `String`           | (선택) 서버가 실행되는 호스트 이름을 지정합니다.                                    |\n| `port`       | `Number`           | (선택) 서버가 실행되는 포트를 지정합니다.                                           |\n| `httpServer` | `node:http#Server` | (선택) Next.js가 작동 중인 HTTP 서버 객체를 넘겨줄 수 있습니다.                     |\n| `turbo`      | `Boolean`          | (선택) Turbopack을 활성화할지 여부입니다.                                           |\n\n---\n\n**간단 팁!**\n\n- 개발할 때 `dev` 옵션을 `true`로 주면 핫 리로딩도 잡아주고 디버깅이 편해져요.\n- 프로젝트 경로가 현재 폴더가 아니라면 `dir` 옵션으로 정확히 지정해주는 게 중요합니다.\n- `quiet` 옵션을 켜면 서버 에러 로그가 줄어들어 콘솔이 깔끔해져서 가끔 쓰면 좋아요.\n- 그리고 마지막으로 `turbo` 옵션은 Next.js의 차세대 번들러인 Turbopack을 활성화하는건데, 아직 실험적인 기능이라 프로젝트 특성에 따라 테스트해보시는 걸 추천해요.\n\n이렇게 다양한 옵션을 활용해서 커스텀 서버 환경을 자신의 필요에 맞게 세팅해보세요! 개발할 때 내 서버 환경을 좀 더 세밀하게 컨트롤할 수 있어서 편리합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n반환된 앱은 Next.js가 요청을 필요한 대로 처리할 수 있도록 사용하는 데 활용할 수 있어요.\n\n여기서 중요한 점은, Next.js가 기본적으로 서버 사이드 렌더링(SSR)과 정적 생성(SSG) 모두를 지원하기 때문에, 반환된 앱으로 다양한 요청 처리 방식을 유연하게 다룰 수 있다는 거예요.\n\n예를 들어, API 라우트나 커스텀 서버를 구축할 때 조금 더 세밀한 제어가 필요하면 이렇게 반환된 앱을 통해 요청을 직접 처리할 수 있고, 그렇지 않으면 Next.js의 기본 라우팅에 맡길 수도 있죠.\n\n이런 방식을 활용하면 복잡한 서버 로직을 구현할 때도 Next.js의 장점을 최대한 살리면서 개발할 수 있어요!\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003e커스텀 서버(Custom Server) 이해하기\u003c/h1\u003e\n\u003cp\u003eNext.js를 사용하면 기본적으로 \u003ccode\u003enext start\u003c/code\u003e 명령어로 내장된 서버가 바로 실행돼요. 그런데 만약 이미 백엔드 서버가 따로 있다면, 그걸 그대로 유지하면서 Next.js와 함께 사용할 수도 있답니다. 이 경우를 ‘커스텀 서버(Custom Server)’라고 부르지 않아요.\u003c/p\u003e\n\u003cp\u003e커스텀 Next.js 서버는 필요에 따라 내 프로그램에서 직접 서버를 띄우면서 라우팅이나 요청 처리 방식을 자유롭게 바꾸고 싶을 때 사용해요. 하지만 대부분의 경우에는 Next.js가 제공하는 기본 라우터만으로도 충분하기 때문에 굳이 커스텀 서버를 만들 필요가 없어요.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e여기서 주의!\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e커스텀 서버는 Next.js의 자동 정적 최적화(Automatic Static Optimization) 같은 중요한 성능 개선 기능들을 포기하는 대가를 치러야 해요.\u003c/li\u003e\n\u003cli\u003e그리고 Vercel 같은 Next.js 공식 배포 플랫폼에서는 커스텀 서버를 사용할 수 없어요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003estandalone\u003c/code\u003e 출력 모드를 사용할 때는 커스텀 서버 파일을 함께 추적하지 않고, 대신 최소한의 \u003ccode\u003eserver.js\u003c/code\u003e 파일만 따로 만들어내요. 그래서 둘을 동시에 사용할 수도 없으니 주의가 필요해요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e아래는 커스텀 서버의 간단한 예시를 보여드릴게요. 예전에는 Express.js 같은 외부 서버 라이브러리와 함께 Next.js를 이렇게 쓰는 경우가 많았는데, 최근 Next.js가 점점 더 자체 기능을 강화하면서 점차 필요성이 줄고 있죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e express = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"express\"\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e next = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"next\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e port = \u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e app = \u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003edev\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e });\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e handle = app.\u003cspan class=\"hljs-title function_\"\u003egetRequestHandler\u003c/span\u003e();\n\napp.\u003cspan class=\"hljs-title function_\"\u003eprepare\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e server = \u003cspan class=\"hljs-title function_\"\u003eexpress\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-comment\"\u003e// 커스텀 라우트 예시\u003c/span\u003e\n  server.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"/p/:id\"\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ereq, res\u003c/span\u003e) =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e actualPage = \u003cspan class=\"hljs-string\"\u003e\"/post\"\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e queryParams = { \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: req.\u003cspan class=\"hljs-property\"\u003eparams\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e };\n    app.\u003cspan class=\"hljs-title function_\"\u003erender\u003c/span\u003e(req, res, actualPage, queryParams);\n  });\n\n  \u003cspan class=\"hljs-comment\"\u003e// 나머지는 Next.js 기본 처리\u003c/span\u003e\n  server.\u003cspan class=\"hljs-title function_\"\u003eall\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"*\"\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ereq, res\u003c/span\u003e) =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandle\u003c/span\u003e(req, res);\n  });\n\n  server.\u003cspan class=\"hljs-title function_\"\u003elisten\u003c/span\u003e(port, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eerr\u003c/span\u003e) =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (err) \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e err;\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`\u003e Ready on http://localhost:\u003cspan class=\"hljs-subst\"\u003e${port}\u003c/span\u003e`\u003c/span\u003e);\n  });\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003e꼭 알아두면 좋은 팁\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e커스텀 서버는 정말 필요할 때에만 써요! 기본 Next.js 라우팅으로 충분하면 굳이 복잡하게 서버를 직접 관리할 필요 없어요.\u003c/li\u003e\n\u003cli\u003eVercel 배포에서는 사용 불가라는 점, 잊지 마세요.\u003c/li\u003e\n\u003cli\u003e서버 없는 환경(serverless)이나 요즘 많이 쓰는 ISR(Incremental Static Regeneration) 기능이랑도 잘 맞지 않아요.\u003c/li\u003e\n\u003cli\u003e많이 쓰이는 기능은 공식 Next.js 라우터 기능이나 API 라우트를 활용하는 게 더 깔끔하고 이후 유지보수도 편해요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e만약 커스텀 서버와 관련해서 더 궁금한 점 있으면 언제든 질문해 주세요! 혹은 Next.js 기본 라우터들의 여러 팁도 공유해 드릴게요. 😊\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eNext.js 프로젝트에서 커스텀 서버를 직접 만들고 싶을 때, 보통 \u003ccode\u003eserver.js\u003c/code\u003e 파일을 만들어서 Node.js의 HTTP 서버를 활용하곤 해요. 오늘은 간단한 커스텀 서버 예제와, 이걸 어떻게 실행할지 package.json에 스크립트를 어떻게 추가하는지 알려드릴게요.\u003c/p\u003e\n\u003cp\u003e먼저, 이 코드를 보시면 서버를 직접 생성하고 Next.js 앱을 \u003ccode\u003enext()\u003c/code\u003e 함수로 감싼 뒤에 준비가 끝나면 HTTP 서버를 띄우는 구조예요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { createServer } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'http'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { parse } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'url'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e next \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e port = \u003cspan class=\"hljs-built_in\"\u003eparseInt\u003c/span\u003e(process.\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ePORT\u003c/span\u003e || \u003cspan class=\"hljs-string\"\u003e'3000'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e)\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e dev = process.\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eNODE_ENV\u003c/span\u003e !== \u003cspan class=\"hljs-string\"\u003e'production'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e app = \u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e({ dev })\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e handle = app.\u003cspan class=\"hljs-title function_\"\u003egetRequestHandler\u003c/span\u003e()\n\napp.\u003cspan class=\"hljs-title function_\"\u003eprepare\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003ecreateServer\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ereq, res\u003c/span\u003e) =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e parsedUrl = \u003cspan class=\"hljs-title function_\"\u003eparse\u003c/span\u003e(req.\u003cspan class=\"hljs-property\"\u003eurl\u003c/span\u003e!, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e)\n    \u003cspan class=\"hljs-title function_\"\u003ehandle\u003c/span\u003e(req, res, parsedUrl)\n  }).\u003cspan class=\"hljs-title function_\"\u003elisten\u003c/span\u003e(port)\n\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\n    \u003cspan class=\"hljs-string\"\u003e`\u003e Server listening at http://localhost:\u003cspan class=\"hljs-subst\"\u003e${port}\u003c/span\u003e as \u003cspan class=\"hljs-subst\"\u003e${\n      dev ? \u003cspan class=\"hljs-string\"\u003e'development'\u003c/span\u003e : process.env.NODE_ENV\n    }\u003c/span\u003e`\u003c/span\u003e\n  )\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 코드에서 핵심은 \u003ccode\u003eapp.prepare()\u003c/code\u003e가 끝나면 HTTP 서버를 열며, 들어오는 요청을 \u003ccode\u003ehandle\u003c/code\u003e 함수로 넘겨서 Next.js가 페이지를 렌더링하도록 한다는 점이에요.\u003c/p\u003e\n\u003ch3\u003e그런데 여기서 중요한 점!\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eserver.js\u003c/code\u003e는 Next.js 컴파일러를 거치지 않고 그냥 Node.js에서 직접 실행되기 때문에, 최신 문법(예: ES 모듈 \u003ccode\u003eimport\u003c/code\u003e 구문)을 쓸 때 Node.js 버전과 호환되는지 반드시 확인해야 합니다. 만약 호환 안 되면 직접 \u003ccode\u003erequire()\u003c/code\u003e로 바꾸거나, Babel 같은 트랜스파일러 사용을 고려해야 해요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003epackage.json에 커스텀 서버 실행 스크립트 추가하기\u003c/h3\u003e\n\u003cp\u003e커스텀 서버를 실행하려면 \u003ccode\u003epackage.json\u003c/code\u003e의 \u003ccode\u003escripts\u003c/code\u003e를 이렇게 바꿔줘야 해요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-json\"\u003e\u003cspan class=\"hljs-punctuation\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003e\"scripts\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"dev\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"node server.js\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"build\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"next build\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"start\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"NODE_ENV=production node server.js\"\u003c/span\u003e\n  \u003cspan class=\"hljs-punctuation\"\u003e}\u003c/span\u003e\n\u003cspan class=\"hljs-punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003edev\u003c/code\u003e: 개발 모드에서 커스텀 서버 바로 실행\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ebuild\u003c/code\u003e: Next.js 빌드 수행\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003estart\u003c/code\u003e: 프로덕션 환경에서 커스텀 서버 실행\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003e덧붙여서…\u003c/h3\u003e\n\u003cp\u003e커스텀 서버를 만들면 유연하게 서버 로직 제어가 가능하지만, Next.js의 기본 서버 기능과 자동 최적화, 배포 플랫폼(예: Vercel) 지원을 덜 받게 돼요. 그러니 정말 필요한 경우가 아니라면 기본 Next.js 빌트인 서버를 쓰는 걸 권장합니다!\u003c/p\u003e\n\u003cp\u003e그럼, 여러분만의 커스텀 서버 만들어서 원하는 기능 자유롭게 구현해보세요! 궁금한 점 있으면 언제든 질문 남겨주세요. 😄\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e대신에 nodemon을 설정해서 사용할 수도 있어요(예시 참고). 커스텀 서버는 Next.js 애플리케이션과 연결하기 위해 아래와 같은 import 문을 사용합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e next \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"next\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e app = \u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e({});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 next 함수는 옵션들을 담은 객체를 인자로 받는데요, 주요 옵션들은 다음과 같습니다:\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e옵션\u003c/th\u003e\u003cth\u003e타입\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003econf\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eObject\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003enext.config.js\u003c/code\u003e 에서 사용하는 설정 객체와 동일해요. 기본값은 \u003ccode\u003e{}\u003c/code\u003e 입니다.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003edev\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eBoolean\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e(선택) Next.js를 개발 모드로 실행할지 여부입니다. 기본값은 \u003ccode\u003efalse\u003c/code\u003e 입니다.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003edir\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eString\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e(선택) Next.js 프로젝트 위치를 지정합니다. 기본값은 현재 폴더 \u003ccode\u003e'.'\u003c/code\u003e 입니다.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003equiet\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eBoolean\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e(선택) 서버 정보가 포함된 에러 메시지를 숨길지 결정합니다. 기본값은 \u003ccode\u003efalse\u003c/code\u003e 입니다.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ehostname\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eString\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e(선택) 서버가 실행되는 호스트 이름을 지정합니다.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eport\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eNumber\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e(선택) 서버가 실행되는 포트를 지정합니다.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ehttpServer\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003enode:http#Server\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e(선택) Next.js가 작동 중인 HTTP 서버 객체를 넘겨줄 수 있습니다.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eturbo\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eBoolean\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e(선택) Turbopack을 활성화할지 여부입니다.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e간단 팁!\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e개발할 때 \u003ccode\u003edev\u003c/code\u003e 옵션을 \u003ccode\u003etrue\u003c/code\u003e로 주면 핫 리로딩도 잡아주고 디버깅이 편해져요.\u003c/li\u003e\n\u003cli\u003e프로젝트 경로가 현재 폴더가 아니라면 \u003ccode\u003edir\u003c/code\u003e 옵션으로 정확히 지정해주는 게 중요합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003equiet\u003c/code\u003e 옵션을 켜면 서버 에러 로그가 줄어들어 콘솔이 깔끔해져서 가끔 쓰면 좋아요.\u003c/li\u003e\n\u003cli\u003e그리고 마지막으로 \u003ccode\u003eturbo\u003c/code\u003e 옵션은 Next.js의 차세대 번들러인 Turbopack을 활성화하는건데, 아직 실험적인 기능이라 프로젝트 특성에 따라 테스트해보시는 걸 추천해요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이렇게 다양한 옵션을 활용해서 커스텀 서버 환경을 자신의 필요에 맞게 세팅해보세요! 개발할 때 내 서버 환경을 좀 더 세밀하게 컨트롤할 수 있어서 편리합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e반환된 앱은 Next.js가 요청을 필요한 대로 처리할 수 있도록 사용하는 데 활용할 수 있어요.\u003c/p\u003e\n\u003cp\u003e여기서 중요한 점은, Next.js가 기본적으로 서버 사이드 렌더링(SSR)과 정적 생성(SSG) 모두를 지원하기 때문에, 반환된 앱으로 다양한 요청 처리 방식을 유연하게 다룰 수 있다는 거예요.\u003c/p\u003e\n\u003cp\u003e예를 들어, API 라우트나 커스텀 서버를 구축할 때 조금 더 세밀한 제어가 필요하면 이렇게 반환된 앱을 통해 요청을 직접 처리할 수 있고, 그렇지 않으면 Next.js의 기본 라우팅에 맡길 수도 있죠.\u003c/p\u003e\n\u003cp\u003e이런 방식을 활용하면 복잡한 서버 로직을 구현할 때도 Next.js의 장점을 최대한 살리면서 개발할 수 있어요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2025-04-22-CustomServer"},"buildId":"olPs1cVezSGTqD7OaewDI","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>